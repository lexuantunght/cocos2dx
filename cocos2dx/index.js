var ei = Object.defineProperty;
var H = (t, e) => ei(t, "name", { value: e, configurable: !0 });
const __viteBrowserExternal = {}, __CJS__cocos__import__1__ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var module = { exports: {} }, exports = module.exports, cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
var _p = window;
_p.gl;
_p.WebGLRenderingContext;
_p.DeviceOrientationEvent;
_p.DeviceMotionEvent;
_p.AudioContext;
_p.AudioContext || _p.webkitAudioContext;
_p.mozAudioContext;
_p = Object.prototype;
_p._super;
_p.ctor;
_p = null;
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._supportRender = !1;
cc._canvas = null;
cc.container = null;
cc._gameDiv = null;
cc.newElement = function(t) {
  return document.createElement(t);
};
cc.each = function(t, e, n) {
  if (t) {
    if (t instanceof Array) {
      for (var r = 0, s = t.length; r < s; r++)
        if (e.call(n, t[r], r) === !1)
          return;
    } else
      for (var o in t)
        if (e.call(n, t[o], o) === !1)
          return;
  }
};
cc.extend = function(t) {
  var e = arguments.length >= 2 ? Array.prototype.slice.call(arguments, 1) : [];
  return cc.each(e, function(n) {
    for (var r in n)
      n.hasOwnProperty(r) && (t[r] = n[r]);
  }), t;
};
cc.isFunction = function(t) {
  return typeof t == "function";
};
cc.isNumber = function(t) {
  return typeof t == "number" || Object.prototype.toString.call(t) === "[object Number]";
};
cc.isString = function(t) {
  return typeof t == "string" || Object.prototype.toString.call(t) === "[object String]";
};
cc.isArray = function(t) {
  return Array.isArray(t) || typeof t == "object" && Object.prototype.toString.call(t) === "[object Array]";
};
cc.isUndefined = function(t) {
  return typeof t == "undefined";
};
cc.isObject = function(t) {
  return typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]";
};
cc.isCrossOrigin = function(t) {
  if (!t)
    return cc.log("invalid URL"), !1;
  var e = t.indexOf("://");
  if (e === -1)
    return !1;
  var n = t.indexOf("/", e + 3), r = n === -1 ? t : t.substring(0, n);
  return r !== location.origin;
};
cc.AsyncPool = function(t, e, n, r, s) {
  var o = (this || window);
  o._srcObj = t, o._limit = e, o._pool = [], o._iterator = n, o._iteratorTarget = s, o._onEnd = r, o._onEndTarget = s, o._results = t instanceof Array ? [] : {}, o._errors = t instanceof Array ? [] : {}, cc.each(t, function(a, c) {
    o._pool.push({ index: c, value: a });
  }), o.size = o._pool.length, o.finishedSize = 0, o._workingSize = 0, o._limit = o._limit || o.size, o.onIterator = function(a, c) {
    o._iterator = a, o._iteratorTarget = c;
  }, o.onEnd = function(a, c) {
    o._onEnd = a, o._onEndTarget = c;
  }, o._handleItem = function() {
    var a = (this || window);
    if (!(a._pool.length === 0 || a._workingSize >= a._limit)) {
      var c = a._pool.shift(), l = c.value, h = c.index;
      a._workingSize++, a._iterator.call(
        a._iteratorTarget,
        l,
        h,
        function(u, _) {
          if (a.finishedSize++, a._workingSize--, u ? a._errors[this.index] = u : a._results[this.index] = _, a.finishedSize === a.size) {
            if (a._onEnd) {
              var d = a._errors.length === 0 ? null : a._errors;
              a._onEnd.call(a._onEndTarget, d, a._results);
            }
            return;
          }
          a._handleItem();
        }.bind(c),
        a
      );
    }
  }, o.flow = function() {
    var a = (this || window);
    if (a._pool.length === 0) {
      a._onEnd && a._onEnd.call(a._onEndTarget, null, []);
      return;
    }
    for (var c = 0; c < a._limit; c++)
      a._handleItem();
  };
};
cc.async = {
  series: function(t, e, n) {
    var r = new cc.AsyncPool(t, 1, function(s, o, a) {
      s.call(n, a);
    }, e, n);
    return r.flow(), r;
  },
  parallel: function(t, e, n) {
    var r = new cc.AsyncPool(t, 0, function(s, o, a) {
      s.call(n, a);
    }, e, n);
    return r.flow(), r;
  },
  waterfall: function(t, e, n) {
    var r = [], s = [null], o = new cc.AsyncPool(
      t,
      1,
      function(a, c, l) {
        r.push(function(h) {
          r = Array.prototype.slice.call(arguments, 1), t.length - 1 === c && (s = s.concat(r)), l.apply(null, arguments);
        }), a.apply(n, r);
      },
      function(a) {
        if (e) {
          if (a)
            return e.call(n, a);
          e.apply(n, s);
        }
      }
    );
    return o.flow(), o;
  },
  map: function(t, e, n, r) {
    var s = e;
    typeof e == "object" && (n = e.cb, r = e.iteratorTarget, s = e.iterator);
    var o = new cc.AsyncPool(t, 0, s, n, r);
    return o.flow(), o;
  },
  mapLimit: function(t, e, n, r, s) {
    var o = new cc.AsyncPool(t, e, n, r, s);
    return o.flow(), o;
  }
};
cc.path = {
  normalizeRE: /[^\.\/]+\/\.\.\//,
  join: function() {
    for (var t = arguments.length, e = "", n = 0; n < t; n++)
      e = (e + (e === "" ? "" : "/") + arguments[n]).replace(/(\/|\\\\)$/, "");
    return e;
  },
  extname: function(t) {
    var e = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(t);
    return e ? e[1] : null;
  },
  mainFileName: function(t) {
    if (t) {
      var e = t.lastIndexOf(".");
      if (e !== -1)
        return t.substring(0, e);
    }
    return t;
  },
  basename: function(t, e) {
    var n = t.indexOf("?");
    n > 0 && (t = t.substring(0, n));
    var r = /(\/|\\\\)([^(\/|\\\\)]+)$/g, s = r.exec(t.replace(/(\/|\\\\)$/, ""));
    if (!s)
      return null;
    var o = s[2];
    return e && t.substring(t.length - e.length).toLowerCase() === e.toLowerCase() ? o.substring(0, o.length - e.length) : o;
  },
  dirname: function(t) {
    return t.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2");
  },
  changeExtname: function(t, e) {
    e = e || "";
    var n = t.indexOf("?"), r = "";
    return n > 0 && (r = t.substring(n), t = t.substring(0, n)), n = t.lastIndexOf("."), n < 0 ? t + e + r : t.substring(0, n) + e + r;
  },
  changeBasename: function(t, e, n) {
    if (e.indexOf(".") === 0)
      return this.changeExtname(t, e);
    var r = t.indexOf("?"), s = "", o = n ? this.extname(t) : "";
    return r > 0 && (s = t.substring(r), t = t.substring(0, r)), r = t.lastIndexOf("/"), r = r <= 0 ? 0 : r + 1, t.substring(0, r) + e + o + s;
  },
  _normalize: function(t) {
    var e = t = String(t);
    do
      e = t, t = t.replace(this.normalizeRE, "");
    while (e.length !== t.length);
    return t;
  }
};
cc.loader = function() {
  var t = {}, e = {}, n = {}, r = {}, s = {}, o = new RegExp(
    "^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$",
    "i"
  );
  return {
    resPath: "",
    audioPath: "",
    cache: {},
    getXMLHttpRequest: function() {
      return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
    },
    _getArgs4Js: function(a) {
      var c = a[0], l = a[1], h = a[2], u = ["", null, null];
      if (a.length === 1)
        u[1] = c instanceof Array ? c : [c];
      else if (a.length === 2)
        typeof l == "function" ? (u[1] = c instanceof Array ? c : [c], u[2] = l) : (u[0] = c || "", u[1] = l instanceof Array ? l : [l]);
      else if (a.length === 3)
        u[0] = c || "", u[1] = l instanceof Array ? l : [l], u[2] = h;
      else
        throw new Error("arguments error to load js!");
      return u;
    },
    isLoading: function(a) {
      return s[a] !== void 0;
    },
    loadJs: function(a, c, l) {
      var h = (this || window), u = h._getArgs4Js(arguments), _ = u[0], d = u[1], f = u[2];
      navigator.userAgent.indexOf("Trident/5") > -1 ? h._loadJs4Dependency(_, d, 0, f) : cc.async.map(d, function(C, m, g) {
        var y = cc.path.join(_, C);
        if (t[y])
          return g(null);
        h._createScript(y, !1, g);
      }, f);
    },
    loadJsWithImg: function(a, c, l) {
      var h = (this || window), u = h._loadJsImg(), _ = h._getArgs4Js(arguments);
      this.loadJs(_[0], _[1], function(d) {
        if (d)
          throw new Error(d);
        u.parentNode.removeChild(u), _[2] && _[2]();
      });
    },
    _createScript: function(a, c, l) {
      var h = document, u = (this || window), _ = document.createElement("script");
      _.async = c, t[a] = !0, cc.game.config.noCache && typeof a == "string" ? u._noCacheRex.test(a) ? _.src = a + "&_t=" + (/* @__PURE__ */ new Date() - 0) : _.src = a + "?_t=" + (/* @__PURE__ */ new Date() - 0) : _.src = a, _.addEventListener("load", function() {
        _.parentNode.removeChild(_), this.removeEventListener("load", arguments.callee, !1), l();
      }, !1), _.addEventListener("error", function() {
        _.parentNode.removeChild(_), l("Load " + a + " failed!");
      }, !1), h.body.appendChild(_);
    },
    _loadJs4Dependency: function(a, c, l, h) {
      if (l >= c.length) {
        h && h();
        return;
      }
      var u = (this || window);
      u._createScript(cc.path.join(a, c[l]), !1, function(_) {
        if (_)
          return h(_);
        u._loadJs4Dependency(a, c, l + 1, h);
      });
    },
    _loadJsImg: function() {
      var a = document, c = a.getElementById("cocos2d_loadJsImg");
      if (!c) {
        c = document.createElement("img"), cc._loadingImage && (c.src = cc._loadingImage);
        var l = a.getElementById(cc.game.config.id);
        l.style.backgroundColor = "transparent", l.parentNode.appendChild(c);
        var h = getComputedStyle ? getComputedStyle(l) : l.currentStyle;
        h || (h = { width: l.width, height: l.height }), c.style.left = l.offsetLeft + (parseFloat(h.width) - c.width) / 2 + "px", c.style.top = l.offsetTop + (parseFloat(h.height) - c.height) / 2 + "px", c.style.position = "absolute";
      }
      return c;
    },
    loadTxt: function(a, c) {
      if (!cc._isNodeJs || !0) {
        var l = (this || window).getXMLHttpRequest(), h = "load " + a + " failed!";
        l.open("GET", a, !0), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (l.setRequestHeader("Accept-Charset", "utf-8"), l.onreadystatechange = function() {
          l.readyState === 4 && (l.status === 200 ? c(null, l.responseText) : c({ status: l.status, errorMessage: h }, null));
        }) : (l.overrideMimeType && l.overrideMimeType("text/plain; charset=utf-8"), l.onload = function() {
          l.readyState === 4 && (l.status === 200 ? c(null, l.responseText) : c({ status: l.status, errorMessage: h }, null));
        }, l.onerror = function() {
          c({ status: l.status, errorMessage: h }, null);
        }), l.send(null);
      } else
        var u;
    },
    _loadTxtSync: function(a) {
      if (!cc._isNodeJs || !0) {
        var c = (this || window).getXMLHttpRequest();
        return c.open("GET", a, !1), /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? c.setRequestHeader("Accept-Charset", "utf-8") : c.overrideMimeType && c.overrideMimeType("text/plain; charset=utf-8"), c.send(null), !c.readyState === 4 || c.status !== 200 ? null : c.responseText;
      } else
        var l;
    },
    loadCsb: function(a, c) {
      var l = new XMLHttpRequest(), h = "load " + a + " failed!";
      l.open("GET", a, !0), l.responseType = "arraybuffer", l.onload = function() {
        var u = l.response;
        u && (window.msg = u), l.readyState === 4 && (l.status === 200 ? c(null, l.response) : c({ status: l.status, errorMessage: h }, null));
      }, l.onerror = function() {
        c({ status: l.status, errorMessage: h }, null);
      }, l.send(null);
    },
    loadJson: function(a, c) {
      this.loadTxt(a, function(l, h) {
        if (l)
          c(l);
        else {
          try {
            var u = JSON.parse(h);
          } catch (_) {
            throw new Error("parse json [" + a + "] failed : " + _);
          }
          c(null, u);
        }
      });
    },
    _checkIsImageURL: function(a) {
      var c = /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a);
      return c != null;
    },
    loadImg: function(a, c, l) {
      var h = {
        isCrossOrigin: !0
      };
      l !== void 0 ? h.isCrossOrigin = c.isCrossOrigin === void 0 ? h.isCrossOrigin : c.isCrossOrigin : c !== void 0 && (l = c);
      var u = (this || window).getRes(a);
      if (u)
        return l && l(null, u), u;
      var _ = s[a];
      if (_)
        return _.callbacks.push(l), _.img;
      u = new Image(), h.isCrossOrigin && location.origin !== "file://" && (u.crossOrigin = "Anonymous");
      var d = /* @__PURE__ */ H(function() {
        this.removeEventListener("load", d, !1), this.removeEventListener("error", C, !1), o.test(a) || (cc.loader.cache[a] = u);
        var m = s[a];
        if (m) {
          for (var g = m.callbacks, y = 0; y < g.length; ++y) {
            var A = g[y];
            A && A(null, u);
          }
          m.img = null, delete s[a];
        }
      }, "loadCallback"), f = (this || window), C = /* @__PURE__ */ H(function() {
        if (this.removeEventListener("error", C, !1), u.crossOrigin && u.crossOrigin.toLowerCase() === "anonymous")
          h.isCrossOrigin = !1, f.release(a), cc.loader.loadImg(a, h, l);
        else {
          var m = s[a];
          if (m) {
            for (var g = m.callbacks, y = 0; y < g.length; ++y) {
              var A = g[y];
              A && A("load image failed");
            }
            m.img = null, delete s[a];
          }
        }
      }, "errorCallback");
      return s[a] = {
        img: u,
        callbacks: l ? [l] : []
      }, u.addEventListener("load", d), u.addEventListener("error", C), u.src = a, u;
    },
    _loadResIterator: function(a, c, l) {
      var h = (this || window), u = null, _ = a.type;
      _ ? (_ = "." + _.toLowerCase(), u = a.src ? a.src : a.name + _) : (u = a, _ = cc.path.extname(u));
      var d = h.getRes(u);
      if (d)
        return l(null, d);
      var f = null;
      if (_ && (f = e[_.toLowerCase()]), !f)
        return cc.error("loader for [" + _ + "] not exists!"), l();
      var C = u;
      if (!o.test(u)) {
        var m = f.getBasePath ? f.getBasePath() : h.resPath;
        C = h.getUrl(m, u);
      }
      cc.game.config.noCache && typeof C == "string" && (h._noCacheRex.test(C) ? C += "&_t=" + (/* @__PURE__ */ new Date() - 0) : C += "?_t=" + (/* @__PURE__ */ new Date() - 0)), f.load(C, u, a, function(g, y) {
        g ? (cc.log(g), h.cache[u] = null, delete h.cache[u], l({ status: 520, errorMessage: g }, null)) : (h.cache[u] = y, l(null, y));
      });
    },
    _noCacheRex: /\?/,
    getUrl: function(a, c) {
      var l = (this || window), h = cc.path;
      if (a !== void 0 && c === void 0) {
        c = a;
        var u = h.extname(c);
        u = u ? u.toLowerCase() : "";
        var _ = e[u];
        _ ? a = _.getBasePath ? _.getBasePath() : l.resPath : a = l.resPath;
      }
      if (c = cc.path.join(a || "", c), c.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
        if (n[c])
          return n[c];
        var d = h.extname(c) || "";
        c = n[c] = c.substring(0, c.length - d.length) + "_" + cc.sys.language + d;
      }
      return c;
    },
    load: function(a, c, l) {
      var h = (this || window), u = arguments.length;
      if (u === 0)
        throw new Error("arguments error!");
      u === 3 ? typeof c == "function" && (typeof l == "function" ? c = { trigger: c, cb: l } : c = { cb: c, cbTarget: l }) : u === 2 ? typeof c == "function" && (c = { cb: c }) : u === 1 && (c = {}), a instanceof Array || (a = [a]);
      var _ = new cc.AsyncPool(
        a,
        0,
        function(d, f, C, m) {
          h._loadResIterator(d, f, function(g) {
            var y = Array.prototype.slice.call(arguments, 1);
            c.trigger && c.trigger.call(c.triggerTarget, y[0], m.size, m.finishedSize), C(g, y[0]);
          });
        },
        c.cb,
        c.cbTarget
      );
      return _.flow(), _;
    },
    _handleAliases: function(a, c) {
      var l = [];
      for (var h in a) {
        var u = a[h];
        r[h] = u, l.push(u);
      }
      this.load(l, c);
    },
    loadAliases: function(a, c) {
      var l = (this || window), h = l.getRes(a);
      h ? l._handleAliases(h.filenames, c) : l.load(a, function(u, _) {
        l._handleAliases(_[0].filenames, c);
      });
    },
    register: function(a, c) {
      if (!(!a || !c)) {
        if (typeof a == "string")
          return e[a.trim().toLowerCase()] = c;
        for (var l = 0, h = a.length; l < h; l++)
          e["." + a[l].trim().toLowerCase()] = c;
      }
    },
    getRes: function(a) {
      return this.cache[a] || this.cache[r[a]];
    },
    _getAliase: function(a) {
      return r[a];
    },
    release: function(a) {
      var c = (this || window).cache, l = s[a];
      l && (l.img = null, delete s[a]), delete c[a], delete c[r[a]], delete r[a];
    },
    releaseAll: function() {
      var a = (this || window).cache;
      for (var c in a)
        delete a[c];
      for (var c in r)
        delete r[c];
    }
  };
}();
cc.formatStr = function() {
  var t = arguments, e = t.length;
  if (e < 1)
    return "";
  var n = t[0], r = !0;
  typeof n == "object" && (r = !1);
  for (var s = 1; s < e; ++s) {
    var o = t[s];
    if (r)
      for (; ; ) {
        var a = null;
        if (typeof o == "number" && (a = n.match(/(%d)|(%s)/), a)) {
          n = n.replace(/(%d)|(%s)/, o);
          break;
        }
        a = n.match(/%s/), a ? n = n.replace(/%s/, o) : n += "    " + o;
        break;
      }
    else
      n += "    " + o;
  }
  return n;
};
(function() {
  var t = document.createElement("canvas"), e = document.createElement("canvas");
  cc.create3DContext = function(_, d) {
    for (var f = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], C = null, m = 0; m < f.length; ++m) {
      try {
        C = _.getContext(f[m], d);
      } catch (g) {
      }
      if (C)
        break;
    }
    return C;
  };
  var n = /* @__PURE__ */ H(function() {
    cc.sys = {};
    var _ = cc.sys;
    _.LANGUAGE_ENGLISH = "en", _.LANGUAGE_CHINESE = "zh", _.LANGUAGE_FRENCH = "fr", _.LANGUAGE_ITALIAN = "it", _.LANGUAGE_GERMAN = "de", _.LANGUAGE_SPANISH = "es", _.LANGUAGE_DUTCH = "du", _.LANGUAGE_RUSSIAN = "ru", _.LANGUAGE_KOREAN = "ko", _.LANGUAGE_JAPANESE = "ja", _.LANGUAGE_HUNGARIAN = "hu", _.LANGUAGE_PORTUGUESE = "pt", _.LANGUAGE_ARABIC = "ar", _.LANGUAGE_NORWEGIAN = "no", _.LANGUAGE_POLISH = "pl", _.LANGUAGE_UNKNOWN = "unkonwn", _.OS_IOS = "iOS", _.OS_ANDROID = "Android", _.OS_WINDOWS = "Windows", _.OS_MARMALADE = "Marmalade", _.OS_LINUX = "Linux", _.OS_BADA = "Bada", _.OS_BLACKBERRY = "Blackberry", _.OS_OSX = "OS X", _.OS_WP8 = "WP8", _.OS_WINRT = "WINRT", _.OS_UNKNOWN = "Unknown", _.UNKNOWN = -1, _.WIN32 = 0, _.LINUX = 1, _.MACOS = 2, _.ANDROID = 3, _.IPHONE = 4, _.IPAD = 5, _.BLACKBERRY = 6, _.NACL = 7, _.EMSCRIPTEN = 8, _.TIZEN = 9, _.WINRT = 10, _.WP8 = 11, _.MOBILE_BROWSER = 100, _.DESKTOP_BROWSER = 101, _.BROWSER_TYPE_WECHAT = "wechat", _.BROWSER_TYPE_ANDROID = "androidbrowser", _.BROWSER_TYPE_IE = "ie", _.BROWSER_TYPE_QQ = "qqbrowser", _.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser", _.BROWSER_TYPE_UC = "ucbrowser", _.BROWSER_TYPE_360 = "360browser", _.BROWSER_TYPE_BAIDU_APP = "baiduboxapp", _.BROWSER_TYPE_BAIDU = "baidubrowser", _.BROWSER_TYPE_MAXTHON = "maxthon", _.BROWSER_TYPE_OPERA = "opera", _.BROWSER_TYPE_OUPENG = "oupeng", _.BROWSER_TYPE_MIUI = "miuibrowser", _.BROWSER_TYPE_FIREFOX = "firefox", _.BROWSER_TYPE_SAFARI = "safari", _.BROWSER_TYPE_CHROME = "chrome", _.BROWSER_TYPE_LIEBAO = "liebao", _.BROWSER_TYPE_QZONE = "qzone", _.BROWSER_TYPE_SOUGOU = "sogou", _.BROWSER_TYPE_UNKNOWN = "unknown", _.isNative = !1;
    var d = window, f = d.navigator, C = document, m = C.documentElement, g = f.userAgent.toLowerCase();
    _.isMobile = g.indexOf("mobile") !== -1 || g.indexOf("android") !== -1, _.platform = _.isMobile ? _.MOBILE_BROWSER : _.DESKTOP_BROWSER;
    var y = f.language;
    y = y || f.browserLanguage, y = y ? y.split("-")[0] : _.LANGUAGE_ENGLISH, _.language = y;
    var A = !1, D = !1, N = "", z = 0, M = /android (\d+(?:\.\d+)+)/i.exec(g) || /android (\d+(?:\.\d+)+)/i.exec(f.platform);
    M && (A = !0, N = M[1] || "", z = parseInt(N) || 0), M = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(g), M && (D = !0, N = M[2] || "", z = parseInt(N) || 0);
    var Z = _.OS_UNKNOWN;
    f.appVersion.indexOf("Win") !== -1 ? Z = _.OS_WINDOWS : D ? Z = _.OS_IOS : f.appVersion.indexOf("Mac") !== -1 ? Z = _.OS_OSX : f.appVersion.indexOf("X11") !== -1 && f.appVersion.indexOf("Linux") === -1 ? Z = _.OS_UNIX : A ? Z = _.OS_ANDROID : f.appVersion.indexOf("Linux") !== -1 && (Z = _.OS_LINUX), _.os = Z, _.osVersion = N, _.osMainVersion = z, _.browserType = _.BROWSER_TYPE_UNKNOWN, function() {
      var b = /mqqbrowser|sogou|qzone|liebao|micromessenger|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|trident|miuibrowser/i, W = /qqbrowser|chrome|safari|firefox|opr|oupeng|opera/i, x = b.exec(g);
      x || (x = W.exec(g));
      var E = x ? x[0] : _.BROWSER_TYPE_UNKNOWN;
      E === "micromessenger" ? E = _.BROWSER_TYPE_WECHAT : E === "safari" && g.match(/android.*applewebkit/) ? E = _.BROWSER_TYPE_ANDROID : E === "trident" ? E = _.BROWSER_TYPE_IE : E === "360 aphone" ? E = _.BROWSER_TYPE_360 : E === "mxbrowser" ? E = _.BROWSER_TYPE_MAXTHON : E === "opr" && (E = _.BROWSER_TYPE_OPERA), _.browserType = E;
    }(), _.browserVersion = "", function() {
      var b = /(micromessenger|qq|mx|maxthon|baidu|sogou)(mobile)?(browser)?\/?([\d.]+)/i, W = /(msie |rv:|firefox|chrome|ucbrowser|oupeng|opera|opr|safari|miui)(mobile)?(browser)?\/?([\d.]+)/i, x = g.match(b);
      x || (x = g.match(W)), _.browserVersion = x ? x[4] : "";
    }();
    var U = window.innerWidth || document.documentElement.clientWidth, Q = window.innerHeight || document.documentElement.clientHeight, et = window.devicePixelRatio || 1;
    if (_.windowPixelResolution = {
      width: et * U,
      height: et * Q
    }, _._checkWebGLRenderMode = function() {
      if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL)
        throw new Error("This feature supports WebGL render mode only.");
    }, _._supportCanvasNewBlendModes = function() {
      var b = t;
      b.width = 1, b.height = 1;
      var W = b.getContext("2d");
      W.fillStyle = "#000", W.fillRect(0, 0, 1, 1), W.globalCompositeOperation = "multiply";
      var x = e;
      x.width = 1, x.height = 1;
      var E = x.getContext("2d");
      return E.fillStyle = "#fff", E.fillRect(0, 0, 1, 1), W.drawImage(x, 0, 0, 1, 1), W.getImageData(0, 0, 1, 1).data[0] === 0;
    }(), cc.sys.isMobile) {
      var rt = document.createElement("style");
      rt.type = "text/css", document.body.appendChild(rt), rt.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}";
    }
    try {
      var w = _.localStorage = d.localStorage;
      w.setItem("storage", ""), w.removeItem("storage"), w = null;
    } catch (b) {
      var L = /* @__PURE__ */ H(function() {
        cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option");
      }, "warn");
      _.localStorage = {
        getItem: L,
        setItem: L,
        removeItem: L,
        clear: L
      };
    }
    var G = !!t.getContext("2d"), I = !1;
    if (d.WebGLRenderingContext) {
      var O = document.createElement("CANVAS");
      try {
        var K = cc.create3DContext(O, { stencil: !0 });
        if (K && (I = !0), I && _.os === _.OS_ANDROID) {
          var $ = parseFloat(_.browserVersion);
          switch (_.browserType) {
            case _.BROWSER_TYPE_MOBILE_QQ:
            case _.BROWSER_TYPE_BAIDU:
            case _.BROWSER_TYPE_BAIDU_APP:
              $ >= 6.2 ? I = !0 : I = !1;
              break;
            case _.BROWSER_TYPE_CHROME:
              $ >= 30 ? I = !0 : I = !1;
              break;
            case _.BROWSER_TYPE_ANDROID:
              _.osMainVersion && _.osMainVersion >= 5 && (I = !0);
              break;
            case _.BROWSER_TYPE_UNKNOWN:
            case _.BROWSER_TYPE_360:
            case _.BROWSER_TYPE_MIUI:
            case _.BROWSER_TYPE_UC:
              I = !1;
          }
        }
      } catch (b) {
      }
      O = null;
    }
    var S = _.capabilities = {
      canvas: G,
      opengl: I
    };
    (m.ontouchstart !== void 0 || C.ontouchstart !== void 0 || f.msPointerEnabled) && (S.touches = !0), m.onmouseup !== void 0 && (S.mouse = !0), m.onkeyup !== void 0 && (S.keyboard = !0), (d.DeviceMotionEvent || d.DeviceOrientationEvent) && (S.accelerometer = !0), _.garbageCollect = function() {
    }, _.dumpRoot = function() {
    }, _.restartVM = function() {
    }, _.cleanScript = function(b) {
    }, _.isObjectValid = function(b) {
      return !!b;
    }, _.dump = function() {
      var b = (this || window), W = "";
      W += "isMobile : " + b.isMobile + `\r
`, W += "language : " + b.language + `\r
`, W += "browserType : " + b.browserType + `\r
`, W += "browserVersion : " + b.browserVersion + `\r
`, W += "capabilities : " + JSON.stringify(b.capabilities) + `\r
`, W += "os : " + b.os + `\r
`, W += "osVersion : " + b.osVersion + `\r
`, W += "platform : " + b.platform + `\r
`, W += "Using " + (cc._renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + ` renderer.\r
`, cc.log(W);
    }, _.openURL = function(b) {
      window.open(b);
    };
  }, "_initSys");
  n(), t = null, e = null, cc.log = cc.warn = cc.error = cc.assert = function() {
  };
  var r = {}, s = !1, o = null;
  cc._engineLoaded = !1;
  function a(_) {
    var d = cc.game.CONFIG_KEY, f = parseInt(_[d.renderMode]) || 0;
    (isNaN(f) || f > 2 || f < 0) && (_[d.renderMode] = 0), cc._renderType = cc.game.RENDER_TYPE_CANVAS, cc._supportRender = !1, f === 0 ? cc.sys.capabilities.opengl ? (cc._renderType = cc.game.RENDER_TYPE_WEBGL, cc._supportRender = !0) : cc.sys.capabilities.canvas && (cc._renderType = cc.game.RENDER_TYPE_CANVAS, cc._supportRender = !0) : f === 1 && cc.sys.capabilities.canvas ? (cc._renderType = cc.game.RENDER_TYPE_CANVAS, cc._supportRender = !0) : f === 2 && cc.sys.capabilities.opengl && (cc._renderType = cc.game.RENDER_TYPE_WEBGL, cc._supportRender = !0);
  }
  H(a, "_determineRenderType");
  function c(_, d, f) {
    if (r[d])
      return null;
    f = f || "";
    var C = [], m = _[d];
    if (!m)
      throw new Error("can not find module [" + d + "]");
    for (var g = cc.path, y = 0, A = m.length; y < A; y++) {
      var D = m[y];
      if (!r[D]) {
        var N = g.extname(D);
        if (N)
          N.toLowerCase() === ".js" && C.push(g.join(f, D));
        else {
          var z = c(_, D, f);
          z && (C = C.concat(z));
        }
        r[D] = 1;
      }
    }
    return C;
  }
  H(c, "_getJsListOfModule");
  function l(_) {
    cc._initDebugSetting && cc._initDebugSetting(_[cc.game.CONFIG_KEY.debugMode]), cc._engineLoaded = !0, cc.log(cc.ENGINE_VERSION), o && o();
  }
  H(l, "_afterEngineLoaded");
  function h(_) {
    var d = cc.game.CONFIG_KEY, f = _[d.engineDir], C = cc.loader;
    if (cc.Class)
      l(_);
    else {
      var m = cc.path.join(f, "moduleConfig.json");
      C.loadJson(m, function(g, y) {
        if (g)
          throw new Error(g);
        var A = _.modules || [], D = y.module, N = [];
        cc.sys.capabilities.opengl && A.indexOf("base4webgl") < 0 ? A.splice(0, 0, "base4webgl") : A.indexOf("core") < 0 && A.splice(0, 0, "core");
        for (var z = 0, M = A.length; z < M; z++) {
          var Z = c(D, A[z], f);
          Z && (N = N.concat(Z));
        }
        cc.loader.loadJsWithImg(N, function(U) {
          if (U)
            throw U;
          l(_);
        });
      });
    }
  }
  H(h, "_load");
  function u() {
    this.removeEventListener("load", u, !1), h(cc.game.config);
  }
  H(u, "_windowLoaded"), cc.initEngine = function(_, d) {
    if (s) {
      var f = o;
      o = /* @__PURE__ */ H(function() {
        f && f(), d && d();
      }, "_engineLoadedCallback");
      return;
    }
    o = d, !cc.game.config && _ ? cc.game.config = _ : cc.game.config || cc.game._loadConfig(), _ = cc.game.config, a(_), document.body ? h(_) : cc._addEventListener(window, "load", u, !1), s = !0;
  };
})();
cc.game = {
  DEBUG_MODE_NONE: 0,
  DEBUG_MODE_INFO: 1,
  DEBUG_MODE_WARN: 2,
  DEBUG_MODE_ERROR: 3,
  DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
  DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
  DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
  EVENT_HIDE: "game_on_hide",
  EVENT_SHOW: "game_on_show",
  EVENT_RESIZE: "game_on_resize",
  EVENT_RENDERER_INITED: "renderer_inited",
  RENDER_TYPE_CANVAS: 0,
  RENDER_TYPE_WEBGL: 1,
  RENDER_TYPE_OPENGL: 2,
  _eventHide: null,
  _eventShow: null,
  CONFIG_KEY: {
    width: "width",
    height: "height",
    engineDir: "engineDir",
    modules: "modules",
    debugMode: "debugMode",
    showFPS: "showFPS",
    frameRate: "frameRate",
    id: "id",
    renderMode: "renderMode",
    jsList: "jsList"
  },
  _paused: !0,
  //whether the game is paused
  _prepareCalled: !1,
  //whether the prepare function has been called
  _prepared: !1,
  //whether the engine has prepared
  _rendererInitialized: !1,
  _renderContext: null,
  _intervalId: null,
  //interval target of main
  _lastTime: null,
  _frameTime: null,
  frame: null,
  container: null,
  canvas: null,
  config: null,
  onStart: null,
  onStop: null,
  setFrameRate: function(t) {
    var e = (this || window), n = e.config, r = e.CONFIG_KEY;
    n[r.frameRate] = t, e._intervalId && window.cancelAnimationFrame(e._intervalId), e._paused = !0, e._setAnimFrame(), e._runMainLoop();
  },
  step: function() {
    cc.director.mainLoop();
  },
  pause: function() {
    this._paused || (this._paused = !0, cc.audioEngine && (cc.audioEngine.stopAllEffects(), cc.audioEngine.pauseMusic()), this._intervalId && window.cancelAnimationFrame(this._intervalId), this._intervalId = 0);
  },
  resume: function() {
    this._paused && (this._paused = !1, cc.audioEngine && cc.audioEngine.resumeMusic(), this._runMainLoop());
  },
  isPaused: function() {
    return this._paused;
  },
  restart: function() {
    cc.director.popToSceneStackLevel(0), cc.audioEngine && cc.audioEngine.end(), cc.game.onStart();
  },
  end: function() {
    close();
  },
  prepare: function(t) {
    var e = (this || window), n = e.config, r = e.CONFIG_KEY;
    if (this._loadConfig(), this._prepared) {
      t && t();
      return;
    }
    if (!this._prepareCalled) {
      if (cc._engineLoaded) {
        this._prepareCalled = !0, this._initRenderer(n[r.width], n[r.height]), cc.view = cc.EGLView._getInstance(), cc.director = cc.Director._getInstance(), cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view), cc.winSize = cc.director.getWinSize(), this._initEvents(), this._setAnimFrame(), this._runMainLoop();
        var s = n[r.jsList];
        s ? cc.loader.loadJsWithImg(s, function(o) {
          if (o)
            throw new Error(o);
          e._prepared = !0, t && t();
        }) : t && t();
        return;
      }
      cc.initEngine(this.config, function() {
        e.prepare(t);
      });
    }
  },
  run: function(t, e) {
    typeof t == "function" ? cc.game.onStart = t : (t && (typeof t == "string" ? (cc.game.config || this._loadConfig(), cc.game.config[cc.game.CONFIG_KEY.id] = t) : cc.game.config = t), typeof e == "function" && (cc.game.onStart = e)), this.prepare(cc.game.onStart && cc.game.onStart.bind(cc.game));
  },
  _setAnimFrame: function() {
    this._lastTime = /* @__PURE__ */ new Date(), this._frameTime = 1e3 / cc.game.config[cc.game.CONFIG_KEY.frameRate], cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT || cc.game.config[cc.game.CONFIG_KEY.frameRate] !== 60 ? (window.requestAnimFrame = (this || window)._stTime, window.cancelAnimationFrame = (this || window)._ctTime) : (window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime);
  },
  _stTime: function(t) {
    var e = (/* @__PURE__ */ new Date()).getTime(), n = Math.max(0, cc.game._frameTime - (e - cc.game._lastTime)), r = window.setTimeout(
      function() {
        t();
      },
      n
    );
    return cc.game._lastTime = e + n, r;
  },
  _ctTime: function(t) {
    window.clearTimeout(t);
  },
  _runMainLoop: function() {
    var t = (this || window), e, n = t.config, r = t.CONFIG_KEY, s = cc.director;
    s.setDisplayStats(n[r.showFPS]), e = /* @__PURE__ */ H(function() {
      t._paused || (s.mainLoop(), t._intervalId && window.cancelAnimationFrame(t._intervalId), t._intervalId = window.requestAnimFrame(e));
    }, "callback"), window.requestAnimFrame(e), t._paused = !1;
  },
  _loadConfig: function() {
    if (this.config) {
      this._initConfig(this.config);
      return;
    }
    if (document.ccConfig)
      this._initConfig(document.ccConfig);
    else {
      var t = {};
      try {
        for (var e = document.getElementsByTagName("script"), n = 0; n < e.length; n++) {
          var r = e[n].getAttribute("cocos");
          if (r === "" || r)
            break;
        }
        var s, o, a;
        n < e.length && (s = e[n].src, s && (a = /(.*)\//.exec(s)[0], cc.loader.resPath = a, s = cc.path.join(a, "project.json")), o = cc.loader._loadTxtSync(s)), o || (o = cc.loader._loadTxtSync("project.json")), t = JSON.parse(o);
      } catch (c) {
        cc.log("Failed to read or parse project.json");
      }
      this._initConfig(t);
    }
  },
  _initConfig: function(t) {
    var e = (this || window).CONFIG_KEY, n = t[e.modules];
    t[e.showFPS] = typeof t[e.showFPS] == "undefined" ? !0 : t[e.showFPS], t[e.engineDir] = t[e.engineDir] || "frameworks/cocos2d-html5", t[e.debugMode] == null && (t[e.debugMode] = 0), t[e.frameRate] = t[e.frameRate] || 60, t[e.renderMode] == null && (t[e.renderMode] = 0), t[e.registerSystemEvent] == null && (t[e.registerSystemEvent] = !0), n && n.indexOf("core") < 0 && n.splice(0, 0, "core"), n && (t[e.modules] = n), this.config = t;
  },
  _initRenderer: function(t, e) {
    if (!this._rendererInitialized) {
      if (!cc._supportRender)
        throw new Error("The renderer doesn't support the renderMode " + this.config[this.CONFIG_KEY.renderMode]);
      var n = (this || window).config[cc.game.CONFIG_KEY.id], r = window, s = cc.$(n) || cc.$("#" + n), o, a;
      s.tagName === "CANVAS" ? (t = t || s.width, e = e || s.height, this.canvas = cc._canvas = o = s, this.container = cc.container = a = document.createElement("DIV"), o.parentNode && o.parentNode.insertBefore(a, o)) : (s.tagName !== "DIV" && cc.log("Warning: target element is not a DIV or CANVAS"), t = t || s.clientWidth, e = e || s.clientHeight, this.canvas = cc._canvas = o = document.createElement("CANVAS"), this.container = cc.container = a = document.createElement("DIV"), s.appendChild(a)), a.setAttribute("id", "Cocos2dGameContainer"), a.appendChild(o), this.frame = a.parentNode === document.body ? document.documentElement : a.parentNode, o.addClass("gameCanvas"), o.setAttribute("width", t || 480), o.setAttribute("height", e || 320), o.setAttribute("tabindex", 99), cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this._renderContext = cc._renderContext = cc.webglContext = cc.create3DContext(o, {
        stencil: !0,
        antialias: !cc.sys.isMobile,
        alpha: !1
      })), this._renderContext ? (cc.renderer = cc.rendererWebGL, r.gl = (this || window)._renderContext, cc.renderer.init(), cc.shaderCache._init(), cc._drawingUtil = new cc.DrawingPrimitiveWebGL(this._renderContext), cc.textureCache._initializingRenderer(), cc.glExt = {}, cc.glExt.instanced_arrays = r.gl.getExtension("ANGLE_instanced_arrays"), cc.glExt.element_uint = r.gl.getExtension("OES_element_index_uint")) : (cc._renderType = cc.game.RENDER_TYPE_CANVAS, cc.renderer = cc.rendererCanvas, this._renderContext = cc._renderContext = new cc.CanvasContextWrapper(o.getContext("2d")), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(this._renderContext) : null), cc._gameDiv = a, cc.game.canvas.oncontextmenu = function() {
        if (!cc._isContextMenuEnable)
          return !1;
      }, this.dispatchEvent(this.EVENT_RENDERER_INITED, !0), this._rendererInitialized = !0;
    }
  },
  _initEvents: function() {
    var t = window, e, n;
    this._eventHide = (this || window)._eventHide || new cc.EventCustom(this.EVENT_HIDE), this._eventHide.setUserData(this), this._eventShow = (this || window)._eventShow || new cc.EventCustom(this.EVENT_SHOW), this._eventShow.setUserData(this), this.config[this.CONFIG_KEY.registerSystemEvent] && cc.inputManager.registerSystemEvent(this.canvas), cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (e = "webkitHidden", n = "webkitvisibilitychange") : (e = "msHidden", n = "msvisibilitychange") : (e = "mozHidden", n = "mozvisibilitychange") : (e = "hidden", n = "visibilitychange");
    var r = /* @__PURE__ */ H(function() {
      cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide);
    }, "onHidden"), s = /* @__PURE__ */ H(function() {
      cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow);
    }, "onShow");
    e ? document.addEventListener(n, function() {
      document[e] ? r() : s();
    }, !1) : (t.addEventListener("blur", r, !1), t.addEventListener("focus", s, !1)), navigator.userAgent.indexOf("MicroMessenger") > -1 && (t.onfocus = function() {
      s();
    }), "onpageshow" in window && "onpagehide" in window && (t.addEventListener("pagehide", r, !1), t.addEventListener("pageshow", s, !1)), cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
      cc.game.pause();
    }), cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
      cc.game.resume();
    });
  }
};
Function.prototype.bind = Function.prototype.bind || function(t) {
  if (!cc.isFunction(this))
    throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
  var e = Array.prototype.slice.call(arguments, 1), n = (this || window), r = /* @__PURE__ */ H(function() {
  }, "fNOP"), s = /* @__PURE__ */ H(function() {
    return n.apply(
      this instanceof r && t ? this : t,
      e.concat(Array.prototype.slice.call(arguments))
    );
  }, "fBound");
  return r.prototype = (this || window).prototype, s.prototype = new r(), s;
};
cc._urlRegExp = new RegExp(
  "^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$",
  "i"
);
cc.SimplePool = function() {
  this._pool = [];
};
cc.SimplePool.prototype = {
  constructor: cc.SimplePool,
  size: function() {
    return this._pool.length;
  },
  put: function(t) {
    t && this._pool.indexOf(t) === -1 && this._pool.unshift(t);
  },
  get: function() {
    var t = (this || window)._pool.length - 1;
    if (t < 0)
      return null;
    var e = (this || window)._pool[t];
    return this._pool.length = t, e;
  },
  find: function(t, e) {
    var n, r, s, o = (this || window)._pool, a = o.length - 1;
    for (r = o.length; r >= 0; --r)
      if (s = o[r], n = t(r, s), n)
        return o[r] = o[a], o.length = a, s;
    if (e) {
      var c = e();
      if (c >= 0)
        return o[c] = o[a], o.length = a, s;
    }
    return null;
  }
};
cc.EventHelper = function() {
};
cc.EventHelper.prototype = {
  constructor: cc.EventHelper,
  apply: function(t) {
    t.addEventListener = cc.EventHelper.prototype.addEventListener, t.hasEventListener = cc.EventHelper.prototype.hasEventListener, t.removeEventListener = cc.EventHelper.prototype.removeEventListener, t.dispatchEvent = cc.EventHelper.prototype.dispatchEvent;
  },
  addEventListener: function(t, e, n) {
    if (t === "load" && this._textureLoaded) {
      setTimeout(function() {
        e.call(n);
      }, 0);
      return;
    }
    this._listeners === void 0 && (this._listeners = {});
    var r = (this || window)._listeners;
    r[t] === void 0 && (r[t] = []), this.hasEventListener(t, e, n) || r[t].push({ callback: e, eventTarget: n });
  },
  hasEventListener: function(t, e, n) {
    if (this._listeners === void 0)
      return !1;
    var r = (this || window)._listeners;
    if (r[t] !== void 0)
      for (var s = 0, o = r.length; s < o; s++) {
        var a = r[s];
        if (a.callback === e && a.eventTarget === n)
          return !0;
      }
    return !1;
  },
  removeEventListener: function(t, e, n) {
    if (this._listeners !== void 0) {
      var r = (this || window)._listeners, s = r[t];
      if (s !== void 0)
        for (var o = 0; o < s.length; ) {
          var a = s[o];
          a.eventTarget === n && a.callback === e ? s.splice(o, 1) : o++;
        }
    }
  },
  removeEventTarget: function(t, e, n) {
    if (this._listeners !== void 0) {
      var r = (this || window)._listeners, s = r[t];
      if (s !== void 0)
        for (var o = 0; o < s.length; ) {
          var a = s[o];
          a.eventTarget === n ? s.splice(o, 1) : o++;
        }
    }
  },
  dispatchEvent: function(t, e) {
    if (this._listeners !== void 0) {
      e == null && (e = !0);
      var n = (this || window)._listeners, r = n[t];
      if (r !== void 0) {
        for (var s = [], o = r.length, a = 0; a < o; a++)
          s[a] = r[a];
        for (a = 0; a < o; a++)
          s[a].callback.call(s[a].eventTarget, this);
        e && (r.length = 0);
      }
    }
  }
};
cc.EventHelper.prototype.apply(cc.game);
var cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAgCAYAAAD9qabkAAAKQ2lDQ1BJQ0MgcHJvZmlsZQAAeNqdU3dYk/cWPt/3ZQ9WQtjwsZdsgQAiI6wIyBBZohCSAGGEEBJAxYWIClYUFRGcSFXEgtUKSJ2I4qAouGdBiohai1VcOO4f3Ke1fXrv7e371/u855zn/M55zw+AERImkeaiagA5UoU8Otgfj09IxMm9gAIVSOAEIBDmy8JnBcUAAPADeXh+dLA//AGvbwACAHDVLiQSx+H/g7pQJlcAIJEA4CIS5wsBkFIAyC5UyBQAyBgAsFOzZAoAlAAAbHl8QiIAqg0A7PRJPgUA2KmT3BcA2KIcqQgAjQEAmShHJAJAuwBgVYFSLALAwgCgrEAiLgTArgGAWbYyRwKAvQUAdo5YkA9AYACAmUIszAAgOAIAQx4TzQMgTAOgMNK/4KlfcIW4SAEAwMuVzZdL0jMUuJXQGnfy8ODiIeLCbLFCYRcpEGYJ5CKcl5sjE0jnA0zODAAAGvnRwf44P5Dn5uTh5mbnbO/0xaL+a/BvIj4h8d/+vIwCBAAQTs/v2l/l5dYDcMcBsHW/a6lbANpWAGjf+V0z2wmgWgrQevmLeTj8QB6eoVDIPB0cCgsL7SViob0w44s+/zPhb+CLfvb8QB7+23rwAHGaQJmtwKOD/XFhbnauUo7nywRCMW735yP+x4V//Y4p0eI0sVwsFYrxWIm4UCJNx3m5UpFEIcmV4hLpfzLxH5b9CZN3DQCshk/ATrYHtctswH7uAQKLDljSdgBAfvMtjBoLkQAQZzQyefcAAJO/+Y9AKwEAzZek4wAAvOgYXKiUF0zGCAAARKCBKrBBBwzBFKzADpzBHbzAFwJhBkRADCTAPBBCBuSAHAqhGJZBGVTAOtgEtbADGqARmuEQtMExOA3n4BJcgetwFwZgGJ7CGLyGCQRByAgTYSE6iBFijtgizggXmY4EImFINJKApCDpiBRRIsXIcqQCqUJqkV1II/ItchQ5jVxA+pDbyCAyivyKvEcxlIGyUQPUAnVAuagfGorGoHPRdDQPXYCWomvRGrQePYC2oqfRS+h1dAB9io5jgNExDmaM2WFcjIdFYIlYGibHFmPlWDVWjzVjHVg3dhUbwJ5h7wgkAouAE+wIXoQQwmyCkJBHWExYQ6gl7CO0EroIVwmDhDHCJyKTqE+0JXoS+cR4YjqxkFhGrCbuIR4hniVeJw4TX5NIJA7JkuROCiElkDJJC0lrSNtILaRTpD7SEGmcTCbrkG3J3uQIsoCsIJeRt5APkE+S+8nD5LcUOsWI4kwJoiRSpJQSSjVlP+UEpZ8yQpmgqlHNqZ7UCKqIOp9aSW2gdlAvU4epEzR1miXNmxZDy6Qto9XQmmlnafdoL+l0ugndgx5Fl9CX0mvoB+nn6YP0dwwNhg2Dx0hiKBlrGXsZpxi3GS+ZTKYF05eZyFQw1zIbmWeYD5hvVVgq9ip8FZHKEpU6lVaVfpXnqlRVc1U/1XmqC1SrVQ+rXlZ9pkZVs1DjqQnUFqvVqR1Vu6k2rs5Sd1KPUM9RX6O+X/2C+mMNsoaFRqCGSKNUY7fGGY0hFsYyZfFYQtZyVgPrLGuYTWJbsvnsTHYF+xt2L3tMU0NzqmasZpFmneZxzQEOxrHg8DnZnErOIc4NznstAy0/LbHWaq1mrX6tN9p62r7aYu1y7Rbt69rvdXCdQJ0snfU6bTr3dQm6NrpRuoW623XP6j7TY+t56Qn1yvUO6d3RR/Vt9KP1F+rv1u/RHzcwNAg2kBlsMThj8MyQY+hrmGm40fCE4agRy2i6kcRoo9FJoye4Ju6HZ+M1eBc+ZqxvHGKsNN5l3Gs8YWJpMtukxKTF5L4pzZRrmma60bTTdMzMyCzcrNisyeyOOdWca55hvtm82/yNhaVFnMVKizaLx5balnzLBZZNlvesmFY+VnlW9VbXrEnWXOss623WV2xQG1ebDJs6m8u2qK2brcR2m23fFOIUjynSKfVTbtox7PzsCuya7AbtOfZh9iX2bfbPHcwcEh3WO3Q7fHJ0dcx2bHC866ThNMOpxKnD6VdnG2ehc53zNRemS5DLEpd2lxdTbaeKp26fesuV5RruutK10/Wjm7ub3K3ZbdTdzD3Ffav7TS6bG8ldwz3vQfTw91jicczjnaebp8LzkOcvXnZeWV77vR5Ps5wmntYwbcjbxFvgvct7YDo+PWX6zukDPsY+Ap96n4e+pr4i3z2+I37Wfpl+B/ye+zv6y/2P+L/hefIW8U4FYAHBAeUBvYEagbMDawMfBJkEpQc1BY0FuwYvDD4VQgwJDVkfcpNvwBfyG/ljM9xnLJrRFcoInRVaG/owzCZMHtYRjobPCN8Qfm+m+UzpzLYIiOBHbIi4H2kZmRf5fRQpKjKqLupRtFN0cXT3LNas5Fn7Z72O8Y+pjLk722q2cnZnrGpsUmxj7Ju4gLiquIF4h/hF8ZcSdBMkCe2J5MTYxD2J43MC52yaM5zkmlSWdGOu5dyiuRfm6c7Lnnc8WTVZkHw4hZgSl7I/5YMgQlAvGE/lp25NHRPyhJuFT0W+oo2iUbG3uEo8kuadVpX2ON07fUP6aIZPRnXGMwlPUit5kRmSuSPzTVZE1t6sz9lx2S05lJyUnKNSDWmWtCvXMLcot09mKyuTDeR55m3KG5OHyvfkI/lz89sVbIVM0aO0Uq5QDhZML6greFsYW3i4SL1IWtQz32b+6vkjC4IWfL2QsFC4sLPYuHhZ8eAiv0W7FiOLUxd3LjFdUrpkeGnw0n3LaMuylv1Q4lhSVfJqedzyjlKD0qWlQyuCVzSVqZTJy26u9Fq5YxVhlWRV72qX1VtWfyoXlV+scKyorviwRrjm4ldOX9V89Xlt2treSrfK7etI66Trbqz3Wb+vSr1qQdXQhvANrRvxjeUbX21K3nShemr1js20zcrNAzVhNe1bzLas2/KhNqP2ep1/XctW/a2rt77ZJtrWv913e/MOgx0VO97vlOy8tSt4V2u9RX31btLugt2PGmIbur/mft24R3dPxZ6Pe6V7B/ZF7+tqdG9s3K+/v7IJbVI2jR5IOnDlm4Bv2pvtmne1cFoqDsJB5cEn36Z8e+NQ6KHOw9zDzd+Zf7f1COtIeSvSOr91rC2jbaA9ob3v6IyjnR1eHUe+t/9+7zHjY3XHNY9XnqCdKD3x+eSCk+OnZKeenU4/PdSZ3Hn3TPyZa11RXb1nQ8+ePxd07ky3X/fJ897nj13wvHD0Ivdi2yW3S609rj1HfnD94UivW2/rZffL7Vc8rnT0Tes70e/Tf/pqwNVz1/jXLl2feb3vxuwbt24m3Ry4Jbr1+Hb27Rd3Cu5M3F16j3iv/L7a/eoH+g/qf7T+sWXAbeD4YMBgz8NZD+8OCYee/pT/04fh0kfMR9UjRiONj50fHxsNGr3yZM6T4aeypxPPyn5W/3nrc6vn3/3i+0vPWPzY8Av5i8+/rnmp83Lvq6mvOscjxx+8znk98ab8rc7bfe+477rfx70fmSj8QP5Q89H6Y8en0E/3Pud8/vwv94Tz+4A5JREAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfcAgcQLxxUBNp/AAAQZ0lEQVR42u2be3QVVZbGv1N17829eRLyIKAEOiISEtPhJTJAYuyBDmhWjAEx4iAGBhxA4wABbVAMWUAeykMCM+HRTcBRWkNH2l5moS0LCCrQTkYeQWBQSCAIgYRXEpKbW/XNH5zS4noR7faPEeu31l0h4dSpvc+t/Z199jkFWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhY/H9D/MR9qfKnLj/00U71aqfJn9+HCkCR/Wk36ddsgyJ/1wF4fkDfqqm9/gPsUeTnVr6a2xlQfnxdI7zs0W7irzD17Ytb2WT7EeNv/r4ox1O3Quf2QP2pgt9utwfout4FQE8AVBSlnaRmfvAURQkg2RlAbwB9AThlW5L0GaiKojhJhgOIBqDa7XaPrusdPtr5kQwF0BVAAoBIABRCKDd5aFUhRDAAw57eAOwAhKIoupft3zoqhB1AqLwuHIBut9uFt02qqvqRDJR2dAEQJj/BAOjn56dqmma+xiaECAEQAWAggLsB6A6HQ2iaZggBhBAqgEAAnQB0kzaEmT4hAITT6VQ8Ho/HJAKKECJQtr8LwD1y/A1/vcdfEUIEyfZ9AcQbYvZ942Px88L2UwlJR0dH0EMPPbRj5syZPUeNGrXR7Xb/641xIwJ1XY9NSUlZm52dfW+XLl1w8uRJzJ8//+OGhoYJqqqe1TSt1Wsm9NN1PSIqKmr12rVrR5WUlHy1bdu2AQCumWc3IYRD1/UwVVXnFRQUTIuNjUVzczN2797dWFJSkq8oymZd15sAGAEnFEUJ1nX9nzIzM1dnZmZGh4SE4OTJk5g5c+Zf29vbp9pstrMej6fVOyhIhgAYU1hY+B+hoaGoqKg4XVlZea+XTULTNFdCQsLGiRMnPuR2u3UhBOV9eeDAAWXTpk095DUe6WsoyRE5OTlr0tLSAux2O/bs2cO5c+e+pijKUpIXSHaQVAGkvPLKK++6XK4OksJLCFlXV2cvKSlJBFAjhU+x2WwhHo9nUHp6+urMzMy7wsLCUF9fjxdffPHjxsbGiTab7WuPx9NiEutOuq4PyMjI+M+srKyYqKgoHD58GDNmzNjq8XhyVFU9b/q+LH7hBAEYu3PnTlZVVRFAGgCX6f/tAHoOHDjwa0p27txp/JO9e/f+QM7cipw9nfL3kQBKt2zZQpJ87rnn6mQmoHilw2EACs+cOUOSrK+vZ1NTE0nyo48+IoBpxswoBcMJ4Ndjx471kOTFixe5d+9ekqTH42H//v13A4jyzpAURfEH0H/OnDnthu1z5sw558MmFUCPWbNmnaMP3nrrLZoyDmP8Hl68eDFJ8siRI9/Yc+zYMQKYKdtAztrTrl27xptRXV1NAKMAOAyBBBA/Y8aMdpLs6Ojgxx9//E37+++//29yvFXppwvAwMcee8xjtDHsuXLlCqOjo//ia3wsfpkoALqFhoZuIckJEyackimm3dQmEMDUmpoakmRISMhhAHOHDx/eQJIbN24kgKEyMAHAFRMTs2XXrl1saWkhSZ0kp0+ffhrAr3wEW/S8efOukORLL72kA1gKYMPWrVtJkk899dRJAHeYrgsEsIQkjx8/TgDvAPjd448/3kaSb7zxBmUa7vC6z53BwcFbSHL9+vU6Sc6aNes8gF5ewWAH0PfVV18lSQL4DMBGIcQ6AKtcLleBFC2jXtFt8ODBe0iyoqKCAJYByC8qKmJDQwOzsrK+MAmqo1OnTveHhoa+GRkZ+XZkZOSWiIiIvzgcjk9mzpypkWRmZuZpmbYbGV4AgPnNzc1sa2sjgN0A5iQmJtaSZHl5OQHcb/K3s81mW0uSTU1NBFAFYFbfvn1Pk+Tbb79NAA8IIVzW42/hByA+Pz/fLR/2ZXIda05NI/z9/TeR5J49ewhgqlxTrtI0jY2NjQQw3zTLuWJiYjaUlJToS5Ys6fjkk080kwDEeAmADcA9GzZsIElGRUW9CyAWwLApU6Y0kOSKFSsog9QICGdERMTGsrIyZmVlEcC9AB4IDw/fTpLbtm0jgN94CUAnAJmVlZVcs2aNZ/LkyRdJcvbs2b4EwAkgZfPmzTxw4AABFAN4BkC6vFeUSewcAO5duXIlSTIhIaEawGMAxgKYAmAGgCS73e5vrKVk/yGythANYEhCQsIhkly+fDkBpKqqGmL6DgIALDKN/3yZpVWQZGVlJQE8aPI3KiMjo5okV61aRQAjAPQBMPfIkSN0u90EUCBtsPiFEwpgbn19PdetW2fM5N4zQ9ekpKQqkty0aRMBpMjiWM6JEydIkoqirJUFJ6iq6pAPVy8A6cZMehMBUACEuVyuFwG8HBwcPEIWx367ZMkSjSQXLVrUJouTRorrkAHdA8BdQogsAOsKCwtJkmPGjDkvMw2bDDo/ADEjRoz4XylyFbm5uY0mAbjLyyZ/AOOrq6tZVlbWsWDBgo69e/eyoqKCgwcPPg4gSQaoIRbp27dvN7KF+tLSUr28vJwFBQXtMpvpYRIM7+wrAkDeqVOnePbsWQIoNKfzpiXPg8uXLydJJicnNwF4f+nSpW6STEtLq5fjYwhk1wkTJtSQ5Ouvv04AqTKj+N2xY8dIkgEBAW/Ie1v8wncRegwZMmQvSfbr12+3Ua33WqPfOWbMmP0kWVpaSgCDZAqcfejQIWNZsEGKgvnh9gfQb9myZd8nAEJVVZtMkUNk8CcNHTq0liR1XWdYWNhmH1mJIme80OnTp18x1rp5eXkEsNJms92Fb7e/IgEsvHz5Mp999tkmAI/l5uZeMC0B7vEqqAYAyL106RJJsra2lpWVld+sucePH38ZQG+5NncBeOrgwYMkqbe3t/Po0aOsra011wAWyl0H7x0JJ4DE+fPnu0kyPT29DsDdUrBuyNKEEAkAdpw/f/6GeoEM8GUmfwEgPCIiopwkGxsbabPZPgOw6L777vvm4p49e26VGYjFLxUhhD+ApLKyMp44ccIoVnXybgbgzkcfffRzklyzZg0BDJYCMMmoCwQFBXkLgLGWvvcWAgBToSsKwNPTp09vMR7UuLi4rwH0lgU8c/Db5ezbeeTIkRWzZ8++aMxu+fn5BPCADBwHgP4LFy701NXVEUAJgAnPP/98kyxMNgHo53A4zH77BQQETMvPz7+Um5vbBuAlAFMSExPPmdbVL0qh8Acw8fDhw5SCchVAEYAVb775JknyhRdeaJYztHfxMwLAaqNwCGC2FArv8x0hAHKNLGPKlCme5OTk/Zs3bzb7O0wKiiG8KXl5ed8IxenTp0mSR48e1UmyW7duWywBuD2xyQcgFECgoih+8H1gyJgZV5Lkyy+/3CbTRIePtl2HDBmyw1QBHyGDdXZdXR1JUghRKkXBjOMHCoBdpr0L3nvvPZLkF198wejo6O0A4lVVDTb74HQ6AwD8Wq7Jh8rgGgDgQ13XjVR8qaxJuADMbmlpYXl5uV5UVNRWUFDgfv/993Vj/ZydnU1c37eHXML4S3viAcQqitJD2l104cIFY8lTKsXSBWBMVVWVcd9yed2A1NTUQ6Zl00CvLMMOoHdubm6zFIlWOf5+PsY/Kj09vdrU11QAwwGsv3jxIk21m2DZr10I0RXAuAcffPBgaWkpV69eTYfDcdiwUxY0w6xw+flX8L1xApjevXv3lREREaW6rofB93aPDUDQpEmTMgHgtddeqwBwEd/utZvpqK6uPgEAcXFxkA94NwB9unfvjrNnz4LklwDcf08iIqv66Zs2bXrl4YcfxooVKxAbG7uqrq5uAYA2TdOEqqpGYIi2tjbl6aeffu/YsWPv5uTk7JaC1wHg4Pnz542MwoVvTx+21dbWYvjw4WLixIl+2dnZ9lGjRgmSTE1NRUpKCkwFTGiaxtTU1OXTpk3707Bhw/6g67pDipnT4biuj7qut+Lbk3Vf1tTUXI9qu91Pjq1QFEUBgJaWFgBo8yGOQ8eNGxcAAOvXr/8QwBUfYygAKL169eoCABcuXACAWtn2hOGv0+kMNO1KiPDw8F4A4rZv3/7R1KlTR0+bNu1ht9u9r1+/fqitrQXJgwDarRC6/QjPzs4+QJIffPCB9/aQmSAA43ft2mW0e1QGoi8CAPyLsZccExNTC2BlRkbGRdOyYJCP2csBIN6UAZzCd7cBbQCijYp/dXU1ExMTz6SmptaMHj36f9LS0vYlJCRsl6mxIWSdu3fv/g5J7t+/nwC2AShMTk6+SJKff/45AWRLYbD7+fndAeDf5BJnLoCCyZMnt5JkdnZ2C4B/F0KEm1Pu+Pj4rST55ZdfEsBWAK+mpaVdMo3raDn7KwDuSEpK+m+S3LBhAwG8DuCtHTt2UBbpjgC408vvcFVV15HkuXPnjMp+p5uMf0RcXNyHJNnQ0EBVVfcCWBQXF3fG+Jv0yxABPwB5LS0tRmFxN4BlTzzxxGWSXLx4sS5F3GGFy+1Hp5SUlJq6ujoWFxdTpsZ2H+0iIyMj/0iSWVlZX5mr5jfJFroPGzasxlhTnjp1iiTZ3NxMl8tlrCd9pfa9SkpKSJI5OTmnZOageLUZZqxvfVFWVkZcPwdgNwnSCKPqb17jkmR8fPzfZMDZ5CRsFBmNI7h95s2b1yhT7/MAYmStwCx4vy0uLqa3v5qmEcCfvSr1QQAeXb16NY3Cm3HQ55133iGAp+SxZTNhKSkpfzUddkrFjYevzAQCeGjp0qXfsYckY2NjTwD4leGDLCL2HTdunNtoY+zWSHFcIHdsFCtcfuZ1vO9Eqs3m7/F47sb1k2qX/f3997W2tl7BjWfpBYDOzzzzzIVJkyZh0KBBCwEsB3AJvl9AETabLcDj8dwRFRW1ctasWb8JCgpSzp07d62wsPC/Wltb8xRFadR1/ZqPXYbgAQMGbI2Pjw/+6quv9ldVVT0r01ezuPRJSUn5Y9euXXVd11WzDaqq6kePHm3+7LPPRgO4KlNuxWazhXo8nuTk5OSXMjIyEl0uFxoaGtqKior+dPXq1VdUVT0jj7r68ieoT58+vx8yZMjdx48fP1JVVTVF9m20VW02WyfZf97YsWPjXS4X6urqWvPy8jYCWCyEuEDS8FdVFKWzruv//OSTTy5OTk7uqWkaPv3007qysrJ8RVH+LI8ym8/rB3Tu3HnRI488knLo0KG2ffv2ZQI4C98vP6mqqoZqmpaclpa2cOTIkX39/f3R0NDQUVxc/G5TU9PLqqrWa5rWLH1QVFUN0TStX1JSUvH48eP7BwYG4uDBg1cKCgpeBbBe2u+2Qug2EwD5N5sMPuNtMe8XP4TT6Qxoa2sbIGeXvUKIK7d4IISiKC5d1wPljOfA9bPwzYqiXNV13dd6Uqiq6qdpml2mpe02m63d4/G4vcTF5fF47LJf71nJA6BZVVW3pmntuPHlmAD5wk6Q9NnbHp9vHaqq6tA0zU/64PZhk1FfCZB9G/23ALiqKEqzD39tpvbGUqoFwFUhRLP3yzpCCDtJpxyXDulfG27+pqRR3DXsUWVd4Yq0x/taVQjhIhksC8L+ABpM9ljBf5sKwI8pIBr75L5E4vvu+UNeG/a+hv+AL7yFH8qPtOfHjtOP6V/Bja8D6z/B2Nys/1u9Xv33tLf4GfF/LC4GCJwByWIAAAAASUVORK5CYII=";
cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k=";
cc.loader.loadBinary = function(t, e) {
  var n = (this || window), r = (this || window).getXMLHttpRequest(), s = "load " + t + " failed!";
  r.open("GET", t, !0), cc.loader.loadBinary._IEFilter ? (r.setRequestHeader("Accept-Charset", "x-user-defined"), r.onreadystatechange = function() {
    if (r.readyState === 4 && r.status === 200) {
      var o = cc._convertResponseBodyToText(r.responseBody);
      e(null, n._str2Uint8Array(o));
    } else
      e(s);
  }) : (r.overrideMimeType && r.overrideMimeType("text/plain; charset=x-user-defined"), r.onload = function() {
    r.readyState === 4 && r.status === 200 ? e(null, n._str2Uint8Array(r.responseText)) : e(s);
  }), r.send(null);
};
cc.loader.loadBinary._IEFilter = /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && window.IEBinaryToArray_ByteStr && window.IEBinaryToArray_ByteStr_Last;
cc.loader._str2Uint8Array = function(t) {
  if (!t)
    return null;
  for (var e = new Uint8Array(t.length), n = 0; n < t.length; n++)
    e[n] = t.charCodeAt(n) & 255;
  return e;
};
cc.loader.loadBinarySync = function(t) {
  var e = (this || window), n = (this || window).getXMLHttpRequest(), r = "load " + t + " failed!";
  n.open("GET", t, !1);
  var s = null;
  if (cc.loader.loadBinary._IEFilter) {
    if (n.setRequestHeader("Accept-Charset", "x-user-defined"), n.send(null), n.status !== 200)
      return cc.log(r), null;
    var o = cc._convertResponseBodyToText(n.responseBody);
    o && (s = e._str2Uint8Array(o));
  } else {
    if (n.overrideMimeType && n.overrideMimeType("text/plain; charset=x-user-defined"), n.send(null), n.status !== 200)
      return cc.log(r), null;
    s = (this || window)._str2Uint8Array(n.responseText);
  }
  return s;
};
window.Uint8Array = window.Uint8Array || window.Array;
if (cc.loader.loadBinary._IEFilter) {
  var IEBinaryToArray_ByteStr_Script = `<!-- IEBinaryToArray_ByteStr -->\r
Function IEBinaryToArray_ByteStr(Binary)\r
   IEBinaryToArray_ByteStr = CStr(Binary)\r
End Function\r
Function IEBinaryToArray_ByteStr_Last(Binary)\r
   Dim lastIndex\r
   lastIndex = LenB(Binary)\r
   if lastIndex mod 2 Then\r
       IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r
   Else\r
       IEBinaryToArray_ByteStr_Last = ""\r
   End If\r
End Function\r
`, myVBScript = document.createElement("script");
  myVBScript.type = "text/vbscript", myVBScript.textContent = IEBinaryToArray_ByteStr_Script, document.body.appendChild(myVBScript), cc._convertResponseBodyToText = function(t) {
    for (var e = {}, n = 0; n < 256; n++)
      for (var r = 0; r < 256; r++)
        e[String.fromCharCode(n + r * 256)] = String.fromCharCode(n) + String.fromCharCode(r);
    var s = IEBinaryToArray_ByteStr(t), o = IEBinaryToArray_ByteStr_Last(t);
    return s.replace(
      /[\s\S]/g,
      function(a) {
        return e[a];
      }
    ) + o;
  };
}
var cc = cc || {}, ClassManager = {
  id: 0 | Math.random() * 998,
  instanceId: 0 | Math.random() * 998,
  getNewID: function() {
    return this.id++;
  },
  getNewInstanceId: function() {
    return this.instanceId++;
  }
};
(function() {
  var t = /\b_super\b/;
  cc.Class = function() {
  }, cc.Class.extend = function(e) {
    var n = (this || window).prototype, r = Object.create(n), s = ClassManager.getNewID();
    ClassManager[s] = n;
    var o = { writable: !0, enumerable: !1, configurable: !0 };
    r.__instanceId = null;
    function a() {
      this.__instanceId = ClassManager.getNewInstanceId(), this.ctor && this.ctor.apply(this, arguments);
    }
    H(a, "Class"), a.id = s, o.value = s, Object.defineProperty(r, "__pid", o), a.prototype = r, o.value = a, Object.defineProperty(a.prototype, "constructor", o), this.__getters__ && (a.__getters__ = cc.clone(this.__getters__)), this.__setters__ && (a.__setters__ = cc.clone(this.__setters__));
    for (var c = 0, l = arguments.length; c < l; ++c) {
      var h = arguments[c];
      for (var u in h) {
        var _ = typeof h[u] == "function", d = typeof n[u] == "function", f = t.test(h[u]);
        if (_ && d && f ? (o.value = function(A, D) {
          return function() {
            var N = (this || window)._super;
            this._super = n[A];
            var z = D.apply(this, arguments);
            return this._super = N, z;
          };
        }(u, h[u]), Object.defineProperty(r, u, o)) : _ ? (o.value = h[u], Object.defineProperty(r, u, o)) : r[u] = h[u], _) {
          var C, m, g;
          if (this.__getters__ && this.__getters__[u]) {
            g = (this || window).__getters__[u];
            for (var y in this.__setters__)
              if (this.__setters__[y] === g) {
                m = y;
                break;
              }
            cc.defineGetterSetter(r, g, h[u], h[m] ? h[m] : r[m], u, m);
          }
          if (this.__setters__ && this.__setters__[u]) {
            g = (this || window).__setters__[u];
            for (var y in this.__getters__)
              if (this.__getters__[y] === g) {
                C = y;
                break;
              }
            cc.defineGetterSetter(r, g, h[C] ? h[C] : r[C], h[u], C, u);
          }
        }
      }
    }
    return a.extend = cc.Class.extend, a.implement = function(A) {
      for (var D in A)
        r[D] = A[D];
    }, a;
  };
})();
cc.defineGetterSetter = function(t, e, n, r, s, o) {
  if (t.__defineGetter__)
    n && t.__defineGetter__(e, n), r && t.__defineSetter__(e, r);
  else if (Object.defineProperty) {
    var a = { enumerable: !1, configurable: !0 };
    n && (a.get = n), r && (a.set = r), Object.defineProperty(t, e, a);
  } else
    throw new Error("browser does not support getters");
  if (!s && !o)
    for (var c = n != null, l = r != null, h = Object.getOwnPropertyNames(t), u = 0; u < h.length; u++) {
      var _ = h[u];
      if (!((t.__lookupGetter__ ? t.__lookupGetter__(_) : Object.getOwnPropertyDescriptor(t, _)) || typeof t[_] != "function")) {
        var d = t[_];
        if (c && d === n && (s = _, !l || o) || l && d === r && (o = _, !c || s))
          break;
      }
    }
  var f = t.constructor;
  s && (f.__getters__ || (f.__getters__ = {}), f.__getters__[s] = e), o && (f.__setters__ || (f.__setters__ = {}), f.__setters__[o] = e);
};
cc.clone = function(t) {
  var e = t.constructor ? new t.constructor() : {};
  for (var n in t) {
    var r = t[n];
    typeof r == "object" && r && !(r instanceof cc.Node) && !(r instanceof HTMLElement) ? e[n] = cc.clone(r) : e[n] = r;
  }
  return e;
};
cc.inject = function(t, e) {
  for (var n in t)
    e[n] = t[n];
};
cc.Point = function(t, e) {
  this.x = t || 0, this.y = e || 0;
};
cc.p = function(t, e) {
  return t === void 0 ? { x: 0, y: 0 } : e === void 0 ? { x: t.x, y: t.y } : { x: t, y: e };
};
cc.pointEqualToPoint = function(t, e) {
  return t && e && t.x === e.x && t.y === e.y;
};
cc.Size = function(t, e) {
  this.width = t || 0, this.height = e || 0;
};
cc.size = function(t, e) {
  return t === void 0 ? { width: 0, height: 0 } : e === void 0 ? { width: t.width, height: t.height } : { width: t, height: e };
};
cc.sizeEqualToSize = function(t, e) {
  return t && e && t.width === e.width && t.height === e.height;
};
cc.Rect = function(t, e, n, r) {
  this.x = t || 0, this.y = e || 0, this.width = n || 0, this.height = r || 0;
};
cc.rect = function(t, e, n, r) {
  return t === void 0 ? { x: 0, y: 0, width: 0, height: 0 } : e === void 0 ? { x: t.x, y: t.y, width: t.width, height: t.height } : { x: t, y: e, width: n, height: r };
};
cc.rectEqualToRect = function(t, e) {
  return t && e && t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
};
cc._rectEqualToZero = function(t) {
  return t && t.x === 0 && t.y === 0 && t.width === 0 && t.height === 0;
};
cc.rectContainsRect = function(t, e) {
  return !t || !e ? !1 : !(t.x >= e.x || t.y >= e.y || t.x + t.width <= e.x + e.width || t.y + t.height <= e.y + e.height);
};
cc.rectGetMaxX = function(t) {
  return t.x + t.width;
};
cc.rectGetMidX = function(t) {
  return t.x + t.width / 2;
};
cc.rectGetMinX = function(t) {
  return t.x;
};
cc.rectGetMaxY = function(t) {
  return t.y + t.height;
};
cc.rectGetMidY = function(t) {
  return t.y + t.height / 2;
};
cc.rectGetMinY = function(t) {
  return t.y;
};
cc.rectContainsPoint = function(t, e) {
  return e.x >= cc.rectGetMinX(t) && e.x <= cc.rectGetMaxX(t) && e.y >= cc.rectGetMinY(t) && e.y <= cc.rectGetMaxY(t);
};
cc.rectIntersectsRect = function(t, e) {
  var n = t.x + t.width, r = t.y + t.height, s = e.x + e.width, o = e.y + e.height;
  return !(n < e.x || s < t.x || r < e.y || o < t.y);
};
cc.rectOverlapsRect = function(t, e) {
  return !(t.x + t.width < e.x || e.x + e.width < t.x || t.y + t.height < e.y || e.y + e.height < t.y);
};
cc.rectUnion = function(t, e) {
  var n = cc.rect(0, 0, 0, 0);
  return n.x = Math.min(t.x, e.x), n.y = Math.min(t.y, e.y), n.width = Math.max(t.x + t.width, e.x + e.width) - n.x, n.height = Math.max(t.y + t.height, e.y + e.height) - n.y, n;
};
cc.rectIntersection = function(t, e) {
  var n = cc.rect(
    Math.max(cc.rectGetMinX(t), cc.rectGetMinX(e)),
    Math.max(cc.rectGetMinY(t), cc.rectGetMinY(e)),
    0,
    0
  );
  return n.width = Math.min(cc.rectGetMaxX(t), cc.rectGetMaxX(e)) - cc.rectGetMinX(n), n.height = Math.min(cc.rectGetMaxY(t), cc.rectGetMaxY(e)) - cc.rectGetMinY(n), n;
};
cc.SAXParser = cc.Class.extend({
  _parser: null,
  _isSupportDOMParser: null,
  ctor: function() {
    window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser()) : this._isSupportDOMParser = !1;
  },
  parse: function(t) {
    return this._parseXML(t);
  },
  _parseXML: function(t) {
    var e;
    return this._isSupportDOMParser ? e = (this || window)._parser.parseFromString(t, "text/xml") : (e = new ActiveXObject("Microsoft.XMLDOM"), e.async = "false", e.loadXML(t)), e;
  }
});
cc.PlistParser = cc.SAXParser.extend({
  parse: function(t) {
    var e = (this || window)._parseXML(t), n = e.documentElement;
    if (n.tagName !== "plist")
      return cc.warn("Not a plist file!"), {};
    for (var r = null, s = 0, o = n.childNodes.length; s < o && (r = n.childNodes[s], r.nodeType !== 1); s++)
      ;
    return e = null, this._parseNode(r);
  },
  _parseNode: function(t) {
    var e = null, n = t.tagName;
    if (n === "dict")
      e = (this || window)._parseDict(t);
    else if (n === "array")
      e = (this || window)._parseArray(t);
    else if (n === "string")
      if (t.childNodes.length === 1)
        e = t.firstChild.nodeValue;
      else {
        e = "";
        for (var r = 0; r < t.childNodes.length; r++)
          e += t.childNodes[r].nodeValue;
      }
    else
      n === "false" ? e = !1 : n === "true" ? e = !0 : n === "real" ? e = parseFloat(t.firstChild.nodeValue) : n === "integer" && (e = parseInt(t.firstChild.nodeValue, 10));
    return e;
  },
  _parseArray: function(t) {
    for (var e = [], n = 0, r = t.childNodes.length; n < r; n++) {
      var s = t.childNodes[n];
      s.nodeType === 1 && e.push(this._parseNode(s));
    }
    return e;
  },
  _parseDict: function(t) {
    for (var e = {}, n = null, r = 0, s = t.childNodes.length; r < s; r++) {
      var o = t.childNodes[r];
      o.nodeType === 1 && (o.tagName === "key" ? n = o.firstChild.nodeValue : e[n] = (this || window)._parseNode(o));
    }
    return e;
  }
});
cc.saxParser = new cc.SAXParser();
cc.plistParser = new cc.PlistParser();
cc._txtLoader = {
  load: function(t, e, n, r) {
    cc.loader.loadTxt(t, r);
  }
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
  load: function(t, e, n, r) {
    cc.loader.loadJson(t, r);
  }
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._jsLoader = {
  load: function(t, e, n, r) {
    cc.loader.loadJs(t, r);
  }
};
cc.loader.register(["js"], cc._jsLoader);
cc._imgLoader = {
  load: function(t, e, n, r) {
    var s;
    cc.loader.isLoading(t) ? s = r : s = /* @__PURE__ */ H(function(o, a) {
      if (o)
        return r(o);
      cc.loader.cache[e] = a, cc.textureCache.handleLoadedTexture(e), r(null, a);
    }, "callback"), cc.loader.loadImg(t, s);
  }
};
cc.loader.register(["png", "jpg", "bmp", "jpeg", "gif", "ico", "tiff", "webp"], cc._imgLoader);
cc._serverImgLoader = {
  load: function(t, e, n, r) {
    cc._imgLoader.load(n.src, e, n, r);
  }
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
  load: function(t, e, n, r) {
    cc.loader.loadTxt(t, function(s, o) {
      if (s)
        return r(s);
      r(null, cc.plistParser.parse(o));
    });
  }
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
  TYPE: {
    ".eot": "embedded-opentype",
    ".ttf": "truetype",
    ".ttc": "truetype",
    ".woff": "woff",
    ".svg": "svg"
  },
  _loadFont: function(t, e, n) {
    var r = document, s = cc.path, o = (this || window).TYPE, a = document.createElement("style");
    a.type = "text/css", r.body.appendChild(a);
    var c = "";
    if (isNaN(t - 0) ? c += "@font-face { font-family:" + t + "; src:" : c += "@font-face { font-family:'" + t + "'; src:", e instanceof Array)
      for (var l = 0, h = e.length; l < h; l++) {
        var u = e[l];
        n = s.extname(u).toLowerCase(), c += "url('" + e[l] + "') format('" + o[n] + "')", c += l === h - 1 ? ";" : ",";
      }
    else
      n = n.toLowerCase(), c += "url('" + e + "') format('" + o[n] + "');";
    a.textContent += c + "}";
    var _ = document.createElement("div"), d = _.style;
    d.fontFamily = t, _.innerHTML = ".", d.position = "absolute", d.left = "-100px", d.top = "-100px", r.body.appendChild(_);
  },
  load: function(t, e, n, r) {
    var s = (this || window), o = n.type, a = n.name, c = n.srcs;
    cc.isString(n) ? (o = cc.path.extname(n), a = cc.path.basename(n, o), s._loadFont(a, n, o)) : s._loadFont(a, c), document.fonts ? document.fonts.load("1em " + a).then(function() {
      r(null, !0);
    }, function(l) {
      r(l);
    }) : r(null, !0);
  }
};
cc.loader.register(["font", "eot", "ttf", "woff", "svg", "ttc"], cc._fontLoader);
cc._binaryLoader = {
  load: function(t, e, n, r) {
    cc.loader.loadBinary(t, r);
  }
};
cc._csbLoader = {
  load: function(t, e, n, r) {
    cc.loader.loadCsb(t, r);
  }
};
cc.loader.register(["csb"], cc._csbLoader);
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.13";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function(t) {
  var e = (this || window) === cc ? document : this, n = t instanceof HTMLElement ? t : e.querySelector(t);
  return n && (n.find = n.find || cc.$, n.hasClass = n.hasClass || function(r) {
    return this.className.match(new RegExp("(\\s|^)" + r + "(\\s|$)"));
  }, n.addClass = n.addClass || function(r) {
    return this.hasClass(r) || (this.className && (this.className += " "), this.className += r), (this || window)
  }, n.removeClass = n.removeClass || function(r) {
    return this.hasClass(r) && (this.className = (this || window).className.replace(r, "")), (this || window)
  }, n.remove = n.remove || function() {
    return this.parentNode && this.parentNode.removeChild(this), (this || window)
  }, n.appendTo = n.appendTo || function(r) {
    return r.appendChild(this), (this || window)
  }, n.prependTo = n.prependTo || function(r) {
    return r.childNodes[0] ? r.insertBefore(this, r.childNodes[0]) : r.appendChild(this), (this || window)
  }, n.transforms = n.transforms || function() {
    return this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew), (this || window)
  }, n.position = n.position || { x: 0, y: 0 }, n.rotation = n.rotation || 0, n.scale = n.scale || { x: 1, y: 1 }, n.skew = n.skew || { x: 0, y: 0 }, n.translates = function(r, s) {
    return this.position.x = r, this.position.y = s, this.transforms(), (this || window)
  }, n.rotate = function(r) {
    return this.rotation = r, this.transforms(), (this || window)
  }, n.resize = function(r, s) {
    return this.scale.x = r, this.scale.y = s, this.transforms(), (this || window)
  }, n.setSkew = function(r, s) {
    return this.skew.x = r, this.skew.y = s, this.transforms(), (this || window)
  }), n;
};
switch (cc.sys.browserType) {
  case cc.sys.BROWSER_TYPE_FIREFOX:
    cc.$.pfx = "Moz", cc.$.hd = !0;
    break;
  case cc.sys.BROWSER_TYPE_CHROME:
  case cc.sys.BROWSER_TYPE_SAFARI:
    cc.$.pfx = "webkit", cc.$.hd = !0;
    break;
  case cc.sys.BROWSER_TYPE_OPERA:
    cc.$.pfx = "O", cc.$.hd = !1;
    break;
  case cc.sys.BROWSER_TYPE_IE:
    cc.$.pfx = "ms", cc.$.hd = !1;
    break;
  default:
    cc.$.pfx = "webkit", cc.$.hd = !0;
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function(t) {
  return "translate3d(" + t.x + "px, " + t.y + "px, 0) ";
} : function(t) {
  return "translate(" + t.x + "px, " + t.y + "px) ";
};
cc.$.rotate = cc.$.hd ? function(t) {
  return "rotateZ(" + t + "deg) ";
} : function(t) {
  return "rotate(" + t + "deg) ";
};
cc.$.scale = function(t) {
  return "scale(" + t.x + ", " + t.y + ") ";
};
cc.$.skew = function(t) {
  return "skewX(" + -t.x + "deg) skewY(" + t.y + "deg)";
};
cc.$new = function(t) {
  return cc.$(document.createElement(t));
};
cc.$.findpos = function(t) {
  var e = 0, n = 0;
  do
    e += t.offsetLeft, n += t.offsetTop;
  while (t = t.offsetParent);
  return { x: e, y: n };
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function(t, e, n) {
  if (cc.isObject(n) && !cc.isUndefined(n.x) && !cc.isUndefined(n.y)) {
    var r = n[t];
    n[t] = n[e], n[e] = r;
  } else
    cc.log(cc._LogInfos.swap);
};
cc.lerp = function(t, e, n) {
  return t + (e - t) * n;
};
cc.rand = function() {
  return Math.random() * 16777215;
};
cc.randomMinus1To1 = function() {
  return (Math.random() - 0.5) * 2;
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function(t) {
  return t * cc.RAD;
};
cc.radiansToDegrees = function(t) {
  return t * cc.DEG;
};
cc.radiansToDegress = function(t) {
  return cc.log(cc._LogInfos.radiansToDegress), t * cc.DEG;
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.nodeDrawSetup = function(t) {
  t._shaderProgram && (t._shaderProgram.use(), t._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4());
};
cc.enableDefaultGLStates = function() {
};
cc.disableDefaultGLStates = function() {
};
cc.incrementGLDraws = function(t) {
  cc.g_NumberOfDraws += t;
};
cc.FLT_EPSILON = 1192092896e-16;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
  return cc.director.getContentScaleFactor();
} : function() {
  return 1;
};
cc.pointPointsToPixels = function(t) {
  var e = cc.contentScaleFactor();
  return cc.p(t.x * e, t.y * e);
};
cc.pointPixelsToPoints = function(t) {
  var e = cc.contentScaleFactor();
  return cc.p(t.x / e, t.y / e);
};
cc._pointPixelsToPointsOut = function(t, e) {
  var n = cc.contentScaleFactor();
  e.x = t.x / n, e.y = t.y / n;
};
cc.sizePointsToPixels = function(t) {
  var e = cc.contentScaleFactor();
  return cc.size(t.width * e, t.height * e);
};
cc.sizePixelsToPoints = function(t) {
  var e = cc.contentScaleFactor();
  return cc.size(t.width / e, t.height / e);
};
cc._sizePixelsToPointsOut = function(t, e) {
  var n = cc.contentScaleFactor();
  e.width = t.width / n, e.height = t.height / n;
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(t) {
  var e = cc.contentScaleFactor();
  return cc.rect(
    t.x / e,
    t.y / e,
    t.width / e,
    t.height / e
  );
} : function(t) {
  return t;
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(t) {
  var e = cc.contentScaleFactor();
  return cc.rect(
    t.x * e,
    t.y * e,
    t.width * e,
    t.height * e
  );
} : function(t) {
  return t;
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.LINEAR = 9729;
cc.REPEAT = 10497;
cc.CLAMP_TO_EDGE = 33071;
cc.MIRRORED_REPEAT = 33648;
cc.BLEND_SRC = cc.SRC_ALPHA;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA && (cc.BLEND_SRC = cc.ONE);
});
cc.BLEND_DST = cc.ONE_MINUS_SRC_ALPHA;
cc.checkGLErrorDebug = function() {
  if (cc.renderMode === cc.game.RENDER_TYPE_WEBGL) {
    var t = cc._renderContext.getError();
    t && cc.log(cc._LogInfos.checkGLErrorDebug, t);
  }
};
cc.ORIENTATION_PORTRAIT = 1;
cc.ORIENTATION_LANDSCAPE = 2;
cc.ORIENTATION_AUTO = 3;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 7;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_SPRITE_POSITION_TEXTURECOLOR = "ShaderSpritePositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST = "ShaderSpritePositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_SPRITE_POSITION_COLOR = "ShaderSpritePositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ATTRIBUTE_NAME_MVMAT = "a_mvMatrix";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function(t, e) {
  if (t && t.length > 0) {
    for (var n = 0; n < t.length; n++)
      if (!(t[n] instanceof e))
        return cc.log("element type is wrong!"), !1;
  }
  return !0;
};
cc.arrayRemoveObject = function(t, e) {
  for (var n = 0, r = t.length; n < r; n++)
    if (t[n] === e) {
      t.splice(n, 1);
      break;
    }
};
cc.arrayRemoveArray = function(t, e) {
  for (var n = 0, r = e.length; n < r; n++)
    cc.arrayRemoveObject(t, e[n]);
};
cc.arrayAppendObjectsToIndex = function(t, e, n) {
  return t.splice.apply(t, [n, 0].concat(e)), t;
};
cc.copyArray = function(t) {
  var e, n = t.length, r = new Array(n);
  for (e = 0; e < n; e += 1)
    r[e] = t[e];
  return r;
};
cc._tmp.PrototypeColor = function() {
  var t = cc.color;
  t._getWhite = function() {
    return t(255, 255, 255);
  }, t._getYellow = function() {
    return t(255, 255, 0);
  }, t._getBlue = function() {
    return t(0, 0, 255);
  }, t._getGreen = function() {
    return t(0, 255, 0);
  }, t._getRed = function() {
    return t(255, 0, 0);
  }, t._getMagenta = function() {
    return t(255, 0, 255);
  }, t._getBlack = function() {
    return t(0, 0, 0);
  }, t._getOrange = function() {
    return t(255, 127, 0);
  }, t._getGray = function() {
    return t(166, 166, 166);
  }, t.WHITE, cc.defineGetterSetter(t, "WHITE", t._getWhite), t.YELLOW, cc.defineGetterSetter(t, "YELLOW", t._getYellow), t.BLUE, cc.defineGetterSetter(t, "BLUE", t._getBlue), t.GREEN, cc.defineGetterSetter(t, "GREEN", t._getGreen), t.RED, cc.defineGetterSetter(t, "RED", t._getRed), t.MAGENTA, cc.defineGetterSetter(t, "MAGENTA", t._getMagenta), t.BLACK, cc.defineGetterSetter(t, "BLACK", t._getBlack), t.ORANGE, cc.defineGetterSetter(t, "ORANGE", t._getOrange), t.GRAY, cc.defineGetterSetter(t, "GRAY", t._getGray), cc.BlendFunc._disable = function() {
    return new cc.BlendFunc(cc.ONE, cc.ZERO);
  }, cc.BlendFunc._alphaPremultiplied = function() {
    return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
  }, cc.BlendFunc._alphaNonPremultiplied = function() {
    return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
  }, cc.BlendFunc._additive = function() {
    return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE);
  }, cc.BlendFunc.DISABLE, cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable), cc.BlendFunc.ALPHA_PREMULTIPLIED, cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied), cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied), cc.BlendFunc.ADDITIVE, cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive);
};
var cc = cc || {};
cc._tmp = cc._tmp || {};
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
    cc.color = function(e, n, r, s, o, a) {
      if (e === void 0)
        return new cc.Color(0, 0, 0, 255, o, a);
      if (cc.isString(e)) {
        var c = cc.hexToColor(e);
        return new cc.Color(c.r, c.g, c.b, c.a);
      }
      return cc.isObject(e) ? new cc.Color(e.r, e.g, e.b, e.a, e.arrayBuffer, e.offset) : new cc.Color(e, n, r, s, o, a);
    }, cc.Color = function(e, n, r, s, o, a) {
      this._arrayBuffer = o || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT), this._offset = a || 0;
      var c = (this || window)._arrayBuffer, l = (this || window)._offset;
      this._view = new Uint8Array(c, l, 4), this._view[0] = e || 0, this._view[1] = n || 0, this._view[2] = r || 0, this._view[3] = s == null ? 255 : s, s === void 0 && (this.a_undefined = !0);
    }, cc.Color.BYTES_PER_ELEMENT = 4;
    var t = cc.Color.prototype;
    t._getR = function() {
      return this._view[0];
    }, t._setR = function(e) {
      this._view[0] = e < 0 ? 0 : e;
    }, t._getG = function() {
      return this._view[1];
    }, t._setG = function(e) {
      this._view[1] = e < 0 ? 0 : e;
    }, t._getB = function() {
      return this._view[2];
    }, t._setB = function(e) {
      this._view[2] = e < 0 ? 0 : e;
    }, t._getA = function() {
      return this._view[3];
    }, t._setA = function(e) {
      this._view[3] = e < 0 ? 0 : e;
    }, t.r, cc.defineGetterSetter(t, "r", t._getR, t._setR), t.g, cc.defineGetterSetter(t, "g", t._getG, t._setG), t.b, cc.defineGetterSetter(t, "b", t._getB, t._setB), t.a, cc.defineGetterSetter(t, "a", t._getA, t._setA), cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js"), cc._tmp.PrototypeColor(), delete cc._tmp.PrototypeColor;
  }
});
cc.Color = function(t, e, n, r) {
  this.r = t || 0, this.g = e || 0, this.b = n || 0, this.a = r == null ? 255 : r;
};
cc.color = function(t, e, n, r) {
  return t === void 0 ? { r: 0, g: 0, b: 0, a: 255 } : cc.isString(t) ? cc.hexToColor(t) : cc.isObject(t) ? { r: t.r, g: t.g, b: t.b, a: t.a == null ? 255 : t.a } : { r: t, g: e, b: n, a: r == null ? 255 : r };
};
cc.colorEqual = function(t, e) {
  return t.r === e.r && t.g === e.g && t.b === e.b;
};
cc.Acceleration = function(t, e, n, r) {
  this.x = t || 0, this.y = e || 0, this.z = n || 0, this.timestamp = r || 0;
};
cc.Vertex2F = function(t, e, n, r) {
  this._arrayBuffer = n || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT), this._offset = r || 0, this._view = new Float32Array(this._arrayBuffer, this._offset, 2), this._view[0] = t || 0, this._view[1] = e || 0;
};
cc.Vertex2F.BYTES_PER_ELEMENT = 8;
_p = cc.Vertex2F.prototype;
_p._getX = function() {
  return this._view[0];
};
_p._setX = function(t) {
  this._view[0] = t;
};
_p._getY = function() {
  return this._view[1];
};
_p._setY = function(t) {
  this._view[1] = t;
};
_p.x;
cc.defineGetterSetter(_p, "x", _p._getX, _p._setX);
_p.y;
cc.defineGetterSetter(_p, "y", _p._getY, _p._setY);
cc.Vertex3F = function(t, e, n, r, s) {
  this._arrayBuffer = r || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT), this._offset = s || 0;
  var o = (this || window)._arrayBuffer, a = (this || window)._offset;
  this._view = new Float32Array(o, a, 3), this._view[0] = t || 0, this._view[1] = e || 0, this._view[2] = n || 0;
};
cc.Vertex3F.BYTES_PER_ELEMENT = 12;
_p = cc.Vertex3F.prototype;
_p._getX = function() {
  return this._view[0];
};
_p._setX = function(t) {
  this._view[0] = t;
};
_p._getY = function() {
  return this._view[1];
};
_p._setY = function(t) {
  this._view[1] = t;
};
_p._getZ = function() {
  return this._view[2];
};
_p._setZ = function(t) {
  this._view[2] = t;
};
_p.x;
cc.defineGetterSetter(_p, "x", _p._getX, _p._setX);
_p.y;
cc.defineGetterSetter(_p, "y", _p._getY, _p._setY);
_p.z;
cc.defineGetterSetter(_p, "z", _p._getZ, _p._setZ);
cc.Tex2F = function(t, e, n, r) {
  this._arrayBuffer = n || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT), this._offset = r || 0, this._view = new Float32Array(this._arrayBuffer, this._offset, 2), this._view[0] = t || 0, this._view[1] = e || 0;
};
cc.Tex2F.BYTES_PER_ELEMENT = 8;
_p = cc.Tex2F.prototype;
_p._getU = function() {
  return this._view[0];
};
_p._setU = function(t) {
  this._view[0] = t;
};
_p._getV = function() {
  return this._view[1];
};
_p._setV = function(t) {
  this._view[1] = t;
};
_p.u;
cc.defineGetterSetter(_p, "u", _p._getU, _p._setU);
_p.v;
cc.defineGetterSetter(_p, "v", _p._getV, _p._setV);
cc.Quad2 = function(t, e, n, r, s, o) {
  this._arrayBuffer = s || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT), this._offset = o || 0;
  var a = (this || window)._arrayBuffer, c = (this || window)._offset, l = cc.Vertex2F.BYTES_PER_ELEMENT;
  this._tl = t ? new cc.Vertex2F(t.x, t.y, a, c) : new cc.Vertex2F(0, 0, a, c), c += l, this._tr = e ? new cc.Vertex2F(e.x, e.y, a, c) : new cc.Vertex2F(0, 0, a, c), c += l, this._bl = n ? new cc.Vertex2F(n.x, n.y, a, c) : new cc.Vertex2F(0, 0, a, c), c += l, this._br = r ? new cc.Vertex2F(r.x, r.y, a, c) : new cc.Vertex2F(0, 0, a, c);
};
cc.Quad2.BYTES_PER_ELEMENT = 32;
_p = cc.Quad2.prototype;
_p._getTL = function() {
  return this._tl;
};
_p._setTL = function(t) {
  this._tl._view[0] = t.x, this._tl._view[1] = t.y;
};
_p._getTR = function() {
  return this._tr;
};
_p._setTR = function(t) {
  this._tr._view[0] = t.x, this._tr._view[1] = t.y;
};
_p._getBL = function() {
  return this._bl;
};
_p._setBL = function(t) {
  this._bl._view[0] = t.x, this._bl._view[1] = t.y;
};
_p._getBR = function() {
  return this._br;
};
_p._setBR = function(t) {
  this._br._view[0] = t.x, this._br._view[1] = t.y;
};
_p.tl;
cc.defineGetterSetter(_p, "tl", _p._getTL, _p._setTL);
_p.tr;
cc.defineGetterSetter(_p, "tr", _p._getTR, _p._setTR);
_p.bl;
cc.defineGetterSetter(_p, "bl", _p._getBL, _p._setBL);
_p.br;
cc.defineGetterSetter(_p, "br", _p._getBR, _p._setBR);
cc.Quad3 = function(t, e, n, r, s, o) {
  this._arrayBuffer = s || new ArrayBuffer(cc.Quad3.BYTES_PER_ELEMENT), this._offset = o || 0;
  var a = (this || window)._arrayBuffer, c = (this || window)._offset, l = cc.Vertex3F.BYTES_PER_ELEMENT;
  this.bl = t ? new cc.Vertex3F(t.x, t.y, t.z, a, c) : new cc.Vertex3F(0, 0, 0, a, c), c += l, this.br = e ? new cc.Vertex3F(e.x, e.y, e.z, a, c) : new cc.Vertex3F(0, 0, 0, a, c), c += l, this.tl = n ? new cc.Vertex3F(n.x, n.y, n.z, a, c) : new cc.Vertex3F(0, 0, 0, a, c), c += l, this.tr = r ? new cc.Vertex3F(r.x, r.y, r.z, a, c) : new cc.Vertex3F(0, 0, 0, a, c);
};
cc.Quad3.BYTES_PER_ELEMENT = 48;
cc.V3F_C4B_T2F = function(t, e, n, r, s) {
  this._arrayBuffer = r || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT), this._offset = s || 0;
  var o = (this || window)._arrayBuffer, a = (this || window)._offset;
  this._vertices = t ? new cc.Vertex3F(t.x, t.y, t.z, o, a) : new cc.Vertex3F(0, 0, 0, o, a), a += cc.Vertex3F.BYTES_PER_ELEMENT, this._colors = e ? new cc.Color(e.r, e.g, e.b, e.a, o, a) : new cc.Color(0, 0, 0, 0, o, a), a += cc.Color.BYTES_PER_ELEMENT, this._texCoords = n ? new cc.Tex2F(n.u, n.v, o, a) : new cc.Tex2F(0, 0, o, a);
};
cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
_p = cc.V3F_C4B_T2F.prototype;
_p._getVertices = function() {
  return this._vertices;
};
_p._setVertices = function(t) {
  var e = (this || window)._vertices;
  e._view[0] = t.x, e._view[1] = t.y, e._view[2] = t.z;
};
_p._getColor = function() {
  return this._colors;
};
_p._setColor = function(t) {
  var e = (this || window)._colors;
  e._view[0] = t.r, e._view[1] = t.g, e._view[2] = t.b, e._view[3] = t.a;
};
_p._getTexCoords = function() {
  return this._texCoords;
};
_p._setTexCoords = function(t) {
  this._texCoords._view[0] = t.u, this._texCoords._view[1] = t.v;
};
_p.vertices;
cc.defineGetterSetter(_p, "vertices", _p._getVertices, _p._setVertices);
_p.colors;
cc.defineGetterSetter(_p, "colors", _p._getColor, _p._setColor);
_p.texCoords;
cc.defineGetterSetter(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
cc.V3F_C4B_T2F_Quad = function(t, e, n, r, s, o) {
  this._arrayBuffer = s || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT), this._offset = o || 0;
  var a = (this || window)._arrayBuffer, c = (this || window)._offset, l = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
  this._tl = t ? new cc.V3F_C4B_T2F(t.vertices, t.colors, t.texCoords, a, c) : new cc.V3F_C4B_T2F(null, null, null, a, c), c += l, this._bl = e ? new cc.V3F_C4B_T2F(e.vertices, e.colors, e.texCoords, a, c) : new cc.V3F_C4B_T2F(null, null, null, a, c), c += l, this._tr = n ? new cc.V3F_C4B_T2F(n.vertices, n.colors, n.texCoords, a, c) : new cc.V3F_C4B_T2F(null, null, null, a, c), c += l, this._br = r ? new cc.V3F_C4B_T2F(r.vertices, r.colors, r.texCoords, a, c) : new cc.V3F_C4B_T2F(null, null, null, a, c);
};
cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
_p = cc.V3F_C4B_T2F_Quad.prototype;
_p._getTL = function() {
  return this._tl;
};
_p._setTL = function(t) {
  var e = (this || window)._tl;
  e.vertices = t.vertices, e.colors = t.colors, e.texCoords = t.texCoords;
};
_p._getBL = function() {
  return this._bl;
};
_p._setBL = function(t) {
  var e = (this || window)._bl;
  e.vertices = t.vertices, e.colors = t.colors, e.texCoords = t.texCoords;
};
_p._getTR = function() {
  return this._tr;
};
_p._setTR = function(t) {
  var e = (this || window)._tr;
  e.vertices = t.vertices, e.colors = t.colors, e.texCoords = t.texCoords;
};
_p._getBR = function() {
  return this._br;
};
_p._setBR = function(t) {
  var e = (this || window)._br;
  e.vertices = t.vertices, e.colors = t.colors, e.texCoords = t.texCoords;
};
_p._getArrayBuffer = function() {
  return this._arrayBuffer;
};
_p.tl;
cc.defineGetterSetter(_p, "tl", _p._getTL, _p._setTL);
_p.tr;
cc.defineGetterSetter(_p, "tr", _p._getTR, _p._setTR);
_p.bl;
cc.defineGetterSetter(_p, "bl", _p._getBL, _p._setBL);
_p.br;
cc.defineGetterSetter(_p, "br", _p._getBR, _p._setBR);
_p.arrayBuffer;
cc.defineGetterSetter(_p, "arrayBuffer", _p._getArrayBuffer, null);
cc.V3F_C4B_T2F_QuadZero = function() {
  return new cc.V3F_C4B_T2F_Quad();
};
cc.V3F_C4B_T2F_QuadCopy = function(t) {
  if (!t)
    return cc.V3F_C4B_T2F_QuadZero();
  var e = t.tl, n = t.bl, r = t.tr, s = t.br;
  return {
    tl: {
      vertices: { x: e.vertices.x, y: e.vertices.y, z: e.vertices.z },
      colors: { r: e.colors.r, g: e.colors.g, b: e.colors.b, a: e.colors.a },
      texCoords: { u: e.texCoords.u, v: e.texCoords.v }
    },
    bl: {
      vertices: { x: n.vertices.x, y: n.vertices.y, z: n.vertices.z },
      colors: { r: n.colors.r, g: n.colors.g, b: n.colors.b, a: n.colors.a },
      texCoords: { u: n.texCoords.u, v: n.texCoords.v }
    },
    tr: {
      vertices: { x: r.vertices.x, y: r.vertices.y, z: r.vertices.z },
      colors: { r: r.colors.r, g: r.colors.g, b: r.colors.b, a: r.colors.a },
      texCoords: { u: r.texCoords.u, v: r.texCoords.v }
    },
    br: {
      vertices: { x: s.vertices.x, y: s.vertices.y, z: s.vertices.z },
      colors: { r: s.colors.r, g: s.colors.g, b: s.colors.b, a: s.colors.a },
      texCoords: { u: s.texCoords.u, v: s.texCoords.v }
    }
  };
};
cc.V3F_C4B_T2F_QuadsCopy = function(t) {
  if (!t)
    return [];
  for (var e = [], n = 0; n < t.length; n++)
    e.push(cc.V3F_C4B_T2F_QuadCopy(t[n]));
  return e;
};
cc.V2F_C4B_T2F = function(t, e, n, r, s) {
  this._arrayBuffer = r || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT), this._offset = s || 0;
  var o = (this || window)._arrayBuffer, a = (this || window)._offset;
  this._vertices = t ? new cc.Vertex2F(t.x, t.y, o, a) : new cc.Vertex2F(0, 0, o, a), a += cc.Vertex2F.BYTES_PER_ELEMENT, this._colors = e ? cc.color(e.r, e.g, e.b, e.a, o, a) : cc.color(0, 0, 0, 0, o, a), a += cc.Color.BYTES_PER_ELEMENT, this._texCoords = n ? new cc.Tex2F(n.u, n.v, o, a) : new cc.Tex2F(0, 0, o, a);
};
cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
_p = cc.V2F_C4B_T2F.prototype;
_p._getVertices = function() {
  return this._vertices;
};
_p._setVertices = function(t) {
  this._vertices._view[0] = t.x, this._vertices._view[1] = t.y;
};
_p._getColor = function() {
  return this._colors;
};
_p._setColor = function(t) {
  var e = (this || window)._colors;
  e._view[0] = t.r, e._view[1] = t.g, e._view[2] = t.b, e._view[3] = t.a;
};
_p._getTexCoords = function() {
  return this._texCoords;
};
_p._setTexCoords = function(t) {
  this._texCoords._view[0] = t.u, this._texCoords._view[1] = t.v;
};
_p.vertices;
cc.defineGetterSetter(_p, "vertices", _p._getVertices, _p._setVertices);
_p.colors;
cc.defineGetterSetter(_p, "colors", _p._getColor, _p._setColor);
_p.texCoords;
cc.defineGetterSetter(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
cc.V2F_C4B_T2F_Triangle = function(t, e, n, r, s) {
  this._arrayBuffer = r || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT), this._offset = s || 0;
  var o = (this || window)._arrayBuffer, a = (this || window)._offset, c = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
  this._a = t ? new cc.V2F_C4B_T2F(t.vertices, t.colors, t.texCoords, o, a) : new cc.V2F_C4B_T2F(null, null, null, o, a), a += c, this._b = e ? new cc.V2F_C4B_T2F(e.vertices, e.colors, e.texCoords, o, a) : new cc.V2F_C4B_T2F(null, null, null, o, a), a += c, this._c = n ? new cc.V2F_C4B_T2F(n.vertices, n.colors, n.texCoords, o, a) : new cc.V2F_C4B_T2F(null, null, null, o, a);
};
cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
_p = cc.V2F_C4B_T2F_Triangle.prototype;
_p._getA = function() {
  return this._a;
};
_p._setA = function(t) {
  var e = (this || window)._a;
  e.vertices = t.vertices, e.colors = t.colors, e.texCoords = t.texCoords;
};
_p._getB = function() {
  return this._b;
};
_p._setB = function(t) {
  var e = (this || window)._b;
  e.vertices = t.vertices, e.colors = t.colors, e.texCoords = t.texCoords;
};
_p._getC = function() {
  return this._c;
};
_p._setC = function(t) {
  var e = (this || window)._c;
  e.vertices = t.vertices, e.colors = t.colors, e.texCoords = t.texCoords;
};
_p.a;
cc.defineGetterSetter(_p, "a", _p._getA, _p._setA);
_p.b;
cc.defineGetterSetter(_p, "b", _p._getB, _p._setB);
_p.c;
cc.defineGetterSetter(_p, "c", _p._getC, _p._setC);
cc.vertex2 = function(t, e) {
  return new cc.Vertex2F(t, e);
};
cc.vertex3 = function(t, e, n) {
  return new cc.Vertex3F(t, e, n);
};
cc.tex2 = function(t, e) {
  return new cc.Tex2F(t, e);
};
cc.BlendFunc = function(t, e) {
  this.src = t, this.dst = e;
};
cc.blendFuncDisable = function() {
  return new cc.BlendFunc(cc.ONE, cc.ZERO);
};
cc.hexToColor = function(t) {
  t = t.replace(/^#?/, "0x");
  var e = parseInt(t), n = e >> 16, r = (e >> 8) % 256, s = e % 256;
  return cc.color(n, r, s);
};
cc.colorToHex = function(t) {
  var e = t.r.toString(16), n = t.g.toString(16), r = t.b.toString(16);
  return "#" + (t.r < 16 ? "0" + e : e) + (t.g < 16 ? "0" + n : n) + (t.b < 16 ? "0" + r : r);
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
  _keyMapTb: null,
  _valueMapTb: null,
  __currId: 0,
  ctor: function() {
    this._keyMapTb = {}, this._valueMapTb = {}, this.__currId = 2 << (0 | Math.random() * 10);
  },
  __getKey: function() {
    return this.__currId++, "key_" + this.__currId;
  },
  setObject: function(t, e) {
    if (e != null) {
      var n = (this || window).__getKey();
      this._keyMapTb[n] = e, this._valueMapTb[n] = t;
    }
  },
  objectForKey: function(t) {
    if (t == null)
      return null;
    var e = (this || window)._keyMapTb;
    for (var n in e)
      if (e[n] === t)
        return this._valueMapTb[n];
    return null;
  },
  valueForKey: function(t) {
    return this.objectForKey(t);
  },
  removeObjectForKey: function(t) {
    if (t != null) {
      var e = (this || window)._keyMapTb;
      for (var n in e)
        if (e[n] === t) {
          delete this._valueMapTb[n], delete e[n];
          return;
        }
    }
  },
  removeObjectsForKeys: function(t) {
    if (t != null)
      for (var e = 0; e < t.length; e++)
        this.removeObjectForKey(t[e]);
  },
  allKeys: function() {
    var t = [], e = (this || window)._keyMapTb;
    for (var n in e)
      t.push(e[n]);
    return t;
  },
  removeAllObjects: function() {
    this._keyMapTb = {}, this._valueMapTb = {};
  },
  count: function() {
    return this.allKeys().length;
  }
});
cc.FontDefinition = function(t) {
  var e = (this || window);
  if (e.fontName = "Arial", e.fontSize = 12, e.textAlign = cc.TEXT_ALIGNMENT_CENTER, e.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP, e.fillStyle = cc.color(255, 255, 255, 255), e.boundingWidth = 0, e.boundingHeight = 0, e.strokeEnabled = !1, e.strokeStyle = cc.color(255, 255, 255, 255), e.lineWidth = 1, e.lineHeight = "normal", e.fontStyle = "normal", e.fontWeight = "normal", e.shadowEnabled = !1, e.shadowOffsetX = 0, e.shadowOffsetY = 0, e.shadowBlur = 0, e.shadowOpacity = 1, t && t instanceof Object)
    for (var n in t)
      e[n] = t[n];
};
cc.FontDefinition.prototype._getCanvasFontStr = function() {
  var t = (this || window).lineHeight.charAt ? this.lineHeight : this.lineHeight + "px";
  return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px/" + t + " '" + this.fontName + "'";
};
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  cc._renderType === cc.game.RENDER_TYPE_CANVAS && (cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js"), cc._tmp.PrototypeColor(), delete cc._tmp.PrototypeColor);
});
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
var __BrowserGetter = {
  init: function() {
    this.html = document.getElementsByTagName("html")[0];
  },
  availWidth: function(t) {
    return !t || t === (this || window).html ? window.innerWidth : t.clientWidth;
  },
  availHeight: function(t) {
    return !t || t === (this || window).html ? window.innerHeight : t.clientHeight;
  },
  meta: {
    width: "device-width"
  },
  adaptationType: cc.sys.browserType
};
window.navigator.userAgent.indexOf("OS 8_1_") > -1 && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_MIUI);
cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
switch (__BrowserGetter.adaptationType) {
  case cc.sys.BROWSER_TYPE_SAFARI:
    __BrowserGetter.meta["minimal-ui"] = "true", __BrowserGetter.availWidth = function(t) {
      return t.clientWidth;
    }, __BrowserGetter.availHeight = function(t) {
      return t.clientHeight;
    };
    break;
  case cc.sys.BROWSER_TYPE_CHROME:
    __BrowserGetter.__defineGetter__("target-densitydpi", function() {
      return cc.view._targetDensityDPI;
    });
  case cc.sys.BROWSER_TYPE_SOUGOU:
  case cc.sys.BROWSER_TYPE_UC:
    __BrowserGetter.availWidth = function(t) {
      return t.clientWidth;
    }, __BrowserGetter.availHeight = function(t) {
      return t.clientHeight;
    };
    break;
  case cc.sys.BROWSER_TYPE_MIUI:
    __BrowserGetter.init = function(t) {
      if (!t.__resizeWithBrowserSize) {
        var e = /* @__PURE__ */ H(function() {
          t.setDesignResolutionSize(
            t._designResolutionSize.width,
            t._designResolutionSize.height,
            t._resolutionPolicy
          ), window.removeEventListener("resize", e, !1);
        }, "resize");
        window.addEventListener("resize", e, !1);
      }
    };
    break;
}
var _scissorRect = cc.rect();
cc.EGLView = cc.Class.extend({
  _delegate: null,
  _frameSize: null,
  _designResolutionSize: null,
  _originalDesignResolutionSize: null,
  _viewPortRect: null,
  _visibleRect: null,
  _retinaEnabled: !1,
  _autoFullScreen: !1,
  _devicePixelRatio: 1,
  _viewName: "",
  _resizeCallback: null,
  _scaleX: 1,
  _originalScaleX: 1,
  _scaleY: 1,
  _originalScaleY: 1,
  _isRotated: !1,
  _orientation: 3,
  _resolutionPolicy: null,
  _rpExactFit: null,
  _rpShowAll: null,
  _rpNoBorder: null,
  _rpFixedHeight: null,
  _rpFixedWidth: null,
  _initialized: !1,
  _contentTranslateLeftTop: null,
  _frame: null,
  _frameZoomFactor: 1,
  __resizeWithBrowserSize: !1,
  _isAdjustViewPort: !0,
  _targetDensityDPI: null,
  ctor: function() {
    var t = (this || window), e = document, n = cc.ContainerStrategy, r = cc.ContentStrategy;
    __BrowserGetter.init(this), t._frame = cc.container.parentNode === e.body ? e.documentElement : cc.container.parentNode, t._frameSize = cc.size(0, 0), t._initFrameSize();
    var s = cc._canvas.width, o = cc._canvas.height;
    t._designResolutionSize = cc.size(s, o), t._originalDesignResolutionSize = cc.size(s, o), t._viewPortRect = cc.rect(0, 0, s, o), t._visibleRect = cc.rect(0, 0, s, o), t._contentTranslateLeftTop = { left: 0, top: 0 }, t._viewName = "Cocos2dHTML5";
    var a = cc.sys;
    t.enableRetina(a.os === a.OS_IOS || a.os === a.OS_OSX), t.enableAutoFullScreen(a.isMobile && a.browserType !== a.BROWSER_TYPE_BAIDU), cc.visibleRect && cc.visibleRect.init(t._visibleRect), t._rpExactFit = new cc.ResolutionPolicy(n.EQUAL_TO_FRAME, r.EXACT_FIT), t._rpShowAll = new cc.ResolutionPolicy(n.PROPORTION_TO_FRAME, r.SHOW_ALL), t._rpNoBorder = new cc.ResolutionPolicy(n.EQUAL_TO_FRAME, r.NO_BORDER), t._rpFixedHeight = new cc.ResolutionPolicy(n.EQUAL_TO_FRAME, r.FIXED_HEIGHT), t._rpFixedWidth = new cc.ResolutionPolicy(n.EQUAL_TO_FRAME, r.FIXED_WIDTH), t._targetDensityDPI = cc.DENSITYDPI_HIGH;
  },
  _resizeEvent: function() {
    var t;
    this.setDesignResolutionSize ? t = (this || window) : t = cc.view;
    var e = t._frameSize.width, n = t._frameSize.height, r = t._isRotated;
    if (t._initFrameSize(), !(t._isRotated === r && t._frameSize.width === e && t._frameSize.height === n)) {
      t._resizeCallback && t._resizeCallback.call();
      var s = t._originalDesignResolutionSize.width, o = t._originalDesignResolutionSize.height;
      s > 0 && t.setDesignResolutionSize(s, o, t._resolutionPolicy);
    }
  },
  setTargetDensityDPI: function(t) {
    this._targetDensityDPI = t, this._adjustViewportMeta();
  },
  getTargetDensityDPI: function() {
    return this._targetDensityDPI;
  },
  resizeWithBrowserSize: function(t) {
    t ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, window.addEventListener("resize", this._resizeEvent), window.addEventListener("orientationchange", this._resizeEvent)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !1, window.removeEventListener("resize", this._resizeEvent), window.removeEventListener("orientationchange", this._resizeEvent));
  },
  setResizeCallback: function(t) {
    (cc.isFunction(t) || t == null) && (this._resizeCallback = t);
  },
  setOrientation: function(t) {
    t = t & cc.ORIENTATION_AUTO, t && (this._orientation = t);
  },
  _initFrameSize: function() {
    var t = (this || window)._frameSize, e = __BrowserGetter.availWidth(this._frame), n = __BrowserGetter.availHeight(this._frame), r = e >= n;
    !cc.sys.isMobile || r && this._orientation & cc.ORIENTATION_LANDSCAPE || !r && this._orientation & cc.ORIENTATION_PORTRAIT ? (t.width = e, t.height = n, cc.container.style["-webkit-transform"] = "rotate(0deg)", cc.container.style.transform = "rotate(0deg)", this._isRotated = !1) : (t.width = n, t.height = e, cc.container.style["-webkit-transform"] = "rotate(90deg)", cc.container.style.transform = "rotate(90deg)", cc.container.style["-webkit-transform-origin"] = "0px 0px 0px", cc.container.style.transformOrigin = "0px 0px 0px", this._isRotated = !0);
  },
  _adjustSizeKeepCanvasSize: function() {
    var t = (this || window)._originalDesignResolutionSize.width, e = (this || window)._originalDesignResolutionSize.height;
    t > 0 && this.setDesignResolutionSize(t, e, this._resolutionPolicy);
  },
  _setViewportMeta: function(t, e) {
    var n = document.getElementById("cocosMetaElement");
    n && e && document.head.removeChild(n);
    var r = document.getElementsByName("viewport"), s = r ? r[0] : null, o, a, c;
    o = s ? s.content : "", n = n || document.createElement("meta"), n.id = "cocosMetaElement", n.name = "viewport", n.content = "";
    for (a in t)
      o.indexOf(a) == -1 ? o += "," + a + "=" + t[a] : e && (c = new RegExp(a + "s*=s*[^,]+"), o.replace(c, a + "=" + t[a]));
    /^,/.test(o) && (o = o.substr(1)), n.content = o, s && (s.content = o), document.head.appendChild(n);
  },
  _adjustViewportMeta: function() {
    this._isAdjustViewPort && (this._setViewportMeta(__BrowserGetter.meta, !1), this._isAdjustViewPort = !1);
  },
  _setScaleXYForRenderTexture: function() {
    var t = cc.contentScaleFactor();
    this._scaleX = t, this._scaleY = t;
  },
  _resetScale: function() {
    this._scaleX = (this || window)._originalScaleX, this._scaleY = (this || window)._originalScaleY;
  },
  _adjustSizeToBrowser: function() {
  },
  initialize: function() {
    this._initialized = !0;
  },
  adjustViewPort: function(t) {
    this._isAdjustViewPort = t;
  },
  enableRetina: function(t) {
    this._retinaEnabled = !!t;
  },
  isRetinaEnabled: function() {
    return this._retinaEnabled;
  },
  enableAutoFullScreen: function(t) {
    t && t !== (this || window)._autoFullScreen && cc.sys.isMobile && this._frame === document.documentElement ? (this._autoFullScreen = !0, cc.screen.autoFullScreen(this._frame)) : this._autoFullScreen = !1;
  },
  isAutoFullScreenEnabled: function() {
    return this._autoFullScreen;
  },
  end: function() {
  },
  isOpenGLReady: function() {
    return cc.game.canvas && cc._renderContext;
  },
  setFrameZoomFactor: function(t) {
    this._frameZoomFactor = t, this.centerWindow(), cc.director.setProjection(cc.director.getProjection());
  },
  swapBuffers: function() {
  },
  setIMEKeyboardState: function(t) {
  },
  setContentTranslateLeftTop: function(t, e) {
    this._contentTranslateLeftTop = { left: t, top: e };
  },
  getContentTranslateLeftTop: function() {
    return this._contentTranslateLeftTop;
  },
  getCanvasSize: function() {
    return cc.size(cc._canvas.width, cc._canvas.height);
  },
  getFrameSize: function() {
    return cc.size(this._frameSize.width, this._frameSize.height);
  },
  setFrameSize: function(t, e) {
    this._frameSize.width = t, this._frameSize.height = e, this._frame.style.width = t + "px", this._frame.style.height = e + "px", this._resizeEvent(), cc.director.setProjection(cc.director.getProjection());
  },
  centerWindow: function() {
  },
  getVisibleSize: function() {
    return cc.size(this._visibleRect.width, this._visibleRect.height);
  },
  getVisibleSizeInPixel: function() {
    return cc.size(
      this._visibleRect.width * this._scaleX,
      this._visibleRect.height * this._scaleY
    );
  },
  getVisibleOrigin: function() {
    return cc.p(this._visibleRect.x, this._visibleRect.y);
  },
  getVisibleOriginInPixel: function() {
    return cc.p(
      this._visibleRect.x * this._scaleX,
      this._visibleRect.y * this._scaleY
    );
  },
  canSetContentScaleFactor: function() {
    return !0;
  },
  getResolutionPolicy: function() {
    return this._resolutionPolicy;
  },
  setResolutionPolicy: function(t) {
    var e = (this || window);
    if (t instanceof cc.ResolutionPolicy)
      e._resolutionPolicy = t;
    else {
      var n = cc.ResolutionPolicy;
      t === n.EXACT_FIT && (e._resolutionPolicy = e._rpExactFit), t === n.SHOW_ALL && (e._resolutionPolicy = e._rpShowAll), t === n.NO_BORDER && (e._resolutionPolicy = e._rpNoBorder), t === n.FIXED_HEIGHT && (e._resolutionPolicy = e._rpFixedHeight), t === n.FIXED_WIDTH && (e._resolutionPolicy = e._rpFixedWidth);
    }
  },
  setDesignResolutionSize: function(t, e, n) {
    if (!(t > 0 || e > 0)) {
      cc.log(cc._LogInfos.EGLView_setDesignResolutionSize);
      return;
    }
    this.setResolutionPolicy(n);
    var r = (this || window)._resolutionPolicy;
    if (!r) {
      cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
      return;
    }
    r.preApply(this), cc.sys.isMobile && this._adjustViewportMeta(), this._initFrameSize(), this._originalDesignResolutionSize.width = (this || window)._designResolutionSize.width = t, this._originalDesignResolutionSize.height = (this || window)._designResolutionSize.height = e;
    var s = r.apply(this, this._designResolutionSize);
    if (s.scale && s.scale.length === 2 && (this._scaleX = s.scale[0], this._scaleY = s.scale[1]), s.viewport) {
      var o = (this || window)._viewPortRect, a = (this || window)._visibleRect, c = s.viewport;
      o.x = c.x, o.y = c.y, o.width = c.width, o.height = c.height, a.x = -o.x / this._scaleX, a.y = -o.y / this._scaleY, a.width = cc._canvas.width / this._scaleX, a.height = cc._canvas.height / this._scaleY, cc._renderContext.setOffset && cc._renderContext.setOffset(o.x, -o.y);
    }
    var l = cc.director;
    l._winSizeInPoints.width = (this || window)._designResolutionSize.width, l._winSizeInPoints.height = (this || window)._designResolutionSize.height, r.postApply(this), cc.winSize.width = l._winSizeInPoints.width, cc.winSize.height = l._winSizeInPoints.height, cc._renderType === cc.game.RENDER_TYPE_WEBGL && l.setGLDefaultValues(), this._originalScaleX = (this || window)._scaleX, this._originalScaleY = (this || window)._scaleY, cc.DOM && cc.DOM._resetEGLViewDiv(), cc.visibleRect && cc.visibleRect.init(this._visibleRect);
  },
  getDesignResolutionSize: function() {
    return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
  },
  setRealPixelResolution: function(t, e, n) {
    this._setViewportMeta({ width: t, "target-densitydpi": cc.DENSITYDPI_DEVICE }, !0), document.body.style.width = t + "px", document.body.style.left = "0px", document.body.style.top = "0px", this.setDesignResolutionSize(t, e, n);
  },
  setViewPortInPoints: function(t, e, n, r) {
    var s = (this || window)._frameZoomFactor, o = (this || window)._scaleX, a = (this || window)._scaleY;
    cc._renderContext.viewport(
      t * o * s + this._viewPortRect.x * s,
      e * a * s + this._viewPortRect.y * s,
      n * o * s,
      r * a * s
    );
  },
  setScissorInPoints: function(t, e, n, r) {
    var s = (this || window)._frameZoomFactor, o = (this || window)._scaleX, a = (this || window)._scaleY;
    _scissorRect.x = t, _scissorRect.y = e, _scissorRect.width = n, _scissorRect.height = r, cc._renderContext.scissor(
      t * o * s + this._viewPortRect.x * s,
      e * a * s + this._viewPortRect.y * s,
      n * o * s,
      r * a * s
    );
  },
  isScissorEnabled: function() {
    return cc._renderContext.isEnabled(gl.SCISSOR_TEST);
  },
  getScissorRect: function() {
    return cc.rect(_scissorRect);
  },
  setViewName: function(t) {
    t != null && t.length > 0 && (this._viewName = t);
  },
  getViewName: function() {
    return this._viewName;
  },
  getViewPortRect: function() {
    return this._viewPortRect;
  },
  getScaleX: function() {
    return this._scaleX;
  },
  getScaleY: function() {
    return this._scaleY;
  },
  getDevicePixelRatio: function() {
    return this._devicePixelRatio;
  },
  convertToLocationInView: function(t, e, n) {
    var r = (this || window)._devicePixelRatio * (t - n.left), s = (this || window)._devicePixelRatio * (n.top + n.height - e);
    return this._isRotated ? { x: this._viewPortRect.width - s, y: r } : { x: r, y: s };
  },
  _convertMouseToLocationInView: function(t, e) {
    var n = (this || window)._viewPortRect, r = (this || window);
    t.x = (r._devicePixelRatio * (t.x - e.left) - n.x) / r._scaleX, t.y = (r._devicePixelRatio * (e.top + e.height - t.y) - n.y) / r._scaleY;
  },
  _convertPointWithScale: function(t) {
    var e = (this || window)._viewPortRect;
    t.x = (t.x - e.x) / this._scaleX, t.y = (t.y - e.y) / this._scaleY;
  },
  _convertTouchesWithScale: function(t) {
    for (var e = (this || window)._viewPortRect, n = (this || window)._scaleX, r = (this || window)._scaleY, s, o, a, c = 0; c < t.length; c++)
      s = t[c], o = s._point, a = s._prevPoint, o.x = (o.x - e.x) / n, o.y = (o.y - e.y) / r, a.x = (a.x - e.x) / n, a.y = (a.y - e.y) / r;
  }
});
cc.EGLView._getInstance = function() {
  return this._instance || (this._instance = (this || window)._instance || new cc.EGLView(), this._instance.initialize()), this._instance;
};
cc.ContainerStrategy = cc.Class.extend({
  preApply: function(t) {
  },
  apply: function(t, e) {
  },
  postApply: function(t) {
  },
  _setupContainer: function(t, e, n) {
    var r = cc.game.canvas, s = cc.game.container;
    s.style.width = r.style.width = e + "px", s.style.height = r.style.height = n + "px";
    var o = t._devicePixelRatio = 1;
    t.isRetinaEnabled() && (o = t._devicePixelRatio = Math.min(2, window.devicePixelRatio || 1)), r.width = e * o, r.height = n * o, cc._renderContext.resetCache && cc._renderContext.resetCache();
  },
  _fixContainer: function() {
    document.body.insertBefore(cc.container, document.body.firstChild);
    var t = document.body.style;
    t.width = window.innerWidth + "px", t.height = window.innerHeight + "px", t.overflow = "hidden";
    var e = cc.container.style;
    e.position = "fixed", e.left = e.top = "0px", document.body.scrollTop = 0;
  }
});
cc.ContentStrategy = cc.Class.extend({
  _result: {
    scale: [1, 1],
    viewport: null
  },
  _buildResult: function(t, e, n, r, s, o) {
    Math.abs(t - n) < 2 && (n = t), Math.abs(e - r) < 2 && (r = e);
    var a = cc.rect(
      Math.round((t - n) / 2),
      Math.round((e - r) / 2),
      n,
      r
    );
    return cc._renderType, cc.game.RENDER_TYPE_CANVAS, this._result.scale = [s, o], this._result.viewport = a, this._result;
  },
  preApply: function(t) {
  },
  apply: function(t, e) {
    return { scale: [1, 1] };
  },
  postApply: function(t) {
  }
});
(function() {
  var t = cc.ContainerStrategy.extend({
    apply: function(l) {
      var h = l._frameSize.height, u = cc.container.style;
      this._setupContainer(l, l._frameSize.width, l._frameSize.height), l._isRotated ? u.marginLeft = h + "px" : u.margin = "0px";
    }
  }), e = cc.ContainerStrategy.extend({
    apply: function(l, h) {
      var u = l._frameSize.width, _ = l._frameSize.height, d = cc.container.style, f = h.width, C = h.height, m = u / f, g = _ / C, y, A;
      m < g ? (y = u, A = C * m) : (y = f * g, A = _);
      var D = Math.round((u - y) / 2), N = Math.round((_ - A) / 2);
      y = u - 2 * D, A = _ - 2 * N, this._setupContainer(l, y, A), l._isRotated ? d.marginLeft = _ + "px" : d.margin = "0px", d.paddingLeft = D + "px", d.paddingRight = D + "px", d.paddingTop = N + "px", d.paddingBottom = N + "px";
    }
  });
  t.extend({
    preApply: function(l) {
      this._super(l), l._frame = document.documentElement;
    },
    apply: function(l) {
      this._super(l), this._fixContainer();
    }
  }), e.extend({
    preApply: function(l) {
      this._super(l), l._frame = document.documentElement;
    },
    apply: function(l, h) {
      this._super(l, h), this._fixContainer();
    }
  });
  var n = cc.ContainerStrategy.extend({
    apply: function(l) {
      this._setupContainer(l, cc._canvas.width, cc._canvas.height);
    }
  });
  cc.ContainerStrategy.EQUAL_TO_FRAME = new t(), cc.ContainerStrategy.PROPORTION_TO_FRAME = new e(), cc.ContainerStrategy.ORIGINAL_CONTAINER = new n();
  var r = cc.ContentStrategy.extend({
    apply: function(l, h) {
      var u = cc._canvas.width, _ = cc._canvas.height, d = u / h.width, f = _ / h.height;
      return this._buildResult(u, _, u, _, d, f);
    }
  }), s = cc.ContentStrategy.extend({
    apply: function(l, h) {
      var u = cc._canvas.width, _ = cc._canvas.height, d = h.width, f = h.height, C = u / d, m = _ / f, g = 0, y, A;
      return C < m ? (g = C, y = u, A = f * g) : (g = m, y = d * g, A = _), this._buildResult(u, _, y, A, g, g);
    }
  }), o = cc.ContentStrategy.extend({
    apply: function(l, h) {
      var u = cc._canvas.width, _ = cc._canvas.height, d = h.width, f = h.height, C = u / d, m = _ / f, g, y, A;
      return C < m ? (g = m, y = d * g, A = _) : (g = C, y = u, A = f * g), this._buildResult(u, _, y, A, g, g);
    }
  }), a = cc.ContentStrategy.extend({
    apply: function(l, h) {
      var u = cc._canvas.width, _ = cc._canvas.height, d = h.height, f = _ / d, C = u, m = _;
      return this._buildResult(u, _, C, m, f, f);
    },
    postApply: function(l) {
      cc.director._winSizeInPoints = l.getVisibleSize();
    }
  }), c = cc.ContentStrategy.extend({
    apply: function(l, h) {
      var u = cc._canvas.width, _ = cc._canvas.height, d = h.width, f = u / d, C = u, m = _;
      return this._buildResult(u, _, C, m, f, f);
    },
    postApply: function(l) {
      cc.director._winSizeInPoints = l.getVisibleSize();
    }
  });
  cc.ContentStrategy.EXACT_FIT = new r(), cc.ContentStrategy.SHOW_ALL = new s(), cc.ContentStrategy.NO_BORDER = new o(), cc.ContentStrategy.FIXED_HEIGHT = new a(), cc.ContentStrategy.FIXED_WIDTH = new c();
})();
cc.ResolutionPolicy = cc.Class.extend({
  _containerStrategy: null,
  _contentStrategy: null,
  ctor: function(t, e) {
    this.setContainerStrategy(t), this.setContentStrategy(e);
  },
  preApply: function(t) {
    this._containerStrategy.preApply(t), this._contentStrategy.preApply(t);
  },
  apply: function(t, e) {
    return this._containerStrategy.apply(t, e), this._contentStrategy.apply(t, e);
  },
  postApply: function(t) {
    this._containerStrategy.postApply(t), this._contentStrategy.postApply(t);
  },
  setContainerStrategy: function(t) {
    t instanceof cc.ContainerStrategy && (this._containerStrategy = t);
  },
  setContentStrategy: function(t) {
    t instanceof cc.ContentStrategy && (this._contentStrategy = t);
  }
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
  _supportsFullScreen: !1,
  _preOnFullScreenChange: null,
  _touchEvent: "",
  _fn: null,
  _fnMap: [
    [
      "requestFullscreen",
      "exitFullscreen",
      "fullscreenchange",
      "fullscreenEnabled",
      "fullscreenElement"
    ],
    [
      "requestFullScreen",
      "exitFullScreen",
      "fullScreenchange",
      "fullScreenEnabled",
      "fullScreenElement"
    ],
    [
      "webkitRequestFullScreen",
      "webkitCancelFullScreen",
      "webkitfullscreenchange",
      "webkitIsFullScreen",
      "webkitCurrentFullScreenElement"
    ],
    [
      "mozRequestFullScreen",
      "mozCancelFullScreen",
      "mozfullscreenchange",
      "mozFullScreen",
      "mozFullScreenElement"
    ],
    [
      "msRequestFullscreen",
      "msExitFullscreen",
      "MSFullscreenChange",
      "msFullscreenEnabled",
      "msFullscreenElement"
    ]
  ],
  init: function() {
    this._fn = {};
    var t, e, n = (this || window)._fnMap, r, s;
    for (t = 0, s = n.length; t < s; t++)
      if (e = n[t], e && e[1] in document) {
        for (t = 0, r = e.length; t < r; t++)
          this._fn[n[0][t]] = e[t];
        break;
      }
    this._supportsFullScreen = typeof this._fn.requestFullscreen != "undefined", this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
  },
  fullScreen: function() {
    return this._supportsFullScreen ? !(document[this._fn.fullscreenElement] === void 0 || document[this._fn.fullscreenElement] === null) : !1;
  },
  requestFullScreen: function(t, e) {
    if (this._supportsFullScreen) {
      if (t = t || document.documentElement, e) {
        var n = (this || window)._fn.fullscreenchange;
        this._preOnFullScreenChange && document.removeEventListener(n, this._preOnFullScreenChange), this._preOnFullScreenChange = e, document.addEventListener(n, e, !1);
      }
      return t[this._fn.requestFullscreen]();
    }
  },
  exitFullScreen: function() {
    return this._supportsFullScreen ? document[this._fn.exitFullscreen]() : !0;
  },
  autoFullScreen: function(t, e) {
    t = t || document.body;
    var n = cc.game.canvas || t, r = (this || window);
    function s() {
      n.removeEventListener(r._touchEvent, s), r.requestFullScreen(t, e);
    }
    H(s, "callback"), this.requestFullScreen(t, e), n.addEventListener(this._touchEvent, s);
  }
};
cc.screen.init();
cc.visibleRect = {
  topLeft: cc.p(0, 0),
  topRight: cc.p(0, 0),
  top: cc.p(0, 0),
  bottomLeft: cc.p(0, 0),
  bottomRight: cc.p(0, 0),
  bottom: cc.p(0, 0),
  center: cc.p(0, 0),
  left: cc.p(0, 0),
  right: cc.p(0, 0),
  width: 0,
  height: 0,
  init: function(t) {
    var e = (this || window).width = t.width, n = (this || window).height = t.height, r = t.x, s = t.y, o = s + n, a = r + e;
    this.topLeft.x = r, this.topLeft.y = o, this.topRight.x = a, this.topRight.y = o, this.top.x = r + e / 2, this.top.y = o, this.bottomLeft.x = r, this.bottomLeft.y = s, this.bottomRight.x = a, this.bottomRight.y = s, this.bottom.x = r + e / 2, this.bottom.y = s, this.center.x = r + e / 2, this.center.y = s + n / 2, this.left.x = r, this.left.y = s + n / 2, this.right.x = a, this.right.y = s + n / 2;
  }
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
  _mousePressed: !1,
  _isRegisterEvent: !1,
  _preTouchPoint: cc.p(0, 0),
  _prevMousePoint: cc.p(0, 0),
  _preTouchPool: [],
  _preTouchPoolPointer: 0,
  _touches: [],
  _touchesIntegerDict: {},
  _indexBitsUsed: 0,
  _maxTouches: 5,
  _accelEnabled: !1,
  _accelInterval: 1 / 30,
  _accelMinus: 1,
  _accelCurTime: 0,
  _acceleration: null,
  _accelDeviceEvent: null,
  _getUnUsedIndex: function() {
    for (var t = (this || window)._indexBitsUsed, e = 0; e < this._maxTouches; e++) {
      if (!(t & 1))
        return this._indexBitsUsed |= 1 << e, e;
      t >>= 1;
    }
    return -1;
  },
  _removeUsedIndexBit: function(t) {
    if (!(t < 0 || t >= (this || window)._maxTouches)) {
      var e = 1 << t;
      e = ~e, this._indexBitsUsed &= e;
    }
  },
  _glView: null,
  handleTouchesBegin: function(t) {
    for (var e, n, r, s, o = [], a = (this || window)._touchesIntegerDict, c = 0, l = t.length; c < l; c++)
      if (e = t[c], s = e.getID(), n = a[s], n == null) {
        var h = (this || window)._getUnUsedIndex();
        if (h === -1) {
          cc.log(cc._LogInfos.inputManager_handleTouchesBegin, h);
          continue;
        }
        r = (this || window)._touches[h] = new cc.Touch(e._point.x, e._point.y, e.getID()), r._setPrevPoint(e._prevPoint), a[s] = h, o.push(r);
      }
    if (o.length > 0) {
      this._glView._convertTouchesWithScale(o);
      var u = new cc.EventTouch(o);
      u._eventCode = cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(u);
    }
  },
  handleTouchesMove: function(t) {
    for (var e, n, r, s = [], o = (this || window)._touches, a = 0, c = t.length; a < c; a++)
      e = t[a], r = e.getID(), n = (this || window)._touchesIntegerDict[r], n != null && o[n] && (o[n]._setPoint(e._point), o[n]._setPrevPoint(e._prevPoint), s.push(o[n]));
    if (s.length > 0) {
      this._glView._convertTouchesWithScale(s);
      var l = new cc.EventTouch(s);
      l._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(l);
    }
  },
  handleTouchesEnd: function(t) {
    var e = (this || window).getSetOfTouchesEndOrCancel(t);
    if (e.length > 0) {
      this._glView._convertTouchesWithScale(e);
      var n = new cc.EventTouch(e);
      n._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(n);
    }
  },
  handleTouchesCancel: function(t) {
    var e = (this || window).getSetOfTouchesEndOrCancel(t);
    if (e.length > 0) {
      this._glView._convertTouchesWithScale(e);
      var n = new cc.EventTouch(e);
      n._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(n);
    }
  },
  getSetOfTouchesEndOrCancel: function(t) {
    for (var e, n, r, s = [], o = (this || window)._touches, a = (this || window)._touchesIntegerDict, c = 0, l = t.length; c < l; c++)
      e = t[c], r = e.getID(), n = a[r], n != null && o[n] && (o[n]._setPoint(e._point), o[n]._setPrevPoint(e._prevPoint), s.push(o[n]), this._removeUsedIndexBit(n), delete a[r]);
    return s;
  },
  getHTMLElementPosition: function(t) {
    var e = document.documentElement, n = window, r = null;
    return cc.isFunction(t.getBoundingClientRect) ? r = t.getBoundingClientRect() : r = {
      left: 0,
      top: 0,
      width: parseInt(t.style.width),
      height: parseInt(t.style.height)
    }, {
      left: r.left + n.pageXOffset - e.clientLeft,
      top: r.top + n.pageYOffset - e.clientTop,
      width: r.width,
      height: r.height
    };
  },
  getPreTouch: function(t) {
    for (var e = null, n = (this || window)._preTouchPool, r = t.getID(), s = n.length - 1; s >= 0; s--)
      if (n[s].getID() === r) {
        e = n[s];
        break;
      }
    return e || (e = t), e;
  },
  setPreTouch: function(t) {
    for (var e = !1, n = (this || window)._preTouchPool, r = t.getID(), s = n.length - 1; s >= 0; s--)
      if (n[s].getID() === r) {
        n[s] = t, e = !0;
        break;
      }
    e || (n.length <= 50 ? n.push(t) : (n[this._preTouchPoolPointer] = t, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50));
  },
  getTouchByXY: function(t, e, n) {
    var r = (this || window)._preTouchPoint, s = (this || window)._glView.convertToLocationInView(t, e, n), o = new cc.Touch(s.x, s.y);
    return o._setPrevPoint(r.x, r.y), r.x = s.x, r.y = s.y, o;
  },
  getMouseEvent: function(t, e, n) {
    var r = (this || window)._prevMousePoint;
    this._glView._convertMouseToLocationInView(t, e);
    var s = new cc.EventMouse(n);
    return s.setLocation(t.x, t.y), s._setPrevCursor(r.x, r.y), r.x = t.x, r.y = t.y, s;
  },
  getPointByEvent: function(t, e) {
    return t.pageX != null ? { x: t.pageX, y: t.pageY } : (e.left -= document.body.scrollLeft, e.top -= document.body.scrollTop, { x: t.clientX, y: t.clientY });
  },
  getTouchesByEvent: function(t, e) {
    for (var n = [], r = (this || window)._glView, s, o, a, c = (this || window)._preTouchPoint, l = t.changedTouches.length, h = 0; h < l; h++)
      if (s = t.changedTouches[h], s) {
        var u;
        cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? u = r.convertToLocationInView(s.pageX, s.pageY, e) : u = r.convertToLocationInView(s.clientX, s.clientY, e), s.identifier != null ? (o = new cc.Touch(u.x, u.y, s.identifier), a = (this || window).getPreTouch(o).getLocation(), o._setPrevPoint(a.x, a.y), this.setPreTouch(o)) : (o = new cc.Touch(u.x, u.y), o._setPrevPoint(c.x, c.y)), c.x = u.x, c.y = u.y, n.push(o);
      }
    return n;
  },
  registerSystemEvent: function(t) {
    if (!this._isRegisterEvent) {
      this._glView = cc.view;
      var e = (this || window), n = "mouse" in cc.sys.capabilities, r = "touches" in cc.sys.capabilities, s = !1;
      if (cc.sys.isMobile && (s = !0), n && (window.addEventListener("mousedown", function() {
        e._mousePressed = !0;
      }, !1), window.addEventListener("mouseup", function(c) {
        if (!s) {
          var l = e._mousePressed;
          if (e._mousePressed = !1, !!l) {
            var h = e.getHTMLElementPosition(t), u = e.getPointByEvent(c, h);
            if (!cc.rectContainsPoint(new cc.Rect(h.left, h.top, h.width, h.height), u)) {
              e.handleTouchesEnd([e.getTouchByXY(u.x, u.y, h)]);
              var _ = e.getMouseEvent(u, h, cc.EventMouse.UP);
              _.setButton(c.button), cc.eventManager.dispatchEvent(_);
            }
          }
        }
      }, !1), t.addEventListener("mousedown", function(c) {
        if (!s) {
          e._mousePressed = !0;
          var l = e.getHTMLElementPosition(t), h = e.getPointByEvent(c, l);
          e.handleTouchesBegin([e.getTouchByXY(h.x, h.y, l)]);
          var u = e.getMouseEvent(h, l, cc.EventMouse.DOWN);
          u.setButton(c.button), cc.eventManager.dispatchEvent(u), c.stopPropagation(), c.preventDefault(), t.focus();
        }
      }, !1), t.addEventListener("mouseup", function(c) {
        if (!s) {
          e._mousePressed = !1;
          var l = e.getHTMLElementPosition(t), h = e.getPointByEvent(c, l);
          e.handleTouchesEnd([e.getTouchByXY(h.x, h.y, l)]);
          var u = e.getMouseEvent(h, l, cc.EventMouse.UP);
          u.setButton(c.button), cc.eventManager.dispatchEvent(u), c.stopPropagation(), c.preventDefault();
        }
      }, !1), t.addEventListener("mousemove", function(c) {
        if (!s) {
          var l = e.getHTMLElementPosition(t), h = e.getPointByEvent(c, l);
          e.handleTouchesMove([e.getTouchByXY(h.x, h.y, l)]);
          var u = e.getMouseEvent(h, l, cc.EventMouse.MOVE);
          e._mousePressed ? u.setButton(c.button) : u.setButton(null), cc.eventManager.dispatchEvent(u), c.stopPropagation(), c.preventDefault();
        }
      }, !1), t.addEventListener("mousewheel", function(c) {
        var l = e.getHTMLElementPosition(t), h = e.getPointByEvent(c, l), u = e.getMouseEvent(h, l, cc.EventMouse.SCROLL);
        u.setButton(c.button), u.setScrollData(0, c.wheelDelta), cc.eventManager.dispatchEvent(u), c.stopPropagation(), c.preventDefault();
      }, !1), t.addEventListener("DOMMouseScroll", function(c) {
        var l = e.getHTMLElementPosition(t), h = e.getPointByEvent(c, l), u = e.getMouseEvent(h, l, cc.EventMouse.SCROLL);
        u.setButton(c.button), u.setScrollData(0, c.detail * -120), cc.eventManager.dispatchEvent(u), c.stopPropagation(), c.preventDefault();
      }, !1)), window.navigator.msPointerEnabled) {
        var o = {
          MSPointerDown: e.handleTouchesBegin,
          MSPointerMove: e.handleTouchesMove,
          MSPointerUp: e.handleTouchesEnd,
          MSPointerCancel: e.handleTouchesCancel
        };
        for (var a in o)
          (function(c, l) {
            t.addEventListener(c, function(h) {
              var u = e.getHTMLElementPosition(t);
              u.left -= document.documentElement.scrollLeft, u.top -= document.documentElement.scrollTop, l.call(e, [e.getTouchByXY(h.clientX, h.clientY, u)]), h.stopPropagation();
            }, !1);
          })(a, o[a]);
      }
      r && (t.addEventListener("touchstart", function(c) {
        if (c.changedTouches) {
          var l = e.getHTMLElementPosition(t);
          l.left -= document.body.scrollLeft, l.top -= document.body.scrollTop, e.handleTouchesBegin(e.getTouchesByEvent(c, l)), c.stopPropagation(), c.preventDefault(), t.focus();
        }
      }, !1), t.addEventListener("touchmove", function(c) {
        if (c.changedTouches) {
          var l = e.getHTMLElementPosition(t);
          l.left -= document.body.scrollLeft, l.top -= document.body.scrollTop, e.handleTouchesMove(e.getTouchesByEvent(c, l)), c.stopPropagation(), c.preventDefault();
        }
      }, !1), t.addEventListener("touchend", function(c) {
        if (c.changedTouches) {
          var l = e.getHTMLElementPosition(t);
          l.left -= document.body.scrollLeft, l.top -= document.body.scrollTop, e.handleTouchesEnd(e.getTouchesByEvent(c, l)), c.stopPropagation(), c.preventDefault();
        }
      }, !1), t.addEventListener("touchcancel", function(c) {
        if (c.changedTouches) {
          var l = e.getHTMLElementPosition(t);
          l.left -= document.body.scrollLeft, l.top -= document.body.scrollTop, e.handleTouchesCancel(e.getTouchesByEvent(c, l)), c.stopPropagation(), c.preventDefault();
        }
      }, !1)), this._registerKeyboardEvent(), this._registerAccelerometerEvent(), this._isRegisterEvent = !0;
    }
  },
  _registerKeyboardEvent: function() {
  },
  _registerAccelerometerEvent: function() {
  },
  update: function(t) {
    this._accelCurTime > this._accelInterval && (this._accelCurTime -= (this || window)._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration))), this._accelCurTime += t;
  }
};
cc.AffineTransform = function(t, e, n, r, s, o) {
  this.a = t, this.b = e, this.c = n, this.d = r, this.tx = s, this.ty = o;
};
cc.affineTransformMake = function(t, e, n, r, s, o) {
  return { a: t, b: e, c: n, d: r, tx: s, ty: o };
};
cc.pointApplyAffineTransform = function(t, e, n) {
  var r, s;
  return n === void 0 ? (n = e, r = t.x, s = t.y) : (r = t, s = e), { x: n.a * r + n.c * s + n.tx, y: n.b * r + n.d * s + n.ty };
};
cc._pointApplyAffineTransform = function(t, e, n) {
  return cc.pointApplyAffineTransform(t, e, n);
};
cc.sizeApplyAffineTransform = function(t, e) {
  return { width: e.a * t.width + e.c * t.height, height: e.b * t.width + e.d * t.height };
};
cc.affineTransformMakeIdentity = function() {
  return { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 };
};
cc.affineTransformIdentity = function() {
  return { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 };
};
cc.rectApplyAffineTransform = function(t, e) {
  var n = cc.rectGetMinY(t), r = cc.rectGetMinX(t), s = cc.rectGetMaxX(t), o = cc.rectGetMaxY(t), a = cc.pointApplyAffineTransform(r, n, e), c = cc.pointApplyAffineTransform(s, n, e), l = cc.pointApplyAffineTransform(r, o, e), h = cc.pointApplyAffineTransform(s, o, e), u = Math.min(a.x, c.x, l.x, h.x), _ = Math.max(a.x, c.x, l.x, h.x), d = Math.min(a.y, c.y, l.y, h.y), f = Math.max(a.y, c.y, l.y, h.y);
  return cc.rect(u, d, _ - u, f - d);
};
cc._rectApplyAffineTransformIn = function(t, e) {
  var n = cc.rectGetMinY(t), r = cc.rectGetMinX(t), s = cc.rectGetMaxX(t), o = cc.rectGetMaxY(t), a = cc.pointApplyAffineTransform(r, n, e), c = cc.pointApplyAffineTransform(s, n, e), l = cc.pointApplyAffineTransform(r, o, e), h = cc.pointApplyAffineTransform(s, o, e), u = Math.min(a.x, c.x, l.x, h.x), _ = Math.max(a.x, c.x, l.x, h.x), d = Math.min(a.y, c.y, l.y, h.y), f = Math.max(a.y, c.y, l.y, h.y);
  return t.x = u, t.y = d, t.width = _ - u, t.height = f - d, t;
};
cc.affineTransformTranslate = function(t, e, n) {
  return {
    a: t.a,
    b: t.b,
    c: t.c,
    d: t.d,
    tx: t.tx + t.a * e + t.c * n,
    ty: t.ty + t.b * e + t.d * n
  };
};
cc.affineTransformScale = function(t, e, n) {
  return { a: t.a * e, b: t.b * e, c: t.c * n, d: t.d * n, tx: t.tx, ty: t.ty };
};
cc.affineTransformRotate = function(t, e) {
  var n = Math.sin(e), r = Math.cos(e);
  return {
    a: t.a * r + t.c * n,
    b: t.b * r + t.d * n,
    c: t.c * r - t.a * n,
    d: t.d * r - t.b * n,
    tx: t.tx,
    ty: t.ty
  };
};
cc.affineTransformConcat = function(t, e) {
  return {
    a: t.a * e.a + t.b * e.c,
    b: t.a * e.b + t.b * e.d,
    c: t.c * e.a + t.d * e.c,
    d: t.c * e.b + t.d * e.d,
    tx: t.tx * e.a + t.ty * e.c + e.tx,
    ty: t.tx * e.b + t.ty * e.d + e.ty
  };
};
cc.affineTransformConcatIn = function(t, e) {
  var n = t.a, r = t.b, s = t.c, o = t.d, a = t.tx, c = t.ty;
  return t.a = n * e.a + r * e.c, t.b = n * e.b + r * e.d, t.c = s * e.a + o * e.c, t.d = s * e.b + o * e.d, t.tx = a * e.a + c * e.c + e.tx, t.ty = a * e.b + c * e.d + e.ty, t;
};
cc.affineTransformEqualToTransform = function(t, e) {
  return t.a === e.a && t.b === e.b && t.c === e.c && t.d === e.d && t.tx === e.tx && t.ty === e.ty;
};
cc.affineTransformInvert = function(t) {
  var e = 1 / (t.a * t.d - t.b * t.c);
  return {
    a: e * t.d,
    b: -e * t.b,
    c: -e * t.c,
    d: e * t.a,
    tx: e * (t.c * t.ty - t.d * t.tx),
    ty: e * (t.b * t.tx - t.a * t.ty)
  };
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function(t) {
  return cc.p(-t.x, -t.y);
};
cc.pAdd = function(t, e) {
  return cc.p(t.x + e.x, t.y + e.y);
};
cc.pSub = function(t, e) {
  return cc.p(t.x - e.x, t.y - e.y);
};
cc.pMult = function(t, e) {
  return cc.p(t.x * e, t.y * e);
};
cc.pMidpoint = function(t, e) {
  return cc.pMult(cc.pAdd(t, e), 0.5);
};
cc.pDot = function(t, e) {
  return t.x * e.x + t.y * e.y;
};
cc.pCross = function(t, e) {
  return t.x * e.y - t.y * e.x;
};
cc.pPerp = function(t) {
  return cc.p(-t.y, t.x);
};
cc.pRPerp = function(t) {
  return cc.p(t.y, -t.x);
};
cc.pProject = function(t, e) {
  return cc.pMult(e, cc.pDot(t, e) / cc.pDot(e, e));
};
cc.pRotate = function(t, e) {
  return cc.p(t.x * e.x - t.y * e.y, t.x * e.y + t.y * e.x);
};
cc.pUnrotate = function(t, e) {
  return cc.p(t.x * e.x + t.y * e.y, t.y * e.x - t.x * e.y);
};
cc.pLengthSQ = function(t) {
  return cc.pDot(t, t);
};
cc.pDistanceSQ = function(t, e) {
  return cc.pLengthSQ(cc.pSub(t, e));
};
cc.pLength = function(t) {
  return Math.sqrt(cc.pLengthSQ(t));
};
cc.pDistance = function(t, e) {
  return cc.pLength(cc.pSub(t, e));
};
cc.pNormalize = function(t) {
  var e = cc.pLength(t);
  return e === 0 ? cc.p(t) : cc.pMult(t, 1 / e);
};
cc.pForAngle = function(t) {
  return cc.p(Math.cos(t), Math.sin(t));
};
cc.pToAngle = function(t) {
  return Math.atan2(t.y, t.x);
};
cc.clampf = function(t, e, n) {
  if (e > n) {
    var r = e;
    e = n, n = r;
  }
  return t < e ? e : t < n ? t : n;
};
cc.pClamp = function(t, e, n) {
  return cc.p(cc.clampf(t.x, e.x, n.x), cc.clampf(t.y, e.y, n.y));
};
cc.pFromSize = function(t) {
  return cc.p(t.width, t.height);
};
cc.pCompOp = function(t, e) {
  return cc.p(e(t.x), e(t.y));
};
cc.pLerp = function(t, e, n) {
  return cc.pAdd(cc.pMult(t, 1 - n), cc.pMult(e, n));
};
cc.pFuzzyEqual = function(t, e, n) {
  return t.x - n <= e.x && e.x <= t.x + n && t.y - n <= e.y && e.y <= t.y + n;
};
cc.pCompMult = function(t, e) {
  return cc.p(t.x * e.x, t.y * e.y);
};
cc.pAngleSigned = function(t, e) {
  var n = cc.pNormalize(t), r = cc.pNormalize(e), s = Math.atan2(n.x * r.y - n.y * r.x, cc.pDot(n, r));
  return Math.abs(s) < cc.POINT_EPSILON ? 0 : s;
};
cc.pAngle = function(t, e) {
  var n = Math.acos(cc.pDot(cc.pNormalize(t), cc.pNormalize(e)));
  return Math.abs(n) < cc.POINT_EPSILON ? 0 : n;
};
cc.pRotateByAngle = function(t, e, n) {
  var r = cc.pSub(t, e), s = Math.cos(n), o = Math.sin(n), a = r.x;
  return r.x = a * s - r.y * o + e.x, r.y = a * o + r.y * s + e.y, r;
};
cc.pLineIntersect = function(t, e, n, r, s) {
  if (t.x === e.x && t.y === e.y || n.x === r.x && n.y === r.y)
    return !1;
  var o = e.x - t.x, a = e.y - t.y, c = r.x - n.x, l = r.y - n.y, h = t.x - n.x, u = t.y - n.y, _ = l * o - c * a;
  return s.x = c * u - l * h, s.y = o * u - a * h, _ === 0 ? s.x === 0 || s.y === 0 : (s.x = s.x / _, s.y = s.y / _, !0);
};
cc.pSegmentIntersect = function(t, e, n, r) {
  var s = cc.p(0, 0);
  return !!(cc.pLineIntersect(t, e, n, r, s) && s.x >= 0 && s.x <= 1 && s.y >= 0 && s.y <= 1);
};
cc.pIntersectPoint = function(t, e, n, r) {
  var s = cc.p(0, 0);
  if (cc.pLineIntersect(t, e, n, r, s)) {
    var o = cc.p(0, 0);
    return o.x = t.x + s.x * (e.x - t.x), o.y = t.y + s.x * (e.y - t.y), o;
  }
  return cc.p(0, 0);
};
cc.pSameAs = function(t, e) {
  return t != null && e != null ? t.x === e.x && t.y === e.y : !1;
};
cc.pZeroIn = function(t) {
  t.x = 0, t.y = 0;
};
cc.pIn = function(t, e) {
  t.x = e.x, t.y = e.y;
};
cc.pMultIn = function(t, e) {
  t.x *= e, t.y *= e;
};
cc.pSubIn = function(t, e) {
  t.x -= e.x, t.y -= e.y;
};
cc.pAddIn = function(t, e) {
  t.x += e.x, t.y += e.y;
};
cc.pNormalizeIn = function(t) {
  cc.pMultIn(t, 1 / Math.sqrt(t.x * t.x + t.y * t.y));
};
cc.Touch = cc.Class.extend({
  _point: null,
  _prevPoint: null,
  _id: 0,
  _startPointCaptured: !1,
  _startPoint: null,
  ctor: function(t, e, n) {
    this.setTouchInfo(n, t, e);
  },
  getLocation: function() {
    return { x: this._point.x, y: this._point.y };
  },
  getLocationX: function() {
    return this._point.x;
  },
  getLocationY: function() {
    return this._point.y;
  },
  getPreviousLocation: function() {
    return { x: this._prevPoint.x, y: this._prevPoint.y };
  },
  getStartLocation: function() {
    return { x: this._startPoint.x, y: this._startPoint.y };
  },
  getDelta: function() {
    return cc.pSub(this._point, this._prevPoint);
  },
  getLocationInView: function() {
    return { x: this._point.x, y: this._point.y };
  },
  getPreviousLocationInView: function() {
    return { x: this._prevPoint.x, y: this._prevPoint.y };
  },
  getStartLocationInView: function() {
    return { x: this._startPoint.x, y: this._startPoint.y };
  },
  getID: function() {
    return this._id;
  },
  getId: function() {
    return cc.log("getId is deprecated. Please use getID instead."), this._id;
  },
  setTouchInfo: function(t, e, n) {
    this._prevPoint = (this || window)._point, this._point = cc.p(e || 0, n || 0), this._id = t, this._startPointCaptured || (this._startPoint = cc.p(this._point), cc.view._convertPointWithScale(this._startPoint), this._startPointCaptured = !0);
  },
  _setPoint: function(t, e) {
    e === void 0 ? (this._point.x = t.x, this._point.y = t.y) : (this._point.x = t, this._point.y = e);
  },
  _setPrevPoint: function(t, e) {
    e === void 0 ? this._prevPoint = cc.p(t.x, t.y) : this._prevPoint = cc.p(t || 0, e || 0);
  }
});
cc.Event = cc.Class.extend({
  _type: 0,
  _isStopped: !1,
  _currentTarget: null,
  _setCurrentTarget: function(t) {
    this._currentTarget = t;
  },
  ctor: function(t) {
    this._type = t;
  },
  getType: function() {
    return this._type;
  },
  stopPropagation: function() {
    this._isStopped = !0;
  },
  isStopped: function() {
    return this._isStopped;
  },
  getCurrentTarget: function() {
    return this._currentTarget;
  }
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.FOCUS = 4;
cc.Event.CUSTOM = 6;
cc.EventCustom = cc.Event.extend({
  _eventName: null,
  _userData: null,
  ctor: function(t) {
    cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM), this._eventName = t;
  },
  setUserData: function(t) {
    this._userData = t;
  },
  getUserData: function() {
    return this._userData;
  },
  getEventName: function() {
    return this._eventName;
  }
});
cc.EventMouse = cc.Event.extend({
  _eventType: 0,
  _button: 0,
  _x: 0,
  _y: 0,
  _prevX: 0,
  _prevY: 0,
  _scrollX: 0,
  _scrollY: 0,
  ctor: function(t) {
    cc.Event.prototype.ctor.call(this, cc.Event.MOUSE), this._eventType = t;
  },
  setScrollData: function(t, e) {
    this._scrollX = t, this._scrollY = e;
  },
  getScrollX: function() {
    return this._scrollX;
  },
  getScrollY: function() {
    return this._scrollY;
  },
  setLocation: function(t, e) {
    this._x = t, this._y = e;
  },
  getLocation: function() {
    return { x: this._x, y: this._y };
  },
  getLocationInView: function() {
    return { x: this._x, y: cc.view._designResolutionSize.height - this._y };
  },
  _setPrevCursor: function(t, e) {
    this._prevX = t, this._prevY = e;
  },
  getDelta: function() {
    return { x: this._x - this._prevX, y: this._y - this._prevY };
  },
  getDeltaX: function() {
    return this._x - this._prevX;
  },
  getDeltaY: function() {
    return this._y - this._prevY;
  },
  setButton: function(t) {
    this._button = t;
  },
  getButton: function() {
    return this._button;
  },
  getLocationX: function() {
    return this._x;
  },
  getLocationY: function() {
    return this._y;
  }
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
  _eventCode: 0,
  _touches: null,
  ctor: function(t) {
    cc.Event.prototype.ctor.call(this, cc.Event.TOUCH), this._touches = t || [];
  },
  getEventCode: function() {
    return this._eventCode;
  },
  getTouches: function() {
    return this._touches;
  },
  _setEventCode: function(t) {
    this._eventCode = t;
  },
  _setTouches: function(t) {
    this._touches = t;
  }
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = { BEGAN: 0, MOVED: 1, ENDED: 2, CANCELLED: 3 };
cc.EventFocus = cc.Event.extend({
  _widgetGetFocus: null,
  _widgetLoseFocus: null,
  ctor: function(t, e) {
    cc.Event.prototype.ctor.call(this, cc.Event.FOCUS), this._widgetGetFocus = e, this._widgetLoseFocus = t;
  }
});
cc.EventListener = cc.Class.extend({
  _onEvent: null,
  _type: 0,
  _listenerID: null,
  _registered: !1,
  _fixedPriority: 0,
  _node: null,
  _paused: !0,
  _isEnabled: !0,
  ctor: function(t, e, n) {
    this._onEvent = n, this._type = t || 0, this._listenerID = e || "";
  },
  _setPaused: function(t) {
    this._paused = t;
  },
  _isPaused: function() {
    return this._paused;
  },
  _setRegistered: function(t) {
    this._registered = t;
  },
  _isRegistered: function() {
    return this._registered;
  },
  _getType: function() {
    return this._type;
  },
  _getListenerID: function() {
    return this._listenerID;
  },
  _setFixedPriority: function(t) {
    this._fixedPriority = t;
  },
  _getFixedPriority: function() {
    return this._fixedPriority;
  },
  _setSceneGraphPriority: function(t) {
    this._node = t;
  },
  _getSceneGraphPriority: function() {
    return this._node;
  },
  checkAvailable: function() {
    return this._onEvent !== null;
  },
  clone: function() {
    return null;
  },
  setEnabled: function(t) {
    this._isEnabled = t;
  },
  isEnabled: function() {
    return this._isEnabled;
  },
  retain: function() {
  },
  release: function() {
  }
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 6;
cc.EventListener.FOCUS = 7;
cc.EventListener.CUSTOM = 8;
cc._EventListenerCustom = cc.EventListener.extend({
  _onCustomEvent: null,
  ctor: function(t, e) {
    this._onCustomEvent = e;
    var n = (this || window), r = /* @__PURE__ */ H(function(s) {
      n._onCustomEvent !== null && n._onCustomEvent(s);
    }, "listener");
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, t, r);
  },
  checkAvailable: function() {
    return cc.EventListener.prototype.checkAvailable.call(this) && this._onCustomEvent !== null;
  },
  clone: function() {
    return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent);
  }
});
cc._EventListenerCustom.create = function(t, e) {
  return new cc._EventListenerCustom(t, e);
};
cc._EventListenerMouse = cc.EventListener.extend({
  onMouseDown: null,
  onMouseUp: null,
  onMouseMove: null,
  onMouseScroll: null,
  ctor: function() {
    var t = (this || window), e = /* @__PURE__ */ H(function(n) {
      var r = cc.EventMouse;
      switch (n._eventType) {
        case r.DOWN:
          t.onMouseDown && t.onMouseDown(n);
          break;
        case r.UP:
          t.onMouseUp && t.onMouseUp(n);
          break;
        case r.MOVE:
          t.onMouseMove && t.onMouseMove(n);
          break;
        case r.SCROLL:
          t.onMouseScroll && t.onMouseScroll(n);
          break;
      }
    }, "listener");
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, e);
  },
  clone: function() {
    var t = new cc._EventListenerMouse();
    return t.onMouseDown = (this || window).onMouseDown, t.onMouseUp = (this || window).onMouseUp, t.onMouseMove = (this || window).onMouseMove, t.onMouseScroll = (this || window).onMouseScroll, t;
  },
  checkAvailable: function() {
    return !0;
  }
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function() {
  return new cc._EventListenerMouse();
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
  _claimedTouches: null,
  swallowTouches: !1,
  onTouchBegan: null,
  onTouchMoved: null,
  onTouchEnded: null,
  onTouchCancelled: null,
  ctor: function() {
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null), this._claimedTouches = [];
  },
  setSwallowTouches: function(t) {
    this.swallowTouches = t;
  },
  isSwallowTouches: function() {
    return this.swallowTouches;
  },
  clone: function() {
    var t = new cc._EventListenerTouchOneByOne();
    return t.onTouchBegan = (this || window).onTouchBegan, t.onTouchMoved = (this || window).onTouchMoved, t.onTouchEnded = (this || window).onTouchEnded, t.onTouchCancelled = (this || window).onTouchCancelled, t.swallowTouches = (this || window).swallowTouches, t;
  },
  checkAvailable: function() {
    return this.onTouchBegan ? !0 : (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1);
  }
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function() {
  return new cc._EventListenerTouchOneByOne();
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
  onTouchesBegan: null,
  onTouchesMoved: null,
  onTouchesEnded: null,
  onTouchesCancelled: null,
  ctor: function() {
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null);
  },
  clone: function() {
    var t = new cc._EventListenerTouchAllAtOnce();
    return t.onTouchesBegan = (this || window).onTouchesBegan, t.onTouchesMoved = (this || window).onTouchesMoved, t.onTouchesEnded = (this || window).onTouchesEnded, t.onTouchesCancelled = (this || window).onTouchesCancelled, t;
  },
  checkAvailable: function() {
    return this.onTouchesBegan === null && this.onTouchesMoved === null && this.onTouchesEnded === null && this.onTouchesCancelled === null ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0;
  }
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function() {
  return new cc._EventListenerTouchAllAtOnce();
};
cc.EventListener.create = function(t) {
  cc.assert(t && t.event, cc._LogInfos.EventListener_create);
  var e = t.event;
  delete t.event;
  var n = null;
  e === cc.EventListener.TOUCH_ONE_BY_ONE ? n = new cc._EventListenerTouchOneByOne() : e === cc.EventListener.TOUCH_ALL_AT_ONCE ? n = new cc._EventListenerTouchAllAtOnce() : e === cc.EventListener.MOUSE ? n = new cc._EventListenerMouse() : e === cc.EventListener.CUSTOM ? (n = new cc._EventListenerCustom(t.eventName, t.callback), delete t.eventName, delete t.callback) : e === cc.EventListener.KEYBOARD ? n = new cc._EventListenerKeyboard() : e === cc.EventListener.ACCELERATION ? (n = new cc._EventListenerAcceleration(t.callback), delete t.callback) : e === cc.EventListener.FOCUS && (n = new cc._EventListenerFocus());
  for (var r in t)
    n[r] = t[r];
  return n;
};
cc._EventListenerFocus = cc.EventListener.extend({
  clone: function() {
    var t = new cc._EventListenerFocus();
    return t.onFocusChanged = (this || window).onFocusChanged, t;
  },
  checkAvailable: function() {
    return this.onFocusChanged ? !0 : (cc.log("Invalid EventListenerFocus!"), !1);
  },
  onFocusChanged: null,
  ctor: function() {
    var t = /* @__PURE__ */ H(function(e) {
      this.onFocusChanged && this.onFocusChanged(e._widgetLoseFocus, e._widgetGetFocus);
    }, "listener");
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.FOCUS, cc._EventListenerFocus.LISTENER_ID, t);
  }
});
cc._EventListenerFocus.LISTENER_ID = "__cc_focus_event";
cc._EventListenerVector = cc.Class.extend({
  _fixedListeners: null,
  _sceneGraphListeners: null,
  gt0Index: 0,
  ctor: function() {
    this._fixedListeners = [], this._sceneGraphListeners = [];
  },
  size: function() {
    return this._fixedListeners.length + this._sceneGraphListeners.length;
  },
  empty: function() {
    return this._fixedListeners.length === 0 && this._sceneGraphListeners.length === 0;
  },
  push: function(t) {
    t._getFixedPriority() === 0 ? this._sceneGraphListeners.push(t) : this._fixedListeners.push(t);
  },
  clearSceneGraphListeners: function() {
    this._sceneGraphListeners.length = 0;
  },
  clearFixedListeners: function() {
    this._fixedListeners.length = 0;
  },
  clear: function() {
    this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0;
  },
  getFixedPriorityListeners: function() {
    return this._fixedListeners;
  },
  getSceneGraphPriorityListeners: function() {
    return this._sceneGraphListeners;
  }
});
cc.__getListenerID = function(t) {
  var e = cc.Event, n = t.getType();
  return n === e.ACCELERATION ? cc._EventListenerAcceleration.LISTENER_ID : n === e.CUSTOM ? t.getEventName() : n === e.KEYBOARD ? cc._EventListenerKeyboard.LISTENER_ID : n === e.MOUSE ? cc._EventListenerMouse.LISTENER_ID : n === e.FOCUS ? cc._EventListenerFocus.LISTENER_ID : (n === e.TOUCH && cc.log(cc._LogInfos.__getListenerID), "");
};
cc.eventManager = {
  DIRTY_NONE: 0,
  DIRTY_FIXED_PRIORITY: 1,
  DIRTY_SCENE_GRAPH_PRIORITY: 2,
  DIRTY_ALL: 3,
  _listenersMap: {},
  _priorityDirtyFlagMap: {},
  _nodeListenersMap: {},
  _nodePriorityMap: {},
  _globalZOrderNodeMap: {},
  _toAddedListeners: [],
  _toRemovedListeners: [],
  _dirtyNodes: [],
  _inDispatch: 0,
  _isEnabled: !1,
  _nodePriorityIndex: 0,
  _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
  _setDirtyForNode: function(t) {
    this._nodeListenersMap[t.__instanceId] != null && this._dirtyNodes.push(t);
    for (var e = t.getChildren(), n = 0, r = e.length; n < r; n++)
      this._setDirtyForNode(e[n]);
  },
  pauseTarget: function(t, e) {
    var n = (this || window)._nodeListenersMap[t.__instanceId], r, s;
    if (n)
      for (r = 0, s = n.length; r < s; r++)
        n[r]._setPaused(!0);
    if (e === !0) {
      var o = t.getChildren();
      for (r = 0, s = o.length; r < s; r++)
        this.pauseTarget(o[r], !0);
    }
  },
  resumeTarget: function(t, e) {
    var n = (this || window)._nodeListenersMap[t.__instanceId], r, s;
    if (n)
      for (r = 0, s = n.length; r < s; r++)
        n[r]._setPaused(!1);
    if (this._setDirtyForNode(t), e === !0) {
      var o = t.getChildren();
      for (r = 0, s = o.length; r < s; r++)
        this.resumeTarget(o[r], !0);
    }
  },
  _addListener: function(t) {
    this._inDispatch === 0 ? this._forceAddEventListener(t) : this._toAddedListeners.push(t);
  },
  _forceAddEventListener: function(t) {
    var e = t._getListenerID(), n = (this || window)._listenersMap[e];
    if (n || (n = new cc._EventListenerVector(), this._listenersMap[e] = n), n.push(t), t._getFixedPriority() === 0) {
      this._setDirty(e, this.DIRTY_SCENE_GRAPH_PRIORITY);
      var r = t._getSceneGraphPriority();
      r === null && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(r, t), r.isRunning() && this.resumeTarget(r);
    } else
      this._setDirty(e, this.DIRTY_FIXED_PRIORITY);
  },
  _getListeners: function(t) {
    return this._listenersMap[t];
  },
  _updateDirtyFlagForSceneGraph: function() {
    if (this._dirtyNodes.length !== 0) {
      for (var t = (this || window)._dirtyNodes, e, n, r = (this || window)._nodeListenersMap, s = 0, o = t.length; s < o; s++)
        if (e = r[t[s].__instanceId], e)
          for (var a = 0, c = e.length; a < c; a++)
            n = e[a], n && this._setDirty(n._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
      this._dirtyNodes.length = 0;
    }
  },
  _removeAllListenersInVector: function(t) {
    if (t)
      for (var e, n = 0; n < t.length; )
        e = t[n], e._setRegistered(!1), e._getSceneGraphPriority() != null && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), this._inDispatch === 0 ? cc.arrayRemoveObject(t, e) : ++n;
  },
  _removeListenersForListenerID: function(t) {
    var e = (this || window)._listenersMap[t], n;
    if (e) {
      var r = e.getFixedPriorityListeners(), s = e.getSceneGraphPriorityListeners();
      this._removeAllListenersInVector(s), this._removeAllListenersInVector(r), delete this._priorityDirtyFlagMap[t], this._inDispatch || (e.clear(), delete this._listenersMap[t]);
    }
    var o = (this || window)._toAddedListeners, a;
    for (n = 0; n < o.length; )
      a = o[n], a && a._getListenerID() === t ? cc.arrayRemoveObject(o, a) : ++n;
  },
  _sortEventListeners: function(t) {
    var e = (this || window).DIRTY_NONE, n = (this || window)._priorityDirtyFlagMap;
    if (n[t] && (e = n[t]), e !== (this || window).DIRTY_NONE && (n[t] = (this || window).DIRTY_NONE, e & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(t), e & this.DIRTY_SCENE_GRAPH_PRIORITY)) {
      var r = cc.director.getRunningScene();
      r ? this._sortListenersOfSceneGraphPriority(t, r) : n[t] = (this || window).DIRTY_SCENE_GRAPH_PRIORITY;
    }
  },
  _sortListenersOfSceneGraphPriority: function(t, e) {
    var n = (this || window)._getListeners(t);
    if (n) {
      var r = n.getSceneGraphPriorityListeners();
      !r || r.length === 0 || (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(e, !0), n.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes));
    }
  },
  _sortEventListenersOfSceneGraphPriorityDes: function(t, e) {
    var n = cc.eventManager._nodePriorityMap, r = t._getSceneGraphPriority(), s = e._getSceneGraphPriority();
    return !e || !s || !n[s.__instanceId] ? -1 : !t || !r || !n[r.__instanceId] ? 1 : n[e._getSceneGraphPriority().__instanceId] - n[t._getSceneGraphPriority().__instanceId];
  },
  _sortListenersOfFixedPriority: function(t) {
    var e = (this || window)._listenersMap[t];
    if (e) {
      var n = e.getFixedPriorityListeners();
      if (!(!n || n.length === 0)) {
        n.sort(this._sortListenersOfFixedPriorityAsc);
        for (var r = 0, s = n.length; r < s && !(n[r]._getFixedPriority() >= 0); )
          ++r;
        e.gt0Index = r;
      }
    }
  },
  _sortListenersOfFixedPriorityAsc: function(t, e) {
    return t._getFixedPriority() - e._getFixedPriority();
  },
  _onUpdateListeners: function(t) {
    var e = (this || window)._listenersMap[t];
    if (e) {
      var n = e.getFixedPriorityListeners(), r = e.getSceneGraphPriorityListeners(), s, o, a, c = (this || window)._toRemovedListeners;
      if (r)
        for (s = 0; s < r.length; )
          o = r[s], o._isRegistered() ? ++s : (cc.arrayRemoveObject(r, o), a = c.indexOf(o), a !== -1 && c.splice(a, 1));
      if (n)
        for (s = 0; s < n.length; )
          o = n[s], o._isRegistered() ? ++s : (cc.arrayRemoveObject(n, o), a = c.indexOf(o), a !== -1 && c.splice(a, 1));
      r && r.length === 0 && e.clearSceneGraphListeners(), n && n.length === 0 && e.clearFixedListeners();
    }
  },
  _updateListeners: function(t) {
    var e = (this || window)._inDispatch;
    if (cc.assert(e > 0, cc._LogInfos.EventManager__updateListeners), !(e > 1)) {
      t.getType() === cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(t)), cc.assert(e === 1, cc._LogInfos.EventManager__updateListeners_2);
      var n = (this || window)._listenersMap, r = (this || window)._priorityDirtyFlagMap;
      for (var s in n)
        n[s].empty() && (delete r[s], delete n[s]);
      var o = (this || window)._toAddedListeners;
      if (o.length !== 0) {
        for (var a = 0, c = o.length; a < c; a++)
          this._forceAddEventListener(o[a]);
        this._toAddedListeners.length = 0;
      }
      this._toRemovedListeners.length !== 0 && this._cleanToRemovedListeners();
    }
  },
  _cleanToRemovedListeners: function() {
    for (var t = (this || window)._toRemovedListeners, e = 0; e < t.length; e++) {
      var n = t[e], r = (this || window)._listenersMap[n._getListenerID()];
      if (r) {
        var s, o = r.getFixedPriorityListeners(), a = r.getSceneGraphPriorityListeners();
        a && (s = a.indexOf(n), s !== -1 && a.splice(s, 1)), o && (s = o.indexOf(n), s !== -1 && o.splice(s, 1));
      }
    }
    t.length = 0;
  },
  _onTouchEventCallback: function(t, e) {
    if (!t._isRegistered)
      return !1;
    var n = e.event, r = e.selTouch;
    n._setCurrentTarget(t._node);
    var s = !1, o, a = n.getEventCode(), c = cc.EventTouch.EventCode;
    return a === c.BEGAN ? t.onTouchBegan && (s = t.onTouchBegan(r, n), s && t._registered && t._claimedTouches.push(r)) : t._claimedTouches.length > 0 && (o = t._claimedTouches.indexOf(r)) !== -1 && (s = !0, a === c.MOVED && t.onTouchMoved ? t.onTouchMoved(r, n) : a === c.ENDED ? (t.onTouchEnded && t.onTouchEnded(r, n), t._registered && t._claimedTouches.splice(o, 1)) : a === c.CANCELLED && (t.onTouchCancelled && t.onTouchCancelled(r, n), t._registered && t._claimedTouches.splice(o, 1))), n.isStopped() ? (cc.eventManager._updateListeners(n), !0) : s && t._registered && t.swallowTouches ? (e.needsMutableSet && e.touches.splice(r, 1), !0) : !1;
  },
  _dispatchTouchEvent: function(t) {
    this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
    var e = (this || window)._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), n = (this || window)._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
    if (!(e === null && n === null)) {
      var r = t.getTouches(), s = cc.copyArray(r), o = { event: t, needsMutableSet: e && n, touches: s, selTouch: null };
      if (e) {
        for (var a = 0; a < r.length; a++)
          if (o.selTouch = r[a], this._dispatchEventToListeners(e, this._onTouchEventCallback, o), t.isStopped())
            return;
      }
      n && s.length > 0 && (this._dispatchEventToListeners(n, this._onTouchesEventCallback, { event: t, touches: s }), t.isStopped()) || this._updateListeners(t);
    }
  },
  _onTouchesEventCallback: function(t, e) {
    if (!t._registered)
      return !1;
    var n = cc.EventTouch.EventCode, r = e.event, s = e.touches, o = r.getEventCode();
    return r._setCurrentTarget(t._node), o === n.BEGAN && t.onTouchesBegan ? t.onTouchesBegan(s, r) : o === n.MOVED && t.onTouchesMoved ? t.onTouchesMoved(s, r) : o === n.ENDED && t.onTouchesEnded ? t.onTouchesEnded(s, r) : o === n.CANCELLED && t.onTouchesCancelled && t.onTouchesCancelled(s, r), r.isStopped() ? (cc.eventManager._updateListeners(r), !0) : !1;
  },
  _associateNodeAndEventListener: function(t, e) {
    var n = (this || window)._nodeListenersMap[t.__instanceId];
    n || (n = [], this._nodeListenersMap[t.__instanceId] = n), n.push(e);
  },
  _dissociateNodeAndEventListener: function(t, e) {
    var n = (this || window)._nodeListenersMap[t.__instanceId];
    n && (cc.arrayRemoveObject(n, e), n.length === 0 && delete this._nodeListenersMap[t.__instanceId]);
  },
  _dispatchEventToListeners: function(t, e, n) {
    var r = !1, s = t.getFixedPriorityListeners(), o = t.getSceneGraphPriorityListeners(), a = 0, c, l;
    if (s && s.length !== 0) {
      for (; a < t.gt0Index; ++a)
        if (l = s[a], l.isEnabled() && !l._isPaused() && l._isRegistered() && e(l, n)) {
          r = !0;
          break;
        }
    }
    if (o && !r) {
      for (c = 0; c < o.length; c++)
        if (l = o[c], l.isEnabled() && !l._isPaused() && l._isRegistered() && e(l, n)) {
          r = !0;
          break;
        }
    }
    if (s && !r) {
      for (; a < s.length; ++a)
        if (l = s[a], l.isEnabled() && !l._isPaused() && l._isRegistered() && e(l, n)) {
          r = !0;
          break;
        }
    }
  },
  _setDirty: function(t, e) {
    var n = (this || window)._priorityDirtyFlagMap;
    n[t] == null ? n[t] = e : n[t] = e | n[t];
  },
  _visitTarget: function(t, e) {
    var n = t.getChildren(), r = 0, s = n.length, o = (this || window)._globalZOrderNodeMap, a = (this || window)._nodeListenersMap;
    if (s > 0) {
      for (var c; r < s && (c = n[r], c && c.getLocalZOrder() < 0); r++)
        this._visitTarget(c, !1);
      for (a[t.__instanceId] != null && (o[t.getGlobalZOrder()] || (o[t.getGlobalZOrder()] = []), o[t.getGlobalZOrder()].push(t.__instanceId)); r < s; r++)
        c = n[r], c && this._visitTarget(c, !1);
    } else
      a[t.__instanceId] != null && (o[t.getGlobalZOrder()] || (o[t.getGlobalZOrder()] = []), o[t.getGlobalZOrder()].push(t.__instanceId));
    if (e) {
      var l = [];
      for (var h in o)
        l.push(h);
      l.sort(this._sortNumberAsc);
      var u = l.length, _, d, f = (this || window)._nodePriorityMap;
      for (r = 0; r < u; r++)
        for (_ = o[l[r]], d = 0; d < _.length; d++)
          f[_[d]] = ++this._nodePriorityIndex;
      this._globalZOrderNodeMap = {};
    }
  },
  _sortNumberAsc: function(t, e) {
    return t - e;
  },
  addListener: function(t, e) {
    if (cc.assert(t && e, cc._LogInfos.eventManager_addListener_2), !(t instanceof cc.EventListener))
      cc.assert(!cc.isNumber(e), cc._LogInfos.eventManager_addListener_3), t = cc.EventListener.create(t);
    else if (t._isRegistered()) {
      cc.log(cc._LogInfos.eventManager_addListener_4);
      return;
    }
    if (t.checkAvailable()) {
      if (cc.isNumber(e)) {
        if (e === 0) {
          cc.log(cc._LogInfos.eventManager_addListener);
          return;
        }
        t._setSceneGraphPriority(null), t._setFixedPriority(e), t._setRegistered(!0), t._setPaused(!1), this._addListener(t);
      } else
        t._setSceneGraphPriority(e), t._setFixedPriority(0), t._setRegistered(!0), this._addListener(t);
      return t;
    }
  },
  addCustomListener: function(t, e) {
    var n = new cc._EventListenerCustom(t, e);
    return this.addListener(n, 1), n;
  },
  removeListener: function(t) {
    if (t != null) {
      var e, n = (this || window)._listenersMap;
      for (var r in n) {
        var s = n[r], o = s.getFixedPriorityListeners(), a = s.getSceneGraphPriorityListeners();
        if (e = (this || window)._removeListenerInVector(a, t), e ? this._setDirty(t._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY) : (e = (this || window)._removeListenerInVector(o, t), e && this._setDirty(t._getListenerID(), this.DIRTY_FIXED_PRIORITY)), s.empty() && (delete this._priorityDirtyFlagMap[t._getListenerID()], delete n[r]), e)
          break;
      }
      if (!e)
        for (var c = (this || window)._toAddedListeners, l = 0, h = c.length; l < h; l++) {
          var u = c[l];
          if (u === t) {
            cc.arrayRemoveObject(c, u), u._setRegistered(!1);
            break;
          }
        }
    }
  },
  _removeListenerInCallback: function(t, e) {
    if (t == null)
      return !1;
    for (var n = 0, r = t.length; n < r; n++) {
      var s = t[n];
      if (s._onCustomEvent === e || s._onEvent === e)
        return s._setRegistered(!1), s._getSceneGraphPriority() != null && (this._dissociateNodeAndEventListener(s._getSceneGraphPriority(), s), s._setSceneGraphPriority(null)), this._inDispatch === 0 && cc.arrayRemoveObject(t, s), !0;
    }
    return !1;
  },
  _removeListenerInVector: function(t, e) {
    if (t == null)
      return !1;
    for (var n = 0, r = t.length; n < r; n++) {
      var s = t[n];
      if (s === e)
        return s._setRegistered(!1), s._getSceneGraphPriority() != null && (this._dissociateNodeAndEventListener(s._getSceneGraphPriority(), s), s._setSceneGraphPriority(null)), this._inDispatch === 0 ? cc.arrayRemoveObject(t, s) : this._toRemovedListeners.push(s), !0;
    }
    return !1;
  },
  removeListeners: function(t, e) {
    var n = (this || window);
    if (t instanceof cc.Node) {
      delete n._nodePriorityMap[t.__instanceId], cc.arrayRemoveObject(n._dirtyNodes, t);
      var r = n._nodeListenersMap[t.__instanceId], s;
      if (r) {
        var o = cc.copyArray(r);
        for (s = 0; s < o.length; s++)
          n.removeListener(o[s]);
        o.length = 0;
      }
      var a = n._toAddedListeners;
      for (s = 0; s < a.length; ) {
        var c = a[s];
        c._getSceneGraphPriority() === t ? (c._setSceneGraphPriority(null), c._setRegistered(!1), a.splice(s, 1)) : ++s;
      }
      if (e === !0) {
        var l = t.getChildren(), h;
        for (s = 0, h = l.length; s < h; s++)
          n.removeListeners(l[s], !0);
      }
    } else
      t === cc.EventListener.TOUCH_ONE_BY_ONE ? n._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : t === cc.EventListener.TOUCH_ALL_AT_ONCE ? n._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : t === cc.EventListener.MOUSE ? n._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : t === cc.EventListener.ACCELERATION ? n._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : t === cc.EventListener.KEYBOARD ? n._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners);
  },
  removeCustomListeners: function(t) {
    this._removeListenersForListenerID(t);
  },
  removeAllListeners: function() {
    var t = (this || window)._listenersMap, e = (this || window)._internalCustomListenerIDs;
    for (var n in t)
      e.indexOf(n) === -1 && this._removeListenersForListenerID(n);
  },
  setPriority: function(t, e) {
    if (t != null) {
      var n = (this || window)._listenersMap;
      for (var r in n) {
        var s = n[r], o = s.getFixedPriorityListeners();
        if (o) {
          var a = o.indexOf(t);
          if (a !== -1) {
            t._getSceneGraphPriority() != null && cc.log(cc._LogInfos.eventManager_setPriority), t._getFixedPriority() !== e && (t._setFixedPriority(e), this._setDirty(t._getListenerID(), this.DIRTY_FIXED_PRIORITY));
            return;
          }
        }
      }
    }
  },
  setEnabled: function(t) {
    this._isEnabled = t;
  },
  isEnabled: function() {
    return this._isEnabled;
  },
  dispatchEvent: function(t) {
    if (this._isEnabled) {
      if (this._updateDirtyFlagForSceneGraph(), this._inDispatch++, !t || !t.getType)
        throw new Error("event is undefined");
      if (t.getType() === cc.Event.TOUCH) {
        this._dispatchTouchEvent(t), this._inDispatch--;
        return;
      }
      var e = cc.__getListenerID(t);
      this._sortEventListeners(e);
      var n = (this || window)._listenersMap[e];
      n != null && this._dispatchEventToListeners(n, this._onListenerCallback, t), this._updateListeners(t), this._inDispatch--;
    }
  },
  _onListenerCallback: function(t, e) {
    return e._setCurrentTarget(t._getSceneGraphPriority()), t._onEvent(e), e.isStopped();
  },
  dispatchCustomEvent: function(t, e) {
    var n = new cc.EventCustom(t);
    n.setUserData(e), this.dispatchEvent(n);
  }
};
cc._tmp.PrototypeCCNode = function() {
  var t = cc.Node.prototype;
  cc.defineGetterSetter(t, "x", t.getPositionX, t.setPositionX), cc.defineGetterSetter(t, "y", t.getPositionY, t.setPositionY), t.width, cc.defineGetterSetter(t, "width", t._getWidth, t._setWidth), t.height, cc.defineGetterSetter(t, "height", t._getHeight, t._setHeight), t.anchorX, cc.defineGetterSetter(t, "anchorX", t._getAnchorX, t._setAnchorX), t.anchorY, cc.defineGetterSetter(t, "anchorY", t._getAnchorY, t._setAnchorY), t.skewX, cc.defineGetterSetter(t, "skewX", t.getSkewX, t.setSkewX), t.skewY, cc.defineGetterSetter(t, "skewY", t.getSkewY, t.setSkewY), t.zIndex, cc.defineGetterSetter(t, "zIndex", t.getLocalZOrder, t.setLocalZOrder), t.vertexZ, cc.defineGetterSetter(t, "vertexZ", t.getVertexZ, t.setVertexZ), t.rotation, cc.defineGetterSetter(t, "rotation", t.getRotation, t.setRotation), t.rotationX, cc.defineGetterSetter(t, "rotationX", t.getRotationX, t.setRotationX), t.rotationY, cc.defineGetterSetter(t, "rotationY", t.getRotationY, t.setRotationY), t.scale, cc.defineGetterSetter(t, "scale", t.getScale, t.setScale), t.scaleX, cc.defineGetterSetter(t, "scaleX", t.getScaleX, t.setScaleX), t.scaleY, cc.defineGetterSetter(t, "scaleY", t.getScaleY, t.setScaleY), t.children, cc.defineGetterSetter(t, "children", t.getChildren), t.childrenCount, cc.defineGetterSetter(t, "childrenCount", t.getChildrenCount), t.parent, cc.defineGetterSetter(t, "parent", t.getParent, t.setParent), t.visible, cc.defineGetterSetter(t, "visible", t.isVisible, t.setVisible), t.running, cc.defineGetterSetter(t, "running", t.isRunning), t.ignoreAnchor, cc.defineGetterSetter(t, "ignoreAnchor", t.isIgnoreAnchorPointForPosition, t.ignoreAnchorPointForPosition), t.tag, t.userData, t.userObject, t.arrivalOrder, t.actionManager, cc.defineGetterSetter(t, "actionManager", t.getActionManager, t.setActionManager), t.scheduler, cc.defineGetterSetter(t, "scheduler", t.getScheduler, t.setScheduler), t.shaderProgram, cc.defineGetterSetter(t, "shaderProgram", t.getShaderProgram, t.setShaderProgram), t.opacity, cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity), t.opacityModifyRGB, cc.defineGetterSetter(t, "opacityModifyRGB", t.isOpacityModifyRGB), t.cascadeOpacity, cc.defineGetterSetter(t, "cascadeOpacity", t.isCascadeOpacityEnabled, t.setCascadeOpacityEnabled), t.color, cc.defineGetterSetter(t, "color", t.getColor, t.setColor), t.cascadeColor, cc.defineGetterSetter(t, "cascadeColor", t.isCascadeColorEnabled, t.setCascadeColorEnabled);
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
  _localZOrder: 0,
  _globalZOrder: 0,
  _vertexZ: 0,
  _customZ: NaN,
  _rotationX: 0,
  _rotationY: 0,
  _scaleX: 1,
  _scaleY: 1,
  _position: null,
  _normalizedPosition: null,
  _usingNormalizedPosition: !1,
  _normalizedPositionDirty: !1,
  _skewX: 0,
  _skewY: 0,
  _children: null,
  _visible: !0,
  _anchorPoint: null,
  _contentSize: null,
  _running: !1,
  _parent: null,
  _ignoreAnchorPointForPosition: !1,
  tag: cc.NODE_TAG_INVALID,
  userData: null,
  userObject: null,
  _reorderChildDirty: !1,
  _shaderProgram: null,
  arrivalOrder: 0,
  _actionManager: null,
  _scheduler: null,
  _eventDispatcher: null,
  _additionalTransformDirty: !1,
  _additionalTransform: null,
  _componentContainer: null,
  _isTransitionFinished: !1,
  _className: "Node",
  _showNode: !1,
  _name: "",
  _realOpacity: 255,
  _realColor: null,
  _cascadeColorEnabled: !1,
  _cascadeOpacityEnabled: !1,
  _renderCmd: null,
  ctor: function() {
    this._initNode(), this._initRendererCmd();
  },
  _initNode: function() {
    var t = (this || window);
    t._anchorPoint = cc.p(0, 0), t._contentSize = cc.size(0, 0), t._position = cc.p(0, 0), t._normalizedPosition = cc.p(0, 0), t._children = [];
    var e = cc.director;
    t._actionManager = e.getActionManager(), t._scheduler = e.getScheduler(), t._additionalTransform = cc.affineTransformMakeIdentity(), cc.ComponentContainer && (t._componentContainer = new cc.ComponentContainer(t)), this._realOpacity = 255, this._realColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabled = !1, this._cascadeOpacityEnabled = !1;
  },
  init: function() {
    return !0;
  },
  _arrayMakeObjectsPerformSelector: function(t, e) {
    if (!(!t || t.length === 0)) {
      var n, r = t.length, s, o = cc.Node._stateCallbackType;
      switch (e) {
        case o.onEnter:
          for (n = 0; n < r; n++)
            s = t[n], s && s.onEnter();
          break;
        case o.onExit:
          for (n = 0; n < r; n++)
            s = t[n], s && s.onExit();
          break;
        case o.onEnterTransitionDidFinish:
          for (n = 0; n < r; n++)
            s = t[n], s && s.onEnterTransitionDidFinish();
          break;
        case o.cleanup:
          for (n = 0; n < r; n++)
            s = t[n], s && s.cleanup();
          break;
        case o.updateTransform:
          for (n = 0; n < r; n++)
            s = t[n], s && s.updateTransform();
          break;
        case o.onExitTransitionDidStart:
          for (n = 0; n < r; n++)
            s = t[n], s && s.onExitTransitionDidStart();
          break;
        case o.sortAllChildren:
          for (n = 0; n < r; n++)
            s = t[n], s && s.sortAllChildren();
          break;
        default:
          cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector);
          break;
      }
    }
  },
  attr: function(t) {
    for (var e in t)
      this[e] = t[e];
  },
  getSkewX: function() {
    return this._skewX;
  },
  setSkewX: function(t) {
    this._skewX = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getSkewY: function() {
    return this._skewY;
  },
  setSkewY: function(t) {
    this._skewY = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  setLocalZOrder: function(t) {
    this._localZOrder = t, this._parent && this._parent.reorderChild(this, t), cc.eventManager._setDirtyForNode(this);
  },
  _setLocalZOrder: function(t) {
    this._localZOrder = t;
  },
  getLocalZOrder: function() {
    return this._localZOrder;
  },
  getZOrder: function() {
    return cc.log(cc._LogInfos.Node_getZOrder), this.getLocalZOrder();
  },
  setZOrder: function(t) {
    cc.log(cc._LogInfos.Node_setZOrder), this.setLocalZOrder(t);
  },
  setGlobalZOrder: function(t) {
    this._globalZOrder !== t && (this._globalZOrder = t, cc.eventManager._setDirtyForNode(this));
  },
  getGlobalZOrder: function() {
    return this._globalZOrder;
  },
  getVertexZ: function() {
    return this._vertexZ;
  },
  setVertexZ: function(t) {
    this._customZ = (this || window)._vertexZ = t;
  },
  getRotation: function() {
    return this._rotationX !== (this || window)._rotationY && cc.log(cc._LogInfos.Node_getRotation), this._rotationX;
  },
  setRotation: function(t) {
    this._rotationX = (this || window)._rotationY = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getRotationX: function() {
    return this._rotationX;
  },
  setRotationX: function(t) {
    this._rotationX = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getRotationY: function() {
    return this._rotationY;
  },
  setRotationY: function(t) {
    this._rotationY = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getScale: function() {
    return this._scaleX !== (this || window)._scaleY && cc.log(cc._LogInfos.Node_getScale), this._scaleX;
  },
  setScale: function(t, e) {
    this._scaleX = t, this._scaleY = e || e === 0 ? e : t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getScaleX: function() {
    return this._scaleX;
  },
  setScaleX: function(t) {
    this._scaleX = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getScaleY: function() {
    return this._scaleY;
  },
  setScaleY: function(t) {
    this._scaleY = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  setPosition: function(t, e) {
    var n = (this || window)._position;
    if (e === void 0) {
      if (n.x === t.x && n.y === t.y)
        return;
      n.x = t.x, n.y = t.y;
    } else {
      if (n.x === t && n.y === e)
        return;
      n.x = t, n.y = e;
    }
    this._usingNormalizedPosition = !1, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  setNormalizedPosition: function(t, e) {
    var n = (this || window)._normalizedPosition;
    e === void 0 ? (n.x = t.x, n.y = t.y) : (n.x = t, n.y = e), this._normalizedPositionDirty = (this || window)._usingNormalizedPosition = !0, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getPosition: function() {
    return cc.p(this._position);
  },
  getNormalizedPosition: function() {
    return cc.p(this._normalizedPosition);
  },
  getPositionX: function() {
    return this._position.x;
  },
  setPositionX: function(t) {
    this._position.x = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getPositionY: function() {
    return this._position.y;
  },
  setPositionY: function(t) {
    this._position.y = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getChildrenCount: function() {
    return this._children.length;
  },
  getChildren: function() {
    return this._children;
  },
  isVisible: function() {
    return this._visible;
  },
  setVisible: function(t) {
    this._visible !== t && (this._visible = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), cc.renderer.childrenOrderDirty = !0);
  },
  getAnchorPoint: function() {
    return cc.p(this._anchorPoint);
  },
  setAnchorPoint: function(t, e) {
    var n = (this || window)._anchorPoint;
    if (e === void 0) {
      if (t.x === n.x && t.y === n.y)
        return;
      n.x = t.x, n.y = t.y;
    } else {
      if (t === n.x && e === n.y)
        return;
      n.x = t, n.y = e;
    }
    this._renderCmd._updateAnchorPointInPoint();
  },
  _getAnchorX: function() {
    return this._anchorPoint.x;
  },
  _setAnchorX: function(t) {
    this._anchorPoint.x !== t && (this._anchorPoint.x = t, this._renderCmd._updateAnchorPointInPoint());
  },
  _getAnchorY: function() {
    return this._anchorPoint.y;
  },
  _setAnchorY: function(t) {
    this._anchorPoint.y !== t && (this._anchorPoint.y = t, this._renderCmd._updateAnchorPointInPoint());
  },
  getAnchorPointInPoints: function() {
    return this._renderCmd.getAnchorPointInPoints();
  },
  _getWidth: function() {
    return this._contentSize.width;
  },
  _setWidth: function(t) {
    this._contentSize.width = t, this._renderCmd._updateAnchorPointInPoint();
  },
  _getHeight: function() {
    return this._contentSize.height;
  },
  _setHeight: function(t) {
    this._contentSize.height = t, this._renderCmd._updateAnchorPointInPoint();
  },
  getContentSize: function() {
    return cc.size(this._contentSize);
  },
  setContentSize: function(t, e) {
    var n = (this || window)._contentSize;
    if (e === void 0) {
      if (t.width === n.width && t.height === n.height)
        return;
      n.width = t.width, n.height = t.height;
    } else {
      if (t === n.width && e === n.height)
        return;
      n.width = t, n.height = e;
    }
    this._renderCmd._updateAnchorPointInPoint();
  },
  isRunning: function() {
    return this._running;
  },
  getParent: function() {
    return this._parent;
  },
  setParent: function(t) {
    this._parent = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  isIgnoreAnchorPointForPosition: function() {
    return this._ignoreAnchorPointForPosition;
  },
  ignoreAnchorPointForPosition: function(t) {
    t !== (this || window)._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty));
  },
  getTag: function() {
    return this.tag;
  },
  setTag: function(t) {
    this.tag = t;
  },
  setName: function(t) {
    this._name = t;
  },
  getName: function() {
    return this._name;
  },
  getUserData: function() {
    return this.userData;
  },
  setUserData: function(t) {
    this.userData = t;
  },
  getUserObject: function() {
    return this.userObject;
  },
  setUserObject: function(t) {
    this.userObject !== t && (this.userObject = t);
  },
  getOrderOfArrival: function() {
    return this.arrivalOrder;
  },
  setOrderOfArrival: function(t) {
    this.arrivalOrder = t;
  },
  getActionManager: function() {
    return this._actionManager || (this._actionManager = cc.director.getActionManager()), this._actionManager;
  },
  setActionManager: function(t) {
    this._actionManager !== t && (this.stopAllActions(), this._actionManager = t);
  },
  getScheduler: function() {
    return this._scheduler || (this._scheduler = cc.director.getScheduler()), this._scheduler;
  },
  setScheduler: function(t) {
    this._scheduler !== t && (this.unscheduleAllCallbacks(), this._scheduler = t);
  },
  boundingBox: function() {
    return cc.log(cc._LogInfos.Node_boundingBox), this.getBoundingBox();
  },
  getBoundingBox: function() {
    var t = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
    return cc._rectApplyAffineTransformIn(t, this.getNodeToParentTransform());
  },
  cleanup: function() {
    this.stopAllActions(), this.unscheduleAllCallbacks(), cc.eventManager.removeListeners(this), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.cleanup);
  },
  getChildByTag: function(t) {
    var e = (this || window)._children;
    if (e !== null)
      for (var n = 0; n < e.length; n++) {
        var r = e[n];
        if (r && r.tag === t)
          return r;
      }
    return null;
  },
  getChildByName: function(t) {
    if (!t)
      return cc.log("Invalid name"), null;
    for (var e = (this || window)._children, n = 0, r = e.length; n < r; n++)
      if (e[n]._name === t)
        return e[n];
    return null;
  },
  addChild: function(t, e, n) {
    e = e === void 0 ? t._localZOrder : e;
    var r, s = !1;
    cc.isUndefined(n) ? (n = void 0, r = t._name) : cc.isString(n) ? (r = n, n = void 0) : cc.isNumber(n) && (s = !0, r = ""), cc.assert(t, cc._LogInfos.Node_addChild_3), cc.assert(t._parent === null, "child already added. It can't be added again"), this._addChildHelper(t, e, n, r, s);
  },
  _addChildHelper: function(t, e, n, r, s) {
    this._children || (this._children = []), this._insertChild(t, e), s ? t.setTag(n) : t.setName(r), t.setParent(this), t.setOrderOfArrival(cc.s_globalOrderOfArrival++), this._running && (t.onEnter(), this._isTransitionFinished && t.onEnterTransitionDidFinish()), t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._cascadeColorEnabled && t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty), this._cascadeOpacityEnabled && t._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty);
  },
  removeFromParent: function(t) {
    this._parent && (t === void 0 && (t = !0), this._parent.removeChild(this, t));
  },
  removeFromParentAndCleanup: function(t) {
    cc.log(cc._LogInfos.Node_removeFromParentAndCleanup), this.removeFromParent(t);
  },
  removeChild: function(t, e) {
    this._children.length !== 0 && (e === void 0 && (e = !0), this._children.indexOf(t) > -1 && this._detachChild(t, e), cc.renderer.childrenOrderDirty = !0);
  },
  removeChildByTag: function(t, e) {
    t === cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
    var n = (this || window).getChildByTag(t);
    n ? this.removeChild(n, e) : cc.log(cc._LogInfos.Node_removeChildByTag_2, t);
  },
  removeAllChildrenWithCleanup: function(t) {
    this.removeAllChildren(t);
  },
  removeAllChildren: function(t) {
    var e = (this || window)._children;
    if (e !== null) {
      t === void 0 && (t = !0);
      for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r && (this._running && (r.onExitTransitionDidStart(), r.onExit()), t && r.cleanup(), r.parent = null, r._renderCmd.detachFromParent());
      }
      this._children.length = 0, cc.renderer.childrenOrderDirty = !0;
    }
  },
  _detachChild: function(t, e) {
    this._running && (t.onExitTransitionDidStart(), t.onExit()), e && t.cleanup(), t.parent = null, t._renderCmd.detachFromParent(), cc.arrayRemoveObject(this._children, t);
  },
  _insertChild: function(t, e) {
    cc.renderer.childrenOrderDirty = (this || window)._reorderChildDirty = !0, this._children.push(t), t._setLocalZOrder(e);
  },
  setNodeDirty: function() {
    this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  reorderChild: function(t, e) {
    cc.assert(t, cc._LogInfos.Node_reorderChild), cc.renderer.childrenOrderDirty = (this || window)._reorderChildDirty = !0, t.arrivalOrder = cc.s_globalOrderOfArrival, cc.s_globalOrderOfArrival++, t._setLocalZOrder(e), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.orderDirty);
  },
  sortAllChildren: function() {
    if (this._reorderChildDirty) {
      var t = (this || window)._children, e = t.length, n, r, s;
      for (n = 1; n < e; n++) {
        for (s = t[n], r = n - 1; r >= 0; ) {
          if (s._localZOrder < t[r]._localZOrder)
            t[r + 1] = t[r];
          else if (s._localZOrder === t[r]._localZOrder && s.arrivalOrder < t[r].arrivalOrder)
            t[r + 1] = t[r];
          else
            break;
          r--;
        }
        t[r + 1] = s;
      }
      this._reorderChildDirty = !1;
    }
  },
  draw: function(t) {
  },
  transformAncestors: function() {
    this._parent !== null && (this._parent.transformAncestors(), this._parent.transform());
  },
  onEnter: function() {
    this._isTransitionFinished = !1, this._running = !0, this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnter), this.resume();
  },
  onEnterTransitionDidFinish: function() {
    this._isTransitionFinished = !0, this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnterTransitionDidFinish);
  },
  onExitTransitionDidStart: function() {
    this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExitTransitionDidStart);
  },
  onExit: function() {
    this._running = !1, this.pause(), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExit), this.removeAllComponents();
  },
  runAction: function(t) {
    return cc.assert(t, cc._LogInfos.Node_runAction), this.actionManager.addAction(t, this, !this._running), t;
  },
  stopAllActions: function() {
    this.actionManager && this.actionManager.removeAllActionsFromTarget(this);
  },
  stopAction: function(t) {
    this.actionManager.removeAction(t);
  },
  stopActionByTag: function(t) {
    if (t === cc.ACTION_TAG_INVALID) {
      cc.log(cc._LogInfos.Node_stopActionByTag);
      return;
    }
    this.actionManager.removeActionByTag(t, this);
  },
  getActionByTag: function(t) {
    return t === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(t, this);
  },
  getNumberOfRunningActions: function() {
    return this.actionManager.numberOfRunningActionsInTarget(this);
  },
  scheduleUpdate: function() {
    this.scheduleUpdateWithPriority(0);
  },
  scheduleUpdateWithPriority: function(t) {
    this.scheduler.scheduleUpdate(this, t, !this._running);
  },
  unscheduleUpdate: function() {
    this.scheduler.unscheduleUpdate(this);
  },
  schedule: function(t, e, n, r, s) {
    var o = arguments.length;
    typeof t == "function" ? o === 1 ? (e = 0, n = cc.REPEAT_FOREVER, r = 0, s = (this || window).__instanceId) : o === 2 ? typeof e == "number" ? (n = cc.REPEAT_FOREVER, r = 0, s = (this || window).__instanceId) : (s = e, e = 0, n = cc.REPEAT_FOREVER, r = 0) : o === 3 ? (typeof n == "string" ? (s = n, n = cc.REPEAT_FOREVER) : s = (this || window).__instanceId, r = 0) : o === 4 && (s = (this || window).__instanceId) : o === 1 ? (e = 0, n = cc.REPEAT_FOREVER, r = 0) : o === 2 && (n = cc.REPEAT_FOREVER, r = 0), cc.assert(t, cc._LogInfos.Node_schedule), cc.assert(e >= 0, cc._LogInfos.Node_schedule_2), e = e || 0, n = n == null ? cc.REPEAT_FOREVER : n, r = r || 0, this.scheduler.schedule(t, this, e, n, r, !this._running, s);
  },
  scheduleOnce: function(t, e, n) {
    n === void 0 && (n = (this || window).__instanceId), this.schedule(t, 0, 0, e, n);
  },
  unschedule: function(t) {
    t && this.scheduler.unschedule(t, this);
  },
  unscheduleAllCallbacks: function() {
    this.scheduler.unscheduleAllForTarget(this);
  },
  resumeSchedulerAndActions: function() {
    cc.log(cc._LogInfos.Node_resumeSchedulerAndActions), this.resume();
  },
  resume: function() {
    this.scheduler.resumeTarget(this), this.actionManager && this.actionManager.resumeTarget(this), cc.eventManager.resumeTarget(this);
  },
  pauseSchedulerAndActions: function() {
    cc.log(cc._LogInfos.Node_pauseSchedulerAndActions), this.pause();
  },
  pause: function() {
    this.scheduler.pauseTarget(this), this.actionManager && this.actionManager.pauseTarget(this), cc.eventManager.pauseTarget(this);
  },
  setAdditionalTransform: function(t) {
    if (t === void 0)
      return this._additionalTransformDirty = !1;
    this._additionalTransform = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._additionalTransformDirty = !0;
  },
  getParentToNodeTransform: function() {
    return this._renderCmd.getParentToNodeTransform();
  },
  parentToNodeTransform: function() {
    return this.getParentToNodeTransform();
  },
  getNodeToWorldTransform: function() {
    for (var t = (this || window).getNodeToParentTransform(), e = (this || window)._parent; e !== null; e = e.parent)
      t = cc.affineTransformConcat(t, e.getNodeToParentTransform());
    return t;
  },
  nodeToWorldTransform: function() {
    return this.getNodeToWorldTransform();
  },
  getWorldToNodeTransform: function() {
    return cc.affineTransformInvert(this.getNodeToWorldTransform());
  },
  worldToNodeTransform: function() {
    return this.getWorldToNodeTransform();
  },
  convertToNodeSpace: function(t) {
    return cc.pointApplyAffineTransform(t, this.getWorldToNodeTransform());
  },
  convertToWorldSpace: function(t) {
    return t = t || cc.p(0, 0), cc.pointApplyAffineTransform(t, this.getNodeToWorldTransform());
  },
  convertToNodeSpaceAR: function(t) {
    return cc.pSub(this.convertToNodeSpace(t), this._renderCmd.getAnchorPointInPoints());
  },
  convertToWorldSpaceAR: function(t) {
    t = t || cc.p(0, 0);
    var e = cc.pAdd(t, this._renderCmd.getAnchorPointInPoints());
    return this.convertToWorldSpace(e);
  },
  _convertToWindowSpace: function(t) {
    var e = (this || window).convertToWorldSpace(t);
    return cc.director.convertToUI(e);
  },
  convertTouchToNodeSpace: function(t) {
    var e = t.getLocation();
    return this.convertToNodeSpace(e);
  },
  convertTouchToNodeSpaceAR: function(t) {
    var e = cc.director.convertToGL(t.getLocation());
    return this.convertToNodeSpaceAR(e);
  },
  update: function(t) {
    this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(t);
  },
  updateTransform: function() {
    this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.updateTransform);
  },
  retain: function() {
  },
  release: function() {
  },
  getComponent: function(t) {
    return this._componentContainer ? this._componentContainer.getComponent(t) : null;
  },
  addComponent: function(t) {
    this._componentContainer && this._componentContainer.add(t);
  },
  removeComponent: function(t) {
    return this._componentContainer ? this._componentContainer.remove(t) : !1;
  },
  removeAllComponents: function() {
    this._componentContainer && this._componentContainer.removeAll();
  },
  grid: null,
  visit: function(t) {
    this._renderCmd.visit(t);
  },
  transform: function(t, e) {
    this._renderCmd.transform(t, e);
  },
  nodeToParentTransform: function() {
    return this.getNodeToParentTransform();
  },
  getNodeToParentTransform: function(t) {
    var e = (this || window)._renderCmd.getNodeToParentTransform();
    if (t) {
      for (var n = { a: e.a, b: e.b, c: e.c, d: e.d, tx: e.tx, ty: e.ty }, r = (this || window)._parent; r != null && r != t; r = r.getParent())
        cc.affineTransformConcatIn(n, r.getNodeToParentTransform());
      return n;
    } else
      return e;
  },
  getNodeToParentAffineTransform: function(t) {
    return this.getNodeToParentTransform(t);
  },
  getCamera: function() {
    return null;
  },
  getGrid: function() {
    return this.grid;
  },
  setGrid: function(t) {
    this.grid = t;
  },
  getShaderProgram: function() {
    return this._renderCmd.getShaderProgram();
  },
  setShaderProgram: function(t) {
    this._renderCmd.setShaderProgram(t);
  },
  getGLServerState: function() {
    return 0;
  },
  setGLServerState: function(t) {
  },
  getBoundingBoxToWorld: function() {
    var t = cc.rect(0, 0, this._contentSize.width, this._contentSize.height), e = (this || window).getNodeToWorldTransform();
    if (t = cc.rectApplyAffineTransform(t, e), !this._children)
      return t;
    for (var n = (this || window)._children, r = 0; r < n.length; r++) {
      var s = n[r];
      if (s && s._visible) {
        var o = s._getBoundingBoxToCurrentNode(e);
        o && (t = cc.rectUnion(t, o));
      }
    }
    return t;
  },
  _getBoundingBoxToCurrentNode: function(t) {
    var e = cc.rect(0, 0, this._contentSize.width, this._contentSize.height), n = t === void 0 ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), t);
    if (e = cc.rectApplyAffineTransform(e, n), !this._children)
      return e;
    for (var r = (this || window)._children, s = 0; s < r.length; s++) {
      var o = r[s];
      if (o && o._visible) {
        var a = o._getBoundingBoxToCurrentNode(n);
        a && (e = cc.rectUnion(e, a));
      }
    }
    return e;
  },
  getOpacity: function() {
    return this._realOpacity;
  },
  getDisplayedOpacity: function() {
    return this._renderCmd.getDisplayedOpacity();
  },
  setOpacity: function(t) {
    this._realOpacity = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty);
  },
  updateDisplayedOpacity: function(t) {
    this._renderCmd._updateDisplayOpacity(t);
  },
  isCascadeOpacityEnabled: function() {
    return this._cascadeOpacityEnabled;
  },
  setCascadeOpacityEnabled: function(t) {
    this._cascadeOpacityEnabled !== t && (this._cascadeOpacityEnabled = t, this._renderCmd.setCascadeOpacityEnabledDirty());
  },
  getColor: function() {
    var t = (this || window)._realColor;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  getDisplayedColor: function() {
    return this._renderCmd.getDisplayedColor();
  },
  setColor: function(t) {
    var e = (this || window)._realColor;
    e.r = t.r, e.g = t.g, e.b = t.b, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
  },
  updateDisplayedColor: function(t) {
    this._renderCmd._updateDisplayColor(t);
  },
  isCascadeColorEnabled: function() {
    return this._cascadeColorEnabled;
  },
  setCascadeColorEnabled: function(t) {
    this._cascadeColorEnabled !== t && (this._cascadeColorEnabled = t, this._renderCmd.setCascadeColorEnabledDirty());
  },
  setOpacityModifyRGB: function(t) {
  },
  isOpacityModifyRGB: function() {
    return !1;
  },
  _initRendererCmd: function() {
    this._renderCmd = cc.renderer.getRenderCmd(this);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Node.CanvasRenderCmd(this) : new cc.Node.WebGLRenderCmd(this);
  },
  enumerateChildren: function(t, e) {
    cc.assert(t && t.length != 0, "Invalid name"), cc.assert(e != null, "Invalid callback function");
    var n = t.length, r = 0, s = n, o = !1;
    n > 2 && t[0] === "/" && t[1] === "/" && (o = !0, r = 2, s -= 2);
    var a = !1;
    n > 3 && t[n - 3] === "/" && t[n - 2] === "." && t[n - 1] === "." && (a = !0, s -= 3);
    var c = t.substr(r, s);
    a && (c = "[[:alnum:]]+/" + c), o ? this.doEnumerateRecursive(this, c, e) : this.doEnumerate(c, e);
  },
  doEnumerateRecursive: function(t, e, n) {
    if (!t.doEnumerate(e, n))
      for (var r, s = t.getChildren(), o = s.length, a = 0; a < o && (r = s[a], !this.doEnumerateRecursive(r, e, n)); a++)
        ;
  },
  doEnumerate: function(t, e) {
    var n = t.indexOf("/"), r = t, s = !1;
    n !== -1 && (r = t.substr(0, n), s = !0);
    for (var o = !1, a, c = (this || window)._children, l = c.length, h = 0; h < l; h++)
      if (a = c[h], a._name.indexOf(r) !== -1) {
        if (s) {
          if (o = a.doEnumerate(t, e), o)
            break;
        } else if (e(a)) {
          o = !0;
          break;
        }
      }
    return o;
  }
});
cc.Node.create = function() {
  return new cc.Node();
};
cc.Node._stateCallbackType = { onEnter: 1, onExit: 2, cleanup: 3, onEnterTransitionDidFinish: 4, updateTransform: 5, onExitTransitionDidStart: 6, sortAllChildren: 7 };
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.CustomRenderCmd = function(t, e) {
  this._needDraw = !0, this._target = t, this._callback = e, this.rendering = function(n, r, s) {
    this._callback && this._callback.call(this._target, n, r, s);
  }, this.needDraw = function() {
    return this._needDraw;
  };
};
cc.Node._dirtyFlags = {
  transformDirty: 1,
  visibleDirty: 2,
  colorDirty: 4,
  opacityDirty: 8,
  cacheDirty: 16,
  orderDirty: 32,
  textDirty: 64,
  gradientDirty: 128,
  textureDirty: 256,
  contentDirty: 512,
  COUNT: 10,
  all: 1024 - 1
};
cc.Node.RenderCmd = function(t) {
  this._dirtyFlag = 1, this._savedDirtyFlag = !0, this._node = t, this._needDraw = !1, this._anchorPointInPoints = new cc.Point(0, 0), this._transform = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, this._worldTransform = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, this._inverse = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, this._displayedOpacity = 255, this._displayedColor = cc.color(255, 255, 255, 255), this._cascadeColorEnabledDirty = !1, this._cascadeOpacityEnabledDirty = !1, this._curLevel = -1;
};
cc.Node.RenderCmd.prototype = {
  constructor: cc.Node.RenderCmd,
  needDraw: function() {
    return this._needDraw;
  },
  getAnchorPointInPoints: function() {
    return cc.p(this._anchorPointInPoints);
  },
  getDisplayedColor: function() {
    var t = (this || window)._displayedColor;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  getDisplayedOpacity: function() {
    return this._displayedOpacity;
  },
  setCascadeColorEnabledDirty: function() {
    this._cascadeColorEnabledDirty = !0, this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
  },
  setCascadeOpacityEnabledDirty: function() {
    this._cascadeOpacityEnabledDirty = !0, this.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty);
  },
  getParentToNodeTransform: function() {
    return this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform())), this._inverse;
  },
  detachFromParent: function() {
  },
  _updateAnchorPointInPoint: function() {
    var t = (this || window)._anchorPointInPoints, e = (this || window)._node._contentSize, n = (this || window)._node._anchorPoint;
    t.x = e.width * n.x, t.y = e.height * n.y, this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  setDirtyFlag: function(t) {
    this._dirtyFlag === 0 && t !== 0 && cc.renderer.pushDirtyNode(this), this._dirtyFlag |= t;
  },
  getParentRenderCmd: function() {
    return this._node && this._node._parent && this._node._parent._renderCmd ? this._node._parent._renderCmd : null;
  },
  transform: function(t, e) {
    var n = (this || window)._node, r = t ? t._worldTransform : null, s = (this || window)._transform, o = (this || window)._worldTransform;
    if (n._usingNormalizedPosition && n._parent) {
      var a = n._parent._contentSize;
      n._position.x = n._normalizedPosition.x * a.width, n._position.y = n._normalizedPosition.y * a.height, n._normalizedPositionDirty = !1;
    }
    var c = n._rotationX || n._rotationY, l = n._skewX || n._skewY, h = n._scaleX, u = n._scaleY, _ = (this || window)._anchorPointInPoints.x, d = (this || window)._anchorPointInPoints.y, f = 1, C = 0, m = 0, g = 1;
    if (c || l) {
      if (s.tx = n._position.x, s.ty = n._position.y, c) {
        var y = n._rotationX * 0.017453292519943295;
        if (m = Math.sin(y), g = Math.cos(y), n._rotationY === n._rotationX)
          f = g, C = -m;
        else {
          var A = n._rotationY * 0.017453292519943295;
          f = Math.cos(A), C = -Math.sin(A);
        }
      }
      if (s.a = f *= h, s.b = C *= h, s.c = m *= u, s.d = g *= u, l) {
        var D = Math.tan(n._skewX * Math.PI / 180), N = Math.tan(n._skewY * Math.PI / 180);
        D === 1 / 0 && (D = 99999999), N === 1 / 0 && (N = 99999999), s.a = f + m * N, s.b = C + g * N, s.c = m + f * D, s.d = g + C * D;
      }
      (_ || d) && (s.tx -= s.a * _ + s.c * d, s.ty -= s.b * _ + s.d * d, n._ignoreAnchorPointForPosition && (s.tx += _, s.ty += d)), r ? (o.a = s.a * r.a + s.b * r.c, o.b = s.a * r.b + s.b * r.d, o.c = s.c * r.a + s.d * r.c, o.d = s.c * r.b + s.d * r.d, o.tx = r.a * s.tx + r.c * s.ty + r.tx, o.ty = r.d * s.ty + r.ty + r.b * s.tx) : (o.a = s.a, o.b = s.b, o.c = s.c, o.d = s.d, o.tx = s.tx, o.ty = s.ty);
    } else
      s.a = h, s.b = 0, s.c = 0, s.d = u, s.tx = n._position.x, s.ty = n._position.y, (_ || d) && (s.tx -= s.a * _, s.ty -= s.d * d, n._ignoreAnchorPointForPosition && (s.tx += _, s.ty += d)), r ? (o.a = s.a * r.a + s.b * r.c, o.b = s.a * r.b + s.b * r.d, o.c = s.c * r.a + s.d * r.c, o.d = s.c * r.b + s.d * r.d, o.tx = s.tx * r.a + s.ty * r.c + r.tx, o.ty = s.tx * r.b + s.ty * r.d + r.ty) : (o.a = s.a, o.b = s.b, o.c = s.c, o.d = s.d, o.tx = s.tx, o.ty = s.ty);
    if (n._additionalTransformDirty && (this._transform = cc.affineTransformConcat(s, n._additionalTransform)), this._updateCurrentRegions && this._updateCurrentRegions(), this._notifyRegionStatus && this._notifyRegionStatus(cc.Node.CanvasRenderCmd.RegionStatus.DirtyDouble), e) {
      var z = (this || window)._node._children;
      if (!z || z.length === 0)
        return;
      var M, Z;
      for (M = 0, Z = z.length; M < Z; M++)
        z[M]._renderCmd.transform(this, e);
    }
    this._cacheDirty = !0;
  },
  getNodeToParentTransform: function() {
    return this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && this.transform(), this._transform;
  },
  visit: function(t) {
    var e = (this || window)._node, n = cc.renderer;
    e._visible && (t = t || this.getParentRenderCmd(), t && (this._curLevel = t._curLevel + 1), isNaN(e._customZ) && (e._vertexZ = n.assignedZ, n.assignedZ += n.assignedZStep), this._syncStatus(t), this.visitChildren());
  },
  _updateDisplayColor: function(t) {
    var e = (this || window)._node, n = (this || window)._displayedColor, r = e._realColor, s, o, a, c;
    if (this._notifyRegionStatus && this._notifyRegionStatus(cc.Node.CanvasRenderCmd.RegionStatus.Dirty), this._cascadeColorEnabledDirty && !e._cascadeColorEnabled) {
      n.r = r.r, n.g = r.g, n.b = r.b;
      var l = new cc.Color(255, 255, 255, 255);
      for (a = e._children, s = 0, o = a.length; s < o; s++)
        c = a[s], c && c._renderCmd && c._renderCmd._updateDisplayColor(l);
      this._cascadeColorEnabledDirty = !1;
    } else {
      if (t === void 0) {
        var h = e._parent;
        h && h._cascadeColorEnabled ? t = h.getDisplayedColor() : t = cc.color.WHITE;
      }
      if (n.r = 0 | r.r * t.r / 255, n.g = 0 | r.g * t.g / 255, n.b = 0 | r.b * t.b / 255, e._cascadeColorEnabled)
        for (a = e._children, s = 0, o = a.length; s < o; s++)
          c = a[s], c && c._renderCmd && (c._renderCmd._updateDisplayColor(n), c._renderCmd._updateColor());
    }
    this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.colorDirty ^ this._dirtyFlag;
  },
  _updateDisplayOpacity: function(t) {
    var e = (this || window)._node, n, r, s, o;
    if (this._notifyRegionStatus && this._notifyRegionStatus(cc.Node.CanvasRenderCmd.RegionStatus.Dirty), this._cascadeOpacityEnabledDirty && !e._cascadeOpacityEnabled) {
      for (this._displayedOpacity = e._realOpacity, s = e._children, n = 0, r = s.length; n < r; n++)
        o = s[n], o && o._renderCmd && o._renderCmd._updateDisplayOpacity(255);
      this._cascadeOpacityEnabledDirty = !1;
    } else {
      if (t === void 0) {
        var a = e._parent;
        t = 255, a && a._cascadeOpacityEnabled && (t = a.getDisplayedOpacity());
      }
      if (this._displayedOpacity = e._realOpacity * t / 255, e._cascadeOpacityEnabled)
        for (s = e._children, n = 0, r = s.length; n < r; n++)
          o = s[n], o && o._renderCmd && (o._renderCmd._updateDisplayOpacity(this._displayedOpacity), o._renderCmd._updateColor());
    }
    this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.opacityDirty ^ this._dirtyFlag;
  },
  _syncDisplayColor: function(t) {
    var e = (this || window)._node, n = (this || window)._displayedColor, r = e._realColor;
    if (t === void 0) {
      var s = e._parent;
      s && s._cascadeColorEnabled ? t = s.getDisplayedColor() : t = cc.color.WHITE;
    }
    n.r = 0 | r.r * t.r / 255, n.g = 0 | r.g * t.g / 255, n.b = 0 | r.b * t.b / 255;
  },
  _syncDisplayOpacity: function(t) {
    var e = (this || window)._node;
    if (t === void 0) {
      var n = e._parent;
      t = 255, n && n._cascadeOpacityEnabled && (t = n.getDisplayedOpacity());
    }
    this._displayedOpacity = e._realOpacity * t / 255;
  },
  _updateColor: function() {
  },
  updateStatus: function() {
    var t = cc.Node._dirtyFlags, e = (this || window)._dirtyFlag, n = e & t.colorDirty, r = e & t.opacityDirty;
    this._savedDirtyFlag = (this || window)._savedDirtyFlag || e, n && this._updateDisplayColor(), r && this._updateDisplayOpacity(), (n || r) && this._updateColor(), e & t.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag = (this || window)._dirtyFlag & t.transformDirty ^ this._dirtyFlag), e & t.orderDirty && (this._dirtyFlag = (this || window)._dirtyFlag & t.orderDirty ^ this._dirtyFlag);
  },
  _syncStatus: function(t) {
    var e = cc.Node._dirtyFlags, n = (this || window)._dirtyFlag, r = null;
    t ? (r = t._node, this._savedDirtyFlag = (this || window)._savedDirtyFlag || t._savedDirtyFlag || n) : this._savedDirtyFlag = (this || window)._savedDirtyFlag || n, r && r._cascadeColorEnabled && t._dirtyFlag & e.colorDirty && (n |= e.colorDirty), r && r._cascadeOpacityEnabled && t._dirtyFlag & e.opacityDirty && (n |= e.opacityDirty), t && t._dirtyFlag & e.transformDirty && (n |= e.transformDirty);
    var s = n & e.colorDirty, o = n & e.opacityDirty;
    this._dirtyFlag = n, s && this._syncDisplayColor(), o && this._syncDisplayOpacity(), (s || o) && this._updateColor(), n & e.transformDirty && this.transform(t), n & e.orderDirty && (this._dirtyFlag = (this || window)._dirtyFlag & e.orderDirty ^ this._dirtyFlag);
  },
  visitChildren: function() {
    var t = cc.renderer, e = (this || window)._node, n, r = e._children, s, o = r.length;
    if (o > 0) {
      for (e.sortAllChildren(), n = 0; n < o && (s = r[n], s._localZOrder < 0); n++)
        s._renderCmd.visit(this);
      for (t.pushRenderCommand(this); n < o; n++)
        r[n]._renderCmd.visit(this);
    } else
      t.pushRenderCommand(this);
    this._dirtyFlag = 0;
  }
};
cc.Node.RenderCmd.prototype.originVisit = cc.Node.RenderCmd.prototype.visit;
cc.Node.RenderCmd.prototype.originTransform = cc.Node.RenderCmd.prototype.transform;
(function() {
  cc.Node.CanvasRenderCmd = function(n) {
    cc.Node.RenderCmd.call(this, n), this._cachedParent = null, this._cacheDirty = !1, this._currentRegion = new cc.Region(), this._oldRegion = new cc.Region(), this._regionFlag = 0, this._canUseDirtyRegion = !1;
  }, cc.Node.CanvasRenderCmd.RegionStatus = {
    NotDirty: 0,
    Dirty: 1,
    DirtyDouble: 2
  };
  var t = cc.Node.CanvasRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
  t.constructor = cc.Node.CanvasRenderCmd, t._notifyRegionStatus = function(n) {
    this._needDraw && this._regionFlag < n && (this._regionFlag = n);
  };
  var e = new cc.Rect();
  t.getLocalBB = function() {
    var n = (this || window)._node;
    return e.x = e.y = 0, e.width = n._contentSize.width, e.height = n._contentSize.height, e;
  }, t._updateCurrentRegions = function() {
    var n = (this || window)._currentRegion;
    this._currentRegion = (this || window)._oldRegion, this._oldRegion = n, cc.Node.CanvasRenderCmd.RegionStatus.DirtyDouble === (this || window)._regionFlag && !this._currentRegion.isEmpty() && this._oldRegion.union(this._currentRegion), this._currentRegion.updateRegion(this.getLocalBB(), this._worldTransform);
  }, t.setDirtyFlag = function(n, r) {
    cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, n, r), this._setCacheDirty(r), this._cachedParent && this._cachedParent.setDirtyFlag(n, !0);
  }, t._setCacheDirty = function() {
    if (this._cacheDirty === !1) {
      this._cacheDirty = !0;
      var n = (this || window)._cachedParent;
      n && n !== (this || window) && n._setNodeDirtyForCache && n._setNodeDirtyForCache();
    }
  }, t._setCachedParent = function(n) {
    if (this._cachedParent !== n) {
      this._cachedParent = n;
      for (var r = (this || window)._node._children, s = 0, o = r.length; s < o; s++)
        r[s]._renderCmd._setCachedParent(n);
    }
  }, t.detachFromParent = function() {
    this._cachedParent = null;
    for (var n = (this || window)._node._children, r, s = 0, o = n.length; s < o; s++)
      r = n[s], r && r._renderCmd && r._renderCmd.detachFromParent();
  }, t.setShaderProgram = function(n) {
  }, t.getShaderProgram = function() {
    return null;
  }, cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(n) {
    return n ? n.src === cc.SRC_ALPHA && n.dst === cc.ONE || n.src === cc.ONE && n.dst === cc.ONE ? "lighter" : n.src === cc.ZERO && n.dst === cc.SRC_ALPHA ? "destination-in" : n.src === cc.ZERO && n.dst === cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over";
  };
})();
cc._tmp.PrototypeTexture2D = function() {
  var t = cc.Texture2D;
  t.PVRImagesHavePremultipliedAlpha = function(s) {
    cc.PVRHaveAlphaPremultiplied_ = s;
  }, t.PIXEL_FORMAT_RGBA8888 = 2, t.PIXEL_FORMAT_RGB888 = 3, t.PIXEL_FORMAT_RGB565 = 4, t.PIXEL_FORMAT_A8 = 5, t.PIXEL_FORMAT_I8 = 6, t.PIXEL_FORMAT_AI88 = 7, t.PIXEL_FORMAT_RGBA4444 = 8, t.PIXEL_FORMAT_RGB5A1 = 7, t.PIXEL_FORMAT_PVRTC4 = 9, t.PIXEL_FORMAT_PVRTC2 = 10, t.PIXEL_FORMAT_DEFAULT = t.PIXEL_FORMAT_RGBA8888, t.defaultPixelFormat = t.PIXEL_FORMAT_DEFAULT;
  var e = cc.Texture2D._M = {};
  e[t.PIXEL_FORMAT_RGBA8888] = "RGBA8888", e[t.PIXEL_FORMAT_RGB888] = "RGB888", e[t.PIXEL_FORMAT_RGB565] = "RGB565", e[t.PIXEL_FORMAT_A8] = "A8", e[t.PIXEL_FORMAT_I8] = "I8", e[t.PIXEL_FORMAT_AI88] = "AI88", e[t.PIXEL_FORMAT_RGBA4444] = "RGBA4444", e[t.PIXEL_FORMAT_RGB5A1] = "RGB5A1", e[t.PIXEL_FORMAT_PVRTC4] = "PVRTC4", e[t.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
  var n = cc.Texture2D._B = {};
  n[t.PIXEL_FORMAT_RGBA8888] = 32, n[t.PIXEL_FORMAT_RGB888] = 24, n[t.PIXEL_FORMAT_RGB565] = 16, n[t.PIXEL_FORMAT_A8] = 8, n[t.PIXEL_FORMAT_I8] = 8, n[t.PIXEL_FORMAT_AI88] = 16, n[t.PIXEL_FORMAT_RGBA4444] = 16, n[t.PIXEL_FORMAT_RGB5A1] = 16, n[t.PIXEL_FORMAT_PVRTC4] = 4, n[t.PIXEL_FORMAT_PVRTC2] = 3;
  var r = cc.Texture2D.prototype;
  r.name, cc.defineGetterSetter(r, "name", r.getName), r.pixelFormat, cc.defineGetterSetter(r, "pixelFormat", r.getPixelFormat), r.pixelsWidth, cc.defineGetterSetter(r, "pixelsWidth", r.getPixelsWide), r.pixelsHeight, cc.defineGetterSetter(r, "pixelsHeight", r.getPixelsHigh), r.width, cc.defineGetterSetter(r, "width", r._getWidth), r.height, cc.defineGetterSetter(r, "height", r._getHeight);
};
cc._tmp.PrototypeTextureAtlas = function() {
  var t = cc.TextureAtlas.prototype;
  t.totalQuads, cc.defineGetterSetter(t, "totalQuads", t.getTotalQuads), t.capacity, cc.defineGetterSetter(t, "capacity", t.getCapacity), t.quads, cc.defineGetterSetter(t, "quads", t.getQuads, t.setQuads);
};
cc._tmp.WebGLTexture2D = function() {
  cc.Texture2D = cc.Class.extend({
    _pVRHaveAlphaPremultiplied: !0,
    _pixelFormat: null,
    _pixelsWide: 0,
    _pixelsHigh: 0,
    _name: "",
    _contentSize: null,
    maxS: 0,
    maxT: 0,
    _hasPremultipliedAlpha: !1,
    _hasMipmaps: !1,
    shaderProgram: null,
    _textureLoaded: !1,
    _htmlElementObj: null,
    _webTextureObj: null,
    url: null,
    ctor: function() {
      this._contentSize = cc.size(0, 0), this._pixelFormat = cc.Texture2D.defaultPixelFormat;
    },
    releaseTexture: function() {
      this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj), cc.loader.release(this.url);
    },
    getPixelFormat: function() {
      return this._pixelFormat;
    },
    getPixelsWide: function() {
      return this._pixelsWide;
    },
    getPixelsHigh: function() {
      return this._pixelsHigh;
    },
    getName: function() {
      return this._webTextureObj;
    },
    getContentSize: function() {
      return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor());
    },
    _getWidth: function() {
      return this._contentSize.width / cc.contentScaleFactor();
    },
    _getHeight: function() {
      return this._contentSize.height / cc.contentScaleFactor();
    },
    getContentSizeInPixels: function() {
      return this._contentSize;
    },
    getMaxS: function() {
      return this.maxS;
    },
    setMaxS: function(t) {
      this.maxS = t;
    },
    getMaxT: function() {
      return this.maxT;
    },
    setMaxT: function(t) {
      this.maxT = t;
    },
    getShaderProgram: function() {
      return this.shaderProgram;
    },
    setShaderProgram: function(t) {
      this.shaderProgram = t;
    },
    hasPremultipliedAlpha: function() {
      return this._hasPremultipliedAlpha;
    },
    hasMipmaps: function() {
      return this._hasMipmaps;
    },
    description: function() {
      var t = (this || window);
      return "<cc.Texture2D | Name = " + t._name + " | Dimensions = " + t._pixelsWide + " x " + t._pixelsHigh + " | Coordinates = (" + t.maxS + ", " + t.maxT + ")>";
    },
    releaseData: function(t) {
    },
    keepData: function(t, e) {
      return t;
    },
    initWithData: function(t, e, n, r, s) {
      var o = (this || window), a = cc.Texture2D, c = cc._renderContext, l = c.RGBA, h = c.UNSIGNED_BYTE, u = cc.Texture2D._B[e], _ = n * u / 8;
      switch (_ % 8 === 0 ? c.pixelStorei(c.UNPACK_ALIGNMENT, 8) : _ % 4 === 0 ? c.pixelStorei(c.UNPACK_ALIGNMENT, 4) : _ % 2 === 0 ? c.pixelStorei(c.UNPACK_ALIGNMENT, 2) : c.pixelStorei(c.UNPACK_ALIGNMENT, 1), o._webTextureObj = c.createTexture(), cc.glBindTexture2D(o), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), e) {
        case a.PIXEL_FORMAT_RGBA8888:
          l = c.RGBA;
          break;
        case a.PIXEL_FORMAT_RGB888:
          l = c.RGB;
          break;
        case a.PIXEL_FORMAT_RGBA4444:
          h = c.UNSIGNED_SHORT_4_4_4_4;
          break;
        case a.PIXEL_FORMAT_RGB5A1:
          h = c.UNSIGNED_SHORT_5_5_5_1;
          break;
        case a.PIXEL_FORMAT_RGB565:
          h = c.UNSIGNED_SHORT_5_6_5;
          break;
        case a.PIXEL_FORMAT_AI88:
          l = c.LUMINANCE_ALPHA;
          break;
        case a.PIXEL_FORMAT_A8:
          l = c.ALPHA;
          break;
        case a.PIXEL_FORMAT_I8:
          l = c.LUMINANCE;
          break;
        default:
          cc.assert(0, cc._LogInfos.Texture2D_initWithData);
      }
      return c.texImage2D(c.TEXTURE_2D, 0, l, n, r, 0, l, h, t), o._contentSize.width = s.width, o._contentSize.height = s.height, o._pixelsWide = n, o._pixelsHigh = r, o._pixelFormat = e, o.maxS = s.width / n, o.maxT = s.height / r, o._hasPremultipliedAlpha = !1, o._hasMipmaps = !1, o.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), o._textureLoaded = !0, !0;
    },
    drawAtPoint: function(t) {
      var e = (this || window), n = [
        0,
        e.maxT,
        e.maxS,
        e.maxT,
        0,
        0,
        e.maxS,
        0
      ], r = cc._renderContext, s = e._pixelsWide * e.maxS, o = e._pixelsHigh * e.maxT, a = [
        t.x,
        t.y,
        0,
        s + t.x,
        t.y,
        0,
        t.x,
        o + t.y,
        0,
        s + t.x,
        o + t.y,
        0
      ];
      e._shaderProgram.use(), e._shaderProgram.setUniformsForBuiltins(), cc.glBindTexture2D(e), r.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), r.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), r.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, r.FLOAT, !1, 0, a), r.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, r.FLOAT, !1, 0, n), r.drawArrays(r.TRIANGLE_STRIP, 0, 4);
    },
    drawInRect: function(t) {
      var e = (this || window), n = [
        0,
        e.maxT,
        e.maxS,
        e.maxT,
        0,
        0,
        e.maxS,
        0
      ], r = [
        t.x,
        t.y,
        t.x + t.width,
        t.y,
        t.x,
        t.y + t.height,
        t.x + t.width,
        t.y + t.height
      ];
      e._shaderProgram.use(), e._shaderProgram.setUniformsForBuiltins(), cc.glBindTexture2D(e);
      var s = cc._renderContext;
      s.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), s.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), s.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, s.FLOAT, !1, 0, r), s.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, s.FLOAT, !1, 0, n), s.drawArrays(s.TRIANGLE_STRIP, 0, 4);
    },
    initWithImage: function(t) {
      if (t == null)
        return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
      var e = t.getWidth(), n = t.getHeight(), r = cc.configuration.getMaxTextureSize();
      return e > r || n > r ? (cc.log(cc._LogInfos.Texture2D_initWithImage_2, e, n, r, r), !1) : (this._textureLoaded = !0, this._initPremultipliedATextureWithImage(t, e, n));
    },
    initWithElement: function(t) {
      t && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = t, this._textureLoaded = !0, this._hasPremultipliedAlpha = !0);
    },
    getHtmlElementObj: function() {
      return this._htmlElementObj;
    },
    isLoaded: function() {
      return this._textureLoaded;
    },
    handleLoadedTexture: function(t) {
      var e = (this || window);
      if (t = t !== void 0 ? t : e._hasPremultipliedAlpha, !!cc.game._rendererInitialized) {
        if (!e._htmlElementObj) {
          var n = cc.loader.getRes(e.url);
          if (!n)
            return;
          e.initWithElement(n);
        }
        if (!(!e._htmlElementObj.width || !e._htmlElementObj.height)) {
          var r = cc._renderContext;
          cc.glBindTexture2D(e), r.pixelStorei(r.UNPACK_ALIGNMENT, 4), t && r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1), r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, e._htmlElementObj), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), e.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), t && r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
          var s = e._htmlElementObj.width, o = e._htmlElementObj.height;
          e._pixelsWide = e._contentSize.width = s, e._pixelsHigh = e._contentSize.height = o, e._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, e.maxS = 1, e.maxT = 1, e._hasPremultipliedAlpha = t, e._hasMipmaps = !1, e.dispatchEvent("load");
        }
      }
    },
    initWithString: function(t, e, n, r, s, o) {
      return cc.log(cc._LogInfos.Texture2D_initWithString), null;
    },
    initWithETCFile: function(t) {
      return cc.log(cc._LogInfos.Texture2D_initWithETCFile_2), !1;
    },
    initWithPVRFile: function(t) {
      return cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2), !1;
    },
    initWithPVRTCData: function(t, e, n, r, s, o) {
      return cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2), !1;
    },
    setTexParameters: function(t, e, n, r) {
      var s = (this || window), o = cc._renderContext;
      e !== void 0 && (t = { minFilter: t, magFilter: e, wrapS: n, wrapT: r }), cc.assert(
        s._pixelsWide === cc.NextPOT(s._pixelsWide) && s._pixelsHigh === cc.NextPOT(s._pixelsHigh) || t.wrapS === o.CLAMP_TO_EDGE && t.wrapT === o.CLAMP_TO_EDGE,
        "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures"
      ), cc.glBindTexture2D(s), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, t.minFilter), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, t.magFilter), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, t.wrapS), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, t.wrapT);
    },
    setAntiAliasTexParameters: function() {
      var t = cc._renderContext;
      cc.glBindTexture2D(this), this._hasMipmaps ? t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR_MIPMAP_NEAREST) : t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR);
    },
    setAliasTexParameters: function() {
      var t = cc._renderContext;
      cc.glBindTexture2D(this), this._hasMipmaps ? t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST_MIPMAP_NEAREST) : t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);
    },
    generateMipmap: function() {
      var t = (this || window);
      cc.assert(t._pixelsWide === cc.NextPOT(t._pixelsWide) && t._pixelsHigh === cc.NextPOT(t._pixelsHigh), "Mimpap texture only works in POT textures"), cc.glBindTexture2D(t), cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D), t._hasMipmaps = !0;
    },
    stringForFormat: function() {
      return cc.Texture2D._M[this._pixelFormat];
    },
    bitsPerPixelForFormat: function(t) {
      t = t || this._pixelFormat;
      var e = cc.Texture2D._B[t];
      return e != null ? e : (cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, t), -1);
    },
    _initPremultipliedATextureWithImage: function(t, e, n) {
      var r = cc.Texture2D, s = t.getData(), o = null, a = null, c = t.hasAlpha(), l = cc.size(t.getWidth(), t.getHeight()), h = r.defaultPixelFormat, u = t.getBitsPerComponent(), _;
      c || (u >= 8 ? h = r.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), h = r.PIXEL_FORMAT_RGB565));
      var d = e * n;
      if (h === r.PIXEL_FORMAT_RGB565)
        if (c)
          for (s = new Uint16Array(e * n), o = t.getData(), _ = 0; _ < d; ++_)
            s[_] = (o[_] >> 0 & 255) >> 3 << 11 | (o[_] >> 8 & 255) >> 2 << 5 | (o[_] >> 16 & 255) >> 3 << 0;
        else
          for (s = new Uint16Array(e * n), a = t.getData(), _ = 0; _ < d; ++_)
            s[_] = (a[_] & 255) >> 3 << 11 | (a[_] & 255) >> 2 << 5 | (a[_] & 255) >> 3 << 0;
      else if (h === r.PIXEL_FORMAT_RGBA4444)
        for (s = new Uint16Array(e * n), o = t.getData(), _ = 0; _ < d; ++_)
          s[_] = (o[_] >> 0 & 255) >> 4 << 12 | (o[_] >> 8 & 255) >> 4 << 8 | (o[_] >> 16 & 255) >> 4 << 4 | (o[_] >> 24 & 255) >> 4 << 0;
      else if (h === r.PIXEL_FORMAT_RGB5A1)
        for (s = new Uint16Array(e * n), o = t.getData(), _ = 0; _ < d; ++_)
          s[_] = (o[_] >> 0 & 255) >> 3 << 11 | (o[_] >> 8 & 255) >> 3 << 6 | (o[_] >> 16 & 255) >> 3 << 1 | (o[_] >> 24 & 255) >> 7 << 0;
      else if (h === r.PIXEL_FORMAT_A8)
        for (s = new Uint8Array(e * n), o = t.getData(), _ = 0; _ < d; ++_)
          s[_] = o >> 24 & 255;
      if (c && h === r.PIXEL_FORMAT_RGB888)
        for (o = t.getData(), s = new Uint8Array(e * n * 3), _ = 0; _ < d; ++_)
          s[_ * 3] = o >> 0 & 255, s[_ * 3 + 1] = o >> 8 & 255, s[_ * 3 + 2] = o >> 16 & 255;
      return this.initWithData(s, h, e, n, l), s != t.getData() && (s = null), this._hasPremultipliedAlpha = t.isPremultipliedAlpha(), !0;
    },
    addLoadedEventListener: function(t, e) {
      this.addEventListener("load", t, e);
    },
    removeLoadedEventListener: function(t) {
      this.removeEventTarget("load", t);
    }
  });
};
cc._tmp.WebGLTextureAtlas = function() {
  var t = cc.TextureAtlas.prototype;
  t._setupVBO = function() {
    var e = (this || window), n = cc._renderContext;
    e._buffersVBO[0] = n.createBuffer(), e._buffersVBO[1] = n.createBuffer(), e._quadsWebBuffer = n.createBuffer(), e._mapBuffers();
  }, t._mapBuffers = function() {
    var e = (this || window), n = cc._renderContext;
    n.bindBuffer(n.ARRAY_BUFFER, e._quadsWebBuffer), n.bufferData(n.ARRAY_BUFFER, e._quadsArrayBuffer, n.DYNAMIC_DRAW), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e._buffersVBO[1]), n.bufferData(n.ELEMENT_ARRAY_BUFFER, e._indices, n.STATIC_DRAW);
  }, t.drawNumberOfQuads = function(e, n) {
    var r = (this || window);
    if (n = n || 0, !(e === 0 || !r.texture || !r.texture.isLoaded())) {
      var s = cc._renderContext;
      cc.glBindTexture2D(r.texture), s.bindBuffer(s.ARRAY_BUFFER, r._quadsWebBuffer), r.dirty && (s.bufferData(s.ARRAY_BUFFER, r._quadsArrayBuffer, s.DYNAMIC_DRAW), r.dirty = !1), s.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), s.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), s.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), s.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, s.FLOAT, !1, 24, 0), s.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, s.UNSIGNED_BYTE, !0, 24, 12), s.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, s.FLOAT, !1, 24, 16), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, r._buffersVBO[1]), cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? s.drawElements(s.TRIANGLE_STRIP, e * 6, s.UNSIGNED_SHORT, n * 6 * r._indices.BYTES_PER_ELEMENT) : s.drawElements(s.TRIANGLES, e * 6, s.UNSIGNED_SHORT, n * 6 * r._indices.BYTES_PER_ELEMENT), cc.g_NumberOfDraws++;
    }
  };
};
cc._tmp.WebGLTextureCache = function() {
  var t = cc.textureCache;
  t.handleLoadedTexture = function(e) {
    var n = (this || window)._textures, r, s;
    cc.game._rendererInitialized || (n = (this || window)._loadedTexturesBefore), r = n[e], r || (r = n[e] = new cc.Texture2D(), r.url = e), s = cc.path.extname(e), s === ".png" ? r.handleLoadedTexture(!0) : r.handleLoadedTexture();
  }, t.addImage = function(e, n, r) {
    cc.assert(e, cc._LogInfos.Texture2D_addImage_2);
    var s = (this || window)._textures;
    cc.game._rendererInitialized || (s = (this || window)._loadedTexturesBefore);
    var o = s[e] || s[cc.loader._getAliase(e)];
    if (o)
      return o.isLoaded() ? (n && n.call(r, o), o) : (o.addEventListener("load", function() {
        n && n.call(r, o);
      }, r), o);
    o = s[e] = new cc.Texture2D(), o.url = e;
    var a = cc.loader.getBasePath ? cc.loader.getBasePath() : cc.loader.resPath;
    return cc.loader.loadImg(cc.path.join(a || "", e), function(c, l) {
      if (c)
        return n && n.call(r, c);
      cc.loader.cache[e] || (cc.loader.cache[e] = l), cc.textureCache.handleLoadedTexture(e);
      var h = s[e];
      n && n.call(r, h);
    }), o;
  }, t.addImageAsync = t.addImage, t = null;
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
    var t = {
      _contentSize: null,
      _textureLoaded: !1,
      _htmlElementObj: null,
      url: null,
      _pattern: null,
      ctor: function() {
        this._contentSize = cc.size(0, 0), this._textureLoaded = !1, this._htmlElementObj = null, this._pattern = "";
      },
      getPixelsWide: function() {
        return this._contentSize.width;
      },
      getPixelsHigh: function() {
        return this._contentSize.height;
      },
      getContentSize: function() {
        var n = cc.contentScaleFactor();
        return cc.size(this._contentSize.width / n, this._contentSize.height / n);
      },
      _getWidth: function() {
        return this._contentSize.width / cc.contentScaleFactor();
      },
      _getHeight: function() {
        return this._contentSize.height / cc.contentScaleFactor();
      },
      getContentSizeInPixels: function() {
        return this._contentSize;
      },
      initWithElement: function(n) {
        n && (this._htmlElementObj = n, this._contentSize.width = n.width, this._contentSize.height = n.height, this._textureLoaded = !0);
      },
      getHtmlElementObj: function() {
        return this._htmlElementObj;
      },
      isLoaded: function() {
        return this._textureLoaded;
      },
      handleLoadedTexture: function() {
        var n = (this || window);
        if (!n._textureLoaded) {
          if (!n._htmlElementObj) {
            var r = cc.loader.getRes(n.url);
            if (!r)
              return;
            n.initWithElement(r);
          }
          var s = n._htmlElementObj;
          n._contentSize.width = s.width, n._contentSize.height = s.height, n.dispatchEvent("load");
        }
      },
      description: function() {
        return "<cc.Texture2D | width = " + this._contentSize.width + " height " + this._contentSize.height + ">";
      },
      initWithData: function(n, r, s, o, a) {
        return !1;
      },
      initWithImage: function(n) {
        return !1;
      },
      initWithString: function(n, r, s, o, a, c) {
        return !1;
      },
      releaseTexture: function() {
        cc.loader.release(this.url);
      },
      getName: function() {
        return null;
      },
      getMaxS: function() {
        return 1;
      },
      setMaxS: function(n) {
      },
      getMaxT: function() {
        return 1;
      },
      setMaxT: function(n) {
      },
      getPixelFormat: function() {
        return null;
      },
      getShaderProgram: function() {
        return null;
      },
      setShaderProgram: function(n) {
      },
      hasPremultipliedAlpha: function() {
        return !1;
      },
      hasMipmaps: function() {
        return !1;
      },
      releaseData: function(n) {
      },
      keepData: function(n, r) {
        return n;
      },
      drawAtPoint: function(n) {
      },
      drawInRect: function(n) {
      },
      initWithETCFile: function(n) {
        return cc.log(cc._LogInfos.Texture2D_initWithETCFile), !1;
      },
      initWithPVRFile: function(n) {
        return cc.log(cc._LogInfos.Texture2D_initWithPVRFile), !1;
      },
      initWithPVRTCData: function(n, r, s, o, a, c) {
        return cc.log(cc._LogInfos.Texture2D_initWithPVRTCData), !1;
      },
      setTexParameters: function(n, r, s, o) {
        if (r !== void 0 && (n = { minFilter: n, magFilter: r, wrapS: s, wrapT: o }), n.wrapS === cc.REPEAT && n.wrapT === cc.REPEAT) {
          this._pattern = "repeat";
          return;
        }
        if (n.wrapS === cc.REPEAT) {
          this._pattern = "repeat-x";
          return;
        }
        if (n.wrapT === cc.REPEAT) {
          this._pattern = "repeat-y";
          return;
        }
        this._pattern = "";
      },
      setAntiAliasTexParameters: function() {
      },
      setAliasTexParameters: function() {
      },
      generateMipmap: function() {
      },
      stringForFormat: function() {
        return "";
      },
      bitsPerPixelForFormat: function(n) {
        return -1;
      },
      addLoadedEventListener: function(n, r) {
        this.addEventListener("load", n, r);
      },
      removeLoadedEventListener: function(n) {
        this.removeEventTarget("load", n);
      },
      _generateColorTexture: function() {
      },
      _generateTextureCacheForColor: function() {
        if (this.channelCache)
          return this.channelCache;
        var n = [
          document.createElement("canvas"),
          document.createElement("canvas"),
          document.createElement("canvas"),
          document.createElement("canvas")
        ];
        return e(this._htmlElementObj, n), this.channelCache = n;
      },
      _grayElementObj: null,
      _backupElement: null,
      _isGray: !1,
      _switchToGray: function(n) {
        !this._textureLoaded || this._isGray === n || (this._isGray = n, this._isGray ? (this._backupElement = (this || window)._htmlElementObj, this._grayElementObj || (this._grayElementObj = cc.Texture2D._generateGrayTexture(this._htmlElementObj)), this._htmlElementObj = (this || window)._grayElementObj) : this._backupElement !== null && (this._htmlElementObj = (this || window)._backupElement));
      }
    }, e = /* @__PURE__ */ H(function(n, r) {
      var s = n.width, o = n.height;
      r[0].width = s, r[0].height = o, r[1].width = s, r[1].height = o, r[2].width = s, r[2].height = o, r[3].width = s, r[3].height = o;
      var a = r[3].getContext("2d");
      a.drawImage(n, 0, 0);
      for (var c = a.getImageData(0, 0, s, o).data, l, h = 0; h < 4; h++) {
        l = r[h].getContext("2d");
        for (var u = l.getImageData(0, 0, s, o), _ = u.data, d = 0; d < c.length; d += 4)
          _[d] = h === 0 ? c[d] : 0, _[d + 1] = h === 1 ? c[d + 1] : 0, _[d + 2] = h === 2 ? c[d + 2] : 0, _[d + 3] = c[d + 3];
        l.putImageData(u, 0, 0);
      }
      n.onload = null;
    }, "renderToCache");
    cc.sys._supportCanvasNewBlendModes ? t._generateColorTexture = function(n, r, s, o, a) {
      var c = !1;
      a ? c = !0 : a = document.createElement("canvas");
      var l = (this || window)._htmlElementObj;
      o || (o = cc.rect(0, 0, l.width, l.height)), a.width = o.width, a.height = o.height;
      var h = a.getContext("2d");
      if (h.globalCompositeOperation = "source-over", h.fillStyle = "rgb(" + (n | 0) + "," + (r | 0) + "," + (s | 0) + ")", h.fillRect(0, 0, o.width, o.height), h.globalCompositeOperation = "multiply", h.drawImage(
        l,
        o.x,
        o.y,
        o.width,
        o.height,
        0,
        0,
        o.width,
        o.height
      ), h.globalCompositeOperation = "destination-atop", h.drawImage(
        l,
        o.x,
        o.y,
        o.width,
        o.height,
        0,
        0,
        o.width,
        o.height
      ), c)
        return a;
      var u = new cc.Texture2D();
      return u.initWithElement(a), u.handleLoadedTexture(), u;
    } : t._generateColorTexture = function(n, r, s, o, a) {
      var c = !1;
      a ? c = !0 : a = document.createElement("canvas");
      var l = (this || window)._htmlElementObj;
      o || (o = cc.rect(0, 0, l.width, l.height));
      var h, u, _, d;
      if (h = o.x, u = o.y, _ = o.width, d = o.height, !(!_ || !d)) {
        a.width = _, a.height = d;
        var f = a.getContext("2d"), C = cc.textureCache.getTextureColors(this);
        if (f.globalCompositeOperation = "lighter", f.drawImage(
          C[3],
          h,
          u,
          _,
          d,
          0,
          0,
          _,
          d
        ), n > 0 && (f.globalAlpha = n / 255, f.drawImage(
          C[0],
          h,
          u,
          _,
          d,
          0,
          0,
          _,
          d
        )), r > 0 && (f.globalAlpha = r / 255, f.drawImage(
          C[1],
          h,
          u,
          _,
          d,
          0,
          0,
          _,
          d
        )), s > 0 && (f.globalAlpha = s / 255, f.drawImage(
          C[2],
          h,
          u,
          _,
          d,
          0,
          0,
          _,
          d
        )), c)
          return a;
        var m = new cc.Texture2D();
        return m.initWithElement(a), m.handleLoadedTexture(), m;
      }
    }, cc.Texture2D = cc.Class.extend(t), cc.Texture2D._generateGrayTexture = function(n, r, s) {
      if (n === null)
        return null;
      s = s || document.createElement("canvas"), r = r || cc.rect(0, 0, n.width, n.height), s.width = r.width, s.height = r.height;
      var o = s.getContext("2d");
      o.drawImage(n, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
      for (var a = o.getImageData(0, 0, r.width, r.height), c = a.data, l = 0, h = c.length; l < h; l += 4)
        c[l] = c[l + 1] = c[l + 2] = 0.34 * c[l] + 0.5 * c[l + 1] + 0.16 * c[l + 2];
      return o.putImageData(a, 0, 0), s;
    };
  } else
    cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
  cc.EventHelper.prototype.apply(cc.Texture2D.prototype), cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js"), cc._tmp.PrototypeTexture2D(), delete cc._tmp.PrototypeTexture2D;
});
cc.textureCache = {
  _textures: {},
  _textureColorsCache: {},
  _textureKeySeq: 0 | Math.random() * 1e3,
  _loadedTexturesBefore: {},
  _initializingRenderer: function() {
    var t, e = (this || window)._loadedTexturesBefore, n = (this || window)._textures;
    for (t in e) {
      var r = e[t];
      r.handleLoadedTexture(), n[t] = r;
    }
    this._loadedTexturesBefore = {};
  },
  addPVRTCImage: function(t) {
    cc.log(cc._LogInfos.textureCache_addPVRTCImage);
  },
  addETCImage: function(t) {
    cc.log(cc._LogInfos.textureCache_addETCImage);
  },
  description: function() {
    return "<TextureCache | Number of textures = " + this._textures.length + ">";
  },
  textureForKey: function(t) {
    return cc.log(cc._LogInfos.textureCache_textureForKey), this.getTextureForKey(t);
  },
  getTextureForKey: function(t) {
    return this._textures[t] || this._textures[cc.loader._getAliase(t)];
  },
  getKeyByTexture: function(t) {
    for (var e in this._textures)
      if (this._textures[e] === t)
        return e;
    return null;
  },
  _generalTextureKey: function(t) {
    return "_textureKey_" + t;
  },
  getTextureColors: function(t) {
    var e = t._htmlElementObj, n = (this || window).getKeyByTexture(e);
    return n || (e instanceof HTMLImageElement ? n = e.src : n = (this || window)._generalTextureKey(t.__instanceId)), this._textureColorsCache[n] || (this._textureColorsCache[n] = t._generateTextureCacheForColor()), this._textureColorsCache[n];
  },
  addPVRImage: function(t) {
    cc.log(cc._LogInfos.textureCache_addPVRImage);
  },
  removeAllTextures: function() {
    var t = (this || window)._textures;
    for (var e in t)
      t[e] && t[e].releaseTexture();
    this._textures = {};
  },
  removeTexture: function(t) {
    if (t) {
      var e = (this || window)._textures;
      for (var n in e)
        e[n] === t && (e[n].releaseTexture(), delete e[n]);
    }
  },
  removeTextureForKey: function(t) {
    t != null && this._textures[t] && delete this._textures[t];
  },
  cacheImage: function(t, e) {
    if (e instanceof cc.Texture2D) {
      this._textures[t] = e;
      return;
    }
    var n = new cc.Texture2D();
    n.initWithElement(e), n.handleLoadedTexture(), this._textures[t] = n;
  },
  addUIImage: function(t, e) {
    if (cc.assert(t, cc._LogInfos.textureCache_addUIImage_2), e && this._textures[e])
      return this._textures[e];
    var n = new cc.Texture2D();
    return n.initWithImage(t), e != null ? this._textures[e] = n : cc.log(cc._LogInfos.textureCache_addUIImage), n;
  },
  dumpCachedTextureInfo: function() {
    var t = 0, e = 0, n = (this || window)._textures;
    for (var r in n) {
      var s = n[r];
      t++, s.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, r, s.getHtmlElementObj().src, s.pixelsWidth, s.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, r, s.pixelsWidth, s.pixelsHeight), e += s.pixelsWidth * s.pixelsHeight * 4;
    }
    var o = (this || window)._textureColorsCache;
    for (r in o) {
      var a = o[r];
      for (var c in a) {
        var l = a[c];
        t++, cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, r, l.width, l.height), e += l.width * l.height * 4;
      }
    }
    cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, t, e / 1024, (e / (1024 * 1024)).toFixed(2));
  },
  _clear: function() {
    this._textures = {}, this._textureColorsCache = {}, this._textureKeySeq = 0 | Math.random() * 1e3, this._loadedTexturesBefore = {};
  }
};
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
    var t = cc.textureCache;
    t.handleLoadedTexture = function(e) {
      var n = (this || window)._textures, r = n[e];
      r || (r = n[e] = new cc.Texture2D(), r.url = e), r.handleLoadedTexture();
    }, t.addImage = function(e, n, r) {
      cc.assert(e, cc._LogInfos.Texture2D_addImage);
      var s = (this || window)._textures, o = s[e] || s[cc.loader._getAliase(e)];
      if (o)
        return o.isLoaded() ? (n && n.call(r, o), o) : (o.addEventListener("load", function() {
          n && n.call(r, o);
        }, r), o);
      o = s[e] = new cc.Texture2D(), o.url = e;
      var a = cc.loader.getBasePath ? cc.loader.getBasePath() : cc.loader.resPath;
      return cc.loader.loadImg(cc.path.join(a || "", e), function(c, l) {
        if (c)
          return n && n.call(r, c);
        cc.loader.cache[e] || (cc.loader.cache[e] = l), cc.textureCache.handleLoadedTexture(e);
        var h = s[e];
        n && n.call(r, h);
      }), o;
    }, t.addImageAsync = t.addImage, t = null;
  } else
    cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache);
});
cc.Scene = cc.Node.extend({
  _className: "Scene",
  ctor: function() {
    cc.Node.prototype.ctor.call(this), this._ignoreAnchorPointForPosition = !0, this.setAnchorPoint(0.5, 0.5), this.setContentSize(cc.director.getWinSize());
  }
});
cc.Scene.create = function() {
  return new cc.Scene();
};
cc.LoaderScene = cc.Scene.extend({
  _interval: null,
  _label: null,
  _className: "LoaderScene",
  cb: null,
  target: null,
  init: function() {
    var t = (this || window), e = 200, n = t._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
    t.addChild(n, 0);
    var r = 24, s = -e / 2 + 100;
    cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, { isCrossOrigin: !1 }, function(a, c) {
      c.width, e = c.height, t._initStage(c, cc.visibleRect.center);
    }), r = 14, s = -e / 2 - 10);
    var o = t._label = new cc.LabelTTF("Loading... 0%", "Arial", r);
    return o.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, s))), o.setColor(cc.color(180, 180, 180)), n.addChild(this._label, 10), !0;
  },
  _initStage: function(t, e) {
    var n = (this || window), r = n._texture2d = new cc.Texture2D();
    r.initWithElement(t), r.handleLoadedTexture();
    var s = n._logo = new cc.Sprite(r);
    s.setScale(cc.contentScaleFactor()), s.x = e.x, s.y = e.y, n._bgLayer.addChild(s, 10);
  },
  onEnter: function() {
    var t = (this || window);
    cc.Node.prototype.onEnter.call(t), t.schedule(t._startLoading, 0.3);
  },
  onExit: function() {
    cc.Node.prototype.onExit.call(this);
    var t = "Loading... 0%";
    this._label.setString(t);
  },
  initWithResources: function(t, e, n) {
    cc.isString(t) && (t = [t]), this.resources = t || [], this.cb = e, this.target = n;
  },
  _startLoading: function() {
    var t = (this || window);
    t.unschedule(t._startLoading);
    var e = t.resources;
    cc.loader.load(
      e,
      function(n, r, s) {
        var o = s / r * 100 | 0;
        o = Math.min(o, 100), t._label.setString("Loading... " + o + "%");
      },
      function() {
        t.cb && t.cb.call(t.target);
      }
    );
  },
  _updateTransform: function() {
    this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._bgLayer._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._label._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._logo._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  }
});
cc.LoaderScene.preload = function(t, e, n) {
  var r = cc;
  return r.loaderScene || (r.loaderScene = new cc.LoaderScene(), r.loaderScene.init(), cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, function() {
    r.loaderScene._updateTransform();
  })), r.loaderScene.initWithResources(t, e, n), cc.director.runScene(r.loaderScene), r.loaderScene;
};
cc.Layer = cc.Node.extend({
  _className: "Layer",
  ctor: function() {
    cc.Node.prototype.ctor.call(this), this._ignoreAnchorPointForPosition = !0, this.setAnchorPoint(0.5, 0.5), this.setContentSize(cc.winSize);
  },
  init: function() {
    var t = (this || window);
    return t._ignoreAnchorPointForPosition = !0, t.setAnchorPoint(0.5, 0.5), t.setContentSize(cc.winSize), t._cascadeColorEnabled = !1, t._cascadeOpacityEnabled = !1, !0;
  },
  bake: function() {
    this._renderCmd.bake();
  },
  unbake: function() {
    this._renderCmd.unbake();
  },
  isBaked: function() {
    return this._renderCmd._isBaked;
  },
  addChild: function(t, e, n) {
    cc.Node.prototype.addChild.call(this, t, e, n), this._renderCmd._bakeForAddChild(t);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Layer.CanvasRenderCmd(this) : new cc.Layer.WebGLRenderCmd(this);
  }
});
cc.Layer.create = function() {
  return new cc.Layer();
};
cc.LayerColor = cc.Layer.extend({
  _blendFunc: null,
  _className: "LayerColor",
  getBlendFunc: function() {
    return this._blendFunc;
  },
  changeWidthAndHeight: function(t, e) {
    this.width = t, this.height = e;
  },
  changeWidth: function(t) {
    this.width = t;
  },
  changeHeight: function(t) {
    this.height = t;
  },
  setOpacityModifyRGB: function(t) {
  },
  isOpacityModifyRGB: function() {
    return !1;
  },
  ctor: function(t, e, n) {
    cc.Layer.prototype.ctor.call(this), this._blendFunc = cc.BlendFunc._alphaNonPremultiplied(), cc.LayerColor.prototype.init.call(this, t, e, n);
  },
  init: function(t, e, n) {
    var r = cc.director.getWinSize();
    t = t || cc.color(0, 0, 0, 255), e = e === void 0 ? r.width : e, n = n === void 0 ? r.height : n;
    var s = (this || window)._realColor;
    return s.r = t.r, s.g = t.g, s.b = t.b, this._realOpacity = t.a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty), cc.LayerColor.prototype.setContentSize.call(this, e, n), !0;
  },
  setBlendFunc: function(t, e) {
    var n = (this || window)._blendFunc;
    e === void 0 ? (n.src = t.src, n.dst = t.dst) : (n.src = t, n.dst = e), this._renderCmd.updateBlendFunc(n);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.LayerColor.CanvasRenderCmd(this) : new cc.LayerColor.WebGLRenderCmd(this);
  }
});
cc.LayerColor.create = function(t, e, n) {
  return new cc.LayerColor(t, e, n);
};
(function() {
  var t = cc.LayerColor.prototype;
  cc.defineGetterSetter(t, "width", t._getWidth, t._setWidth), cc.defineGetterSetter(t, "height", t._getHeight, t._setHeight);
})();
cc.LayerGradient = cc.LayerColor.extend({
  _endColor: null,
  _startOpacity: 255,
  _endOpacity: 255,
  _alongVector: null,
  _compressedInterpolation: !1,
  _className: "LayerGradient",
  _colorStops: [],
  ctor: function(t, e, n, r) {
    cc.LayerColor.prototype.ctor.call(this), this._endColor = cc.color(0, 0, 0, 255), this._alongVector = cc.p(0, -1), this._startOpacity = 255, this._endOpacity = 255, r && r instanceof Array ? (this._colorStops = r, r.splice(0, 0, { p: 0, color: t || cc.color.BLACK }), r.push({ p: 1, color: e || cc.color.BLACK })) : this._colorStops = [{ p: 0, color: t || cc.color.BLACK }, { p: 1, color: e || cc.color.BLACK }], cc.LayerGradient.prototype.init.call(this, t, e, n, r);
  },
  init: function(t, e, n, r) {
    t = t || cc.color(0, 0, 0, 255), e = e || cc.color(0, 0, 0, 255), n = n || cc.p(0, -1);
    var s = (this || window), o = s._endColor;
    return s._startOpacity = t.a, o.r = e.r, o.g = e.g, o.b = e.b, s._endOpacity = e.a, s._alongVector = n, s._compressedInterpolation = !0, cc.LayerColor.prototype.init.call(s, cc.color(t.r, t.g, t.b, 255)), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty), !0;
  },
  setContentSize: function(t, e) {
    cc.LayerColor.prototype.setContentSize.call(this, t, e), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty);
  },
  _setWidth: function(t) {
    cc.LayerColor.prototype._setWidth.call(this, t), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty);
  },
  _setHeight: function(t) {
    cc.LayerColor.prototype._setHeight.call(this, t), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty);
  },
  getStartColor: function() {
    return cc.color(this._realColor);
  },
  setStartColor: function(t) {
    this.color = t;
    var e = (this || window)._colorStops;
    if (e && e.length > 0) {
      var n = e[0].color;
      n.r = t.r, n.g = t.g, n.b = t.b;
    }
  },
  setEndColor: function(t) {
    var e = (this || window)._endColor;
    e.r = t.r, e.g = t.g, e.b = t.b;
    var n = (this || window)._colorStops;
    if (n && n.length > 0) {
      var r = n[n.length - 1].color;
      r.r = t.r, r.g = t.g, r.b = t.b;
    }
    this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
  },
  getEndColor: function() {
    return cc.color(this._endColor);
  },
  setStartOpacity: function(t) {
    this._startOpacity = t;
    var e = (this || window)._colorStops;
    e && e.length > 0 && (e[0].color.a = t), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty);
  },
  getStartOpacity: function() {
    return this._startOpacity;
  },
  setEndOpacity: function(t) {
    this._endOpacity = t;
    var e = (this || window)._colorStops;
    e && e.length > 0 && (e[e.length - 1].color.a = t), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty);
  },
  getEndOpacity: function() {
    return this._endOpacity;
  },
  setVector: function(t) {
    this._alongVector.x = t.x, this._alongVector.y = t.y, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty);
  },
  getVector: function() {
    return cc.p(this._alongVector.x, this._alongVector.y);
  },
  isCompressedInterpolation: function() {
    return this._compressedInterpolation;
  },
  setCompressedInterpolation: function(t) {
    this._compressedInterpolation = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty);
  },
  getColorStops: function() {
    return this._colorStops;
  },
  setColorStops: function(t) {
    this._colorStops = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.LayerGradient.CanvasRenderCmd(this) : new cc.LayerGradient.WebGLRenderCmd(this);
  }
});
cc.LayerGradient.create = function(t, e, n, r) {
  return new cc.LayerGradient(t, e, n, r);
};
(function() {
  var t = cc.LayerGradient.prototype;
  t.startColor, cc.defineGetterSetter(t, "startColor", t.getStartColor, t.setStartColor), t.endColor, cc.defineGetterSetter(t, "endColor", t.getEndColor, t.setEndColor), t.startOpacity, cc.defineGetterSetter(t, "startOpacity", t.getStartOpacity, t.setStartOpacity), t.endOpacity, cc.defineGetterSetter(t, "endOpacity", t.getEndOpacity, t.setEndOpacity), t.vector, cc.defineGetterSetter(t, "vector", t.getVector, t.setVector), t.colorStops, cc.defineGetterSetter(t, "colorStops", t.getColorStops, t.setColorStops);
})();
cc.LayerMultiplex = cc.Layer.extend({
  _enabledLayer: 0,
  _layers: null,
  _className: "LayerMultiplex",
  ctor: function(t) {
    cc.Layer.prototype.ctor.call(this), t instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, t) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments));
  },
  initWithLayers: function(t) {
    return t.length > 0 && t[t.length - 1] == null && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers), this._layers = t, this._enabledLayer = 0, this.addChild(this._layers[this._enabledLayer]), !0;
  },
  switchTo: function(t) {
    if (t >= (this || window)._layers.length) {
      cc.log(cc._LogInfos.LayerMultiplex_switchTo);
      return;
    }
    this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = t, this.addChild(this._layers[t]);
  },
  switchToAndReleaseMe: function(t) {
    if (t >= (this || window)._layers.length) {
      cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe);
      return;
    }
    this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = t, this.addChild(this._layers[t]);
  },
  addLayer: function(t) {
    if (!t) {
      cc.log(cc._LogInfos.LayerMultiplex_addLayer);
      return;
    }
    this._layers.push(t);
  }
});
cc.LayerMultiplex.create = function() {
  return new cc.LayerMultiplex(Array.prototype.slice.call(arguments));
};
(function() {
  cc.Layer.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._isBaked = !1, this._bakeSprite = null, this._canUseDirtyRegion = !0, this._updateCache = 2;
  };
  var t = cc.Layer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.Layer.CanvasRenderCmd, t._setCacheDirty = function(e) {
    if (e && this._updateCache === 0 && (this._updateCache = 2), this._cacheDirty === !1) {
      this._cacheDirty = !0;
      var n = (this || window)._cachedParent;
      n && n !== (this || window) && n._setNodeDirtyForCache && n._setNodeDirtyForCache();
    }
  }, t.updateStatus = function() {
    var e = cc.Node._dirtyFlags, n = (this || window)._dirtyFlag;
    n & e.orderDirty && (this._cacheDirty = !0, this._updateCache === 0 && (this._updateCache = 2), this._dirtyFlag = n & e.orderDirty ^ n), cc.Node.RenderCmd.prototype.updateStatus.call(this);
  }, t._syncStatus = function(e) {
    var n = cc.Node._dirtyFlags, r = (this || window)._dirtyFlag;
    r & n.orderDirty && (this._cacheDirty = !0, this._updateCache === 0 && (this._updateCache = 2), this._dirtyFlag = r & n.orderDirty ^ r), cc.Node.RenderCmd.prototype._syncStatus.call(this, e);
  }, t.transform = function(e, n) {
    var r = (this || window)._worldTransform, s = r.a, o = r.b, a = r.c, c = r.d;
    r.tx, r.ty, cc.Node.CanvasRenderCmd.prototype.transform.call(this, e, n), (r.a !== s || r.b !== o || r.c !== a || r.d !== c) && this._updateCache === 0 && (this._updateCache = 2);
  }, t.bake = function() {
    if (!this._isBaked) {
      this._needDraw = !0, cc.renderer.childrenOrderDirty = !0, this._isBaked = (this || window)._cacheDirty = !0, this._updateCache === 0 && (this._updateCache = 2);
      for (var e = (this || window)._node._children, n = 0, r = e.length; n < r; n++)
        e[n]._renderCmd._setCachedParent(this);
      this._bakeSprite || (this._bakeSprite = new cc.BakeSprite(), this._bakeSprite.setAnchorPoint(0, 0));
    }
  }, t.unbake = function() {
    if (this._isBaked) {
      cc.renderer.childrenOrderDirty = !0, this._needDraw = !1, this._isBaked = !1, this._cacheDirty = !0, this._updateCache === 0 && (this._updateCache = 2);
      for (var e = (this || window)._node._children, n = 0, r = e.length; n < r; n++)
        e[n]._renderCmd._setCachedParent(null);
    }
  }, t.isBaked = function() {
    return this._isBaked;
  }, t.rendering = function() {
    if (this._cacheDirty) {
      var e = (this || window)._node, n = e._children, r = (this || window)._bakeSprite;
      this.transform(this.getParentRenderCmd(), !0);
      var s = (this || window)._getBoundingBoxForBake();
      s.width = 0 | s.width + 0.5, s.height = 0 | s.height + 0.5;
      var o = r.getCacheContext(), a = o.getContext();
      if (r.setPosition(s.x, s.y), this._updateCache > 0) {
        r.resetCanvasSize(s.width, s.height), o.setOffset(0 - s.x, a.canvas.height - s.height + s.y), e.sortAllChildren(), cc.renderer._turnToCacheMode(this.__instanceId);
        for (var c = 0, l = n.length; c < l; c++)
          n[c].visit(this);
        cc.renderer._renderingToCacheCanvas(o, this.__instanceId), r.transform(), this._updateCache--;
      }
      this._cacheDirty = !1;
    }
  }, t.visit = function(e) {
    if (!this._isBaked) {
      this.originVisit(e);
      return;
    }
    var n = (this || window)._node, r = n._children, s = r.length;
    !n._visible || s === 0 || (this._syncStatus(e), cc.renderer.pushRenderCommand(this), this._bakeSprite.visit(this), this._dirtyFlag = 0);
  }, t._bakeForAddChild = function(e) {
    e._parent === (this || window)._node && this._isBaked && e._renderCmd._setCachedParent(this);
  }, t._getBoundingBoxForBake = function() {
    var e = null, n = (this || window)._node;
    if (!n._children || n._children.length === 0)
      return cc.rect(0, 0, 10, 10);
    for (var r = n.getNodeToWorldTransform(), s = n._children, o = 0, a = s.length; o < a; o++) {
      var c = s[o];
      if (c && c._visible)
        if (e) {
          var l = c._getBoundingBoxToCurrentNode(r);
          l && (e = cc.rectUnion(e, l));
        } else
          e = c._getBoundingBoxToCurrentNode(r);
    }
    return e;
  };
})();
(function() {
  cc.LayerColor.CanvasRenderCmd = function(e) {
    cc.Layer.CanvasRenderCmd.call(this, e), this._needDraw = !0, this._blendFuncStr = "source-over", this._bakeRenderCmd = new cc.CustomRenderCmd(this, this._bakeRendering);
  };
  var t = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
  t.constructor = cc.LayerColor.CanvasRenderCmd, t.unbake = function() {
    cc.Layer.CanvasRenderCmd.prototype.unbake.call(this), this._needDraw = !0;
  }, t.rendering = function(e, n, r) {
    var s = e || cc._renderContext, o = s.getContext(), a = (this || window)._node, c = (this || window)._displayedColor, l = (this || window)._displayedOpacity / 255, h = a._contentSize.width, u = a._contentSize.height;
    l !== 0 && (s.setCompositeOperation(this._blendFuncStr), s.setGlobalAlpha(l), s.setFillStyle("rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + ", 1)"), s.setTransform(this._worldTransform, n, r), o.fillRect(0, 0, h, -u), cc.g_NumberOfDraws++);
  }, t.updateBlendFunc = function(e) {
    this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(e);
  }, t._updateSquareVertices = t._updateSquareVerticesWidth = t._updateSquareVerticesHeight = function() {
  }, t._bakeRendering = function() {
    if (this._cacheDirty) {
      var e = (this || window)._node, n = (this || window)._bakeSprite, r = e._children, s = r.length, o;
      this.transform(this.getParentRenderCmd(), !0);
      var a = (this || window)._getBoundingBoxForBake();
      a.width = 0 | a.width + 0.5, a.height = 0 | a.height + 0.5;
      var c = n.getCacheContext(), l = c.getContext();
      if (n.setPosition(a.x, a.y), this._updateCache > 0) {
        l.fillStyle = c._currentFillStyle, n.resetCanvasSize(a.width, a.height), c.setOffset(0 - a.x, l.canvas.height - a.height + a.y);
        var h;
        if (cc.renderer._turnToCacheMode(this.__instanceId), s > 0) {
          for (e.sortAllChildren(), o = 0; o < s && (h = r[o], h._localZOrder < 0); o++)
            h._renderCmd.visit(this);
          for (cc.renderer.pushRenderCommand(this); o < s; o++)
            r[o]._renderCmd.visit(this);
        } else
          cc.renderer.pushRenderCommand(this);
        cc.renderer._renderingToCacheCanvas(c, this.__instanceId), n.transform(), this._updateCache--;
      }
      this._cacheDirty = !1;
    }
  }, t.visit = function(e) {
    if (!this._isBaked) {
      this.originVisit();
      return;
    }
    var n = (this || window)._node;
    n._visible && (this._syncStatus(e), cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), this._bakeSprite.visit(this), this._dirtyFlag = 0);
  }, t._getBoundingBoxForBake = function() {
    var e = (this || window)._node, n = cc.rect(0, 0, e._contentSize.width, e._contentSize.height), r = e.getNodeToWorldTransform();
    if (n = cc.rectApplyAffineTransform(n, e.getNodeToWorldTransform()), !e._children || e._children.length === 0)
      return n;
    for (var s = e._children, o = 0; o < s.length; o++) {
      var a = s[o];
      if (a && a._visible) {
        var c = a._getBoundingBoxToCurrentNode(r);
        n = cc.rectUnion(n, c);
      }
    }
    return n;
  };
})();
(function() {
  cc.LayerGradient.CanvasRenderCmd = function(e) {
    cc.LayerColor.CanvasRenderCmd.call(this, e), this._needDraw = !0, this._startPoint = cc.p(0, 0), this._endPoint = cc.p(0, 0), this._startStopStr = null, this._endStopStr = null;
  };
  var t = cc.LayerGradient.CanvasRenderCmd.prototype = Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
  t.constructor = cc.LayerGradient.CanvasRenderCmd, t.rendering = function(e, n, r) {
    var s = e || cc._renderContext, o = s.getContext(), a = (this || window)._node, c = (this || window)._displayedOpacity / 255;
    if (c !== 0) {
      var l = a._contentSize.width, h = a._contentSize.height;
      s.setCompositeOperation(this._blendFuncStr), s.setGlobalAlpha(c);
      var u = o.createLinearGradient(this._startPoint.x, this._startPoint.y, this._endPoint.x, this._endPoint.y);
      if (a._colorStops)
        for (var _ = 0; _ < a._colorStops.length; _++) {
          var d = a._colorStops[_];
          u.addColorStop(d.p, this._colorStopsStr[_]);
        }
      else
        u.addColorStop(0, this._startStopStr), u.addColorStop(1, this._endStopStr);
      s.setFillStyle(u), s.setTransform(this._worldTransform, n, r), o.fillRect(0, 0, l, -h), cc.g_NumberOfDraws++;
    }
  }, t.updateStatus = function() {
    var e = cc.Node._dirtyFlags, n = (this || window)._dirtyFlag;
    n & e.gradientDirty && (this._dirtyFlag |= e.colorDirty, this._dirtyFlag = n & e.gradientDirty ^ n), cc.Node.RenderCmd.prototype.updateStatus.call(this);
  }, t._syncStatus = function(e) {
    var n = cc.Node._dirtyFlags, r = (this || window)._dirtyFlag;
    r & n.gradientDirty && (this._dirtyFlag |= n.colorDirty, this._dirtyFlag = r & n.gradientDirty ^ r), cc.Node.RenderCmd.prototype._syncStatus.call(this, e);
  }, t._updateColor = function() {
    var e = (this || window)._node, n = e._contentSize, r = n.width * 0.5, s = n.height * 0.5, o = cc.pAngleSigned(cc.p(0, -1), e._alongVector), a = cc.pRotateByAngle(cc.p(0, -1), cc.p(0, 0), o), c = Math.min(Math.abs(1 / a.x), Math.abs(1 / a.y));
    this._startPoint.x = r * (-a.x * c) + r, this._startPoint.y = s * (a.y * c) - s, this._endPoint.x = r * (a.x * c) + r, this._endPoint.y = s * (-a.y * c) - s;
    var l = (this || window)._displayedColor, h = e._endColor, u = e._startOpacity / 255, _ = e._endOpacity / 255;
    if (this._startStopStr = "rgba(" + Math.round(l.r) + "," + Math.round(l.g) + "," + Math.round(l.b) + "," + u.toFixed(4) + ")", this._endStopStr = "rgba(" + Math.round(h.r) + "," + Math.round(h.g) + "," + Math.round(h.b) + "," + _.toFixed(4) + ")", e._colorStops) {
      this._startOpacity = 0, this._endOpacity = 0, this._colorStopsStr = [];
      for (var d = 0; d < e._colorStops.length; d++) {
        var f = e._colorStops[d].color, C = f.a == null ? 1 : f.a / 255;
        this._colorStopsStr.push("rgba(" + Math.round(f.r) + "," + Math.round(f.g) + "," + Math.round(f.b) + "," + C.toFixed(4) + ")");
      }
    }
  };
})();
cc._tmp.PrototypeSprite = function() {
  var t = cc.Sprite.prototype;
  cc.defineGetterSetter(t, "opacityModifyRGB", t.isOpacityModifyRGB, t.setOpacityModifyRGB), cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity), cc.defineGetterSetter(t, "color", t.getColor, t.setColor), t.dirty, t.flippedX, cc.defineGetterSetter(t, "flippedX", t.isFlippedX, t.setFlippedX), t.flippedY, cc.defineGetterSetter(t, "flippedY", t.isFlippedY, t.setFlippedY), t.offsetX, cc.defineGetterSetter(t, "offsetX", t._getOffsetX), t.offsetY, cc.defineGetterSetter(t, "offsetY", t._getOffsetY), t.atlasIndex, t.texture, cc.defineGetterSetter(t, "texture", t.getTexture, t.setTexture), t.textureRectRotated, cc.defineGetterSetter(t, "textureRectRotated", t.isTextureRectRotated), t.textureAtlas, t.batchNode, cc.defineGetterSetter(t, "batchNode", t.getBatchNode, t.setBatchNode), t.quad, cc.defineGetterSetter(t, "quad", t.getQuad);
};
cc.Sprite = cc.Node.extend({
  dirty: !1,
  atlasIndex: 0,
  textureAtlas: null,
  _batchNode: null,
  _recursiveDirty: null,
  _hasChildren: null,
  _shouldBeHidden: !1,
  _transformToBatch: null,
  _blendFunc: null,
  _texture: null,
  _rect: null,
  _rectRotated: !1,
  _offsetPosition: null,
  _unflippedOffsetPositionFromCenter: null,
  _opacityModifyRGB: !1,
  _flippedX: !1,
  _flippedY: !1,
  _textureLoaded: !1,
  _className: "Sprite",
  ctor: function(t, e, n) {
    var r = (this || window);
    cc.Node.prototype.ctor.call(r), this.setAnchorPoint(0.5, 0.5), r._loader = new cc.Sprite.LoadManager(), r._shouldBeHidden = !1, r._offsetPosition = cc.p(0, 0), r._unflippedOffsetPositionFromCenter = cc.p(0, 0), r._blendFunc = { src: cc.BLEND_SRC, dst: cc.BLEND_DST }, r._rect = cc.rect(0, 0, 0, 0), r._softInit(t, e, n);
  },
  textureLoaded: function() {
    return this._textureLoaded;
  },
  addLoadedEventListener: function(t, e) {
    this.addEventListener("load", t, e);
  },
  isDirty: function() {
    return this.dirty;
  },
  setDirty: function(t) {
    this.dirty = t;
  },
  isTextureRectRotated: function() {
    return this._rectRotated;
  },
  getAtlasIndex: function() {
    return this.atlasIndex;
  },
  setAtlasIndex: function(t) {
    this.atlasIndex = t;
  },
  getTextureRect: function() {
    return cc.rect(this._rect);
  },
  getTextureAtlas: function() {
    return this.textureAtlas;
  },
  setTextureAtlas: function(t) {
    this.textureAtlas = t;
  },
  getOffsetPosition: function() {
    return cc.p(this._offsetPosition);
  },
  _getOffsetX: function() {
    return this._offsetPosition.x;
  },
  _getOffsetY: function() {
    return this._offsetPosition.y;
  },
  getBlendFunc: function() {
    return this._blendFunc;
  },
  initWithSpriteFrame: function(t) {
    return cc.assert(t, cc._LogInfos.Sprite_initWithSpriteFrame), this.setSpriteFrame(t);
  },
  initWithSpriteFrameName: function(t) {
    cc.assert(t, cc._LogInfos.Sprite_initWithSpriteFrameName);
    var e = cc.spriteFrameCache.getSpriteFrame(t);
    return cc.assert(e, t + cc._LogInfos.Sprite_initWithSpriteFrameName1), this.initWithSpriteFrame(e);
  },
  useBatchNode: function(t) {
    this.textureAtlas = t.getTextureAtlas(), this._batchNode = t;
  },
  setVertexRect: function(t) {
    var e = (this || window)._rect;
    e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  sortAllChildren: function() {
    if (this._reorderChildDirty) {
      var t = (this || window)._children;
      cc.Node.prototype.sortAllChildren.call(this), this._batchNode && this._arrayMakeObjectsPerformSelector(t, cc.Node._stateCallbackType.sortAllChildren), this._reorderChildDirty = !1;
    }
  },
  reorderChild: function(t, e) {
    if (cc.assert(t, cc._LogInfos.Sprite_reorderChild_2), this._children.indexOf(t) === -1) {
      cc.log(cc._LogInfos.Sprite_reorderChild);
      return;
    }
    e !== t.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, t, e));
  },
  removeChild: function(t, e) {
    this._batchNode && this._batchNode.removeSpriteFromAtlas(t), cc.Node.prototype.removeChild.call(this, t, e);
  },
  setVisible: function(t) {
    cc.Node.prototype.setVisible.call(this, t), this._renderCmd.setDirtyRecursively(!0);
  },
  removeAllChildren: function(t) {
    var e = (this || window)._children, n = (this || window)._batchNode;
    if (n && e != null)
      for (var r = 0, s = e.length; r < s; r++)
        n.removeSpriteFromAtlas(e[r]);
    cc.Node.prototype.removeAllChildren.call(this, t), this._hasChildren = !1;
  },
  ignoreAnchorPointForPosition: function(t) {
    if (this._batchNode) {
      cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition);
      return;
    }
    cc.Node.prototype.ignoreAnchorPointForPosition.call(this, t);
  },
  setFlippedX: function(t) {
    this._flippedX !== t && (this._flippedX = t, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0));
  },
  setFlippedY: function(t) {
    this._flippedY !== t && (this._flippedY = t, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0));
  },
  isFlippedX: function() {
    return this._flippedX;
  },
  isFlippedY: function() {
    return this._flippedY;
  },
  setOpacityModifyRGB: function(t) {
    this._opacityModifyRGB !== t && (this._opacityModifyRGB = t, this._renderCmd._setColorDirty());
  },
  isOpacityModifyRGB: function() {
    return this._opacityModifyRGB;
  },
  setDisplayFrameWithAnimationName: function(t, e) {
    cc.assert(t, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
    var n = cc.animationCache.getAnimation(t);
    if (!n) {
      cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName);
      return;
    }
    var r = n.getFrames()[e];
    if (!r) {
      cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2);
      return;
    }
    this.setSpriteFrame(r.getSpriteFrame());
  },
  getBatchNode: function() {
    return this._batchNode;
  },
  _setReorderChildDirtyRecursively: function() {
    if (!this._reorderChildDirty) {
      this._reorderChildDirty = !0;
      for (var t = (this || window)._parent; t && t !== (this || window)._batchNode; )
        t._setReorderChildDirtyRecursively(), t = t.parent;
    }
  },
  getTexture: function() {
    return this._texture;
  },
  _softInit: function(t, e, n) {
    if (t === void 0)
      cc.Sprite.prototype.init.call(this);
    else if (cc.isString(t))
      if (t[0] === "#") {
        var r = t.substr(1, t.length - 1), s = cc.spriteFrameCache.getSpriteFrame(r);
        s ? this.initWithSpriteFrame(s) : cc.log("%s does not exist", t);
      } else
        cc.Sprite.prototype.init.call(this, t, e);
    else if (typeof t == "object") {
      if (t instanceof cc.Texture2D)
        this.initWithTexture(t, e, n);
      else if (t instanceof cc.SpriteFrame)
        this.initWithSpriteFrame(t);
      else if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) {
        var o = new cc.Texture2D();
        o.initWithElement(t), o.handleLoadedTexture(), this.initWithTexture(o);
      }
    }
  },
  getQuad: function() {
    return null;
  },
  setBlendFunc: function(t, e) {
    var n = (this || window)._blendFunc;
    e === void 0 ? (n.src = t.src, n.dst = t.dst) : (n.src = t, n.dst = e), this._renderCmd.updateBlendFunc(n);
  },
  init: function() {
    var t = (this || window);
    return arguments.length > 0 ? t.initWithFile(arguments[0], arguments[1]) : (cc.Node.prototype.init.call(t), t.dirty = t._recursiveDirty = !1, t._blendFunc.src = cc.BLEND_SRC, t._blendFunc.dst = cc.BLEND_DST, t.texture = null, t._flippedX = t._flippedY = !1, t.anchorX = 0.5, t.anchorY = 0.5, t._offsetPosition.x = 0, t._offsetPosition.y = 0, t._hasChildren = !1, t.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0)), !0);
  },
  initWithFile: function(t, e) {
    cc.assert(t, cc._LogInfos.Sprite_initWithFile);
    var n = cc.textureCache.getTextureForKey(t);
    if (n || (n = cc.textureCache.addImage(t)), !n.isLoaded())
      return this._loader.clear(), this._loader.once(n, function() {
        this.initWithFile(t, e), this.dispatchEvent("load");
      }, this), !1;
    if (!e) {
      var r = n.getContentSize();
      e = cc.rect(0, 0, r.width, r.height);
    }
    return this.initWithTexture(n, e);
  },
  initWithTexture: function(t, e, n, r) {
    var s = (this || window);
    return cc.assert(arguments.length !== 0, cc._LogInfos.CCSpriteBatchNode_initWithTexture), this._loader.clear(), s._textureLoaded = t.isLoaded(), s._textureLoaded ? (n = n || !1, t = (this || window)._renderCmd._handleTextureForRotatedTexture(t, e, n, r), cc.Node.prototype.init.call(s) ? (s._batchNode = null, s._recursiveDirty = !1, s.dirty = !1, s._opacityModifyRGB = !0, s._blendFunc.src = cc.BLEND_SRC, s._blendFunc.dst = cc.BLEND_DST, s._flippedX = s._flippedY = !1, s._offsetPosition.x = 0, s._offsetPosition.y = 0, s._hasChildren = !1, s._rectRotated = n, e && (s._rect.x = e.x, s._rect.y = e.y, s._rect.width = e.width, s._rect.height = e.height), e || (e = cc.rect(0, 0, t.width, t.height)), this._renderCmd._checkTextureBoundary(t, e, n), s.setTexture(t), s.setTextureRect(e, n), s.setBatchNode(null), !0) : !1) : (this._loader.once(t, function() {
      this.initWithTexture(t, e, n, r), this.dispatchEvent("load");
    }, this), !1);
  },
  setTextureRect: function(t, e, n, r) {
    var s = (this || window);
    s._rectRotated = e || !1, s.setContentSize(n || t), s.setVertexRect(t), s._renderCmd._setTextureCoords(t, r);
    var o = s._unflippedOffsetPositionFromCenter.x, a = s._unflippedOffsetPositionFromCenter.y;
    s._flippedX && (o = -o), s._flippedY && (a = -a);
    var c = s._rect;
    s._offsetPosition.x = o + (s._contentSize.width - c.width) / 2, s._offsetPosition.y = a + (s._contentSize.height - c.height) / 2;
  },
  addChild: function(t, e, n) {
    cc.assert(t, cc._LogInfos.CCSpriteBatchNode_addChild_2), e == null && (e = t._localZOrder), n == null && (n = t.tag), this._renderCmd._setBatchNodeForAddChild(t) && (cc.Node.prototype.addChild.call(this, t, e, n), this._hasChildren = !0);
  },
  setSpriteFrame: function(t) {
    var e = (this || window);
    cc.isString(t) && (t = cc.spriteFrameCache.getSpriteFrame(t), cc.assert(t, cc._LogInfos.Sprite_setSpriteFrame)), this._loader.clear(), this.setNodeDirty(!0);
    var n = t.getTexture();
    if (e._textureLoaded = t.textureLoaded(), this._loader.clear(), !e._textureLoaded)
      return this._loader.once(n, function() {
        this.setSpriteFrame(t), this.dispatchEvent("load");
      }, this), !1;
    var r = t.getOffset();
    e._unflippedOffsetPositionFromCenter.x = r.x, e._unflippedOffsetPositionFromCenter.y = r.y, n !== e._texture && (this._renderCmd._setTexture(n), e.setColor(e._realColor)), e.setTextureRect(t.getRect(), t.isRotated(), t.getOriginalSize());
  },
  setDisplayFrame: function(t) {
    cc.log(cc._LogInfos.Sprite_setDisplayFrame), this.setSpriteFrame(t);
  },
  isFrameDisplayed: function(t) {
    return this._renderCmd.isFrameDisplayed(t);
  },
  displayFrame: function() {
    return this.getSpriteFrame();
  },
  getSpriteFrame: function() {
    return new cc.SpriteFrame(
      this._texture,
      cc.rectPointsToPixels(this._rect),
      this._rectRotated,
      cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter),
      cc.sizePointsToPixels(this._contentSize)
    );
  },
  setBatchNode: function(t) {
    var e = (this || window);
    e._batchNode = t, e._batchNode ? (e._transformToBatch = cc.affineTransformIdentity(), e.textureAtlas = e._batchNode.getTextureAtlas()) : (e.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, e.textureAtlas = null, e._recursiveDirty = !1, e.dirty = !1);
  },
  setTexture: function(t) {
    if (!t)
      return this._renderCmd._setTexture(null);
    var e = cc.isString(t);
    if (e && (t = cc.textureCache.addImage(t)), this._loader.clear(), !t._textureLoaded)
      return this._loader.once(t, function() {
        this.setTexture(t), this.dispatchEvent("load");
      }, this), !1;
    this._renderCmd._setTexture(t), e && this._changeRectWithTexture(t), this.setColor(this._realColor), this._textureLoaded = !0;
  },
  _changeRectWithTexture: function(t) {
    var e = t._contentSize, n = cc.rect(
      0,
      0,
      e.width,
      e.height
    );
    this.setTextureRect(n);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Sprite.CanvasRenderCmd(this) : new cc.Sprite.WebGLRenderCmd(this);
  }
});
cc.Sprite.create = function(t, e, n) {
  return new cc.Sprite(t, e, n);
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
(function() {
  var t = cc.Sprite.LoadManager = function() {
    this.list = [];
  };
  t.prototype.add = function(e, n, r) {
    !e || !e.addEventListener || (e.addEventListener("load", n, r), this.list.push({
      source: e,
      listener: n,
      target: r
    }));
  }, t.prototype.once = function(e, n, r) {
    if (!(!e || !e.addEventListener)) {
      var s = /* @__PURE__ */ H(function(o) {
        e.removeEventListener("load", s, r), n.call(r, o);
      }, "tmpCallback");
      e.addEventListener("load", s, r), this.list.push({
        source: e,
        listener: s,
        target: r
      });
    }
  }, t.prototype.clear = function() {
    for (; this.list.length > 0; ) {
      var e = (this || window).list.pop();
      e.source.removeEventListener("load", e.listener, e.target);
    }
  };
})();
(function() {
  cc.Sprite.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !0, this._textureCoord = {
      renderX: 0,
      renderY: 0,
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      validRect: !1
    }, this._blendFuncStr = "source-over", this._colorized = !1, this._canUseDirtyRegion = !0, this._textureToRender = null;
  };
  var t = cc.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.Sprite.CanvasRenderCmd, t.setDirtyRecursively = function(e) {
  }, t._setTexture = function(e) {
    var n = (this || window)._node;
    n._texture !== e && (e ? n._textureLoaded = e._textureLoaded : n._textureLoaded = !1, n._texture = e, this._updateColor());
  }, t._setColorDirty = function() {
    this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty);
  }, t.isFrameDisplayed = function(e) {
    var n = (this || window)._node;
    return e.getTexture() !== n._texture ? !1 : cc.rectEqualToRect(e.getRect(), n._rect);
  }, t.updateBlendFunc = function(e) {
    this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(e);
  }, t._setBatchNodeForAddChild = function(e) {
    return !0;
  }, t._handleTextureForRotatedTexture = function(e, n, r, s) {
    if (r && e.isLoaded()) {
      var o = e.getHtmlElementObj();
      o = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(o, n, s);
      var a = new cc.Texture2D();
      a.initWithElement(o), a.handleLoadedTexture(), e = a, n.x = n.y = 0, this._node._rect = cc.rect(0, 0, n.width, n.height);
    }
    return e;
  }, t._checkTextureBoundary = function(e, n, r) {
    if (e && e.url) {
      var s = n.x + n.width, o = n.y + n.height;
      s > e.width && cc.error(cc._LogInfos.RectWidth, e.url), o > e.height && cc.error(cc._LogInfos.RectHeight, e.url);
    }
  }, t.rendering = function(e, n, r) {
    var s = (this || window)._node, o = (this || window)._textureCoord, a = (this || window)._displayedOpacity / 255, c = (this || window)._textureToRender || s._texture;
    if (!(c && (o.width === 0 || o.height === 0 || !c._textureLoaded) || a === 0)) {
      var l = e || cc._renderContext, h = l.getContext(), u = s._offsetPosition.x, _ = s._rect.height, d = s._rect.width, f = -s._offsetPosition.y - _, C;
      l.setTransform(this._worldTransform, n, r), l.setCompositeOperation(this._blendFuncStr), l.setGlobalAlpha(a), (s._flippedX || s._flippedY) && l.save(), s._flippedX && (u = -u - d, h.scale(-1, 1)), s._flippedY && (f = s._offsetPosition.y, h.scale(1, -1));
      var m, g, y, A, D, N, z, M;
      if (this._colorized ? (m = 0, g = 0) : (m = o.renderX, g = o.renderY), y = o.width, A = o.height, D = u, N = f, z = d, M = _, c && c._htmlElementObj)
        C = c._htmlElementObj, c._pattern !== "" ? (l.setFillStyle(h.createPattern(C, c._pattern)), h.fillRect(D, N, z, M)) : h.drawImage(
          C,
          m,
          g,
          y,
          A,
          D,
          N,
          z,
          M
        );
      else {
        var Z = s._contentSize;
        if (o.validRect) {
          var U = (this || window)._displayedColor;
          l.setFillStyle("rgba(" + U.r + "," + U.g + "," + U.b + ",1)"), h.fillRect(D, N, Z.width * n, Z.height * r);
        }
      }
      (s._flippedX || s._flippedY) && l.restore(), cc.g_NumberOfDraws++;
    }
  }, t._updateColor = function() {
    var e = (this || window)._node, n = e._texture, r = (this || window)._textureCoord, s = (this || window)._displayedColor;
    n && (s.r !== 255 || s.g !== 255 || s.b !== 255 ? (this._textureToRender = n._generateColorTexture(s.r, s.g, s.b, r), this._colorized = !0) : n && (this._textureToRender = n, this._colorized = !1));
  }, t._textureLoadedCallback = function(e) {
    var n = (this || window);
    if (!n._textureLoaded) {
      n._textureLoaded = !0;
      var r = n._rect, s = (this || window)._renderCmd;
      r ? cc._rectEqualToZero(r) && (r.width = e.width, r.height = e.height) : r = cc.rect(0, 0, e.width, e.height), n.texture = e, n.setTextureRect(r, n._rectRotated);
      var o = s._displayedColor;
      (o.r !== 255 || o.g !== 255 || o.b !== 255) && s._updateColor(), n.setBatchNode(n._batchNode), n.dispatchEvent("load");
    }
  }, t._setTextureCoords = function(e, n) {
    n === void 0 && (n = !0);
    var r = (this || window)._textureCoord, s = n ? cc.contentScaleFactor() : 1;
    r.renderX = r.x = 0 | e.x * s, r.renderY = r.y = 0 | e.y * s, r.width = 0 | e.width * s, r.height = 0 | e.height * s, r.validRect = !(r.width === 0 || r.height === 0 || r.x < 0 || r.y < 0);
  }, cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(e, n, r) {
    if (!e)
      return null;
    if (!n)
      return e;
    r = r == null ? !0 : r;
    var s = document.createElement("canvas");
    s.width = n.width, s.height = n.height;
    var o = s.getContext("2d");
    return o.translate(s.width / 2, s.height / 2), r ? o.rotate(-1.5707963267948966) : o.rotate(1.5707963267948966), o.drawImage(e, n.x, n.y, n.height, n.width, -n.height / 2, -n.width / 2, n.height, n.width), s;
  };
})();
cc.BakeSprite = cc.Sprite.extend({
  _cacheCanvas: null,
  _cacheContext: null,
  ctor: function() {
    cc.Sprite.prototype.ctor.call(this);
    var t = document.createElement("canvas");
    t.width = t.height = 10, this._cacheCanvas = t, this._cacheContext = new cc.CanvasContextWrapper(t.getContext("2d"));
    var e = new cc.Texture2D();
    e.initWithElement(t), e.handleLoadedTexture(), this.setTexture(e);
  },
  getCacheContext: function() {
    return this._cacheContext;
  },
  getCacheCanvas: function() {
    return this._cacheCanvas;
  },
  resetCanvasSize: function(t, e) {
    var n = (this || window)._cacheCanvas, r = (this || window)._cacheContext, s = r._context.strokeStyle, o = r._context.fillStyle;
    e === void 0 && (e = t.height, t = t.width), n.width = t, n.height = e, s !== r._context.strokeStyle && (r._context.strokeStyle = s), o !== r._context.fillStyle && (r._context.fillStyle = o), this.getTexture().handleLoadedTexture(), this.setTextureRect(cc.rect(0, 0, t, e), !1, null, !1);
  }
});
cc.AnimationFrame = cc.Class.extend({
  _spriteFrame: null,
  _delayPerUnit: 0,
  _userInfo: null,
  ctor: function(t, e, n) {
    this._spriteFrame = t || null, this._delayPerUnit = e || 0, this._userInfo = n || null;
  },
  clone: function() {
    var t = new cc.AnimationFrame();
    return t.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo), t;
  },
  copyWithZone: function(t) {
    return cc.clone(this);
  },
  copy: function(t) {
    var e = new cc.AnimationFrame();
    return e.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo), e;
  },
  initWithSpriteFrame: function(t, e, n) {
    return this._spriteFrame = t, this._delayPerUnit = e, this._userInfo = n, !0;
  },
  getSpriteFrame: function() {
    return this._spriteFrame;
  },
  setSpriteFrame: function(t) {
    this._spriteFrame = t;
  },
  getDelayUnits: function() {
    return this._delayPerUnit;
  },
  setDelayUnits: function(t) {
    this._delayPerUnit = t;
  },
  getUserInfo: function() {
    return this._userInfo;
  },
  setUserInfo: function(t) {
    this._userInfo = t;
  }
});
cc.AnimationFrame.create = function(t, e, n) {
  return new cc.AnimationFrame(t, e, n);
};
cc.Animation = cc.Class.extend({
  _frames: null,
  _loops: 0,
  _restoreOriginalFrame: !1,
  _duration: 0,
  _delayPerUnit: 0,
  _totalDelayUnits: 0,
  ctor: function(t, e, n) {
    if (this._frames = [], t === void 0)
      this.initWithSpriteFrames(null, 0);
    else {
      var r = t[0];
      r && (r instanceof cc.SpriteFrame ? this.initWithSpriteFrames(t, e, n) : r instanceof cc.AnimationFrame && this.initWithAnimationFrames(t, e, n));
    }
  },
  getFrames: function() {
    return this._frames;
  },
  setFrames: function(t) {
    this._frames = t;
  },
  addSpriteFrame: function(t) {
    var e = new cc.AnimationFrame();
    e.initWithSpriteFrame(t, 1, null), this._frames.push(e), this._totalDelayUnits++;
  },
  addSpriteFrameWithFile: function(t) {
    var e = cc.textureCache.addImage(t), n = cc.rect(0, 0, 0, 0);
    n.width = e.width, n.height = e.height;
    var r = new cc.SpriteFrame(e, n);
    this.addSpriteFrame(r);
  },
  addSpriteFrameWithTexture: function(t, e) {
    var n = new cc.SpriteFrame(t, e);
    this.addSpriteFrame(n);
  },
  initWithAnimationFrames: function(t, e, n) {
    cc.arrayVerifyType(t, cc.AnimationFrame), this._delayPerUnit = e, this._loops = n === void 0 ? 1 : n, this._totalDelayUnits = 0;
    var r = (this || window)._frames;
    r.length = 0;
    for (var s = 0; s < t.length; s++) {
      var o = t[s];
      r.push(o), this._totalDelayUnits += o.getDelayUnits();
    }
    return !0;
  },
  clone: function() {
    var t = new cc.Animation();
    return t.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops), t.setRestoreOriginalFrame(this._restoreOriginalFrame), t;
  },
  copyWithZone: function(t) {
    var e = new cc.Animation();
    return e.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops), e.setRestoreOriginalFrame(this._restoreOriginalFrame), e;
  },
  _copyFrames: function() {
    for (var t = [], e = 0; e < this._frames.length; e++)
      t.push(this._frames[e].clone());
    return t;
  },
  copy: function(t) {
    return this.copyWithZone(null);
  },
  getLoops: function() {
    return this._loops;
  },
  setLoops: function(t) {
    this._loops = t;
  },
  setRestoreOriginalFrame: function(t) {
    this._restoreOriginalFrame = t;
  },
  getRestoreOriginalFrame: function() {
    return this._restoreOriginalFrame;
  },
  getDuration: function() {
    return this._totalDelayUnits * this._delayPerUnit;
  },
  getDelayPerUnit: function() {
    return this._delayPerUnit;
  },
  setDelayPerUnit: function(t) {
    this._delayPerUnit = t;
  },
  getTotalDelayUnits: function() {
    return this._totalDelayUnits;
  },
  initWithSpriteFrames: function(t, e, n) {
    cc.arrayVerifyType(t, cc.SpriteFrame), this._loops = n === void 0 ? 1 : n, this._delayPerUnit = e || 0, this._totalDelayUnits = 0;
    var r = (this || window)._frames;
    if (r.length = 0, t) {
      for (var s = 0; s < t.length; s++) {
        var o = t[s], a = new cc.AnimationFrame();
        a.initWithSpriteFrame(o, 1, null), r.push(a);
      }
      this._totalDelayUnits += t.length;
    }
    return !0;
  },
  retain: function() {
  },
  release: function() {
  }
});
cc.Animation.create = function(t, e, n) {
  return new cc.Animation(t, e, n);
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
  _animations: {},
  addAnimation: function(t, e) {
    this._animations[e] = t;
  },
  removeAnimation: function(t) {
    t && this._animations[t] && delete this._animations[t];
  },
  getAnimation: function(t) {
    return this._animations[t] ? this._animations[t] : null;
  },
  _addAnimationsWithDictionary: function(t, e) {
    var n = t.animations;
    if (!n) {
      cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary);
      return;
    }
    var r = 1, s = t.properties;
    if (s) {
      r = s.format != null ? parseInt(s.format) : r;
      for (var o = s.spritesheets, a = cc.spriteFrameCache, c = cc.path, l = 0; l < o.length; l++)
        a.addSpriteFrames(c.changeBasename(e, o[l]));
    }
    switch (r) {
      case 1:
        this._parseVersion1(n);
        break;
      case 2:
        this._parseVersion2(n);
        break;
      default:
        cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2);
        break;
    }
  },
  addAnimations: function(t) {
    cc.assert(t, cc._LogInfos.animationCache_addAnimations_2);
    var e = cc.loader.getRes(t);
    if (!e) {
      cc.log(cc._LogInfos.animationCache_addAnimations);
      return;
    }
    this._addAnimationsWithDictionary(e, t);
  },
  _parseVersion1: function(t) {
    var e = cc.spriteFrameCache;
    for (var n in t) {
      var r = t[n], s = r.frames, o = parseFloat(r.delay) || 0, a = null;
      if (!s) {
        cc.log(cc._LogInfos.animationCache__parseVersion1, n);
        continue;
      }
      for (var c = [], l = 0; l < s.length; l++) {
        var h = e.getSpriteFrame(s[l]);
        if (!h) {
          cc.log(cc._LogInfos.animationCache__parseVersion1_2, n, s[l]);
          continue;
        }
        var u = new cc.AnimationFrame();
        u.initWithSpriteFrame(h, 1, null), c.push(u);
      }
      if (c.length === 0) {
        cc.log(cc._LogInfos.animationCache__parseVersion1_3, n);
        continue;
      } else
        c.length !== s.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, n);
      a = new cc.Animation(c, o, 1), cc.animationCache.addAnimation(a, n);
    }
  },
  _parseVersion2: function(t) {
    var e = cc.spriteFrameCache;
    for (var n in t) {
      var r = t[n], s = r.loop, o = parseInt(r.loops), a = s ? cc.REPEAT_FOREVER : isNaN(o) ? 1 : o, c = !!(r.restoreOriginalFrame && r.restoreOriginalFrame == !0), l = r.frames;
      if (!l) {
        cc.log(cc._LogInfos.animationCache__parseVersion2, n);
        continue;
      }
      for (var h = [], u = 0; u < l.length; u++) {
        var _ = l[u], d = _.spriteframe, f = e.getSpriteFrame(d);
        if (!f) {
          cc.log(cc._LogInfos.animationCache__parseVersion2_2, n, d);
          continue;
        }
        var C = parseFloat(_.delayUnits) || 0, m = _.notification, g = new cc.AnimationFrame();
        g.initWithSpriteFrame(f, C, m), h.push(g);
      }
      var y = parseFloat(r.delayPerUnit) || 0, A = new cc.Animation();
      A.initWithAnimationFrames(h, y, a), A.setRestoreOriginalFrame(c), cc.animationCache.addAnimation(A, n);
    }
  },
  _clear: function() {
    this._animations = {};
  }
};
cc.SpriteFrame = cc.Class.extend({
  _offset: null,
  _originalSize: null,
  _rectInPixels: null,
  _rotated: !1,
  _rect: null,
  _offsetInPixels: null,
  _originalSizeInPixels: null,
  _texture: null,
  _textureFilename: "",
  _textureLoaded: !1,
  ctor: function(t, e, n, r, s) {
    this._offset = cc.p(0, 0), this._offsetInPixels = cc.p(0, 0), this._originalSize = cc.size(0, 0), this._rotated = !1, this._originalSizeInPixels = cc.size(0, 0), this._textureFilename = "", this._texture = null, this._textureLoaded = !1, t !== void 0 && e !== void 0 && (n === void 0 || r === void 0 || s === void 0 ? this.initWithTexture(t, e) : this.initWithTexture(t, e, n, r, s));
  },
  textureLoaded: function() {
    return this._textureLoaded;
  },
  addLoadedEventListener: function(t, e) {
    this.addEventListener("load", t, e);
  },
  getRectInPixels: function() {
    var t = (this || window)._rectInPixels;
    return cc.rect(t.x, t.y, t.width, t.height);
  },
  setRectInPixels: function(t) {
    this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0)), this._rectInPixels.x = t.x, this._rectInPixels.y = t.y, this._rectInPixels.width = t.width, this._rectInPixels.height = t.height, this._rect = cc.rectPixelsToPoints(t);
  },
  isRotated: function() {
    return this._rotated;
  },
  setRotated: function(t) {
    this._rotated = t;
  },
  getRect: function() {
    var t = (this || window)._rect;
    return cc.rect(t.x, t.y, t.width, t.height);
  },
  setRect: function(t) {
    this._rect || (this._rect = cc.rect(0, 0, 0, 0)), this._rect.x = t.x, this._rect.y = t.y, this._rect.width = t.width, this._rect.height = t.height, this._rectInPixels = cc.rectPointsToPixels(this._rect);
  },
  getOffsetInPixels: function() {
    return cc.p(this._offsetInPixels);
  },
  setOffsetInPixels: function(t) {
    this._offsetInPixels.x = t.x, this._offsetInPixels.y = t.y, cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset);
  },
  getOriginalSizeInPixels: function() {
    return cc.size(this._originalSizeInPixels);
  },
  setOriginalSizeInPixels: function(t) {
    this._originalSizeInPixels.width = t.width, this._originalSizeInPixels.height = t.height;
  },
  getOriginalSize: function() {
    return cc.size(this._originalSize);
  },
  setOriginalSize: function(t) {
    this._originalSize.width = t.width, this._originalSize.height = t.height;
  },
  getTexture: function() {
    if (this._texture)
      return this._texture;
    if (this._textureFilename !== "") {
      var t = cc.textureCache.addImage(this._textureFilename);
      return t && (this._textureLoaded = t.isLoaded()), t;
    }
    return null;
  },
  setTexture: function(t) {
    if (this._texture !== t) {
      var e = t.isLoaded();
      this._textureLoaded = e, this._texture = t, e || t.addEventListener("load", function(n) {
        if (this._textureLoaded = !0, this._rotated && cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
          var r = n.getHtmlElementObj();
          r = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(r, this.getRect());
          var s = new cc.Texture2D();
          s.initWithElement(r), s.handleLoadedTexture(), this.setTexture(s);
          var o = (this || window).getRect();
          this.setRect(cc.rect(0, 0, o.width, o.height));
        }
        var a = (this || window)._rect;
        if (a.width === 0 && a.height === 0) {
          var c = n.width, l = n.height;
          this._rect.width = c, this._rect.height = l, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = (this || window)._rectInPixels.width, this._originalSizeInPixels.height = (this || window)._rectInPixels.height, this._originalSize.width = c, this._originalSize.height = l;
        }
        this.dispatchEvent("load");
      }, this);
    }
  },
  getOffset: function() {
    return cc.p(this._offset);
  },
  setOffset: function(t) {
    this._offset.x = t.x, this._offset.y = t.y;
  },
  clone: function() {
    var t = new cc.SpriteFrame();
    return t.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels), t.setTexture(this._texture), t;
  },
  copyWithZone: function() {
    var t = new cc.SpriteFrame();
    return t.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels), t.setTexture(this._texture), t;
  },
  copy: function() {
    return this.copyWithZone();
  },
  initWithTexture: function(t, e, n, r, s) {
    if (arguments.length === 2 && (e = cc.rectPointsToPixels(e)), r = r || cc.p(0, 0), s = s || e, n = n || !1, cc.isString(t) ? (this._texture = null, this._textureFilename = t) : t instanceof cc.Texture2D && this.setTexture(t), t = (this || window).getTexture(), this._rectInPixels = e, this._rect = cc.rectPixelsToPoints(e), t && t.url && t.isLoaded()) {
      var o, a;
      n ? (o = e.x + e.height, a = e.y + e.width) : (o = e.x + e.width, a = e.y + e.height), o > t.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, t.url), a > t.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, t.url);
    }
    return this._offsetInPixels.x = r.x, this._offsetInPixels.y = r.y, cc._pointPixelsToPointsOut(r, this._offset), this._originalSizeInPixels.width = s.width, this._originalSizeInPixels.height = s.height, cc._sizePixelsToPointsOut(s, this._originalSize), this._rotated = n, !0;
  }
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function(t, e, n, r, s) {
  return new cc.SpriteFrame(t, e, n, r, s);
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function(t, e, n, r, s) {
  var o = new cc.SpriteFrame();
  return o._texture = t, o._rectInPixels = e, o._rect = cc.rectPixelsToPoints(e), o._offsetInPixels.x = r.x, o._offsetInPixels.y = r.y, cc._pointPixelsToPointsOut(o._offsetInPixels, o._offset), o._originalSizeInPixels.width = s.width, o._originalSizeInPixels.height = s.height, cc._sizePixelsToPointsOut(o._originalSizeInPixels, o._originalSize), o._rotated = n, o;
};
cc.spriteFrameCache = {
  _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
  _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
  _spriteFrames: {},
  _spriteFramesAliases: {},
  _frameConfigCache: {},
  _rectFromString: function(t) {
    var e = (this || window)._CCNS_REG2.exec(t);
    return e ? cc.rect(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]), parseFloat(e[4])) : cc.rect(0, 0, 0, 0);
  },
  _pointFromString: function(t) {
    var e = (this || window)._CCNS_REG1.exec(t);
    return e ? cc.p(parseFloat(e[1]), parseFloat(e[2])) : cc.p(0, 0);
  },
  _sizeFromString: function(t) {
    var e = (this || window)._CCNS_REG1.exec(t);
    return e ? cc.size(parseFloat(e[1]), parseFloat(e[2])) : cc.size(0, 0);
  },
  _getFrameConfig: function(t) {
    var e = cc.loader.getRes(t);
    return cc.assert(e, cc._LogInfos.spriteFrameCache__getFrameConfig_2, t), cc.loader.release(t), e._inited ? (this._frameConfigCache[t] = e, e) : (this._frameConfigCache[t] = (this || window)._parseFrameConfig(e), this._frameConfigCache[t]);
  },
  _getFrameConfigByJsonObject: function(t, e) {
    return cc.assert(e, cc._LogInfos.spriteFrameCache__getFrameConfig_2, t), this._frameConfigCache[t] = (this || window)._parseFrameConfig(e), this._frameConfigCache[t];
  },
  _parseFrameConfig: function(t) {
    var e = t.frames, n = t.metadata || t.meta, r = {}, s = {}, o = 0;
    if (n) {
      var a = n.format;
      o = a.length <= 1 ? parseInt(a) : a, s.image = n.textureFileName || n.textureFileName || n.image;
    }
    for (var c in e) {
      var l = e[c];
      if (l) {
        var h = {};
        if (o == 0) {
          h.rect = cc.rect(l.x, l.y, l.width, l.height), h.rotated = !1, h.offset = cc.p(l.offsetX, l.offsetY);
          var u = l.originalWidth, _ = l.originalHeight;
          (!u || !_) && cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig), u = Math.abs(u), _ = Math.abs(_), h.size = cc.size(u, _);
        } else if (o == 1 || o == 2)
          h.rect = (this || window)._rectFromString(l.frame), h.rotated = l.rotated || !1, h.offset = (this || window)._pointFromString(l.offset), h.size = (this || window)._sizeFromString(l.sourceSize);
        else if (o == 3) {
          var d = (this || window)._sizeFromString(l.spriteSize), f = (this || window)._rectFromString(l.textureRect);
          d && (f = cc.rect(f.x, f.y, d.width, d.height)), h.rect = f, h.rotated = l.textureRotated || !1, h.offset = (this || window)._pointFromString(l.spriteOffset), h.size = (this || window)._sizeFromString(l.spriteSourceSize), h.aliases = l.aliases;
        } else {
          var C = l.frame, m = l.sourceSize;
          c = l.filename || c, h.rect = cc.rect(C.x, C.y, C.w, C.h), h.rotated = l.rotated || !1, h.offset = cc.p(0, 0), h.size = cc.size(m.w, m.h);
        }
        r[c] = h;
      }
    }
    return { _inited: !0, frames: r, meta: s };
  },
  _addSpriteFramesByObject: function(t, e, n) {
    if (cc.assert(t, cc._LogInfos.spriteFrameCache_addSpriteFrames_2), !(!e || !e.frames)) {
      var r = (this || window)._frameConfigCache[t] || this._getFrameConfigByJsonObject(t, e);
      this._createSpriteFrames(t, r, n);
    }
  },
  _createSpriteFrames: function(t, e, n) {
    var r = e.frames, s = e.meta;
    if (n)
      n instanceof cc.Texture2D || (cc.isString(n) ? n = cc.textureCache.addImage(n) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3));
    else {
      var o = cc.path.changeBasename(t, s.image || ".png");
      n = cc.textureCache.addImage(o);
    }
    var a = (this || window)._spriteFramesAliases, c = (this || window)._spriteFrames;
    for (var l in r) {
      var h = r[l], u = c[l];
      if (!u) {
        u = new cc.SpriteFrame(n, h.rect, h.rotated, h.offset, h.size);
        var _ = h.aliases;
        if (_)
          for (var d = 0, f = _.length; d < f; d++) {
            var C = _[d];
            a[C] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, C), a[C] = l;
          }
        if (cc._renderType === cc.game.RENDER_TYPE_CANVAS && u.isRotated()) {
          var m = u.getTexture();
          if (m.isLoaded()) {
            var g = u.getTexture().getHtmlElementObj();
            g = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(g, u.getRectInPixels());
            var y = new cc.Texture2D();
            y.initWithElement(g), y.handleLoadedTexture(), u.setTexture(y);
            var A = u._rect;
            u.setRect(cc.rect(0, 0, A.width, A.height));
          }
        }
        c[l] = u;
      }
    }
  },
  addSpriteFrames: function(t, e) {
    cc.assert(t, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
    var n = (this || window)._frameConfigCache[t] || cc.loader.getRes(t);
    if (!(!n || !n.frames)) {
      var r = (this || window)._frameConfigCache[t] || this._getFrameConfig(t);
      this._createSpriteFrames(t, r, e);
    }
  },
  _checkConflict: function(t) {
    var e = t.frames;
    for (var n in e)
      this._spriteFrames[n] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, n);
  },
  addSpriteFrame: function(t, e) {
    this._spriteFrames[e] = t;
  },
  removeSpriteFrames: function() {
    this._spriteFrames = {}, this._spriteFramesAliases = {};
  },
  removeSpriteFrameByName: function(t) {
    t && (this._spriteFramesAliases[t] && delete this._spriteFramesAliases[t], this._spriteFrames[t] && delete this._spriteFrames[t]);
  },
  removeSpriteFramesFromFile: function(t) {
    var e = (this || window), n = e._spriteFrames, r = e._spriteFramesAliases, s = e._frameConfigCache[t];
    if (s) {
      var o = s.frames;
      for (var a in o)
        if (n[a]) {
          delete n[a];
          for (var c in r)
            r[c] === a && delete r[c];
        }
    }
  },
  removeSpriteFramesFromTexture: function(t) {
    var e = (this || window), n = e._spriteFrames, r = e._spriteFramesAliases;
    for (var s in n) {
      var o = n[s];
      if (o && o.getTexture() === t) {
        delete n[s];
        for (var a in r)
          r[a] === s && delete r[a];
      }
    }
  },
  getSpriteFrame: function(t) {
    var e = (this || window), n = e._spriteFrames[t];
    if (!n) {
      var r = e._spriteFramesAliases[t];
      r && (n = e._spriteFrames[r.toString()], n || delete e._spriteFramesAliases[t]);
    }
    return n;
  },
  _clear: function() {
    this._spriteFrames = {}, this._spriteFramesAliases = {}, this._frameConfigCache = {};
  }
};
cc.g_NumberOfDraws = 0;
cc.Director = cc.Class.extend({
  _landscape: !1,
  _nextDeltaTimeZero: !1,
  _paused: !1,
  _purgeDirectorInNextLoop: !1,
  _sendCleanupToScene: !1,
  _animationInterval: 0,
  _oldAnimationInterval: 0,
  _projection: 0,
  _contentScaleFactor: 1,
  _deltaTime: 0,
  _winSizeInPoints: null,
  _lastUpdate: null,
  _nextScene: null,
  _notificationNode: null,
  _openGLView: null,
  _scenesStack: null,
  _projectionDelegate: null,
  _runningScene: null,
  _totalFrames: 0,
  _secondsPerFrame: 0,
  _dirtyRegion: null,
  _scheduler: null,
  _actionManager: null,
  _eventProjectionChanged: null,
  _eventAfterUpdate: null,
  _eventAfterVisit: null,
  _eventAfterDraw: null,
  ctor: function() {
    var t = (this || window);
    t._lastUpdate = Date.now(), cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
      t._lastUpdate = Date.now();
    });
  },
  init: function() {
    return this._oldAnimationInterval = (this || window)._animationInterval = 1 / cc.defaultFPS, this._scenesStack = [], this._projection = cc.Director.PROJECTION_DEFAULT, this._projectionDelegate = null, this._totalFrames = 0, this._lastUpdate = Date.now(), this._paused = !1, this._purgeDirectorInNextLoop = !1, this._winSizeInPoints = cc.size(0, 0), this._openGLView = null, this._contentScaleFactor = 1, this._scheduler = new cc.Scheduler(), cc.ActionManager ? (this._actionManager = new cc.ActionManager(), this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1)) : this._actionManager = null, this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE), this._eventAfterUpdate.setUserData(this), this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT), this._eventAfterVisit.setUserData(this), this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW), this._eventAfterDraw.setUserData(this), this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED), this._eventProjectionChanged.setUserData(this), !0;
  },
  calculateDeltaTime: function() {
    var t = Date.now();
    this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (t - this._lastUpdate) / 1e3, cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0 && this._deltaTime > 0.2 && (this._deltaTime = 1 / 60), this._lastUpdate = t;
  },
  convertToGL: function(t) {
    var e = document.documentElement, n = cc.view, r = element.getBoundingClientRect();
    r.left += window.pageXOffset - e.clientLeft, r.top += window.pageYOffset - e.clientTop;
    var s = n._devicePixelRatio * (t.x - r.left), o = n._devicePixelRatio * (r.top + r.height - t.y);
    return n._isRotated ? { x: n._viewPortRect.width - o, y: s } : { x: s, y: o };
  },
  convertToUI: function(t) {
    var e = document.documentElement, n = cc.view, r = element.getBoundingClientRect();
    r.left += window.pageXOffset - e.clientLeft, r.top += window.pageYOffset - e.clientTop;
    var s = { x: 0, y: 0 };
    return n._isRotated ? (s.x = r.left + t.y / n._devicePixelRatio, s.y = r.top + r.height - (n._viewPortRect.width - t.x) / n._devicePixelRatio) : (s.x = r.left + t.x / n._devicePixelRatio, s.y = r.top + r.height - t.y / n._devicePixelRatio), s;
  },
  drawScene: function() {
    var t = cc.renderer;
    this.calculateDeltaTime(), this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate)), this._nextScene && this.setNextScene(), this._beforeVisitScene && this._beforeVisitScene(), this._runningScene && (t.childrenOrderDirty ? (cc.renderer.clearRenderCommands(), cc.renderer.assignedZ = 0, this._runningScene._renderCmd._curLevel = 0, this._runningScene.visit(), t.resetFlag()) : t.transformDirty() && t.transform()), t.clear(), this._notificationNode && this._notificationNode.visit(), cc.eventManager.dispatchEvent(this._eventAfterVisit), cc.g_NumberOfDraws = 0, this._afterVisitScene && this._afterVisitScene(), t.rendering(cc._renderContext), this._totalFrames++, cc.eventManager.dispatchEvent(this._eventAfterDraw), this._calculateMPF();
  },
  _beforeVisitScene: null,
  _afterVisitScene: null,
  end: function() {
    this._purgeDirectorInNextLoop = !0;
  },
  getContentScaleFactor: function() {
    return this._contentScaleFactor;
  },
  getNotificationNode: function() {
    return this._notificationNode;
  },
  getWinSize: function() {
    return cc.size(this._winSizeInPoints);
  },
  getWinSizeInPixels: function() {
    return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
  },
  getVisibleSize: null,
  getVisibleOrigin: null,
  getZEye: null,
  pause: function() {
    this._paused || (this._oldAnimationInterval = (this || window)._animationInterval, this.setAnimationInterval(1 / 4), this._paused = !0);
  },
  popScene: function() {
    cc.assert(this._runningScene, cc._LogInfos.Director_popScene), this._scenesStack.pop();
    var t = (this || window)._scenesStack.length;
    t === 0 ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = (this || window)._scenesStack[t - 1]);
  },
  purgeCachedData: function() {
    cc.animationCache._clear(), cc.spriteFrameCache._clear(), cc.textureCache._clear();
  },
  purgeDirector: function() {
    this.getScheduler().unscheduleAll(), cc.eventManager && cc.eventManager.setEnabled(!1), this._runningScene && (this._runningScene.onExitTransitionDidStart(), this._runningScene.onExit(), this._runningScene.cleanup()), this._runningScene = null, this._nextScene = null, this._scenesStack.length = 0, this.stopAnimation(), this.purgeCachedData(), cc.checkGLErrorDebug();
  },
  pushScene: function(t) {
    cc.assert(t, cc._LogInfos.Director_pushScene), this._sendCleanupToScene = !1, this._scenesStack.push(t), this._nextScene = t;
  },
  runScene: function(t) {
    if (cc.assert(t, cc._LogInfos.Director_pushScene), !this._runningScene)
      this.pushScene(t), this.startAnimation();
    else {
      var e = (this || window)._scenesStack.length;
      e === 0 ? (this._sendCleanupToScene = !0, this._scenesStack[e] = t, this._nextScene = t) : (this._sendCleanupToScene = !0, this._scenesStack[e - 1] = t, this._nextScene = t);
    }
  },
  resume: function() {
    this._paused && (this.setAnimationInterval(this._oldAnimationInterval), this._lastUpdate = Date.now(), this._lastUpdate || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0);
  },
  setContentScaleFactor: function(t) {
    t !== (this || window)._contentScaleFactor && (this._contentScaleFactor = t);
  },
  setDepthTest: null,
  setClearColor: null,
  setDefaultValues: function() {
  },
  setNextDeltaTimeZero: function(t) {
    this._nextDeltaTimeZero = t;
  },
  setNextScene: function() {
    var t = !1, e = !1;
    if (cc.TransitionScene && (t = (this || window)._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, e = (this || window)._nextScene ? this._nextScene instanceof cc.TransitionScene : !1), !e) {
      var n = (this || window)._runningScene;
      n && (n.onExitTransitionDidStart(), n.onExit()), this._sendCleanupToScene && n && n.cleanup();
    }
    this._runningScene = (this || window)._nextScene, cc.renderer.childrenOrderDirty = !0, this._nextScene = null, !t && this._runningScene !== null && (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish());
  },
  setNotificationNode: function(t) {
    cc.renderer.childrenOrderDirty = !0, this._notificationNode && (this._notificationNode.onExitTransitionDidStart(), this._notificationNode.onExit(), this._notificationNode.cleanup()), this._notificationNode = t, t && (this._notificationNode.onEnter(), this._notificationNode.onEnterTransitionDidFinish());
  },
  getDelegate: function() {
    return this._projectionDelegate;
  },
  setDelegate: function(t) {
    this._projectionDelegate = t;
  },
  setOpenGLView: null,
  setProjection: null,
  setViewport: null,
  getOpenGLView: null,
  getProjection: null,
  setAlphaBlending: null,
  isSendCleanupToScene: function() {
    return this._sendCleanupToScene;
  },
  getRunningScene: function() {
    return this._runningScene;
  },
  getAnimationInterval: function() {
    return this._animationInterval;
  },
  isDisplayStats: function() {
    return cc.profiler ? cc.profiler.isShowingStats() : !1;
  },
  setDisplayStats: function(t) {
    cc.profiler && (t ? cc.profiler.showStats() : cc.profiler.hideStats());
  },
  getSecondsPerFrame: function() {
    return this._secondsPerFrame;
  },
  isNextDeltaTimeZero: function() {
    return this._nextDeltaTimeZero;
  },
  isPaused: function() {
    return this._paused;
  },
  getTotalFrames: function() {
    return this._totalFrames;
  },
  popToRootScene: function() {
    this.popToSceneStackLevel(1);
  },
  popToSceneStackLevel: function(t) {
    cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
    var e = (this || window)._scenesStack, n = e.length;
    if (t === 0) {
      this.end();
      return;
    }
    if (!(t >= n)) {
      for (; n > t; ) {
        var r = e.pop();
        r.running && (r.onExitTransitionDidStart(), r.onExit()), r.cleanup(), n--;
      }
      this._nextScene = e[e.length - 1], this._sendCleanupToScene = !0;
    }
  },
  getScheduler: function() {
    return this._scheduler;
  },
  setScheduler: function(t) {
    this._scheduler !== t && (this._scheduler = t);
  },
  getActionManager: function() {
    return this._actionManager;
  },
  setActionManager: function(t) {
    this._actionManager !== t && (this._actionManager = t);
  },
  getDeltaTime: function() {
    return this._deltaTime;
  },
  _calculateMPF: function() {
    var t = Date.now();
    this._secondsPerFrame = (t - this._lastUpdate) / 1e3;
  }
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.DisplayLinkDirector = cc.Director.extend({
  invalid: !1,
  startAnimation: function() {
    this._nextDeltaTimeZero = !0, this.invalid = !1;
  },
  mainLoop: function() {
    this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene();
  },
  stopAnimation: function() {
    this.invalid = !0;
  },
  setAnimationInterval: function(t) {
    this._animationInterval = t, this.invalid || (this.stopAnimation(), this.startAnimation());
  }
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function() {
  return cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector(), cc.Director.sharedDirector.init()), cc.Director.sharedDirector;
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_2D;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
    var t = cc.Director.prototype;
    t.getProjection = function(e) {
      return this._projection;
    }, t.setProjection = function(e) {
      this._projection = e, cc.eventManager.dispatchEvent(this._eventProjectionChanged);
    }, t.setDepthTest = function() {
    }, t.setClearColor = function(e) {
      cc.renderer._clearColor = e, cc.renderer._clearFillStyle = "rgb(" + e.r + "," + e.g + "," + e.b + ")";
    }, t.setOpenGLView = function(e) {
      this._winSizeInPoints.width = cc._canvas.width, this._winSizeInPoints.height = cc._canvas.height, this._openGLView = e || cc.view, cc.eventManager && cc.eventManager.setEnabled(!0);
    }, t.getVisibleSize = function() {
      return this.getWinSize();
    }, t.getVisibleOrigin = function() {
      return cc.p(0, 0);
    };
  } else
    cc.Director._fpsImage = new Image(), cc.Director._fpsImage.addEventListener("load", function() {
      cc.Director._fpsImageLoaded = !0;
    }), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage);
});
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function(t, e, n, r, s, o, a) {
  this.prev = t, this.next = e, this.callback = n, this.target = r, this.priority = s, this.paused = o, this.markedForDeletion = a;
};
cc.HashUpdateEntry = function(t, e, n, r, s) {
  this.list = t, this.entry = e, this.target = n, this.callback = r, this.hh = s;
};
cc.HashTimerEntry = cc.hashSelectorEntry = function(t, e, n, r, s, o, a) {
  var c = (this || window);
  c.timers = t, c.target = e, c.timerIndex = n, c.currentTimer = r, c.currentTimerSalvaged = s, c.paused = o, c.hh = a;
};
cc.Timer = cc.Class.extend({
  _scheduler: null,
  _elapsed: 0,
  _runForever: !1,
  _useDelay: !1,
  _timesExecuted: 0,
  _repeat: 0,
  _delay: 0,
  _interval: 0,
  getInterval: function() {
    return this._interval;
  },
  setInterval: function(t) {
    this._interval = t;
  },
  setupTimerWithInterval: function(t, e, n) {
    this._elapsed = -1, this._interval = t, this._delay = n, this._useDelay = (this || window)._delay > 0, this._repeat = e, this._runForever = (this || window)._repeat === cc.REPEAT_FOREVER;
  },
  trigger: function() {
    return 0;
  },
  cancel: function() {
    return 0;
  },
  ctor: function() {
    this._scheduler = null, this._elapsed = -1, this._runForever = !1, this._useDelay = !1, this._timesExecuted = 0, this._repeat = 0, this._delay = 0, this._interval = 0;
  },
  update: function(t) {
    this._elapsed === -1 ? (this._elapsed = 0, this._timesExecuted = 0) : (this._elapsed += t, this._runForever && !this._useDelay ? this._elapsed >= (this || window)._interval && (this.trigger(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= (this || window)._delay && (this.trigger(), this._elapsed -= (this || window)._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= (this || window)._interval && (this.trigger(), this._elapsed = 0, this._timesExecuted += 1), !this._runForever && this._timesExecuted > this._repeat && this.cancel()));
  }
});
cc.TimerTargetSelector = cc.Timer.extend({
  _target: null,
  _selector: null,
  ctor: function() {
    this._target = null, this._selector = null;
  },
  initWithSelector: function(t, e, n, r, s, o) {
    return this._scheduler = t, this._target = n, this._selector = e, this.setupTimerWithInterval(r, s, o), !0;
  },
  getSelector: function() {
    return this._selector;
  },
  trigger: function() {
    this._target && this._selector && this._target.call(this._selector, this._elapsed);
  },
  cancel: function() {
    this._scheduler.unschedule(this._selector, this._target);
  }
});
cc.TimerTargetCallback = cc.Timer.extend({
  _target: null,
  _callback: null,
  _key: null,
  ctor: function() {
    this._target = null, this._callback = null;
  },
  initWithCallback: function(t, e, n, r, s, o, a) {
    return this._scheduler = t, this._target = n, this._callback = e, this._key = r, this.setupTimerWithInterval(s, o, a), !0;
  },
  getCallback: function() {
    return this._callback;
  },
  getKey: function() {
    return this._key;
  },
  trigger: function() {
    this._callback && this._callback.call(this._target, this._elapsed);
  },
  cancel: function() {
    this._scheduler.unschedule(this._callback, this._target);
  }
});
cc.Scheduler = cc.Class.extend({
  _timeScale: 1,
  _updatesNegList: null,
  _updates0List: null,
  _updatesPosList: null,
  _hashForTimers: null,
  _arrayForTimers: null,
  _hashForUpdates: null,
  _currentTarget: null,
  _currentTargetSalvaged: !1,
  _updateHashLocked: !1,
  ctor: function() {
    this._timeScale = 1, this._updatesNegList = [], this._updates0List = [], this._updatesPosList = [], this._hashForUpdates = {}, this._hashForTimers = {}, this._currentTarget = null, this._currentTargetSalvaged = !1, this._updateHashLocked = !1, this._arrayForTimers = [];
  },
  _schedulePerFrame: function(t, e, n, r) {
    var s = (this || window)._hashForUpdates[e.__instanceId];
    if (s && s.entry)
      if (s.entry.priority !== n)
        if (this._updateHashLocked) {
          cc.log("warning: you CANNOT change update priority in scheduled function"), s.entry.markedForDeletion = !1, s.entry.paused = r;
          return;
        } else
          this.unscheduleUpdate(e);
      else {
        s.entry.markedForDeletion = !1, s.entry.paused = r;
        return;
      }
    n === 0 ? this._appendIn(this._updates0List, t, e, r) : n < 0 ? this._priorityIn(this._updatesNegList, t, e, n, r) : this._priorityIn(this._updatesPosList, t, e, n, r);
  },
  _removeHashElement: function(t) {
    delete this._hashForTimers[t.target.__instanceId], cc.arrayRemoveObject(this._arrayForTimers, t), t.Timer = null, t.target = null, t = null;
  },
  _removeUpdateFromHash: function(t) {
    var e = (this || window), n = e._hashForUpdates[t.target.__instanceId];
    n && (cc.arrayRemoveObject(n.list, n.entry), delete e._hashForUpdates[n.target.__instanceId], n.entry = null, n.target = null);
  },
  _priorityIn: function(t, e, n, r, s) {
    var o = (this || window), a = new cc.ListEntry(null, null, e, n, r, s, !1);
    if (!t)
      t = [], t.push(a);
    else {
      for (var c = t.length - 1, l = 0; l <= c; l++)
        if (r < t[l].priority) {
          c = l;
          break;
        }
      t.splice(l, 0, a);
    }
    return o._hashForUpdates[n.__instanceId] = new cc.HashUpdateEntry(t, a, n, null), t;
  },
  _appendIn: function(t, e, n, r) {
    var s = (this || window), o = new cc.ListEntry(null, null, e, n, 0, r, !1);
    t.push(o), s._hashForUpdates[n.__instanceId] = new cc.HashUpdateEntry(t, o, n, null, null);
  },
  setTimeScale: function(t) {
    this._timeScale = t;
  },
  getTimeScale: function() {
    return this._timeScale;
  },
  update: function(t) {
    this._updateHashLocked = !0, this._timeScale !== 1 && (t *= (this || window)._timeScale);
    var e, n, r, s;
    for (e = 0, n = (this || window)._updatesNegList, r = n.length; e < r; e++)
      s = n[e], !s.paused && !s.markedForDeletion && s.callback(t);
    for (e = 0, n = (this || window)._updates0List, r = n.length; e < r; e++)
      s = n[e], !s.paused && !s.markedForDeletion && s.callback(t);
    for (e = 0, n = (this || window)._updatesPosList, r = n.length; e < r; e++)
      s = n[e], !s.paused && !s.markedForDeletion && s.callback(t);
    var o, a = (this || window)._arrayForTimers;
    for (e = 0; e < a.length; e++) {
      if (o = a[e], this._currentTarget = o, this._currentTargetSalvaged = !1, !o.paused)
        for (o.timerIndex = 0; o.timerIndex < o.timers.length; ++o.timerIndex)
          o.currentTimer = o.timers[o.timerIndex], o.currentTimerSalvaged = !1, o.currentTimer.update(t), o.currentTimer = null;
      this._currentTargetSalvaged && this._currentTarget.timers.length === 0 && this._removeHashElement(this._currentTarget);
    }
    for (e = 0, n = (this || window)._updatesNegList; e < n.length; )
      s = n[e], s.markedForDeletion ? this._removeUpdateFromHash(s) : e++;
    for (e = 0, n = (this || window)._updates0List; e < n.length; )
      s = n[e], s.markedForDeletion ? this._removeUpdateFromHash(s) : e++;
    for (e = 0, n = (this || window)._updatesPosList; e < n.length; )
      s = n[e], s.markedForDeletion ? this._removeUpdateFromHash(s) : e++;
    this._updateHashLocked = !1, this._currentTarget = null;
  },
  scheduleCallbackForTarget: function(t, e, n, r, s, o) {
    this.schedule(e, t, n, r, s, o, t.__instanceId + "");
  },
  schedule: function(t, e, n, r, s, o, a) {
    var c = !1;
    if (typeof t != "function") {
      var l = t;
      c = !0;
    }
    c === !1 ? (arguments.length === 4 || arguments.length === 5) && (a = s, o = r, s = 0, r = cc.REPEAT_FOREVER) : arguments.length === 4 && (o = r, r = cc.REPEAT_FOREVER, s = 0), a === void 0 && (a = e.__instanceId + ""), cc.assert(e, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
    var h = (this || window)._hashForTimers[e.__instanceId];
    h ? cc.assert(h.paused === o, "") : (h = new cc.HashTimerEntry(null, e, 0, null, null, o, null), this._arrayForTimers.push(h), this._hashForTimers[e.__instanceId] = h);
    var u, _;
    if (h.timers == null)
      h.timers = [];
    else if (c === !1) {
      for (_ = 0; _ < h.timers.length; _++)
        if (u = h.timers[_], t === u._callback) {
          cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, u.getInterval().toFixed(4), n.toFixed(4)), u._interval = n;
          return;
        }
    } else
      for (_ = 0; _ < h.timers.length; ++_)
        if (u = h.timers[_], u && l === u.getSelector()) {
          cc.log("CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f", u.getInterval(), n), u.setInterval(n);
          return;
        }
    c === !1 ? (u = new cc.TimerTargetCallback(), u.initWithCallback(this, t, e, a, n, r, s), h.timers.push(u)) : (u = new cc.TimerTargetSelector(), u.initWithSelector(this, l, e, n, r, s), h.timers.push(u));
  },
  scheduleUpdate: function(t, e, n) {
    this._schedulePerFrame(function(r) {
      t.update(r);
    }, t, e, n);
  },
  _getUnscheduleMark: function(t, e) {
    switch (typeof t) {
      case "number":
      case "string":
        return t === e.getKey();
      case "function":
        return t === e._callback;
      default:
        return t === e.getSelector();
    }
  },
  unschedule: function(t, e) {
    if (!(!e || !t)) {
      var n = (this || window), r = n._hashForTimers[e.__instanceId];
      if (r)
        for (var s = r.timers, o = 0, a = s.length; o < a; o++) {
          var c = s[o];
          if (this._getUnscheduleMark(t, c)) {
            c === r.currentTimer && !r.currentTimerSalvaged && (r.currentTimerSalvaged = !0), s.splice(o, 1), r.timerIndex >= o && r.timerIndex--, s.length === 0 && (n._currentTarget === r ? n._currentTargetSalvaged = !0 : n._removeHashElement(r));
            return;
          }
        }
    }
  },
  unscheduleUpdate: function(t) {
    if (t != null) {
      var e = (this || window)._hashForUpdates[t.__instanceId];
      e && (this._updateHashLocked ? e.entry.markedForDeletion = !0 : this._removeUpdateFromHash(e.entry));
    }
  },
  unscheduleAllForTarget: function(t) {
    if (t != null) {
      var e = (this || window)._hashForTimers[t.__instanceId];
      e && (e.timers.indexOf(e.currentTimer) > -1 && !e.currentTimerSalvaged && (e.currentTimerSalvaged = !0), e.timers.length = 0, this._currentTarget === e ? this._currentTargetSalvaged = !0 : this._removeHashElement(e)), this.unscheduleUpdate(t);
    }
  },
  unscheduleAll: function() {
    this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
  },
  unscheduleAllWithMinPriority: function(t) {
    var e, n, r = (this || window)._arrayForTimers;
    for (e = r.length - 1; e >= 0; e--)
      n = r[e], this.unscheduleAllForTarget(n.target);
    var s, o = 0;
    if (t < 0)
      for (e = 0; e < this._updatesNegList.length; )
        o = (this || window)._updatesNegList.length, s = (this || window)._updatesNegList[e], s && s.priority >= t && this.unscheduleUpdate(s.target), o == (this || window)._updatesNegList.length && e++;
    if (t <= 0)
      for (e = 0; e < this._updates0List.length; )
        o = (this || window)._updates0List.length, s = (this || window)._updates0List[e], s && this.unscheduleUpdate(s.target), o == (this || window)._updates0List.length && e++;
    for (e = 0; e < this._updatesPosList.length; )
      o = (this || window)._updatesPosList.length, s = (this || window)._updatesPosList[e], s && s.priority >= t && this.unscheduleUpdate(s.target), o == (this || window)._updatesPosList.length && e++;
  },
  isScheduled: function(t, e) {
    cc.assert(t, "Argument key must not be empty"), cc.assert(e, "Argument target must be non-nullptr");
    var n = (this || window)._hashForUpdates[e.__instanceId];
    if (!n || n.timers == null)
      return !1;
    for (var r = n.timers, s = 0; s < r.length; ++s) {
      var o = r[s];
      if (t === o.getKey())
        return !0;
    }
    return !1;
  },
  pauseAllTargets: function() {
    return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
  },
  pauseAllTargetsWithMinPriority: function(t) {
    var e = [], n = (this || window), r, s = n._arrayForTimers, o, a;
    for (o = 0, a = s.length; o < a; o++)
      r = s[o], r && (r.paused = !0, e.push(r.target));
    var c;
    if (t < 0)
      for (o = 0; o < this._updatesNegList.length; o++)
        c = (this || window)._updatesNegList[o], c && c.priority >= t && (c.paused = !0, e.push(c.target));
    if (t <= 0)
      for (o = 0; o < this._updates0List.length; o++)
        c = (this || window)._updates0List[o], c && (c.paused = !0, e.push(c.target));
    for (o = 0; o < this._updatesPosList.length; o++)
      c = (this || window)._updatesPosList[o], c && c.priority >= t && (c.paused = !0, e.push(c.target));
    return e;
  },
  resumeTargets: function(t) {
    if (t)
      for (var e = 0; e < t.length; e++)
        this.resumeTarget(t[e]);
  },
  pauseTarget: function(t) {
    cc.assert(t, cc._LogInfos.Scheduler_pauseTarget);
    var e = (this || window), n = e._hashForTimers[t.__instanceId];
    n && (n.paused = !0);
    var r = e._hashForUpdates[t.__instanceId];
    r && (r.entry.paused = !0);
  },
  resumeTarget: function(t) {
    cc.assert(t, cc._LogInfos.Scheduler_resumeTarget);
    var e = (this || window), n = e._hashForTimers[t.__instanceId];
    n && (n.paused = !1);
    var r = e._hashForUpdates[t.__instanceId];
    r && (r.entry.paused = !1);
  },
  isTargetPaused: function(t) {
    cc.assert(t, cc._LogInfos.Scheduler_isTargetPaused);
    var e = (this || window)._hashForTimers[t.__instanceId];
    if (e)
      return e.paused;
    var n = (this || window)._hashForUpdates[t.__instanceId];
    return n ? n.entry.paused : !1;
  },
  scheduleUpdateForTarget: function(t, e, n) {
    this.scheduleUpdate(t, e, n);
  },
  unscheduleCallbackForTarget: function(t, e) {
    this.unschedule(e, t);
  },
  unscheduleUpdateForTarget: function(t) {
    this.unscheduleUpdate(t);
  },
  unscheduleAllCallbacksForTarget: function(t) {
    this.unschedule(t.__instanceId + "", t);
  },
  unscheduleAllCallbacks: function() {
    this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
  },
  unscheduleAllCallbacksWithMinPriority: function(t) {
    this.unscheduleAllWithMinPriority(t);
  }
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483647 - 1;
cc._tmp.PrototypeLabelTTF = function() {
  var t = cc.LabelTTF.prototype;
  cc.defineGetterSetter(t, "color", t.getColor, t.setColor), cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity), t.string, cc.defineGetterSetter(t, "string", t.getString, t.setString), t.textAlign, cc.defineGetterSetter(t, "textAlign", t.getHorizontalAlignment, t.setHorizontalAlignment), t.verticalAlign, cc.defineGetterSetter(t, "verticalAlign", t.getVerticalAlignment, t.setVerticalAlignment), t.fontSize, cc.defineGetterSetter(t, "fontSize", t.getFontSize, t.setFontSize), t.fontName, cc.defineGetterSetter(t, "fontName", t.getFontName, t.setFontName), t.font, cc.defineGetterSetter(t, "font", t._getFont, t._setFont), t.boundingSize, t.boundingWidth, cc.defineGetterSetter(t, "boundingWidth", t._getBoundingWidth, t._setBoundingWidth), t.boundingHeight, cc.defineGetterSetter(t, "boundingHeight", t._getBoundingHeight, t._setBoundingHeight), t.fillStyle, cc.defineGetterSetter(t, "fillStyle", t._getFillStyle, t.setFontFillColor), t.strokeStyle, cc.defineGetterSetter(t, "strokeStyle", t._getStrokeStyle, t._setStrokeStyle), t.lineWidth, cc.defineGetterSetter(t, "lineWidth", t._getLineWidth, t._setLineWidth), t.shadowOffset, t.shadowOffsetX, cc.defineGetterSetter(t, "shadowOffsetX", t._getShadowOffsetX, t._setShadowOffsetX), t.shadowOffsetY, cc.defineGetterSetter(t, "shadowOffsetY", t._getShadowOffsetY, t._setShadowOffsetY), t.shadowOpacity, cc.defineGetterSetter(t, "shadowOpacity", t._getShadowOpacity, t._setShadowOpacity), t.shadowBlur, cc.defineGetterSetter(t, "shadowBlur", t._getShadowBlur, t._setShadowBlur);
};
cc.LabelTTF = cc.Sprite.extend({
  _dimensions: null,
  _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
  _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
  _fontName: null,
  _fontSize: 0,
  _string: "",
  _originalText: null,
  _onCacheCanvasMode: !0,
  _shadowEnabled: !1,
  _shadowOffset: null,
  _shadowOpacity: 0,
  _shadowBlur: 0,
  _shadowColor: null,
  _strokeEnabled: !1,
  _strokeColor: null,
  _strokeSize: 0,
  _textFillColor: null,
  _strokeShadowOffsetX: 0,
  _strokeShadowOffsetY: 0,
  _needUpdateTexture: !1,
  _lineWidths: null,
  _className: "LabelTTF",
  _fontStyle: "normal",
  _fontWeight: "normal",
  _lineHeight: "normal",
  initWithString: function(t, e, n, r, s, o) {
    var a;
    return t ? a = t + "" : a = "", n = n || 16, r = r || cc.size(0, 0), s = s || cc.TEXT_ALIGNMENT_LEFT, o = o || cc.VERTICAL_TEXT_ALIGNMENT_TOP, this._opacityModifyRGB = !1, this._dimensions = cc.size(r.width, r.height), this._fontName = e || "Arial", this._hAlignment = s, this._vAlignment = o, this._fontSize = n, this._renderCmd._setFontStyle(this._fontName, n, this._fontStyle, this._fontWeight), this.string = a, this._renderCmd._setColorsString(), this._renderCmd._updateTexture(), this._setUpdateTextureDirty(), this._scaleX = (this || window)._scaleY = 1 / cc.view.getDevicePixelRatio(), !0;
  },
  _setUpdateTextureDirty: function() {
    this._needUpdateTexture = !0, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.textDirty);
  },
  ctor: function(t, e, n, r, s, o) {
    cc.Sprite.prototype.ctor.call(this), this._dimensions = cc.size(0, 0), this._hAlignment = cc.TEXT_ALIGNMENT_LEFT, this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP, this._opacityModifyRGB = !1, this._fontName = "Arial", this._shadowEnabled = !1, this._shadowOffset = cc.p(0, 0), this._shadowOpacity = 0, this._shadowBlur = 0, this._strokeEnabled = !1, this._strokeColor = cc.color(255, 255, 255, 255), this._strokeSize = 0, this._textFillColor = cc.color(255, 255, 255, 255), this._strokeShadowOffsetX = 0, this._strokeShadowOffsetY = 0, this._needUpdateTexture = !1, this._lineWidths = [], this._renderCmd._setColorsString(), this._textureLoaded = !0, e && e instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(t, e) : cc.LabelTTF.prototype.initWithString.call(this, t, e, n, r, s, o);
  },
  init: function() {
    return this.initWithString(" ", this._fontName, this._fontSize);
  },
  description: function() {
    return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">";
  },
  getLineHeight: function() {
    return !this._lineHeight || this._lineHeight.charAt ? this._renderCmd._getFontClientHeight() : this._lineHeight || this._renderCmd._getFontClientHeight();
  },
  setLineHeight: function(t) {
    this._lineHeight = t;
  },
  getString: function() {
    return this._string;
  },
  getHorizontalAlignment: function() {
    return this._hAlignment;
  },
  getVerticalAlignment: function() {
    return this._vAlignment;
  },
  getDimensions: function() {
    return cc.size(this._dimensions);
  },
  getFontSize: function() {
    return this._fontSize;
  },
  getFontName: function() {
    return this._fontName;
  },
  initWithStringAndTextDefinition: function(t, e) {
    return this._updateWithTextDefinition(e, !1), this.string = t, !0;
  },
  setTextDefinition: function(t) {
    t && this._updateWithTextDefinition(t, !0);
  },
  getTextDefinition: function() {
    return this._prepareTextDefinition(!1);
  },
  enableShadow: function(t, e, n, r) {
    t.r != null && t.g != null && t.b != null && t.a != null ? this._enableShadow(t, e, n) : this._enableShadowNoneColor(t, e, n, r);
  },
  _enableShadowNoneColor: function(t, e, n, r) {
    n = n || 0.5, this._shadowEnabled === !1 && (this._shadowEnabled = !0);
    var s = (this || window)._shadowOffset;
    (s && s.x !== t || s._y !== e) && (s.x = t, s.y = e), this._shadowOpacity !== n && (this._shadowOpacity = n), this._renderCmd._setColorsString(), this._shadowBlur !== r && (this._shadowBlur = r), this._setUpdateTextureDirty();
  },
  _enableShadow: function(t, e, n) {
    this._shadowColor || (this._shadowColor = cc.color(255, 255, 255, 128)), this._shadowColor.r = t.r, this._shadowColor.g = t.g, this._shadowColor.b = t.b;
    var r, s, o, a;
    r = e.width || e.x || 0, s = e.height || e.y || 0, o = t.a != null ? t.a / 255 : 0.5, a = n, this._enableShadowNoneColor(r, s, o, a);
  },
  _getShadowOffsetX: function() {
    return this._shadowOffset.x;
  },
  _setShadowOffsetX: function(t) {
    this._shadowEnabled === !1 && (this._shadowEnabled = !0), this._shadowOffset.x !== t && (this._shadowOffset.x = t, this._setUpdateTextureDirty());
  },
  _getShadowOffsetY: function() {
    return this._shadowOffset._y;
  },
  _setShadowOffsetY: function(t) {
    this._shadowEnabled === !1 && (this._shadowEnabled = !0), this._shadowOffset._y !== t && (this._shadowOffset._y = t, this._setUpdateTextureDirty());
  },
  _getShadowOffset: function() {
    return cc.p(this._shadowOffset.x, this._shadowOffset.y);
  },
  _setShadowOffset: function(t) {
    this._shadowEnabled === !1 && (this._shadowEnabled = !0), (this._shadowOffset.x !== t.x || this._shadowOffset.y !== t.y) && (this._shadowOffset.x = t.x, this._shadowOffset.y = t.y, this._setUpdateTextureDirty());
  },
  _getShadowOpacity: function() {
    return this._shadowOpacity;
  },
  _setShadowOpacity: function(t) {
    this._shadowEnabled === !1 && (this._shadowEnabled = !0), this._shadowOpacity !== t && (this._shadowOpacity = t, this._renderCmd._setColorsString(), this._setUpdateTextureDirty());
  },
  _getShadowBlur: function() {
    return this._shadowBlur;
  },
  _setShadowBlur: function(t) {
    this._shadowEnabled === !1 && (this._shadowEnabled = !0), this._shadowBlur !== t && (this._shadowBlur = t, this._setUpdateTextureDirty());
  },
  disableShadow: function() {
    this._shadowEnabled && (this._shadowEnabled = !1, this._setUpdateTextureDirty());
  },
  enableStroke: function(t, e) {
    this._strokeEnabled === !1 && (this._strokeEnabled = !0);
    var n = (this || window)._strokeColor;
    (n.r !== t.r || n.g !== t.g || n.b !== t.b) && (n.r = t.r, n.g = t.g, n.b = t.b, this._renderCmd._setColorsString()), this._strokeSize !== e && (this._strokeSize = e || 0), this._setUpdateTextureDirty();
  },
  _getStrokeStyle: function() {
    return this._strokeColor;
  },
  _setStrokeStyle: function(t) {
    this._strokeEnabled === !1 && (this._strokeEnabled = !0);
    var e = (this || window)._strokeColor;
    (e.r !== t.r || e.g !== t.g || e.b !== t.b) && (e.r = t.r, e.g = t.g, e.b = t.b, this._renderCmd._setColorsString(), this._setUpdateTextureDirty());
  },
  _getLineWidth: function() {
    return this._strokeSize;
  },
  _setLineWidth: function(t) {
    this._strokeEnabled === !1 && (this._strokeEnabled = !0), this._strokeSize !== t && (this._strokeSize = t || 0, this._setUpdateTextureDirty());
  },
  disableStroke: function() {
    this._strokeEnabled && (this._strokeEnabled = !1, this._setUpdateTextureDirty());
  },
  setFontFillColor: function(t) {
    var e = (this || window)._textFillColor;
    (e.r !== t.r || e.g !== t.g || e.b !== t.b) && (e.r = t.r, e.g = t.g, e.b = t.b, this._renderCmd._setColorsString(), this._needUpdateTexture = !0);
  },
  _getFillStyle: function() {
    return this._textFillColor;
  },
  _updateWithTextDefinition: function(t, e) {
    t.fontDimensions ? (this._dimensions.width = t.boundingWidth, this._dimensions.height = t.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0), this._hAlignment = t.textAlign, this._vAlignment = t.verticalAlign, this._fontName = t.fontName, this._fontSize = t.fontSize || 12, t.lineHeight ? this._lineHeight = t.lineHeight : this._lineHeight = (this || window)._fontSize, this._renderCmd._setFontStyle(t), t.shadowEnabled && this.enableShadow(
      t.shadowOffsetX,
      t.shadowOffsetY,
      t.shadowOpacity,
      t.shadowBlur
    ), t.strokeEnabled && this.enableStroke(t.strokeStyle, t.lineWidth), this.setFontFillColor(t.fillStyle), e && this._renderCmd._updateTexture();
    var n = cc.Node._dirtyFlags;
    this._renderCmd.setDirtyFlag(n.colorDirty | n.opacityDirty | n.textDirty);
  },
  _prepareTextDefinition: function(t) {
    var e = new cc.FontDefinition();
    if (t ? (e.fontSize = (this || window)._fontSize, e.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, e.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (e.fontSize = (this || window)._fontSize, e.boundingWidth = (this || window)._dimensions.width, e.boundingHeight = (this || window)._dimensions.height), e.fontName = (this || window)._fontName, e.textAlign = (this || window)._hAlignment, e.verticalAlign = (this || window)._vAlignment, this._strokeEnabled) {
      e.strokeEnabled = !0;
      var n = (this || window)._strokeColor;
      e.strokeStyle = cc.color(n.r, n.g, n.b), e.lineWidth = (this || window)._strokeSize;
    } else
      e.strokeEnabled = !1;
    this._shadowEnabled ? (e.shadowEnabled = !0, e.shadowBlur = (this || window)._shadowBlur, e.shadowOpacity = (this || window)._shadowOpacity, e.shadowOffsetX = (t ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, e.shadowOffsetY = (t ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : e._shadowEnabled = !1;
    var r = (this || window)._textFillColor;
    return e.fillStyle = cc.color(r.r, r.g, r.b), e;
  },
  getScale: function() {
    return this._scaleX !== (this || window)._scaleY && cc.log(cc._LogInfos.Node_getScale), this._scaleX * cc.view.getDevicePixelRatio();
  },
  setScale: function(t, e) {
    this._scaleX = t / cc.view.getDevicePixelRatio(), this._scaleY = (e || e === 0 ? e : t) / cc.view.getDevicePixelRatio(), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getScaleX: function() {
    return this._scaleX * cc.view.getDevicePixelRatio();
  },
  setScaleX: function(t) {
    this._scaleX = t / cc.view.getDevicePixelRatio(), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getScaleY: function() {
    return this._scaleY * cc.view.getDevicePixelRatio();
  },
  setScaleY: function(t) {
    this._scaleY = t / cc.view.getDevicePixelRatio(), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  setString: function(t) {
    t = String(t), this._originalText !== t && (this._originalText = t + "", this._updateString(), this._setUpdateTextureDirty(), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty));
  },
  _updateString: function() {
    (!this._string || this._string === "") && this._string !== (this || window)._originalText && (cc.renderer.childrenOrderDirty = !0), this._string = (this || window)._originalText;
  },
  setHorizontalAlignment: function(t) {
    t !== (this || window)._hAlignment && (this._hAlignment = t, this._setUpdateTextureDirty());
  },
  setVerticalAlignment: function(t) {
    t !== (this || window)._vAlignment && (this._vAlignment = t, this._setUpdateTextureDirty());
  },
  setDimensions: function(t, e) {
    var n;
    e === void 0 ? (n = t.width, e = t.height) : n = t, (n !== (this || window)._dimensions.width || e !== (this || window)._dimensions.height) && (this._dimensions.width = n, this._dimensions.height = e, this._updateString(), this._setUpdateTextureDirty());
  },
  _getBoundingWidth: function() {
    return this._dimensions.width;
  },
  _setBoundingWidth: function(t) {
    t !== (this || window)._dimensions.width && (this._dimensions.width = t, this._updateString(), this._setUpdateTextureDirty());
  },
  _getBoundingHeight: function() {
    return this._dimensions.height;
  },
  _setBoundingHeight: function(t) {
    t !== (this || window)._dimensions.height && (this._dimensions.height = t, this._updateString(), this._setUpdateTextureDirty());
  },
  setFontSize: function(t) {
    this._fontSize !== t && (this._fontSize = t, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty());
  },
  setFontName: function(t) {
    this._fontName && this._fontName !== t && (this._fontName = t, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty());
  },
  _getFont: function() {
    return this._renderCmd._getFontStyle();
  },
  _setFont: function(t) {
    var e = cc.LabelTTF._fontStyleRE.exec(t);
    e && (this._fontSize = parseInt(e[1]), this._fontName = e[2], this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty());
  },
  getContentSize: function() {
    return this._needUpdateTexture && this._renderCmd._updateTTF(), cc.size(this._contentSize);
  },
  _getWidth: function() {
    return this._needUpdateTexture && this._renderCmd._updateTTF(), this._contentSize.width;
  },
  _getHeight: function() {
    return this._needUpdateTexture && this._renderCmd._updateTTF(), this._contentSize.height;
  },
  setTextureRect: function(t, e, n) {
    cc.Sprite.prototype.setTextureRect.call(this, t, e, n, !1);
  },
  setDrawMode: function(t) {
    this._onCacheCanvasMode = t;
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelTTF.WebGLRenderCmd(this) : this._onCacheCanvasMode ? new cc.LabelTTF.CacheCanvasRenderCmd(this) : new cc.LabelTTF.CanvasRenderCmd(this);
  },
  _setFontStyle: function(t) {
    this._fontStyle !== t && (this._fontStyle = t, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty());
  },
  _getFontStyle: function() {
    return this._fontStyle;
  },
  _setFontWeight: function(t) {
    this._fontWeight !== t && (this._fontWeight = t, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty());
  },
  _getFontWeight: function() {
    return this._fontWeight;
  }
});
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function(t, e, n, r, s, o) {
  return new cc.LabelTTF(t, e, n, r, s, o);
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
cc.LabelTTF.__labelHeightDiv = document.createElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : window.addEventListener("load", function() {
  this.removeEventListener("load", arguments.callee, !1), document.body.appendChild(cc.LabelTTF.__labelHeightDiv);
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function(t, e) {
  var n, r = cc.LabelTTF.__labelHeightDiv;
  if (t instanceof cc.FontDefinition) {
    var s = t;
    if (n = cc.LabelTTF.__fontHeightCache[s._getCanvasFontStr()], n > 0)
      return n;
    r.innerHTML = "ajghl~!", r.style.fontFamily = s.fontName, r.style.fontSize = s.fontSize + "px", r.style.fontStyle = s.fontStyle, r.style.fontWeight = s.fontWeight, n = r.clientHeight, cc.LabelTTF.__fontHeightCache[s._getCanvasFontStr()] = n, r.innerHTML = "";
  } else {
    if (n = cc.LabelTTF.__fontHeightCache[t + "." + e], n > 0)
      return n;
    r.innerHTML = "ajghl~!", r.style.fontFamily = t, r.style.fontSize = e + "px", n = r.clientHeight, cc.LabelTTF.__fontHeightCache[t + "." + e] = n, r.innerHTML = "";
  }
  return n;
};
cc.LabelTTF.__fontHeightCache = {};
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = !0;
cc.LabelTTF._wordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>、‘“》？。，！]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôû]/;
(function() {
  cc.LabelTTF.RenderCmd = function() {
    this._fontClientHeight = 18, this._fontStyleStr = "", this._shadowColorStr = "rgba(128, 128, 128, 0.5)", this._strokeColorStr = "", this._fillColorStr = "rgba(255,255,255,1)", this._labelCanvas = null, this._labelContext = null, this._lineWidths = [], this._strings = [], this._isMultiLine = !1, this._status = [], this._renderingIndex = 0, this._texRect = cc.rect(), this._canUseDirtyRegion = !0;
  };
  var t = cc.LabelTTF.RenderCmd.prototype;
  t.constructor = cc.LabelTTF.RenderCmd, t._setFontStyle = function(n, r, s, o) {
    if (n instanceof cc.FontDefinition)
      this._fontStyleStr = n._getCanvasFontStr(), this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(n);
    else {
      var a = r * cc.view.getDevicePixelRatio();
      this._fontStyleStr = s + " " + o + " " + a + "px '" + n + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(n, r);
    }
  }, t._getFontStyle = function() {
    return this._fontStyleStr;
  }, t._getFontClientHeight = function() {
    return this._fontClientHeight;
  }, t._updateColor = function() {
    this._setColorsString(), this._updateTexture();
  }, t._setColorsString = function() {
    var n = (this || window)._displayedColor, r = (this || window)._node, s = r._shadowColor || this._displayedColor, o = r._strokeColor, a = r._textFillColor, c = n.r / 255, l = n.g / 255, h = n.b / 255;
    this._shadowColorStr = "rgba(" + (0 | c * s.r) + "," + (0 | l * s.g) + "," + (0 | h * s.b) + "," + r._shadowOpacity + ")", this._fillColorStr = "rgba(" + (0 | c * a.r) + "," + (0 | l * a.g) + "," + (0 | h * a.b) + ", 1)", this._strokeColorStr = "rgba(" + (0 | c * o.r) + "," + (0 | l * o.g) + "," + (0 | h * o.b) + ", 1)";
  };
  var e = new cc.Rect();
  t.getLocalBB = function() {
    var n = (this || window)._node;
    e.x = e.y = 0;
    var r = cc.view.getDevicePixelRatio();
    return e.width = n._getWidth() * r, e.height = n._getHeight() * r, e;
  }, t._updateTTF = function() {
    var n = (this || window)._node, r = cc.view.getDevicePixelRatio(), s = n._dimensions.width * r, o, a, c = (this || window)._lineWidths;
    if (c.length = 0, this._isMultiLine = !1, this._measureConfig(), s !== 0)
      for (this._strings = n._string.split(`
`), o = 0; o < this._strings.length; o++)
        this._checkWarp(this._strings, o, s);
    else
      for (this._strings = n._string.split(`
`), o = 0, a = (this || window)._strings.length; o < a; o++)
        c.push(this._measure(this._strings[o]));
    this._strings.length > 1 && (this._isMultiLine = !0);
    var l, h = 0, u = 0;
    if (n._strokeEnabled && (h = u = n._strokeSize * 2), n._shadowEnabled) {
      var _ = n._shadowOffset;
      h += Math.abs(_.x) * 2, u += Math.abs(_.y) * 2;
    }
    s === 0 ? this._isMultiLine ? l = cc.size(
      Math.ceil(Math.max.apply(Math, c) + h),
      Math.ceil(this._fontClientHeight * r * this._strings.length + u)
    ) : l = cc.size(
      Math.ceil(this._measure(n._string) + h),
      Math.ceil(this._fontClientHeight * r + u)
    ) : n._dimensions.height === 0 ? this._isMultiLine ? l = cc.size(
      Math.ceil(s + h),
      Math.ceil(n.getLineHeight() * r * this._strings.length + u)
    ) : l = cc.size(
      Math.ceil(s + h),
      Math.ceil(n.getLineHeight() * r + u)
    ) : l = cc.size(
      Math.ceil(s + h),
      Math.ceil(n._dimensions.height * r + u)
    ), n._getFontStyle() !== "normal" && (l.width = Math.ceil(l.width + n._fontSize * 0.3)), this._strings.length === 0 ? (this._texRect.width = 1, this._texRect.height = l.height || 1) : (this._texRect.width = l.width, this._texRect.height = l.height);
    var d = l.width / r, f = l.height / r;
    n.setContentSize(d, f), n._strokeShadowOffsetX = h, n._strokeShadowOffsetY = u;
    var C = n._anchorPoint;
    this._anchorPointInPoints.x = h * 0.5 + (l.width - h) * C.x, this._anchorPointInPoints.y = u * 0.5 + (l.height - u) * C.y;
  }, t._saveStatus = function() {
    var n = (this || window)._node, r = cc.view.getDevicePixelRatio(), s = n._strokeShadowOffsetX, o = n._strokeShadowOffsetY, a = n._contentSize.height * r - o, c = n._vAlignment, l = n._hAlignment, h = s * 0.5, u = a + o * 0.5, _ = 0, d = 0, f = [], C = n._contentSize.width * r - s, m = n.getLineHeight() * r, g = (m - this._fontClientHeight * r) / 2;
    if (l === cc.TEXT_ALIGNMENT_RIGHT ? _ += C : l === cc.TEXT_ALIGNMENT_CENTER ? _ += C / 2 : _ += 0, this._isMultiLine) {
      var y = (this || window)._strings.length;
      c === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? d = m - g * 2 + a - m * y : c === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (d = (m - g * 2) / 2 + (a - m * y) / 2);
      for (var A = 0; A < y; A++) {
        var D = -a + (m * A + g) + d;
        f.push(D);
      }
    } else
      c === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM || (c === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? d -= a : d -= a * 0.5), f.push(d);
    var N = {
      contextTransform: cc.p(h, u),
      xOffset: _,
      OffsetYArray: f
    };
    this._status.push(N);
  }, t._drawTTFInCanvas = function(n) {
    if (n) {
      var r = (this || window)._status.pop();
      n.setTransform(1, 0, 0, 1, r.contextTransform.x, r.contextTransform.y);
      var s = r.xOffset, o = r.OffsetYArray;
      this.drawLabels(n, s, o);
    }
  }, t._checkWarp = function(n, r, s) {
    var o = n[r], a = (this || window)._measure(o);
    if (a > s && o.length > 1) {
      for (var c = o.length * (s / a) | 0, l = o.substr(c), h = a - this._measure(l), u, _ = 0, d = 0; h > s && d++ < 100; )
        c *= s / h, c = c | 0, l = o.substr(c), h = a - this._measure(l);
      for (d = 0; h < s && d++ < 100; ) {
        if (l) {
          var f = cc.LabelTTF._wordRex.exec(l);
          _ = f ? f[0].length : 1, u = l;
        }
        c = c + _, l = o.substr(c), h = a - this._measure(l);
      }
      c -= _, c === 0 && (c = 1, u = u.substr(1));
      var C = o.substr(0, c), m;
      cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(u || l) && (m = cc.LabelTTF._lastWordRex.exec(C), c -= m ? m[0].length : 0, c === 0 && (c = 1), u = o.substr(c), C = o.substr(0, c)), cc.LabelTTF._firsrEnglish.test(u) && (m = cc.LabelTTF._lastEnglish.exec(C), m && C !== m[0] && (c -= m[0].length, u = o.substr(c), C = o.substr(0, c))), n[r] = u || l, n.splice(r, 0, C);
    }
  }, t.updateStatus = function() {
    var n = cc.Node._dirtyFlags, r = (this || window)._dirtyFlag;
    r & n.textDirty && this._updateTexture(), cc.Node.RenderCmd.prototype.updateStatus.call(this), this._dirtyFlag & n.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag);
  }, t._syncStatus = function(n) {
    var r = cc.Node._dirtyFlags, s = (this || window)._dirtyFlag;
    s & r.textDirty && this._updateTexture(), cc.Node.RenderCmd.prototype._syncStatus.call(this, n), (cc._renderType === cc.game.RENDER_TYPE_WEBGL || s & r.transformDirty) && this.transform(n);
  }, t.drawLabels = function(n, r, s) {
    var o = (this || window)._node;
    if (o._shadowEnabled) {
      var a = o._shadowOffset;
      n.shadowColor = (this || window)._shadowColorStr, n.shadowOffsetX = a.x, n.shadowOffsetY = -a.y, n.shadowBlur = o._shadowBlur;
    }
    var c = o._hAlignment, l = o._vAlignment, h = o._strokeSize;
    n.font !== (this || window)._fontStyleStr && (n.font = (this || window)._fontStyleStr), n.fillStyle = (this || window)._fillColorStr;
    var u = o._strokeEnabled;
    u && (n.lineWidth = h * 2, n.strokeStyle = (this || window)._strokeColorStr), n.textBaseline = cc.LabelTTF._textBaseline[l], n.textAlign = cc.LabelTTF._textAlign[c];
    for (var _ = (this || window)._strings.length, d = 0; d < _; d++) {
      var f = (this || window)._strings[d];
      u && n.strokeText(f, r, s[d]), n.fillText(f, r, s[d]);
    }
    cc.g_NumberOfDraws++;
  };
})();
(function() {
  cc.LabelTTF.CacheRenderCmd = function(e) {
    cc.LabelTTF.RenderCmd.call(this, e);
    var n = (this || window)._labelCanvas = document.createElement("canvas");
    n.width = 1, n.height = 1, this._labelContext = n.getContext("2d"), this._texRect = cc.rect();
  }, cc.LabelTTF.CacheRenderCmd.prototype = Object.create(cc.LabelTTF.RenderCmd.prototype), cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CacheRenderCmd.prototype);
  var t = cc.LabelTTF.CacheRenderCmd.prototype;
  t.constructor = cc.LabelTTF.CacheRenderCmd, t._updateTexture = function() {
    this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.textDirty ^ this._dirtyFlag;
    var e = (this || window)._node;
    this._updateTTF();
    var n = (this || window)._texRect.width, r = (this || window)._texRect.height, s = (this || window)._labelContext, o = (this || window)._labelCanvas;
    if (!e._texture) {
      var a = new cc.Texture2D();
      a.initWithElement(this._labelCanvas), e.setTexture(a);
    }
    if (e._string.length === 0)
      return o.width = n, o.height = r, e._texture && e._texture.handleLoadedTexture(), e.setTextureRect(this._texRect), !0;
    s.font = (this || window)._fontStyleStr;
    var c = o.width === n && o.height === r;
    return o.width = (this || window)._texRect.width, o.height = (this || window)._texRect.height, c && s.clearRect(0, 0, n, r), this._saveStatus(), this._drawTTFInCanvas(s), e._texture && e._texture.handleLoadedTexture(), e.setTextureRect(this._texRect), !0;
  }, t._measureConfig = function() {
    this._labelContext.font = (this || window)._fontStyleStr;
  }, t._measure = function(e) {
    return this._labelContext.measureText(e).width;
  };
})();
(function() {
  cc.LabelTTF.CacheCanvasRenderCmd = function(e) {
    cc.Sprite.CanvasRenderCmd.call(this, e), cc.LabelTTF.CacheRenderCmd.call(this);
  };
  var t = cc.LabelTTF.CacheCanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
  cc.inject(cc.LabelTTF.CacheRenderCmd.prototype, t), t.constructor = cc.LabelTTF.CacheCanvasRenderCmd;
})();
(function() {
  cc.LabelTTF.CanvasRenderCmd = function(e) {
    cc.Sprite.CanvasRenderCmd.call(this, e), cc.LabelTTF.RenderCmd.call(this);
  }, cc.LabelTTF.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype), cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CanvasRenderCmd.prototype);
  var t = cc.LabelTTF.CanvasRenderCmd.prototype;
  t.constructor = cc.LabelTTF.CanvasRenderCmd, t._measureConfig = function() {
  }, t._measure = function(e) {
    var n = cc._renderContext.getContext();
    return n.font = (this || window)._fontStyleStr, n.measureText(e).width;
  }, t._updateTexture = function() {
    this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.textDirty ^ this._dirtyFlag;
    var e = (this || window)._node;
    return cc.view.getDevicePixelRatio(), this._updateTTF(), e._string.length === 0 ? (e.setTextureRect(this._texRect), !0) : (this._saveStatus(), e.setTextureRect(this._texRect), !0);
  }, t.rendering = function(e) {
    var n = cc.view.getScaleX(), r = cc.view.getScaleY(), s = e || cc._renderContext, o = s.getContext();
    if (o) {
      var a = (this || window)._node;
      if (s.computeRealOffsetY(), !(this._status.length <= 0)) {
        var c = (this || window)._renderingIndex >= (this || window)._status.length ? this._renderingIndex - this._status.length : this._renderingIndex, l = (this || window)._status[c];
        this._renderingIndex = c + 1;
        var h = a._rect.height, u = a._offsetPosition.x, _ = -a._offsetPosition.y - h, d = (this || window)._displayedOpacity / 255;
        s.setTransform(this._worldTransform, n, r), s.setCompositeOperation(this._blendFuncStr), s.setGlobalAlpha(d), s.save(), a._flippedX && (u = -u - a._rect.width, o.scale(-1, 1)), a._flippedY && (_ = a._offsetPosition.y, o.scale(1, -1));
        for (var f = l.xOffset + l.contextTransform.x + u * n, C = [], m = (this || window)._strings.length, g = 0; g < m; g++)
          C.push(l.OffsetYArray[g] + l.contextTransform.y + _ * r);
        this.drawLabels(o, f, C), s.restore();
      }
    }
  };
})();
var cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function(t, e) {
};
cc.KEY = {
  none: 0,
  back: 6,
  menu: 18,
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  ctrl: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  space: 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  select: 41,
  insert: 45,
  Delete: 46,
  0: 48,
  1: 49,
  2: 50,
  3: 51,
  4: 52,
  5: 53,
  6: 54,
  7: 55,
  8: 56,
  9: 57,
  a: 65,
  b: 66,
  c: 67,
  d: 68,
  e: 69,
  f: 70,
  g: 71,
  h: 72,
  i: 73,
  j: 74,
  k: 75,
  l: 76,
  m: 77,
  n: 78,
  o: 79,
  p: 80,
  q: 81,
  r: 82,
  s: 83,
  t: 84,
  u: 85,
  v: 86,
  w: 87,
  x: 88,
  y: 89,
  z: 90,
  num0: 96,
  num1: 97,
  num2: 98,
  num3: 99,
  num4: 100,
  num5: 101,
  num6: 102,
  num7: 103,
  num8: 104,
  num9: 105,
  "*": 106,
  "+": 107,
  "-": 109,
  numdel: 110,
  "/": 111,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  semicolon: 186,
  equal: 187,
  "=": 187,
  ",": 188,
  comma: 188,
  dash: 189,
  ".": 190,
  period: 190,
  forwardslash: 191,
  grave: 192,
  "[": 219,
  openbracket: 219,
  backslash: 220,
  "]": 221,
  closebracket: 221,
  quote: 222,
  dpadLeft: 1e3,
  dpadRight: 1001,
  dpadUp: 1003,
  dpadDown: 1004,
  dpadCenter: 1005
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function(t) {
  return t.length > 8 && t[0] === 137 && t[1] === 80 && t[2] === 78 && t[3] === 71 && t[4] === 13 && t[5] === 10 && t[6] === 26 && t[7] === 10 ? cc.FMT_PNG : t.length > 2 && (t[0] === 73 && t[1] === 73 || t[0] === 77 && t[1] === 77 || t[0] === 255 && t[1] === 216) ? cc.FMT_TIFF : cc.FMT_UNKNOWN;
};
cc.inherits = function(t, e) {
  function n() {
  }
  H(n, "tempCtor"), n.prototype = e.prototype, t.superClass_ = e.prototype, t.prototype = new n(), t.prototype.constructor = t;
};
cc.base = function(t, e, n) {
  var r = arguments.callee.caller;
  if (r.superClass_)
    return ret = r.superClass_.constructor.apply(t, Array.prototype.slice.call(arguments, 1)), ret;
  for (var s = Array.prototype.slice.call(arguments, 2), o = !1, a = t.constructor; a; a = a.superClass_ && a.superClass_.constructor)
    if (a.prototype[e] === r)
      o = !0;
    else if (o)
      return a.prototype[e].apply(t, s);
  if (t[e] === r)
    return t.constructor.prototype[e].apply(t, s);
  throw Error(
    "cc.base called from a method of one name to a method of a different name"
  );
};
(function() {
  var t = 888, e = /* @__PURE__ */ H(function(n) {
    this.gl = n, this.vertexBuffer = n.createBuffer(), this.size = t, this.byteLength = t * 4 * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, this.data = new ArrayBuffer(this.byteLength), this.dataArray = new Float32Array(this.data), n.bindBuffer(n.ARRAY_BUFFER, this.vertexBuffer), n.bufferData(n.ARRAY_BUFFER, this.dataArray, n.DYNAMIC_DRAW), this._dirty = !1, this._spaces = {
      0: this.byteLength
    };
  }, "GlobalVertexBuffer");
  return e.prototype = {
    constructor: e,
    allocBuffer: function(n, r) {
      var s = (this || window)._spaces[n];
      if (s && s >= r) {
        if (delete this._spaces[n], s > r) {
          var o = n + r;
          this._spaces[o] = s - r;
        }
        return !0;
      } else
        return !1;
    },
    requestBuffer: function(n) {
      var r, s, o;
      for (r in this._spaces)
        if (s = parseInt(r), o = (this || window)._spaces[r], o >= n && this.allocBuffer(s, n))
          return {
            buffer: this,
            offset: s,
            size: n
          };
      return null;
    },
    freeBuffer: function(n, r) {
      var s = (this || window)._spaces, o, a, c;
      for (a in s) {
        if (o = parseInt(a), o > n)
          break;
        if (o + s[a] >= n) {
          r = r + n - o, n = o;
          break;
        }
      }
      c = n + r, this._spaces[c] && (r += (this || window)._spaces[c], delete this._spaces[c]), this._spaces[n] = r;
    },
    setDirty: function() {
      this._dirty = !0;
    },
    update: function() {
      this._dirty && (this.gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer), this.gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.dataArray), this._dirty = !1);
    },
    destroy: function() {
      this.gl.deleteBuffer(this.vertexBuffer), this.data = null, this.positions = null, this.colors = null, this.texCoords = null, this.vertexBuffer = null;
    }
  }, e;
})();
cc.rendererCanvas = {
  childrenOrderDirty: !0,
  assignedZ: 0,
  assignedZStep: 1 / 1e4,
  _transformNodePool: [],
  _renderCmds: [],
  _isCacheToCanvasOn: !1,
  _cacheToCanvasCmds: {},
  _cacheInstanceIds: [],
  _currentID: 0,
  _clearColor: cc.color(),
  _clearFillStyle: "rgb(0, 0, 0)",
  _dirtyRegion: null,
  _allNeedDraw: !0,
  _enableDirtyRegion: !1,
  _debugDirtyRegion: !1,
  _canUseDirtyRegion: !1,
  _dirtyRegionCountThreshold: 10,
  getRenderCmd: function(t) {
    return t._createRenderCmd();
  },
  enableDirtyRegion: function(t) {
    this._enableDirtyRegion = t;
  },
  isDirtyRegionEnabled: function() {
    return this._enableDirtyRegion;
  },
  setDirtyRegionCountThreshold: function(t) {
    this._dirtyRegionCountThreshold = t;
  },
  _collectDirtyRegion: function() {
    var t = (this || window)._renderCmds, e, n, r = (this || window)._dirtyRegion, s = 0, o = !0, a = cc.Node.CanvasRenderCmd.RegionStatus;
    for (e = 0, n = t.length; e < n; e++) {
      var c = t[e], l = c._regionFlag, h = c._oldRegion, u = c._currentRegion;
      l > a.NotDirty && (++s, s > this._dirtyRegionCountThreshold && (o = !1), o && (!u.isEmpty() && r.addRegion(u), c._regionFlag > a.Dirty && !h.isEmpty() && r.addRegion(h)), c._regionFlag = a.NotDirty);
    }
    return o;
  },
  _beginDrawDirtyRegion: function(t) {
    var e = t.getContext(), n = (this || window)._dirtyRegion.getDirtyRegions();
    e.save();
    var r = t._scaleX, s = t._scaleY;
    t.setTransform({ a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, r, s), e.beginPath();
    for (var o = 0, a = n.length; o < a; ++o) {
      var c = n[o];
      e.rect(c._minX, -c._maxY, c._width, c._height);
    }
    e.clip();
  },
  _endDrawDirtyRegion: function(t) {
    t.restore();
  },
  _debugDrawDirtyRegion: function(t) {
    if (this._debugDirtyRegion) {
      var e = t.getContext(), n = (this || window)._dirtyRegion.getDirtyRegions(), r = t._scaleX, s = t._scaleY;
      t.setTransform({ a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, r, s), e.beginPath();
      for (var o = 0, a = n.length; o < a; ++o) {
        var c = n[o];
        e.rect(c._minX, -c._maxY, c._width, c._height);
      }
      var l = e.fillStyle;
      e.fillStyle = "green", e.fill(), e.fillStyle = l;
    }
  },
  rendering: function(t) {
    var e = (this || window)._dirtyRegion = (this || window)._dirtyRegion || new cc.DirtyRegion(), n = cc._canvas, r = t || cc._renderContext, s = r.getContext(), o = cc.view.getScaleX(), a = cc.view.getScaleY();
    r.setViewScale(o, a), r.computeRealOffsetY();
    var c = (this || window)._dirtyRegion.getDirtyRegions(), l = (this || window)._renderCmds, h, u, _ = (this || window)._allNeedDraw || !this._enableDirtyRegion || !this._canUseDirtyRegion, d = !0;
    for (_ || (d = (this || window)._collectDirtyRegion()), _ = _ || !d, _ || this._beginDrawDirtyRegion(r), s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, n.width, n.height), (this._clearColor.r !== 0 || this._clearColor.g !== 0 || this._clearColor.b !== 0) && (r.setFillStyle(this._clearFillStyle), r.setGlobalAlpha(this._clearColor.a), s.fillRect(0, 0, n.width, n.height)), h = 0, u = l.length; h < u; h++) {
      var f = l[h], C = !1, m = f._currentRegion;
      if (!m || _)
        C = !0;
      else
        for (var g = 0, y = c.length; g < y; ++g)
          if (c[g].intersects(m)) {
            C = !0;
            break;
          }
      C && f.rendering(r, o, a);
    }
    _ || (this._debugDrawDirtyRegion(r), this._endDrawDirtyRegion(s)), e.clear(), this._allNeedDraw = !1;
  },
  _renderingToCacheCanvas: function(t, e, n, r) {
    t || cc.log("The context of RenderTexture is invalid."), n = cc.isUndefined(n) ? 1 : n, r = cc.isUndefined(r) ? 1 : r, e = e || this._currentID;
    var s = (this || window)._cacheToCanvasCmds[e], o, a;
    for (t.computeRealOffsetY(), o = 0, a = s.length; o < a; o++)
      s[o].rendering(t, n, r);
    this._removeCache(e);
    var c = (this || window)._cacheInstanceIds;
    c.length === 0 ? this._isCacheToCanvasOn = !1 : this._currentID = c[c.length - 1];
  },
  _turnToCacheMode: function(t) {
    this._isCacheToCanvasOn = !0, t = t || 0, this._cacheToCanvasCmds[t] = [], this._cacheInstanceIds.indexOf(t) === -1 && this._cacheInstanceIds.push(t), this._currentID = t;
  },
  _turnToNormalMode: function() {
    this._isCacheToCanvasOn = !1;
  },
  _removeCache: function(t) {
    t = t || this._currentID;
    var e = (this || window)._cacheToCanvasCmds[t];
    e && (e.length = 0, delete this._cacheToCanvasCmds[t]);
    var n = (this || window)._cacheInstanceIds;
    cc.arrayRemoveObject(n, t);
  },
  resetFlag: function() {
    this.childrenOrderDirty = !1, this._transformNodePool.length = 0;
  },
  transform: function() {
    var t = (this || window)._transformNodePool;
    t.sort(this._sortNodeByLevelAsc);
    for (var e = 0, n = t.length; e < n; e++)
      t[e]._dirtyFlag !== 0 && t[e].updateStatus();
    t.length = 0;
  },
  transformDirty: function() {
    return this._transformNodePool.length > 0;
  },
  _sortNodeByLevelAsc: function(t, e) {
    return t._curLevel - e._curLevel;
  },
  pushDirtyNode: function(t) {
    this._transformNodePool.push(t);
  },
  clear: function() {
  },
  clearRenderCommands: function() {
    this._renderCmds.length = 0, this._cacheInstanceIds.length = 0, this._isCacheToCanvasOn = !1, this._allNeedDraw = !0, this._canUseDirtyRegion = !0;
  },
  pushRenderCommand: function(t) {
    if (t.needDraw())
      if (t._canUseDirtyRegion || (this._canUseDirtyRegion = !1), this._isCacheToCanvasOn) {
        var e = (this || window)._currentID, n = (this || window)._cacheToCanvasCmds, r = n[e];
        r.indexOf(t) === -1 && r.push(t);
      } else
        this._renderCmds.indexOf(t) === -1 && this._renderCmds.push(t);
  }
};
(function() {
  cc.CanvasContextWrapper = function(e) {
    this._context = e, this._saveCount = 0, this._currentAlpha = e.globalAlpha, this._currentCompositeOperation = e.globalCompositeOperation, this._currentFillStyle = e.fillStyle, this._currentStrokeStyle = e.strokeStyle, this._offsetX = 0, this._offsetY = 0, this._realOffsetY = (this || window).height, this._armatureMode = 0;
  };
  var t = cc.CanvasContextWrapper.prototype;
  t.resetCache = function() {
    var e = (this || window)._context;
    this._currentAlpha = e.globalAlpha, this._currentCompositeOperation = e.globalCompositeOperation, this._currentFillStyle = e.fillStyle, this._currentStrokeStyle = e.strokeStyle, this._realOffsetY = (this || window)._context.canvas.height + this._offsetY;
  }, t.setOffset = function(e, n) {
    this._offsetX = e, this._offsetY = n, this._realOffsetY = (this || window)._context.canvas.height + this._offsetY;
  }, t.computeRealOffsetY = function() {
    this._realOffsetY = (this || window)._context.canvas.height + this._offsetY;
  }, t.setViewScale = function(e, n) {
    this._scaleX = e, this._scaleY = n;
  }, t.getContext = function() {
    return this._context;
  }, t.save = function() {
    this._context.save(), this._saveCount++;
  }, t.restore = function() {
    this._context.restore(), this._saveCount--;
  }, t.setGlobalAlpha = function(e) {
    this._saveCount > 0 ? this._context.globalAlpha = e : this._currentAlpha !== e && (this._currentAlpha = e, this._context.globalAlpha = e);
  }, t.setCompositeOperation = function(e) {
    this._saveCount > 0 ? this._context.globalCompositeOperation = e : this._currentCompositeOperation !== e && (this._currentCompositeOperation = e, this._context.globalCompositeOperation = e);
  }, t.setFillStyle = function(e) {
    this._saveCount > 0 ? this._context.fillStyle = e : this._currentFillStyle !== e && (this._currentFillStyle = e, this._context.fillStyle = e);
  }, t.setStrokeStyle = function(e) {
    this._saveCount > 0 ? this._context.strokeStyle = e : this._currentStrokeStyle !== e && (this._currentStrokeStyle = e, this._context.strokeStyle = e);
  }, t.setTransform = function(e, n, r) {
    this._armatureMode > 0 ? (this.restore(), this.save(), this._context.transform(e.a * n, -e.b * r, -e.c * n, e.d * r, e.tx * n, -(e.ty * r))) : this._context.setTransform(e.a * n, -e.b * r, -e.c * n, e.d * r, this._offsetX + e.tx * n, this._realOffsetY - e.ty * r);
  }, t._switchToArmatureMode = function(e, n, r, s) {
    e ? (this._armatureMode++, this._context.setTransform(n.a, n.c, n.b, n.d, this._offsetX + n.tx * r, this._realOffsetY - n.ty * s), this.save()) : (this._armatureMode--, this.restore());
  };
})();
var Region = /* @__PURE__ */ H(function() {
  this._minX = 0, this._minY = 0, this._maxX = 0, this._maxY = 0, this._width = 0, this._height = 0, this._area = 0;
}, "Region"), regionProto = Region.prototype, regionPool = [];
function regionCreate() {
  var t = regionPool.pop();
  return t || (t = new Region()), t;
}
H(regionCreate, "regionCreate");
function regionRelease(t) {
  regionPool.push(t);
}
H(regionRelease, "regionRelease");
regionProto.setTo = function(t, e, n, r) {
  return this._minX = t, this._minY = e, this._maxX = n, this._maxY = r, this.updateArea(), (this || window)
};
regionProto.intValues = function() {
  this._minX = Math.floor(this._minX), this._minY = Math.floor(this._minY), this._maxX = Math.ceil(this._maxX), this._maxY = Math.ceil(this._maxY), this.updateArea();
};
regionProto.updateArea = function() {
  this._width = (this || window)._maxX - this._minX, this._height = (this || window)._maxY - this._minY, this._area = (this || window)._width * this._height;
};
regionProto.union = function(t) {
  if (this._width <= 0 || this._height <= 0) {
    this.setTo(t._minX, t._minY, t._maxX, t._maxY);
    return;
  }
  this._minX > t._minX && (this._minX = t._minX), this._minY > t._minY && (this._minY = t._minY), this._maxX < t._maxX && (this._maxX = t._maxX), this._maxY < t._maxY && (this._maxY = t._maxY), this.updateArea();
};
regionProto.setEmpty = function() {
  this._minX = 0, this._minY = 0, this._maxX = 0, this._maxY = 0, this._width = 0, this._height = 0, this._area = 0;
};
regionProto.isEmpty = function() {
  return this._width <= 0 || this._height <= 0;
};
regionProto.intersects = function(t) {
  if (this._width <= 0 || this._height <= 0 || t._width <= 0 || t._height <= 0)
    return !1;
  var e = (this || window)._minX > t._minX ? this._minX : t._minX, n = (this || window)._maxX < t._maxX ? this._maxX : t._maxX;
  return e > n ? !1 : (e = (this || window)._minY > t._minY ? this._minY : t._minY, n = (this || window)._maxY < t._maxY ? this._maxY : t._maxY, e <= n);
};
regionProto.updateRegion = function(t, e) {
  if (t.width == 0 || t.height == 0) {
    this.setEmpty();
    return;
  }
  var n = e, r = n.a, s = n.b, o = n.c, a = n.d, c = n.tx, l = n.ty, h = t.x, u = t.y, _ = h + t.width, d = u + t.height, f, C, m, g;
  if (r == 1 && s == 0 && o == 0 && a == 1)
    f = h + c - 1, C = u + l - 1, m = _ + c + 1, g = d + l + 1;
  else {
    var y = r * h + o * u + c, A = s * h + a * u + l, D = r * _ + o * u + c, N = s * _ + a * u + l, z = r * _ + o * d + c, M = s * _ + a * d + l, Z = r * h + o * d + c, U = s * h + a * d + l, Q = 0;
    y > D && (Q = y, y = D, D = Q), z > Z && (Q = z, z = Z, Z = Q), f = (y < z ? y : z) - 1, m = (D > Z ? D : Z) + 1, A > N && (Q = A, A = N, N = Q), M > U && (Q = M, M = U, U = Q), C = (A < M ? A : M) - 1, g = (N > U ? N : U) + 1;
  }
  this._minX = f, this._minY = C, this._maxX = m, this._maxY = g, this._width = m - f, this._height = g - C, this._area = (this || window)._width * this._height;
};
function unionArea(t, e) {
  var n = t._minX < e._minX ? t._minX : e._minX, r = t._minY < e._minY ? t._minY : e._minY, s = t._maxX > e._maxX ? t._maxX : e._maxX, o = t._maxY > e._maxY ? t._maxY : e._maxY;
  return (s - n) * (o - r);
}
H(unionArea, "unionArea");
var DirtyRegion = /* @__PURE__ */ H(function() {
  this.dirtyList = [], this.hasClipRect = !1, this.clipWidth = 0, this.clipHeight = 0, this.clipArea = 0, this.clipRectChanged = !1;
}, "DirtyRegion"), dirtyRegionProto = DirtyRegion.prototype;
dirtyRegionProto.setClipRect = function(t, e) {
  this.hasClipRect = !0, this.clipRectChanged = !0, this.clipWidth = Math.ceil(t), this.clipHeight = Math.ceil(e), this.clipArea = (this || window).clipWidth * this.clipHeight;
};
dirtyRegionProto.addRegion = function(t) {
  var e = t._minX, n = t._minY, r = t._maxX, s = t._maxY;
  if (this.hasClipRect && (e < 0 && (e = 0), n < 0 && (n = 0), r > this.clipWidth && (r = (this || window).clipWidth), s > this.clipHeight && (s = (this || window).clipHeight)), e >= r || n >= s)
    return !1;
  if (this.clipRectChanged)
    return !0;
  var o = (this || window).dirtyList, a = regionCreate();
  return o.push(a.setTo(e, n, r, s)), this.mergeDirtyList(o), !0;
};
dirtyRegionProto.clear = function() {
  for (var t = (this || window).dirtyList, e = t.length, n = 0; n < e; n++)
    regionRelease(t[n]);
  t.length = 0;
};
dirtyRegionProto.getDirtyRegions = function() {
  var t = (this || window).dirtyList;
  if (this.clipRectChanged) {
    this.clipRectChanged = !1, this.clear();
    var e = regionCreate();
    t.push(e.setTo(0, 0, this.clipWidth, this.clipHeight));
  } else
    for (; this.mergeDirtyList(t); )
      ;
  var n = (this || window).dirtyList.length;
  if (n > 0)
    for (var r = 0; r < n; r++)
      this.dirtyList[r].intValues();
  return this.dirtyList;
};
dirtyRegionProto.mergeDirtyList = function(t) {
  var e = t.length;
  if (e < 2)
    return !1;
  for (var n = (this || window).hasClipRect, r = e > 3 ? Number.POSITIVE_INFINITY : 0, s = 0, o = 0, a = 0, c = 0; c < e - 1; c++) {
    var l = t[c];
    n && (a += l.area);
    for (var h = c + 1; h < e; h++) {
      var u = t[h], _ = unionArea(l, u) - l.area - u.area;
      r > _ && (s = c, o = h, r = _);
    }
  }
  if (n && a / this.clipArea > 0.95 && (this.clipRectChanged = !0), s != o) {
    var d = t[o];
    return t[s].union(d), regionRelease(d), t.splice(o, 1), !0;
  }
  return !1;
};
cc.Region = Region;
cc.DirtyRegion = DirtyRegion;
cc.profiler = function() {
  var t = !1, e = !1, n = 0, r = 0, s = 0, o = 0, a = null, c = document.createElement("div"), l = document.createElement("div"), h = document.createElement("div"), u = document.createElement("div"), _ = 0.6, d = 10, f = [0, 10, 20, 30], C = [0, 0, 0, 0], m = 3, g = 0, y = 0;
  u.id = "fps", u.style.position = "absolute", u.style.padding = "3px", u.style.textAlign = "left", u.style.backgroundColor = "rgb(0, 0, 34)", u.style.bottom = cc.DIRECTOR_STATS_POSITION.y + "0px", u.style.left = cc.DIRECTOR_STATS_POSITION.x + "px", u.style.width = "45px", u.style.height = "60px";
  for (var A = [h, l, c], D = 0; D < 3; ++D) {
    var N = A[D].style;
    N.color = "rgb(0, 255, 255)", N.font = "bold 12px Helvetica, Arial", N.lineHeight = "20px", N.width = "100%", u.appendChild(A[D]);
  }
  var z = /* @__PURE__ */ H(function(U) {
    var Q = f.length - 1, et = Q, rt, w = 0;
    for (g++, y += U; et >= 0; et--)
      if (U >= f[et]) {
        C[et]++;
        break;
      }
    if (g >= d) {
      for (w = y / d, et = Q; et > 0; et--)
        if (rt = C[et] / d, rt >= _ && w >= f[et]) {
          et != m && (m = et, Z.onFrameRateChange && Z.onFrameRateChange(w.toFixed(2)));
          break;
        }
      for (_changeCount = 0, g = 0, y = 0, et = Q; et > 0; et--)
        C[et] = 0;
    }
  }, "analyseFPS"), M = /* @__PURE__ */ H(function() {
    s = cc.director.getSecondsPerFrame(), n++, o += cc.director.getDeltaTime(), o > cc.DIRECTOR_FPS_INTERVAL && (r = n / o, n = 0, o = 0, Z.onFrameRateChange && z(r), t && (l.innerText = s.toFixed(3), c.innerText = r.toFixed(1), h.innerText = (0 | cc.g_NumberOfDraws).toString()));
  }, "afterVisit"), Z = {
    onFrameRateChange: null,
    getSecondsPerFrame: function() {
      return s;
    },
    getFrameRate: function() {
      return r;
    },
    setProfileDuration: function(U) {
      !isNaN(U) && U > 0 && (d = U / cc.DIRECTOR_FPS_INTERVAL);
    },
    resumeProfiling: function() {
      cc.eventManager.addListener(a, 1);
    },
    stopProfiling: function() {
      cc.eventManager.removeListener(a);
    },
    isShowingStats: function() {
      return t;
    },
    showStats: function() {
      e || this.init(), u.parentElement === null && cc.container.appendChild(u), t = !0;
    },
    hideStats: function() {
      t = !1, u.parentElement === cc.container && cc.container.removeChild(u);
    },
    init: function() {
      e || (a = cc.eventManager.addCustomListener(cc.Director.EVENT_AFTER_VISIT, M), e = !0);
    }
  };
  return Z;
}();
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
    cc.DirectorDelegate = cc.Class.extend({
      updateProjection: function() {
      }
    });
    var t = cc.Director.prototype, e = /* @__PURE__ */ H(function(n) {
      if (n && n._renderCmd) {
        n._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        var r, s = n._children;
        for (r = 0; r < s.length; r++)
          e(s[r]);
      }
    }, "recursiveChild");
    cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, function() {
      cc.director;
      for (var n = cc.director._scenesStack, r = 0; r < n.length; r++)
        e(n[r]);
    }), t.setProjection = function(n) {
      var r = (this || window), s = r._winSizeInPoints;
      r.setViewport();
      var o = r._openGLView, a = o._viewPortRect.x / o._scaleX, c = o._viewPortRect.y / o._scaleY;
      switch (n) {
        case cc.Director.PROJECTION_2D:
          cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLLoadIdentity();
          var l = cc.math.Matrix4.createOrthographicProjection(
            0,
            s.width,
            0,
            s.height,
            -1024,
            1024
          );
          cc.kmGLMultMatrix(l), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLLoadIdentity();
          break;
        case cc.Director.PROJECTION_3D:
          var h = r.getZEye(), u = new cc.math.Matrix4(), _ = new cc.math.Matrix4();
          cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLLoadIdentity(), u = cc.math.Matrix4.createPerspectiveProjection(60, s.width / s.height, 0.1, h * 2), cc.kmGLMultMatrix(u), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLLoadIdentity();
          var d = new cc.math.Vec3(-a + s.width / 2, -c + s.height / 2, h), f = new cc.math.Vec3(-a + s.width / 2, -c + s.height / 2, 0), C = new cc.math.Vec3(0, 1, 0);
          _.lookAt(d, f, C), cc.kmGLMultMatrix(_);
          break;
        case cc.Director.PROJECTION_CUSTOM:
          r._projectionDelegate && r._projectionDelegate.updateProjection();
          break;
        default:
          cc.log(cc._LogInfos.Director_setProjection);
          break;
      }
      r._projection = n, cc.eventManager.dispatchEvent(r._eventProjectionChanged), cc.setProjectionMatrixDirty(), cc.renderer.childrenOrderDirty = !0;
    }, t.setDepthTest = function(n) {
      cc.renderer.setDepthTest(n);
    }, t.setClearColor = function(n) {
      cc.renderer._clearColor = n;
    }, t.setOpenGLView = function(n) {
      var r = (this || window);
      r._winSizeInPoints.width = cc._canvas.width, r._winSizeInPoints.height = cc._canvas.height, r._openGLView = n || cc.view;
      var s = cc.configuration;
      s.gatherGPUInfo(), s.dumpInfo(), r.setGLDefaultValues(), cc.eventManager && cc.eventManager.setEnabled(!0);
    }, t._clear = function() {
      var n = cc._renderContext;
      n.clear(n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT);
    }, t.getVisibleSize = function() {
      return this._openGLView.getVisibleSize();
    }, t.getVisibleOrigin = function() {
      return this._openGLView.getVisibleOrigin();
    }, t.getZEye = function() {
      return this._winSizeInPoints.height / 1.1566;
    }, t.setViewport = function() {
      var n = (this || window)._openGLView;
      if (n) {
        var r = (this || window)._winSizeInPoints;
        n.setViewPortInPoints(-n._viewPortRect.x / n._scaleX, -n._viewPortRect.y / n._scaleY, r.width, r.height);
      }
    }, t.getOpenGLView = function() {
      return this._openGLView;
    }, t.getProjection = function() {
      return this._projection;
    }, t.setAlphaBlending = function(n) {
      n ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO);
    }, t.setGLDefaultValues = function() {
      var n = (this || window);
      n.setAlphaBlending(!0), n.setProjection(n._projection), cc._renderContext.clearColor(0, 0, 0, 0);
    };
  }
});
cc.configuration = {
  ERROR: 0,
  STRING: 1,
  INT: 2,
  DOUBLE: 3,
  BOOLEAN: 4,
  _maxTextureSize: 0,
  _maxModelviewStackDepth: 0,
  _supportsPVRTC: !1,
  _supportsNPOT: !1,
  _supportsBGRA8888: !1,
  _supportsDiscardFramebuffer: !1,
  _supportsShareableVAO: !1,
  _maxSamplesAllowed: 0,
  _maxTextureUnits: 0,
  _GlExtensions: "",
  _valueDict: {},
  _inited: !1,
  _init: function() {
    var t = (this || window)._valueDict;
    t["cocos2d.x.version"] = cc.ENGINE_VERSION, t["cocos2d.x.compiled_with_profiler"] = !1, t["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE, this._inited = !0;
  },
  getMaxTextureSize: function() {
    return this._maxTextureSize;
  },
  getMaxModelviewStackDepth: function() {
    return this._maxModelviewStackDepth;
  },
  getMaxTextureUnits: function() {
    return this._maxTextureUnits;
  },
  supportsNPOT: function() {
    return this._supportsNPOT;
  },
  supportsPVRTC: function() {
    return this._supportsPVRTC;
  },
  supportsETC: function() {
    return !1;
  },
  supportsS3TC: function() {
    return !1;
  },
  supportsATITC: function() {
    return !1;
  },
  supportsBGRA8888: function() {
    return this._supportsBGRA8888;
  },
  supportsDiscardFramebuffer: function() {
    return this._supportsDiscardFramebuffer;
  },
  supportsShareableVAO: function() {
    return this._supportsShareableVAO;
  },
  checkForGLExtension: function(t) {
    return this._GlExtensions.indexOf(t) > -1;
  },
  getValue: function(t, e) {
    this._inited || this._init();
    var n = (this || window)._valueDict;
    return n[t] ? n[t] : e;
  },
  setValue: function(t, e) {
    this._valueDict[t] = e;
  },
  dumpInfo: function() {
    cc.ENABLE_GL_STATE_CACHE === 0 && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""));
  },
  gatherGPUInfo: function() {
    if (cc._renderType !== cc.game.RENDER_TYPE_CANVAS) {
      this._inited || this._init();
      var t = cc._renderContext, e = (this || window)._valueDict;
      e["gl.vendor"] = t.getParameter(t.VENDOR), e["gl.renderer"] = t.getParameter(t.RENDERER), e["gl.version"] = t.getParameter(t.VERSION), this._GlExtensions = "";
      for (var n = t.getSupportedExtensions(), r = 0; r < n.length; r++)
        this._GlExtensions += n[r] + " ";
      this._maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), e["gl.max_texture_size"] = (this || window)._maxTextureSize, this._maxTextureUnits = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS), e["gl.max_texture_units"] = (this || window)._maxTextureUnits, this._supportsPVRTC = (this || window).checkForGLExtension("GL_IMG_texture_compression_pvrtc"), e["gl.supports_PVRTC"] = (this || window)._supportsPVRTC, this._supportsNPOT = !1, e["gl.supports_NPOT"] = (this || window)._supportsNPOT, this._supportsBGRA8888 = (this || window).checkForGLExtension("GL_IMG_texture_format_BGRA888"), e["gl.supports_BGRA8888"] = (this || window)._supportsBGRA8888, this._supportsDiscardFramebuffer = (this || window).checkForGLExtension("GL_EXT_discard_framebuffer"), e["gl.supports_discard_framebuffer"] = (this || window)._supportsDiscardFramebuffer, this._supportsShareableVAO = (this || window).checkForGLExtension("vertex_array_object"), e["gl.supports_vertex_array_object"] = (this || window)._supportsShareableVAO, cc.checkGLErrorDebug();
    }
  },
  loadConfigFile: function(t) {
    this._inited || this._init();
    var e = cc.loader.getRes(t);
    if (!e)
      throw new Error("Please load the resource first : " + t);
    cc.assert(e, cc._LogInfos.configuration_loadConfigFile_2, t);
    var n = e.data;
    if (!n) {
      cc.log(cc._LogInfos.configuration_loadConfigFile, t);
      return;
    }
    for (var r in n)
      this._valueDict[r] = n[r];
  }
};
cc.rendererWebGL = function() {
  var t = {
    texture: null,
    blendSrc: null,
    blendDst: null,
    shader: null
  }, e = null, n = null, r = 0, s = 0, o = 6, a = null, c = 0, l = null, h = null;
  function u(d) {
    var f = cc._renderContext;
    if (e) {
      f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, e);
      for (var C = new Uint16Array(d * 6), m = 0, g = 0, y = d * 6; g < y; g += 6)
        C[g] = m + 0, C[g + 1] = m + 1, C[g + 2] = m + 2, C[g + 3] = m + 1, C[g + 4] = m + 2, C[g + 5] = m + 3, m += 4;
      f.bufferData(f.ELEMENT_ARRAY_BUFFER, C, f.STATIC_DRAW);
    }
    if (n) {
      c = d * 4 * o;
      var A = c * 4;
      a = new ArrayBuffer(A), l = new Float32Array(a), h = new Uint32Array(a), f.bindBuffer(f.ARRAY_BUFFER, n), f.bufferData(f.ARRAY_BUFFER, l, f.DYNAMIC_DRAW);
    }
    r = d * 4;
  }
  H(u, "updateQuadBuffer");
  function _(d) {
    var f = cc._renderContext;
    e === null && (n = f.createBuffer(), e = f.createBuffer()), u(d);
  }
  return H(_, "initQuadBuffer"), {
    mat4Identity: null,
    childrenOrderDirty: !0,
    assignedZ: 0,
    assignedZStep: 1 / 100,
    _transformNodePool: [],
    _renderCmds: [],
    _isCacheToBufferOn: !1,
    _cacheToBufferCmds: {},
    _cacheInstanceIds: [],
    _currentID: 0,
    _clearColor: cc.color(),
    init: function() {
      var d = cc._renderContext;
      d.disable(d.CULL_FACE), d.disable(d.DEPTH_TEST), this.mat4Identity = new cc.math.Matrix4(), this.mat4Identity.identity(), _(2e3), cc.sys.os, cc.sys.OS_IOS;
    },
    getVertexSize: function() {
      return r;
    },
    getRenderCmd: function(d) {
      return d._createRenderCmd();
    },
    _turnToCacheMode: function(d) {
      this._isCacheToBufferOn = !0, d = d || 0, this._cacheToBufferCmds[d] ? this._cacheToBufferCmds[d].length = 0 : this._cacheToBufferCmds[d] = [], this._cacheInstanceIds.indexOf(d) === -1 && this._cacheInstanceIds.push(d), this._currentID = d;
    },
    _turnToNormalMode: function() {
      this._isCacheToBufferOn = !1;
    },
    _removeCache: function(d) {
      d = d || this._currentID;
      var f = (this || window)._cacheToBufferCmds[d];
      f && (f.length = 0, delete this._cacheToBufferCmds[d]);
      var C = (this || window)._cacheInstanceIds;
      cc.arrayRemoveObject(C, d);
    },
    _renderingToBuffer: function(d) {
      d = d || this._currentID;
      var f = (this || window)._cacheToBufferCmds[d], C = cc._renderContext;
      this.rendering(C, f), this._removeCache(d);
      var m = (this || window)._cacheInstanceIds;
      m.length === 0 ? this._isCacheToBufferOn = !1 : this._currentID = m[m.length - 1];
    },
    resetFlag: function() {
      this.childrenOrderDirty && (this.childrenOrderDirty = !1), this._transformNodePool.length = 0;
    },
    transform: function() {
      var d = (this || window)._transformNodePool;
      d.sort(this._sortNodeByLevelAsc);
      var f, C, m;
      for (f = 0, C = d.length; f < C; f++)
        m = d[f], m.updateStatus();
      d.length = 0;
    },
    transformDirty: function() {
      return this._transformNodePool.length > 0;
    },
    _sortNodeByLevelAsc: function(d, f) {
      return d._curLevel - f._curLevel;
    },
    pushDirtyNode: function(d) {
      this._transformNodePool.push(d);
    },
    clearRenderCommands: function() {
      this._renderCmds.length = 0;
    },
    clear: function() {
      var d = cc._renderContext;
      d.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a), d.clear(d.COLOR_BUFFER_BIT | d.DEPTH_BUFFER_BIT);
    },
    setDepthTest: function(d) {
      var f = cc._renderContext;
      d ? (f.clearDepth(1), f.enable(f.DEPTH_TEST), f.depthFunc(f.LEQUAL)) : f.disable(f.DEPTH_TEST);
    },
    pushRenderCommand: function(d) {
      if (d.needDraw())
        if (this._isCacheToBufferOn) {
          var f = (this || window)._currentID, C = (this || window)._cacheToBufferCmds, m = C[f];
          m.indexOf(d) === -1 && m.push(d);
        } else
          this._renderCmds.indexOf(d) === -1 && this._renderCmds.push(d);
    },
    _increaseBatchingSize: function(d) {
      s += d;
    },
    _uploadBufferData: function(d) {
      s >= r && this._batchRendering();
      var f = d._node._texture, C = d._node._blendFunc.src, m = d._node._blendFunc.dst, g = d._shaderProgram;
      (t.texture !== f || t.blendSrc !== C || t.blendDst !== m || t.shader !== g) && (this._batchRendering(), t.texture = f, t.blendSrc = C, t.blendDst = m, t.shader = g);
      var y = d.uploadData(l, h, s * o);
      y > 0 && (s += y);
    },
    _batchRendering: function() {
      if (!(s === 0 || !t.texture)) {
        var d = cc._renderContext, f = t.texture, C = t.shader, m = s / 4;
        C && (C.use(), C._updateProjectionUniform()), cc.glBlendFunc(t.blendSrc, t.blendDst), cc.glBindTexture2DN(0, f);
        var g = !d.bindBuffer(d.ARRAY_BUFFER, n);
        if (s > r * 0.5)
          d.bufferData(d.ARRAY_BUFFER, l, d.DYNAMIC_DRAW);
        else {
          var y = l.subarray(0, s * o);
          d.bufferData(d.ARRAY_BUFFER, y, d.DYNAMIC_DRAW);
        }
        g && (d.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), d.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), d.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, d.FLOAT, !1, 24, 0), d.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, d.UNSIGNED_BYTE, !0, 24, 12), d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, d.FLOAT, !1, 24, 16)), d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, e), d.drawElements(d.TRIANGLES, m * 6, d.UNSIGNED_SHORT, 0), cc.g_NumberOfDraws++, s = 0;
      }
    },
    rendering: function(d, f) {
      var C = f || this._renderCmds, m, g, y, A = d || cc._renderContext;
      for (A.bindBuffer(gl.ARRAY_BUFFER, null), m = 0, g = C.length; m < g; ++m)
        y = C[m], y.uploadData ? this._uploadBufferData(y) : (s > 0 && this._batchRendering(), y.rendering(A));
      this._batchRendering(), t.texture = null;
    }
  };
}();
(function() {
  cc.Node.WebGLRenderCmd = function(e) {
    cc.Node.RenderCmd.call(this, e), this._shaderProgram = null;
  };
  var t = cc.Node.WebGLRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
  t.constructor = cc.Node.WebGLRenderCmd, t._updateColor = function() {
  }, t.setShaderProgram = function(e) {
    this._shaderProgram = e;
  }, t.getShaderProgram = function() {
    return this._shaderProgram;
  };
})();
(function() {
  cc.Layer.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e);
  };
  var t = cc.Layer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.Layer.WebGLRenderCmd, t.bake = function() {
  }, t.unbake = function() {
  }, t._bakeForAddChild = function() {
  };
})();
(function() {
  cc.LayerColor.WebGLRenderCmd = function(e) {
    cc.Layer.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._matrix = new cc.math.Matrix4(), this._matrix.identity();
    var n = (this || window);
    n._squareVerticesAB = new ArrayBuffer(48), n._squareColorsAB = new ArrayBuffer(16);
    var r = n._squareVerticesAB, s = n._squareColorsAB, o = cc.Vertex3F.BYTES_PER_ELEMENT, a = cc.Color.BYTES_PER_ELEMENT;
    n._squareVertices = [
      new cc.Vertex3F(0, 0, 0, r, 0),
      new cc.Vertex3F(0, 0, 0, r, o),
      new cc.Vertex3F(0, 0, 0, r, o * 2),
      new cc.Vertex3F(0, 0, 0, r, o * 3)
    ], n._squareColors = [
      cc.color(0, 0, 0, 255, s, 0),
      cc.color(0, 0, 0, 255, s, a),
      cc.color(0, 0, 0, 255, s, a * 2),
      cc.color(0, 0, 0, 255, s, a * 3)
    ], n._verticesFloat32Buffer = cc._renderContext.createBuffer(), n._colorsUint8Buffer = cc._renderContext.createBuffer(), this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR);
  };
  var t = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
  t.constructor = cc.LayerColor.WebGLRenderCmd, t.rendering = function(e) {
    var n = e || cc._renderContext, r = (this || window)._node, s = (this || window)._worldTransform;
    this._matrix.mat[0] = s.a, this._matrix.mat[4] = s.c, this._matrix.mat[12] = s.tx, this._matrix.mat[1] = s.b, this._matrix.mat[5] = s.d, this._matrix.mat[13] = s.ty, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix), n.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), n.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc.glBlendFunc(r._blendFunc.src, r._blendFunc.dst), n.bindBuffer(n.ARRAY_BUFFER, this._verticesFloat32Buffer), n.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this._colorsUint8Buffer), n.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, n.UNSIGNED_BYTE, !0, 0, 0), n.drawArrays(n.TRIANGLE_STRIP, 0, this._squareVertices.length);
  }, t.transform = function(e, n) {
    this.originTransform(e, n);
    var r = (this || window)._node, s = r._contentSize.width, o = r._contentSize.height, a = (this || window)._squareVertices;
    a[1].x = s, a[2].y = o, a[3].x = s, a[3].y = o, a[0].z = a[1].z = a[2].z = a[3].z = r._vertexZ, this._bindLayerVerticesBufferData();
  }, t._updateColor = function() {
    for (var e = (this || window)._displayedColor, n = (this || window)._displayedOpacity, r = (this || window)._squareColors, s = 0; s < 4; s++)
      r[s].r = e.r, r[s].g = e.g, r[s].b = e.b, r[s].a = n;
    this._bindLayerColorsBufferData();
  }, t._bindLayerVerticesBufferData = function() {
    var e = cc._renderContext;
    e.bindBuffer(e.ARRAY_BUFFER, this._verticesFloat32Buffer), e.bufferData(e.ARRAY_BUFFER, this._squareVerticesAB, e.DYNAMIC_DRAW);
  }, t._bindLayerColorsBufferData = function() {
    var e = cc._renderContext;
    e.bindBuffer(e.ARRAY_BUFFER, this._colorsUint8Buffer), e.bufferData(e.ARRAY_BUFFER, this._squareColorsAB, e.STATIC_DRAW);
  }, t.updateBlendFunc = function(e) {
  };
})();
(function() {
  cc.LayerGradient.WebGLRenderCmd = function(e) {
    cc.LayerColor.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._clipRect = new cc.Rect(), this._clippingRectDirty = !1;
  };
  var t = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
  t.constructor = cc.LayerGradient.WebGLRenderCmd, t.updateStatus = function() {
    var e = cc.Node._dirtyFlags, n = (this || window)._dirtyFlag;
    n & e.gradientDirty && (this._dirtyFlag |= e.colorDirty, this._updateVertex(), this._dirtyFlag = n & e.gradientDirty ^ n), cc.Node.RenderCmd.prototype.updateStatus.call(this);
  }, t._syncStatus = function(e) {
    var n = cc.Node._dirtyFlags, r = (this || window)._dirtyFlag;
    r & n.gradientDirty && (this._dirtyFlag |= n.colorDirty, this._updateVertex(), this._dirtyFlag = r & n.gradientDirty ^ r), cc.Node.RenderCmd.prototype._syncStatus.call(this, e);
  }, t.transform = function(e, n) {
    this.originTransform(e, n), this._updateVertex();
  }, t._updateVertex = function() {
    var e = (this || window)._node, n = e._colorStops;
    if (!(!n || n.length < 2)) {
      this._clippingRectDirty = !0;
      var r = n.length, s = r * 2, o, a = e._contentSize, c = (this || window)._squareVertices;
      if (c.length < s) {
        this._squareVerticesAB = new ArrayBuffer(s * 12), c.length = 0;
        var l = (this || window)._squareVerticesAB, h = cc.Vertex3F.BYTES_PER_ELEMENT;
        for (o = 0; o < s; o++)
          c.push(new cc.Vertex3F(0, 0, 0, l, h * o));
      }
      var u = Math.PI + cc.pAngleSigned(cc.p(0, -1), e._alongVector), _ = cc.p(a.width / 2, a.height / 2), d = Math.round(cc.radiansToDegrees(u)), f = cc.affineTransformMake(1, 0, 0, 1, _.x, _.y);
      f = cc.affineTransformRotate(f, u);
      var C, m;
      d < 90 ? (C = cc.p(-_.x, _.y), m = cc.p(_.x, _.y)) : d < 180 ? (C = cc.p(_.x, _.y), m = cc.p(_.x, -_.y)) : d < 270 ? (C = cc.p(_.x, -_.y), m = cc.p(-_.x, -_.y)) : (C = cc.p(-_.x, -_.y), m = cc.p(-_.x, _.y));
      var g = Math.sin(u), y = Math.cos(u), A = Math.abs((C.x * y - C.y * g) / _.x), D = Math.abs((m.x * g + m.y * y) / _.y);
      for (f = cc.affineTransformScale(f, A, D), o = 0; o < r; o++) {
        var N = n[o], z = N.p * a.height, M = cc.pointApplyAffineTransform(-_.x, z - _.y, f);
        c[o * 2].x = M.x, c[o * 2].y = M.y, c[o * 2].z = e._vertexZ;
        var Z = cc.pointApplyAffineTransform(a.width - _.x, z - _.y, f);
        c[o * 2 + 1].x = Z.x, c[o * 2 + 1].y = Z.y, c[o * 2 + 1].z = e._vertexZ;
      }
      this._bindLayerVerticesBufferData();
    }
  }, t._updateColor = function() {
    var e = (this || window)._node, n = e._colorStops;
    if (!(!n || n.length < 2)) {
      var r = n.length, s = (this || window)._squareColors, o = r * 2;
      if (s.length < o) {
        this._squareColorsAB = new ArrayBuffer(o * 4), s.length = 0;
        var a = (this || window)._squareColorsAB, c = cc.Color.BYTES_PER_ELEMENT;
        for (i = 0; i < o; i++)
          s.push(cc.color(0, 0, 0, 255, a, c * i));
      }
      var l = (this || window)._displayedOpacity / 255;
      for (i = 0; i < r; i++) {
        var h = n[i].color, u = s[i * 2], _ = s[i * 2 + 1];
        u.r = h.r, u.g = h.g, u.b = h.b, u.a = h.a * l, _.r = h.r, _.g = h.g, _.b = h.b, _.a = h.a * l;
      }
      this._bindLayerColorsBufferData();
    }
  }, t.rendering = function(e) {
    var n = e || cc._renderContext, r = (this || window)._node, s = (this || window)._getClippingRect();
    n.enable(n.SCISSOR_TEST), cc.view.setScissorInPoints(s.x, s.y, s.width, s.height);
    var o = (this || window)._worldTransform;
    this._matrix.mat[0] = o.a, this._matrix.mat[4] = o.c, this._matrix.mat[12] = o.tx, this._matrix.mat[1] = o.b, this._matrix.mat[5] = o.d, this._matrix.mat[13] = o.ty, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix), n.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), n.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc.glBlendFunc(r._blendFunc.src, r._blendFunc.dst), n.bindBuffer(n.ARRAY_BUFFER, this._verticesFloat32Buffer), n.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, n.FLOAT, !1, 0, 0), n.bindBuffer(n.ARRAY_BUFFER, this._colorsUint8Buffer), n.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, n.UNSIGNED_BYTE, !0, 0, 0), n.drawArrays(n.TRIANGLE_STRIP, 0, this._squareVertices.length), n.disable(n.SCISSOR_TEST);
  }, t._getClippingRect = function() {
    if (this._clippingRectDirty) {
      var e = (this || window)._node, n = cc.rect(0, 0, e._contentSize.width, e._contentSize.height), r = e.getNodeToWorldTransform();
      this._clipRect = cc._rectApplyAffineTransformIn(n, r);
    }
    return this._clipRect;
  };
})();
(function() {
  cc.Sprite.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._vertices = [
      { x: 0, y: 0, u: 0, v: 0 },
      { x: 0, y: 0, u: 0, v: 0 },
      { x: 0, y: 0, u: 0, v: 0 },
      { x: 0, y: 0, u: 0, v: 0 }
    ], this._color = new Uint32Array(1), this._dirty = !1, this._recursiveDirty = !1, this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST);
  };
  var t = cc.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.Sprite.WebGLRenderCmd, t.updateBlendFunc = function(e) {
  }, t.setDirtyFlag = function(e) {
    cc.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, e), this._dirty = !0;
  }, t.setDirtyRecursively = function(e) {
    this._recursiveDirty = e, this._dirty = e;
    for (var n = (this || window)._node._children, r, s = n ? n.length : 0, o = 0; o < s; o++)
      r = n[o], r instanceof cc.Sprite && r._renderCmd.setDirtyRecursively(e);
  }, t._setBatchNodeForAddChild = function(e) {
    var n = (this || window)._node;
    if (n._batchNode) {
      if (!(e instanceof cc.Sprite))
        return cc.log(cc._LogInfos.Sprite_addChild), !1;
      e.texture._webTextureObj !== n.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2), n._batchNode.appendChild(e), n._reorderChildDirty || n._setReorderChildDirtyRecursively();
    }
    return !0;
  }, t._handleTextureForRotatedTexture = function(e) {
    return e;
  }, t.isFrameDisplayed = function(e) {
    var n = (this || window)._node;
    return cc.rectEqualToRect(e.getRect(), n._rect) && e.getTexture().getName() === n._texture.getName() && cc.pointEqualToPoint(e.getOffset(), n._unflippedOffsetPositionFromCenter);
  }, t._textureLoadedCallback = function(e) {
    if (!this._textureLoaded) {
      this._textureLoaded = !0;
      var n = (this || window)._rect;
      n ? cc._rectEqualToZero(n) && (n.width = e.width, n.height = e.height) : n = cc.rect(0, 0, e.width, e.height), this.texture = e, this.setTextureRect(n, this._rectRotated), this.setBatchNode(this._batchNode), this.dispatchEvent("load"), cc.renderer.childrenOrderDirty = !0;
    }
  }, t._setTextureCoords = function(e, n) {
    n === void 0 && (n = !0), n && (e = cc.rectPointsToPixels(e));
    var r = (this || window)._node, s = r._batchNode ? r.textureAtlas.texture : r._texture, o = (this || window)._vertices;
    if (s) {
      var a = s.pixelsWidth, c = s.pixelsHeight, l, h, u, _, d;
      r._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (l = (2 * e.x + 1) / (2 * a), h = l + (e.height * 2 - 2) / (2 * a), u = (2 * e.y + 1) / (2 * c), _ = u + (e.width * 2 - 2) / (2 * c)) : (l = e.x / a, h = (e.x + e.height) / a, u = e.y / c, _ = (e.y + e.width) / c), r._flippedX && (d = u, u = _, _ = d), r._flippedY && (d = l, l = h, h = d), o[0].u = h, o[0].v = u, o[1].u = l, o[1].v = u, o[2].u = h, o[2].v = _, o[3].u = l, o[3].v = _) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (l = (2 * e.x + 1) / (2 * a), h = l + (e.width * 2 - 2) / (2 * a), u = (2 * e.y + 1) / (2 * c), _ = u + (e.height * 2 - 2) / (2 * c)) : (l = e.x / a, h = (e.x + e.width) / a, u = e.y / c, _ = (e.y + e.height) / c), r._flippedX && (d = l, l = h, h = d), r._flippedY && (d = u, u = _, _ = d), o[0].u = l, o[0].v = u, o[1].u = l, o[1].v = _, o[2].u = h, o[2].v = u, o[3].u = h, o[3].v = _);
    }
  }, t._setColorDirty = function() {
  }, t._updateBlendFunc = function() {
    if (this._batchNode) {
      cc.log(cc._LogInfos.Sprite__updateBlendFunc);
      return;
    }
    var e = (this || window)._node, n = e._blendFunc;
    !e._texture || !e._texture.hasPremultipliedAlpha() ? (n.src === cc.ONE && n.dst === cc.BLEND_DST && (n.src = cc.SRC_ALPHA), e.opacityModifyRGB = !1) : (n.src === cc.SRC_ALPHA && n.dst === cc.BLEND_DST && (n.src = cc.ONE), e.opacityModifyRGB = !0);
  }, t._setTexture = function(e) {
    var n = (this || window)._node;
    if (n._batchNode) {
      if (n._batchNode.texture !== e) {
        cc.log(cc._LogInfos.Sprite_setTexture);
        return;
      }
    } else
      n._texture !== e && (n._textureLoaded = e ? e._textureLoaded : !1, n._texture = e, this._updateBlendFunc(), n._textureLoaded && (cc.renderer.childrenOrderDirty = !0));
  }, t._checkTextureBoundary = function(e, n, r) {
    if (e && e.url) {
      var s, o;
      r ? (s = n.x + n.height, o = n.y + n.width) : (s = n.x + n.width, o = n.y + n.height), s > e.width && cc.error(cc._LogInfos.RectWidth, e.url), o > e.height && cc.error(cc._LogInfos.RectHeight, e.url);
    }
  }, t.transform = function(e, n) {
    this.originTransform(e, n);
    var r = (this || window)._node, s = r._offsetPosition.x, o = s + r._rect.width, a = r._offsetPosition.y, c = a + r._rect.height, l = (this || window)._worldTransform, h = (this || window)._vertices;
    h[0].x = s * l.a + c * l.c + l.tx, h[0].y = s * l.b + c * l.d + l.ty, h[1].x = s * l.a + a * l.c + l.tx, h[1].y = s * l.b + a * l.d + l.ty, h[2].x = o * l.a + c * l.c + l.tx, h[2].y = o * l.b + c * l.d + l.ty, h[3].x = o * l.a + a * l.c + l.tx, h[3].y = o * l.b + a * l.d + l.ty;
  }, t.needDraw = function() {
    var e = (this || window)._node, n = e._texture;
    return this._needDraw && n;
  }, t.uploadData = function(e, n, r) {
    var s = (this || window)._node, o = s._texture;
    if (!(o && o._textureLoaded && s._rect.width && s._rect.height) || !this._displayedOpacity)
      return !1;
    var a = (this || window)._displayedOpacity, c = (this || window)._displayedColor.r, l = (this || window)._displayedColor.g, h = (this || window)._displayedColor.b;
    if (s._opacityModifyRGB) {
      var u = a / 255;
      c *= u, l *= u, h *= u;
    }
    this._color[0] = a << 24 | h << 16 | l << 8 | c;
    var _ = s._vertexZ, d = (this || window)._vertices, f, C = d.length, m, g = r;
    for (f = 0; f < C; ++f)
      m = d[f], e[g] = m.x, e[g + 1] = m.y, e[g + 2] = _, n[g + 3] = (this || window)._color[0], e[g + 4] = m.u, e[g + 5] = m.v, g += 6;
    return C;
  };
})();
(function() {
  cc.LabelTTF.WebGLRenderCmd = function(e) {
    cc.Sprite.WebGLRenderCmd.call(this, e), cc.LabelTTF.CacheRenderCmd.call(this);
  };
  var t = cc.LabelTTF.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
  cc.inject(cc.LabelTTF.CacheRenderCmd.prototype, t), t.constructor = cc.LabelTTF.WebGLRenderCmd, t._updateColor = function() {
  };
})();
cc.DrawingPrimitiveWebGL = cc.Class.extend({
  _renderContext: null,
  _initialized: !1,
  _shader: null,
  _colorLocation: "u_color",
  _colorArray: null,
  _pointSizeLocation: "u_pointSize",
  _pointSize: -1,
  ctor: function(t) {
    if (t == null && (t = cc._renderContext), !t instanceof WebGLRenderingContext)
      throw new Error("Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext");
    this._renderContext = t, this._colorArray = new Float32Array([1, 1, 1, 1]);
  },
  lazy_init: function() {
    var t = (this || window);
    t._initialized || (t._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR), t._shader._addUniformLocation(this._colorLocation), t._shader._addUniformLocation(this._pointSizeLocation), t._initialized = !0);
  },
  drawInit: function() {
    this._initialized = !1;
  },
  drawPoint: function(t) {
    this.lazy_init();
    var e = (this || window)._renderContext;
    this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), e.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray), this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
    var n = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, n), e.bufferData(e.ARRAY_BUFFER, new Float32Array([t.x, t.y]), e.STATIC_DRAW), e.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, e.FLOAT, !1, 0, 0), e.drawArrays(e.POINTS, 0, 1), e.deleteBuffer(n), cc.incrementGLDraws(1);
  },
  drawPoints: function(t, e) {
    if (!(!t || t.length === 0)) {
      this.lazy_init();
      var n = (this || window)._renderContext;
      this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), n.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray), this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
      var r = n.createBuffer();
      n.bindBuffer(n.ARRAY_BUFFER, r), n.bufferData(n.ARRAY_BUFFER, this._pointsToTypeArray(t), n.STATIC_DRAW), n.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, n.FLOAT, !1, 0, 0), n.drawArrays(n.POINTS, 0, t.length), n.deleteBuffer(r), cc.incrementGLDraws(1);
    }
  },
  _pointsToTypeArray: function(t) {
    for (var e = new Float32Array(t.length * 2), n = 0; n < t.length; n++)
      e[n * 2] = t[n].x, e[n * 2 + 1] = t[n].y;
    return e;
  },
  drawLine: function(t, e) {
    this.lazy_init();
    var n = (this || window)._renderContext;
    this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), n.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
    var r = n.createBuffer();
    n.bindBuffer(n.ARRAY_BUFFER, r), n.bufferData(n.ARRAY_BUFFER, this._pointsToTypeArray([t, e]), n.STATIC_DRAW), n.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, n.FLOAT, !1, 0, 0), n.drawArrays(n.LINES, 0, 2), n.deleteBuffer(r), cc.incrementGLDraws(1);
  },
  drawRect: function(t, e) {
    this.drawLine(cc.p(t.x, t.y), cc.p(e.x, t.y)), this.drawLine(cc.p(e.x, t.y), cc.p(e.x, e.y)), this.drawLine(cc.p(e.x, e.y), cc.p(t.x, e.y)), this.drawLine(cc.p(t.x, e.y), cc.p(t.x, t.y));
  },
  drawSolidRect: function(t, e, n) {
    var r = [
      t,
      cc.p(e.x, t.y),
      e,
      cc.p(t.x, e.y)
    ];
    this.drawSolidPoly(r, 4, n);
  },
  drawPoly: function(t, e, n) {
    this.lazy_init();
    var r = (this || window)._renderContext;
    this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), r.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
    var s = r.createBuffer();
    r.bindBuffer(r.ARRAY_BUFFER, s), r.bufferData(r.ARRAY_BUFFER, this._pointsToTypeArray(t), r.STATIC_DRAW), r.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, r.FLOAT, !1, 0, 0), n ? r.drawArrays(r.LINE_LOOP, 0, t.length) : r.drawArrays(r.LINE_STRIP, 0, t.length), r.deleteBuffer(s), cc.incrementGLDraws(1);
  },
  drawSolidPoly: function(t, e, n) {
    this.lazy_init(), n && this.setDrawColor(n.r, n.g, n.b, n.a);
    var r = (this || window)._renderContext;
    this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), r.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
    var s = r.createBuffer();
    r.bindBuffer(r.ARRAY_BUFFER, s), r.bufferData(r.ARRAY_BUFFER, this._pointsToTypeArray(t), r.STATIC_DRAW), r.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, r.FLOAT, !1, 0, 0), r.drawArrays(r.TRIANGLE_FAN, 0, t.length), r.deleteBuffer(s), cc.incrementGLDraws(1);
  },
  drawCircle: function(t, e, n, r, s) {
    this.lazy_init();
    var o = 1;
    s && o++;
    var a = 2 * Math.PI / r, c = new Float32Array((r + 2) * 2);
    if (c) {
      for (var l = 0; l <= r; l++) {
        var h = l * a, u = e * Math.cos(h + n) + t.x, _ = e * Math.sin(h + n) + t.y;
        c[l * 2] = u, c[l * 2 + 1] = _;
      }
      c[(r + 1) * 2] = t.x, c[(r + 1) * 2 + 1] = t.y;
      var d = (this || window)._renderContext;
      this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), d.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
      var f = d.createBuffer();
      d.bindBuffer(d.ARRAY_BUFFER, f), d.bufferData(d.ARRAY_BUFFER, c, d.STATIC_DRAW), d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, d.FLOAT, !1, 0, 0), d.drawArrays(d.LINE_STRIP, 0, r + o), d.deleteBuffer(f), cc.incrementGLDraws(1);
    }
  },
  drawQuadBezier: function(t, e, n, r) {
    this.lazy_init();
    for (var s = new Float32Array((r + 1) * 2), o = 0, a = 0; a < r; a++)
      s[a * 2] = Math.pow(1 - o, 2) * t.x + 2 * (1 - o) * o * e.x + o * o * n.x, s[a * 2 + 1] = Math.pow(1 - o, 2) * t.y + 2 * (1 - o) * o * e.y + o * o * n.y, o += 1 / r;
    s[r * 2] = n.x, s[r * 2 + 1] = n.y;
    var c = (this || window)._renderContext;
    this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), c.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
    var l = c.createBuffer();
    c.bindBuffer(c.ARRAY_BUFFER, l), c.bufferData(c.ARRAY_BUFFER, s, c.STATIC_DRAW), c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0), c.drawArrays(c.LINE_STRIP, 0, r + 1), c.deleteBuffer(l), cc.incrementGLDraws(1);
  },
  drawCubicBezier: function(t, e, n, r, s) {
    this.lazy_init();
    for (var o = new Float32Array((s + 1) * 2), a = 0, c = 0; c < s; c++)
      o[c * 2] = Math.pow(1 - a, 3) * t.x + 3 * Math.pow(1 - a, 2) * a * e.x + 3 * (1 - a) * a * a * n.x + a * a * a * r.x, o[c * 2 + 1] = Math.pow(1 - a, 3) * t.y + 3 * Math.pow(1 - a, 2) * a * e.y + 3 * (1 - a) * a * a * n.y + a * a * a * r.y, a += 1 / s;
    o[s * 2] = r.x, o[s * 2 + 1] = r.y;
    var l = (this || window)._renderContext;
    this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), l.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
    var h = l.createBuffer();
    l.bindBuffer(l.ARRAY_BUFFER, h), l.bufferData(l.ARRAY_BUFFER, o, l.STATIC_DRAW), l.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, l.FLOAT, !1, 0, 0), l.drawArrays(l.LINE_STRIP, 0, s + 1), l.deleteBuffer(h), cc.incrementGLDraws(1);
  },
  drawCatmullRom: function(t, e) {
    this.drawCardinalSpline(t, 0.5, e);
  },
  drawCardinalSpline: function(t, e, n) {
    this.lazy_init();
    for (var r = new Float32Array((n + 1) * 2), s, o, a = 1 / t.length, c = 0; c < n + 1; c++) {
      var l = c / n;
      l === 1 ? (s = t.length - 1, o = 1) : (s = 0 | l / a, o = (l - a * s) / a);
      var h = cc.cardinalSplineAt(
        cc.getControlPointAt(t, s - 1),
        cc.getControlPointAt(t, s),
        cc.getControlPointAt(t, s + 1),
        cc.getControlPointAt(t, s + 2),
        e,
        o
      );
      r[c * 2] = h.x, r[c * 2 + 1] = h.y;
    }
    var u = (this || window)._renderContext;
    this._shader.use(), this._shader.setUniformForModelViewAndProjectionMatrixWithMat4(), u.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
    var _ = u.createBuffer();
    u.bindBuffer(u.ARRAY_BUFFER, _), u.bufferData(u.ARRAY_BUFFER, r, u.STATIC_DRAW), u.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, u.FLOAT, !1, 0, 0), u.drawArrays(u.LINE_STRIP, 0, n + 1), u.deleteBuffer(_), cc.incrementGLDraws(1);
  },
  setDrawColor: function(t, e, n, r) {
    this._colorArray[0] = t / 255, this._colorArray[1] = e / 255, this._colorArray[2] = n / 255, this._colorArray[3] = r / 255;
  },
  setPointSize: function(t) {
    this._pointSize = t * cc.contentScaleFactor();
  },
  setLineWidth: function(t) {
    this._renderContext.lineWidth && this._renderContext.lineWidth(t);
  }
});
var _p = cc.inputManager;
_p.setAccelerometerEnabled = function(t) {
  var e = (this || window);
  if (e._accelEnabled !== t) {
    e._accelEnabled = t;
    var n = cc.director.getScheduler();
    e._accelEnabled, e._accelCurTime = 0, n.scheduleUpdate(e);
  }
};
_p.setAccelerometerInterval = function(t) {
  this._accelInterval !== t && (this._accelInterval = t);
};
_p._registerKeyboardEvent = function() {
  cc._canvas.addEventListener("keydown", function(t) {
    cc.eventManager.dispatchEvent(new cc.EventKeyboard(t.keyCode, !0)), t.stopPropagation(), t.preventDefault();
  }, !1), cc._canvas.addEventListener("keyup", function(t) {
    cc.eventManager.dispatchEvent(new cc.EventKeyboard(t.keyCode, !1)), t.stopPropagation(), t.preventDefault();
  }, !1);
};
_p._registerAccelerometerEvent = function() {
  var t = window, e = (this || window);
  e._acceleration = new cc.Acceleration(), e._accelDeviceEvent = t.DeviceMotionEvent || t.DeviceOrientationEvent, cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (e._accelDeviceEvent = window.DeviceOrientationEvent);
  var n = e._accelDeviceEvent === t.DeviceMotionEvent ? "devicemotion" : "deviceorientation", r = navigator.userAgent;
  (/Android/.test(r) || /Adr/.test(r) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (e._minus = -1), t.addEventListener(n, e.didAccelerate.bind(e), !1);
};
_p.didAccelerate = function(t) {
  var e = (this || window), n = window;
  if (e._accelEnabled) {
    var r = e._acceleration, s, o, a;
    if (e._accelDeviceEvent === window.DeviceMotionEvent) {
      var c = t.accelerationIncludingGravity;
      s = e._accelMinus * c.x * 0.1, o = e._accelMinus * c.y * 0.1, a = c.z * 0.1;
    } else
      s = t.gamma / 90 * 0.981, o = -(t.beta / 90) * 0.981, a = t.alpha / 90 * 0.981;
    r.x = s, r.y = o, r.z = a, r.timestamp = t.timeStamp || Date.now();
    var l = r.x;
    n.orientation === cc.UIInterfaceOrientationLandscapeRight ? (r.x = -r.y, r.y = l) : n.orientation === cc.UIInterfaceOrientationLandscapeLeft ? (r.x = r.y, r.y = -l) : n.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (r.x = -r.x, r.y = -r.y);
  }
};
_p = null;
cc.vertexLineToPolygon = function(t, e, n, r, s) {
  if (s += r, !(s <= 1)) {
    e *= 0.5;
    for (var o, a = s - 1, c = r; c < s; c++) {
      o = c * 2;
      var l = cc.p(t[c * 2], t[c * 2 + 1]), h;
      if (c === 0)
        h = cc.pPerp(cc.pNormalize(cc.pSub(l, cc.p(t[(c + 1) * 2], t[(c + 1) * 2 + 1]))));
      else if (c === a)
        h = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(t[(c - 1) * 2], t[(c - 1) * 2 + 1]), l)));
      else {
        var u = cc.p(t[(c - 1) * 2], t[(c - 1) * 2 + 1]), _ = cc.p(t[(c + 1) * 2], t[(c + 1) * 2 + 1]), d = cc.pNormalize(cc.pSub(_, l)), f = cc.pNormalize(cc.pSub(u, l)), C = Math.acos(cc.pDot(d, f));
        C < cc.degreesToRadians(70) ? h = cc.pPerp(cc.pNormalize(cc.pMidpoint(d, f))) : C < cc.degreesToRadians(170) ? h = cc.pNormalize(cc.pMidpoint(d, f)) : h = cc.pPerp(cc.pNormalize(cc.pSub(_, u)));
      }
      h = cc.pMult(h, e), n[o * 2] = l.x + h.x, n[o * 2 + 1] = l.y + h.y, n[(o + 1) * 2] = l.x - h.x, n[(o + 1) * 2 + 1] = l.y - h.y;
    }
    for (r = r === 0 ? 0 : r - 1, c = r; c < a; c++) {
      o = c * 2;
      var m = o + 2, g = cc.vertex2(n[o * 2], n[o * 2 + 1]), y = cc.vertex2(n[(o + 1) * 2], n[(o + 1) * 2 + 1]), A = cc.vertex2(n[m * 2], n[m * 2]), D = cc.vertex2(n[(m + 1) * 2], n[(m + 1) * 2 + 1]), N = !cc.vertexLineIntersect(g.x, g.y, D.x, D.y, y.x, y.y, A.x, A.y);
      N.isSuccess || (N.value < 0 || N.value > 1) && (N.isSuccess = !0), N.isSuccess && (n[m * 2] = D.x, n[m * 2 + 1] = D.y, n[(m + 1) * 2] = A.x, n[(m + 1) * 2 + 1] = A.y);
    }
  }
};
cc.vertexLineIntersect = function(t, e, n, r, s, o, a, c) {
  var l, h, u, _;
  if (t === n && e === r || s === a && o === c)
    return { isSuccess: !1, value: 0 };
  if (n -= t, r -= e, s -= t, o -= e, a -= t, c -= e, l = Math.sqrt(n * n + r * r), h = n / l, u = r / l, _ = s * h + o * u, o = o * h - s * u, s = _, _ = a * h + c * u, c = c * h - a * u, a = _, o === c)
    return { isSuccess: !1, value: 0 };
  var d = (a + (s - a) * c / (c - o)) / l;
  return { isSuccess: !0, value: d };
};
cc.vertexListIsClockwise = function(t) {
  for (var e = 0, n = t.length; e < n; e++) {
    var r = t[e], s = t[(e + 1) % n], o = t[(e + 2) % n];
    if (cc.pCross(cc.pSub(s, r), cc.pSub(o, s)) > 0)
      return !1;
  }
  return !0;
};
cc.CGAffineToGL = function(t, e) {
  e[2] = e[3] = e[6] = e[7] = e[8] = e[9] = e[11] = e[14] = 0, e[10] = e[15] = 1, e[0] = t.a, e[4] = t.c, e[12] = t.tx, e[1] = t.b, e[5] = t.d, e[13] = t.ty;
};
cc.GLToCGAffine = function(t, e) {
  e.a = t[0], e.c = t[4], e.tx = t[12], e.b = t[1], e.d = t[5], e.ty = t[13];
};
cc.EventAcceleration = cc.Event.extend({
  _acc: null,
  ctor: function(t) {
    cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION), this._acc = t;
  }
});
cc.EventKeyboard = cc.Event.extend({
  _keyCode: 0,
  _isPressed: !1,
  ctor: function(t, e) {
    cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD), this._keyCode = t, this._isPressed = e;
  }
});
cc._EventListenerAcceleration = cc.EventListener.extend({
  _onAccelerationEvent: null,
  ctor: function(t) {
    this._onAccelerationEvent = t;
    var e = (this || window), n = /* @__PURE__ */ H(function(r) {
      e._onAccelerationEvent(r._acc, r);
    }, "listener");
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, n);
  },
  checkAvailable: function() {
    return cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable), !0;
  },
  clone: function() {
    return new cc._EventListenerAcceleration(this._onAccelerationEvent);
  }
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function(t) {
  return new cc._EventListenerAcceleration(t);
};
cc._EventListenerKeyboard = cc.EventListener.extend({
  onKeyPressed: null,
  onKeyReleased: null,
  ctor: function() {
    var t = (this || window), e = /* @__PURE__ */ H(function(n) {
      n._isPressed ? t.onKeyPressed && t.onKeyPressed(n._keyCode, n) : t.onKeyReleased && t.onKeyReleased(n._keyCode, n);
    }, "listener");
    cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, e);
  },
  clone: function() {
    var t = new cc._EventListenerKeyboard();
    return t.onKeyPressed = (this || window).onKeyPressed, t.onKeyReleased = (this || window).onKeyReleased, t;
  },
  checkAvailable: function() {
    return this.onKeyPressed === null && this.onKeyReleased === null ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0;
  }
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function() {
  return new cc._EventListenerKeyboard();
};
cc.AtlasNode = cc.Node.extend({
  textureAtlas: null,
  quadsToDraw: 0,
  _itemsPerRow: 0,
  _itemsPerColumn: 0,
  _itemWidth: 0,
  _itemHeight: 0,
  _opacityModifyRGB: !1,
  _blendFunc: null,
  _ignoreContentScaleFactor: !1,
  _className: "AtlasNode",
  _texture: null,
  _textureForCanvas: null,
  ctor: function(t, e, n, r) {
    cc.Node.prototype.ctor.call(this), this._blendFunc = { src: cc.BLEND_SRC, dst: cc.BLEND_DST }, this._ignoreContentScaleFactor = !1, r !== void 0 && this.initWithTileFile(t, e, n, r);
  },
  _createRenderCmd: function() {
    cc._renderType === cc.game.RENDER_TYPE_CANVAS ? this._renderCmd = new cc.AtlasNode.CanvasRenderCmd(this) : this._renderCmd = new cc.AtlasNode.WebGLRenderCmd(this);
  },
  updateAtlasValues: function() {
    cc.log(cc._LogInfos.AtlasNode_updateAtlasValues);
  },
  getColor: function() {
    return this._opacityModifyRGB ? this._renderCmd._colorUnmodified : cc.Node.prototype.getColor.call(this);
  },
  setOpacityModifyRGB: function(t) {
    var e = (this || window).color;
    this._opacityModifyRGB = t, this.setColor(e);
  },
  isOpacityModifyRGB: function() {
    return this._opacityModifyRGB;
  },
  getBlendFunc: function() {
    return this._blendFunc;
  },
  setBlendFunc: function(t, e) {
    e === void 0 ? this._blendFunc = t : this._blendFunc = { src: t, dst: e };
  },
  setTextureAtlas: function(t) {
    this.textureAtlas = t;
  },
  getTextureAtlas: function() {
    return this.textureAtlas;
  },
  getQuadsToDraw: function() {
    return this.quadsToDraw;
  },
  setQuadsToDraw: function(t) {
    this.quadsToDraw = t;
  },
  initWithTileFile: function(t, e, n, r) {
    if (!t)
      throw new Error("cc.AtlasNode.initWithTileFile(): title should not be null");
    var s = cc.textureCache.addImage(t);
    return this.initWithTexture(s, e, n, r);
  },
  initWithTexture: function(t, e, n, r) {
    return this._renderCmd.initWithTexture(t, e, n, r);
  },
  setColor: function(t) {
    this._renderCmd.setColor(t);
  },
  setOpacity: function(t) {
    this._renderCmd.setOpacity(t);
  },
  getTexture: function() {
    return this._texture;
  },
  setTexture: function(t) {
    this._texture = t;
  },
  _setIgnoreContentScaleFactor: function(t) {
    this._ignoreContentScaleFactor = t;
  }
});
var _p = cc.AtlasNode.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
_p.texture;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
_p.textureAtlas;
_p.quadsToDraw;
cc.EventHelper.prototype.apply(_p);
cc.AtlasNode.create = function(t, e, n, r) {
  return new cc.AtlasNode(t, e, n, r);
};
(function() {
  cc.AtlasNode.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !1, this._colorUnmodified = cc.color.WHITE, this._textureToRender = null;
  };
  var t = cc.AtlasNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.AtlasNode.CanvasRenderCmd, t.initWithTexture = function(e, n, r, s) {
    var o = (this || window)._node;
    return o._itemWidth = n, o._itemHeight = r, o._opacityModifyRGB = !0, o._texture = e, o._texture ? (this._textureToRender = e, this._calculateMaxItems(), o.quadsToDraw = s, !0) : (cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1);
  }, t.setColor = function(e) {
    var n = (this || window)._node, r = n._realColor;
    r.r === e.r && r.g === e.g && r.b === e.b || (this._colorUnmodified = e, this._changeTextureColor());
  }, t._changeTextureColor = function() {
    var e = (this || window)._node, n = e._texture, r = (this || window)._colorUnmodified, s = n.getHtmlElementObj(), o = cc.rect(0, 0, s.width, s.height);
    n === (this || window)._textureToRender ? this._textureToRender = n._generateColorTexture(r.r, r.g, r.b, o) : n._generateColorTexture(r.r, r.g, r.b, o, this._textureToRender.getHtmlElementObj());
  }, t.setOpacity = function(e) {
    var n = (this || window)._node;
    cc.Node.prototype.setOpacity.call(n, e);
  }, t._calculateMaxItems = function() {
    var e = (this || window)._node, n = e._texture, r = n.getContentSize();
    e._itemsPerColumn = 0 | r.height / e._itemHeight, e._itemsPerRow = 0 | r.width / e._itemWidth;
  };
})();
cc.TextureAtlas = cc.Class.extend({
  dirty: !1,
  texture: null,
  _indices: null,
  _buffersVBO: null,
  _capacity: 0,
  _quads: null,
  _quadsArrayBuffer: null,
  _quadsWebBuffer: null,
  _quadsReader: null,
  ctor: function(t, e) {
    this._buffersVBO = [], cc.isString(t) ? this.initWithFile(t, e) : t instanceof cc.Texture2D && this.initWithTexture(t, e);
  },
  getTotalQuads: function() {
    return this._totalQuads;
  },
  getCapacity: function() {
    return this._capacity;
  },
  getTexture: function() {
    return this.texture;
  },
  setTexture: function(t) {
    this.texture = t;
  },
  setDirty: function(t) {
    this.dirty = t;
  },
  isDirty: function() {
    return this.dirty;
  },
  getQuads: function() {
    return this._quads;
  },
  setQuads: function(t) {
    this._quads = t;
  },
  _copyQuadsToTextureAtlas: function(t, e) {
    if (t)
      for (var n = 0; n < t.length; n++)
        this._setQuadToArray(t[n], e + n);
  },
  _setQuadToArray: function(t, e) {
    var n = (this || window)._quads;
    if (!n[e]) {
      n[e] = new cc.V3F_C4B_T2F_Quad(t.tl, t.bl, t.tr, t.br, this._quadsArrayBuffer, e * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
      return;
    }
    n[e].bl = t.bl, n[e].br = t.br, n[e].tl = t.tl, n[e].tr = t.tr;
  },
  description: function() {
    return "<cc.TextureAtlas | totalQuads =" + this._totalQuads + ">";
  },
  _setupIndices: function() {
    if (this._capacity !== 0)
      for (var t = (this || window)._indices, e = (this || window)._capacity, n = 0; n < e; n++)
        cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (t[n * 6 + 0] = n * 4 + 0, t[n * 6 + 1] = n * 4 + 0, t[n * 6 + 2] = n * 4 + 2, t[n * 6 + 3] = n * 4 + 1, t[n * 6 + 4] = n * 4 + 3, t[n * 6 + 5] = n * 4 + 3) : (t[n * 6 + 0] = n * 4 + 0, t[n * 6 + 1] = n * 4 + 1, t[n * 6 + 2] = n * 4 + 2, t[n * 6 + 3] = n * 4 + 3, t[n * 6 + 4] = n * 4 + 2, t[n * 6 + 5] = n * 4 + 1);
  },
  _setupVBO: function() {
    var t = cc._renderContext;
    this._buffersVBO[0] = t.createBuffer(), this._buffersVBO[1] = t.createBuffer(), this._quadsWebBuffer = t.createBuffer(), this._mapBuffers();
  },
  _mapBuffers: function() {
    var t = cc._renderContext;
    t.bindBuffer(t.ARRAY_BUFFER, this._quadsWebBuffer), t.bufferData(t.ARRAY_BUFFER, this._quadsArrayBuffer, t.DYNAMIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW);
  },
  initWithFile: function(t, e) {
    var n = cc.textureCache.addImage(t);
    return n ? this.initWithTexture(n, e) : (cc.log(cc._LogInfos.TextureAtlas_initWithFile, t), !1);
  },
  initWithTexture: function(t, e) {
    cc.assert(t, cc._LogInfos.TextureAtlas_initWithTexture), e = 0 | e, this._capacity = e, this._totalQuads = 0, this.texture = t, this._quads = [], this._indices = new Uint16Array(e * 6);
    var n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    if (this._quadsArrayBuffer = new ArrayBuffer(n * e), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), !(this._quads && this._indices) && e > 0)
      return !1;
    for (var r = (this || window)._quads, s = 0; s < e; s++)
      r[s] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, s * n);
    return this._setupIndices(), this._setupVBO(), this.dirty = !0, !0;
  },
  updateQuad: function(t, e) {
    cc.assert(t, cc._LogInfos.TextureAtlas_updateQuad), cc.assert(e >= 0 && e < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2), this._totalQuads = Math.max(e + 1, this._totalQuads), this._setQuadToArray(t, e), this.dirty = !0;
  },
  insertQuad: function(t, e) {
    if (cc.assert(e < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2), this._totalQuads++, this._totalQuads > this._capacity) {
      cc.log(cc._LogInfos.TextureAtlas_insertQuad);
      return;
    }
    var n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, r = (this || window)._totalQuads - 1 - e, s = e * n, o = r * n;
    this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * n), this._quadsReader.set(this._quadsReader.subarray(s, s + o), s + n), this._setQuadToArray(t, e), this.dirty = !0;
  },
  insertQuads: function(t, e, n) {
    n = n || t.length, cc.assert(e + n <= (this || window)._capacity, cc._LogInfos.TextureAtlas_insertQuads);
    var r = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    if (this._totalQuads += n, this._totalQuads > this._capacity) {
      cc.log(cc._LogInfos.TextureAtlas_insertQuad);
      return;
    }
    var s = (this || window)._totalQuads - 1 - e - n, o = e * r, a = s * r, c = (this || window)._totalQuads - 1 - n, l;
    for (l = 0; l < n; l++)
      this._quads[c + l] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * r);
    for (this._quadsReader.set(this._quadsReader.subarray(o, o + a), o + r * n), l = 0; l < n; l++)
      this._setQuadToArray(t[l], e + l);
    this.dirty = !0;
  },
  insertQuadFromIndex: function(t, e) {
    if (t !== e) {
      cc.assert(e >= 0 || e < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex), cc.assert(t >= 0 || t < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
      var n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, r = (this || window)._quadsReader, s = r.subarray(t * n, n), o, a;
      t > e ? (o = e * n, a = (t - e) * n, r.set(r.subarray(o, o + a), o + n), r.set(s, o)) : (o = (t + 1) * n, a = (e - t) * n, r.set(r.subarray(o, o + a), o - n), r.set(s, e * n)), this.dirty = !0;
    }
  },
  removeQuadAtIndex: function(t) {
    cc.assert(t < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
    var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
    if (this._totalQuads--, this._quads.length = (this || window)._totalQuads, t !== (this || window)._totalQuads) {
      var n = (t + 1) * e, r = (this._totalQuads - t) * e;
      this._quadsReader.set(this._quadsReader.subarray(n, n + r), n - e);
    }
    this.dirty = !0;
  },
  removeQuadsAtIndex: function(t, e) {
    if (cc.assert(t + e <= (this || window)._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex), this._totalQuads -= e, t !== (this || window)._totalQuads) {
      var n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, r = (t + e) * n, s = (this._totalQuads - t) * n, o = t * n;
      this._quadsReader.set(this._quadsReader.subarray(r, r + s), o);
    }
    this.dirty = !0;
  },
  removeAllQuads: function() {
    this._quads.length = 0, this._totalQuads = 0;
  },
  _setDirty: function(t) {
    this.dirty = t;
  },
  resizeCapacity: function(t) {
    if (t === (this || window)._capacity)
      return !0;
    var e = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, n = (this || window)._capacity;
    this._totalQuads = Math.min(this._totalQuads, t), this._capacity = 0 | t;
    var r, s = (this || window)._capacity, o = (this || window)._totalQuads;
    if (this._quads === null)
      for (this._quads = [], this._quadsArrayBuffer = new ArrayBuffer(e * s), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), r = 0; r < s; r++)
        this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, r * e);
    else {
      var a, c, l = (this || window)._quads;
      if (s > n) {
        for (a = [], c = new ArrayBuffer(e * s), r = 0; r < o; r++)
          a[r] = new cc.V3F_C4B_T2F_Quad(
            l[r].tl,
            l[r].bl,
            l[r].tr,
            l[r].br,
            c,
            r * e
          );
        for (; r < s; r++)
          a[r] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, c, r * e);
        this._quadsReader = new Uint8Array(c), this._quads = a, this._quadsArrayBuffer = c;
      } else {
        var h = Math.max(o, s);
        for (a = [], c = new ArrayBuffer(e * s), r = 0; r < h; r++)
          a[r] = new cc.V3F_C4B_T2F_Quad(
            l[r].tl,
            l[r].bl,
            l[r].tr,
            l[r].br,
            c,
            r * e
          );
        this._quadsReader = new Uint8Array(c), this._quads = a, this._quadsArrayBuffer = c;
      }
    }
    if (this._indices === null)
      this._indices = new Uint16Array(s * 6);
    else if (s > n) {
      var u = new Uint16Array(s * 6);
      u.set(this._indices, 0), this._indices = u;
    } else
      this._indices = (this || window)._indices.subarray(0, s * 6);
    return this._setupIndices(), this._mapBuffers(), this.dirty = !0, !0;
  },
  increaseTotalQuadsWith: function(t) {
    this._totalQuads += t;
  },
  moveQuadsFromIndex: function(t, e, n) {
    if (n === void 0) {
      if (n = e, e = (this || window)._totalQuads - t, cc.assert(n + (this._totalQuads - t) <= (this || window)._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), e === 0)
        return;
    } else if (cc.assert(n + e <= (this || window)._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(t < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), t === n)
      return;
    var r = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, s = t * r, o = e * r, a = (this || window)._quadsReader, c = a.subarray(s, s + o), l = n * r, h, u;
    n < t ? (h = (t - n) * r, u = n * r, a.set(a.subarray(u, u + h), u + o)) : (h = (n - t) * r, u = (t + e) * r, a.set(a.subarray(u, u + h), s)), a.set(c, l), this.dirty = !0;
  },
  fillWithEmptyQuadsFromIndex: function(t, e) {
    for (var n = e * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, r = new Uint8Array(this._quadsArrayBuffer, t * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, n), s = 0; s < n; s++)
      r[s] = 0;
  },
  drawQuads: function() {
    this.drawNumberOfQuads(this._totalQuads, 0);
  },
  _releaseBuffer: function() {
    var t = cc._renderContext;
    this._buffersVBO && (this._buffersVBO[0] && t.deleteBuffer(this._buffersVBO[0]), this._buffersVBO[1] && t.deleteBuffer(this._buffersVBO[1])), this._quadsWebBuffer && t.deleteBuffer(this._quadsWebBuffer);
  }
});
var _p = cc.TextureAtlas.prototype;
_p.totalQuads;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
_p.capacity;
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
_p.quads;
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function(t, e) {
  return new cc.TextureAtlas(t, e);
};
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas);
});
cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.PI2 = Math.PI * 2;
cc.DrawingPrimitiveCanvas = cc.Class.extend({
  _cacheArray: [],
  _renderContext: null,
  ctor: function(t) {
    this._renderContext = t;
  },
  drawPoint: function(t, e) {
    e || (e = 1);
    var n = cc.view.getScaleX(), r = cc.view.getScaleY(), s = cc.p(t.x * n, t.y * r), o = (this || window)._renderContext.getContext();
    o.beginPath(), o.arc(s.x, -s.y, e * n, 0, Math.PI * 2, !1), o.closePath(), o.fill();
  },
  drawPoints: function(t, e, n) {
    if (t != null) {
      n || (n = 1);
      var r = (this || window)._renderContext.getContext(), s = cc.view.getScaleX(), o = cc.view.getScaleY();
      r.beginPath();
      for (var a = 0, c = t.length; a < c; a++)
        r.arc(t[a].x * s, -t[a].y * o, n * s, 0, Math.PI * 2, !1);
      r.closePath(), r.fill();
    }
  },
  drawLine: function(t, e) {
    var n = (this || window)._renderContext.getContext();
    cc.view.getScaleX(), cc.view.getScaleY(), n.beginPath(), n.moveTo(t.x, -t.y), n.lineTo(e.x, -e.y), n.closePath(), n.stroke();
  },
  drawRect: function(t, e) {
    this.drawLine(cc.p(t.x, t.y), cc.p(e.x, t.y)), this.drawLine(cc.p(e.x, t.y), cc.p(e.x, e.y)), this.drawLine(cc.p(e.x, e.y), cc.p(t.x, e.y)), this.drawLine(cc.p(t.x, e.y), cc.p(t.x, t.y));
  },
  drawSolidRect: function(t, e, n) {
    var r = [
      t,
      cc.p(e.x, t.y),
      e,
      cc.p(t.x, e.y)
    ];
    this.drawSolidPoly(r, 4, n);
  },
  drawPoly: function(t, e, n, r) {
    if (r = r || !1, t != null) {
      if (t.length < 3)
        throw new Error("Polygon's point must greater than 2");
      var s = t[0], o = (this || window)._renderContext.getContext();
      cc.view.getScaleX(), cc.view.getScaleY(), o.beginPath(), o.moveTo(s.x, -s.y);
      for (var a = 1, c = t.length; a < c; a++)
        o.lineTo(t[a].x, -t[a].y);
      n && o.closePath(), r ? o.fill() : o.stroke();
    }
  },
  drawSolidPoly: function(t, e, n) {
    this.setDrawColor(n.r, n.g, n.b, n.a), this.drawPoly(t, e, !0, !0);
  },
  drawCircle: function(t, e, n, r, s) {
    s = s || !1;
    var o = (this || window)._renderContext.getContext();
    cc.view.getScaleX(), cc.view.getScaleY(), o.beginPath();
    var a = n - Math.PI * 2;
    o.arc(0 | t.x, 0 | -t.y, e, -n, -a, !1), s && o.lineTo(0 | t.x, 0 | -t.y), o.stroke();
  },
  drawQuadBezier: function(t, e, n, r) {
    var s = (this || window)._cacheArray;
    s.length = 0;
    for (var o = 0, a = 0; a < r; a++) {
      var c = Math.pow(1 - o, 2) * t.x + 2 * (1 - o) * o * e.x + o * o * n.x, l = Math.pow(1 - o, 2) * t.y + 2 * (1 - o) * o * e.y + o * o * n.y;
      s.push(cc.p(c, l)), o += 1 / r;
    }
    s.push(cc.p(n.x, n.y)), this.drawPoly(s, r + 1, !1, !1);
  },
  drawCubicBezier: function(t, e, n, r, s) {
    var o = (this || window)._cacheArray;
    o.length = 0;
    for (var a = 0, c = 0; c < s; c++) {
      var l = Math.pow(1 - a, 3) * t.x + 3 * Math.pow(1 - a, 2) * a * e.x + 3 * (1 - a) * a * a * n.x + a * a * a * r.x, h = Math.pow(1 - a, 3) * t.y + 3 * Math.pow(1 - a, 2) * a * e.y + 3 * (1 - a) * a * a * n.y + a * a * a * r.y;
      o.push(cc.p(l, h)), a += 1 / s;
    }
    o.push(cc.p(r.x, r.y)), this.drawPoly(o, s + 1, !1, !1);
  },
  drawCatmullRom: function(t, e) {
    this.drawCardinalSpline(t, 0.5, e);
  },
  drawCardinalSpline: function(t, e, n) {
    cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
    var r = (this || window)._cacheArray;
    r.length = 0;
    for (var s, o, a = 1 / t.length, c = 0; c < n + 1; c++) {
      var l = c / n;
      l === 1 ? (s = t.length - 1, o = 1) : (s = 0 | l / a, o = (l - a * s) / a);
      var h = cc.CardinalSplineAt(
        cc.getControlPointAt(t, s - 1),
        cc.getControlPointAt(t, s - 0),
        cc.getControlPointAt(t, s + 1),
        cc.getControlPointAt(t, s + 2),
        e,
        o
      );
      r.push(h);
    }
    this.drawPoly(r, n + 1, !1, !1);
  },
  drawImage: function(t, e, n, r, s) {
    var o = arguments.length, a = (this || window)._renderContext.getContext();
    switch (o) {
      case 2:
        var c = t.height;
        a.drawImage(t, e.x, -(e.y + c));
        break;
      case 3:
        a.drawImage(t, e.x, -(e.y + n.height), n.width, n.height);
        break;
      case 5:
        a.drawImage(
          t,
          e.x,
          e.y,
          n.width,
          n.height,
          r.x,
          -(r.y + s.height),
          s.width,
          s.height
        );
        break;
      default:
        throw new Error("Argument must be non-nil");
    }
  },
  drawStar: function(t, e, n) {
    var r = t || this._renderContext, s = r.getContext(), o = "rgba(" + (0 | n.r) + "," + (0 | n.g) + "," + (0 | n.b);
    r.setFillStyle(o + ",1)");
    var a = e / 10;
    s.beginPath(), s.moveTo(-e, e), s.lineTo(0, a), s.lineTo(e, e), s.lineTo(a, 0), s.lineTo(e, -e), s.lineTo(0, -a), s.lineTo(-e, -e), s.lineTo(-a, 0), s.lineTo(-e, e), s.closePath(), s.fill();
    var c = s.createRadialGradient(0, 0, a, 0, 0, e);
    c.addColorStop(0, o + ", 1)"), c.addColorStop(0.3, o + ", 0.8)"), c.addColorStop(1, o + ", 0.0)"), r.setFillStyle(c), s.beginPath();
    var l = 0, h = cc.PI2;
    s.arc(0, 0, e - a, l, h, !1), s.closePath(), s.fill();
  },
  drawColorBall: function(t, e, n) {
    var r = t || this._renderContext, s = r.getContext();
    e *= cc.view.getScaleX();
    var o = "rgba(" + (0 | n.r) + "," + (0 | n.g) + "," + (0 | n.b), a = e / 10, c = s.createRadialGradient(0, 0, a, 0, 0, e);
    c.addColorStop(0, o + ", 1)"), c.addColorStop(0.3, o + ", 0.8)"), c.addColorStop(0.6, o + ", 0.4)"), c.addColorStop(1, o + ", 0.0)"), r.setFillStyle(c), s.beginPath();
    var l = 0, h = cc.PI2;
    s.arc(0, 0, e, l, h, !1), s.closePath(), s.fill();
  },
  fillText: function(t, e, n) {
    this._renderContext.getContext().fillText(t, e, -n);
  },
  setDrawColor: function(t, e, n, r) {
    this._renderContext.setFillStyle("rgba(" + t + "," + e + "," + n + "," + r / 255 + ")"), this._renderContext.setStrokeStyle("rgba(" + t + "," + e + "," + n + "," + r / 255 + ")");
  },
  setPointSize: function(t) {
  },
  setLineWidth: function(t) {
    this._renderContext.getContext().lineWidth = t * cc.view.getScaleX();
  }
});
(function() {
  cc.AtlasNode.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._textureAtlas = null, this._colorUnmodified = cc.color.WHITE, this._colorF32Array = null, this._uniformColor = null, this._matrix = new cc.math.Matrix4(), this._matrix.identity(), this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR), this._uniformColor = cc._renderContext.getUniformLocation(this._shaderProgram.getProgram(), "u_color");
  };
  var t = cc.AtlasNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.AtlasNode.WebGLRenderCmd, t._updateBlendFunc = function() {
    var e = (this || window)._node;
    this._textureAtlas.texture.hasPremultipliedAlpha() || (e._blendFunc.src = cc.SRC_ALPHA, e._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA);
  }, t._updateOpacityModifyRGB = function() {
    this._node._opacityModifyRGB = (this || window)._textureAtlas.texture.hasPremultipliedAlpha();
  }, t.rendering = function(e) {
    var n = e || cc._renderContext, r = (this || window)._node, s = (this || window)._worldTransform;
    this._matrix.mat[0] = s.a, this._matrix.mat[4] = s.c, this._matrix.mat[12] = s.tx, this._matrix.mat[1] = s.b, this._matrix.mat[5] = s.d, this._matrix.mat[13] = s.ty, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix), cc.glBlendFunc(r._blendFunc.src, r._blendFunc.dst), this._uniformColor && this._colorF32Array && (n.uniform4fv(this._uniformColor, this._colorF32Array), this._textureAtlas.drawNumberOfQuads(r.quadsToDraw, 0));
  }, t.initWithTexture = function(e, n, r, s) {
    var o = (this || window)._node;
    o._itemWidth = n, o._itemHeight = r, this._colorUnmodified = cc.color.WHITE, o._opacityModifyRGB = !0, o._blendFunc.src = cc.BLEND_SRC, o._blendFunc.dst = cc.BLEND_DST;
    var a = o._realColor;
    return this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, o._realOpacity / 255]), this._textureAtlas = new cc.TextureAtlas(), this._textureAtlas.initWithTexture(e, s), this._textureAtlas ? (this._updateBlendFunc(), this._updateOpacityModifyRGB(), this._calculateMaxItems(), o.quadsToDraw = s, !0) : (cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1);
  }, t.setColor = function(e) {
    var n = cc.color(e.r, e.g, e.b), r = (this || window)._node;
    this._colorUnmodified = e;
    var s = (this || window)._displayedOpacity;
    r._opacityModifyRGB && (n.r = n.r * s / 255, n.g = n.g * s / 255, n.b = n.b * s / 255), cc.Node.prototype.setColor.call(r, n);
  }, t.setOpacity = function(e) {
    var n = (this || window)._node;
    cc.Node.prototype.setOpacity.call(n, e), n._opacityModifyRGB && (n.color = (this || window)._colorUnmodified);
  }, t._updateColor = function() {
    if (this._colorF32Array) {
      var e = (this || window)._displayedColor;
      this._colorF32Array[0] = e.r / 255, this._colorF32Array[1] = e.g / 255, this._colorF32Array[2] = e.b / 255, this._colorF32Array[3] = (this || window)._displayedOpacity / 255;
    }
  }, t.getTexture = function() {
    return this._textureAtlas.texture;
  }, t.setTexture = function(e) {
    this._textureAtlas.texture = e, this._updateBlendFunc(), this._updateOpacityModifyRGB();
  }, t._calculateMaxItems = function() {
    var e = (this || window)._node, n = (this || window)._textureAtlas.texture, r = n.getContentSize();
    e._ignoreContentScaleFactor && (r = n.getContentSizeInPixels()), e._itemsPerColumn = 0 | r.height / e._itemHeight, e._itemsPerRow = 0 | r.width / e._itemWidth;
  };
})();
cc._LogInfos = {
  ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
  ActionManager_removeAction: "cocos2d: removeAction: Target not found",
  ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
  ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
  ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
  ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag = %s): Action not found",
  configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
  configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
  configuration_loadConfigFile_2: "Please load the resource first : %s",
  Director_resume: "cocos2d: Director: Error in gettimeofday",
  Director_setProjection: "cocos2d: Director: unrecognized projection",
  Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
  Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
  Director_popScene: "running scene should not null",
  Director_pushScene: "the scene should not null",
  arrayVerifyType: "element type is wrong!",
  Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
  Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
  Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
  Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
  Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
  Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
  Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
  Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
  Node_getRotation: "RotationX != RotationY. Don't know which one to return",
  Node_getScale: "ScaleX != ScaleY. Don't know which one to return",
  Node_addChild: "An Node can't be added as a child of itself.",
  Node_addChild_2: "child already added. It can't be added again",
  Node_addChild_3: "child must be non-null",
  Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
  Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
  Node_removeChildByTag: "argument tag is an invalid tag",
  Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag = %s): child not found!",
  Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
  Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
  Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
  Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
  Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
  Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
  Node_reorderChild: "child must be non-null",
  Node_runAction: "cc.Node.runAction(): action must be non-null",
  Node_schedule: "callback function must be non-null",
  Node_schedule_2: "interval must be positive",
  Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
  AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
  AtlasNode_initWithTileFile: "",
  AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
  _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
  _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
  _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
  _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
  EventListener_create: "Invalid parameter.",
  __getListenerID: "Don't call this method if the event is for touch.",
  eventManager__forceAddEventListener: "Invalid scene graph priority!",
  eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
  eventManager_removeListeners: "Invalid listener type!",
  eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
  eventManager_addListener_2: "Invalid parameters.",
  eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
  eventManager_addListener_4: "The listener has been registered, please don't register it again.",
  LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
  LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
  LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
  LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
  EGLView_setDesignResolutionSize: "Resolution not valid",
  EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
  inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
  swap: "cc.swap is being modified from original macro, please check usage",
  checkGLErrorDebug: "WebGL error %s",
  animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
  animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
  animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
  animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
  animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
  animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
  animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
  animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
  animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
  animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
  Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
  Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
  Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
  Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
  Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
  Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
  Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
  Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
  Sprite_initWithSpriteFrameName1: " is null, please check.",
  Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
  Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
  Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
  Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
  Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
  Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
  Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
  Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
  Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
  Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
  Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
  Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
  Sprite_setSpriteFrame: "Invalid spriteFrameName",
  Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
  Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
  Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
  SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
  SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
  SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
  SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
  SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
  SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
  SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
  spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
  spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
  spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
  spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
  spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
  spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
  spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
  CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
  CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
  CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
  CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
  CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
  CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
  CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
  CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
  CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
  CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
  TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
  TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
  TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
  TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
  TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
  TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
  TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
  TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
  TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
  TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
  TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
  TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
  TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
  TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
  textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
  textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
  textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
  textureCache_addPVRImage: "addPVRImage does not support on HTML5",
  textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
  textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id=%s %s x %s",
  textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
  textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
  textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
  Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
  Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
  Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
  Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
  Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
  Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
  Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
  Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
  Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
  Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
  Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
  Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
  Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
  Texture2D_initWithData: "NSInternalInconsistencyException",
  MissingFile: "Missing file: %s",
  radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
  RectWidth: "Rect width exceeds maximum margin: %s",
  RectHeight: "Rect height exceeds maximum margin: %s",
  EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
  EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function(t) {
  if (cc._canvas) {
    var e = cc._logList, n = document;
    if (!e) {
      var r = n.createElement("Div"), s = r.style;
      r.setAttribute("id", "logInfoDiv"), cc._canvas.parentNode.appendChild(r), r.setAttribute("width", "200"), r.setAttribute("height", cc._canvas.height), s.zIndex = "99999", s.position = "absolute", s.top = "0", s.left = "0", e = cc._logList = n.createElement("textarea");
      var o = e.style;
      e.setAttribute("rows", "20"), e.setAttribute("cols", "30"), e.setAttribute("disabled", !0), r.appendChild(e), o.backgroundColor = "transparent", o.borderBottom = "1px solid #cccccc", o.borderRightWidth = "0px", o.borderLeftWidth = "0px", o.borderTopWidth = "0px", o.borderTopStyle = "none", o.borderRightStyle = "none", o.borderLeftStyle = "none", o.padding = "0px", o.margin = 0;
    }
    e.value = e.value + t + `\r
`, e.scrollTop = e.scrollHeight;
  }
};
cc._formatString = function(t) {
  if (cc.isObject(t))
    try {
      return JSON.stringify(t);
    } catch (e) {
      return "";
    }
  else
    return t;
};
cc._initDebugSetting = function(t) {
  var e = cc.game;
  if (t !== e.DEBUG_MODE_NONE) {
    var n;
    t > e.DEBUG_MODE_ERROR ? (n = cc._logToWebPage.bind(cc), cc.error = function() {
      n("ERROR :  " + cc.formatStr.apply(cc, arguments));
    }, cc.assert = function(r, s) {
      if (!r && s) {
        for (var o = 2; o < arguments.length; o++)
          s = s.replace(/(%s)|(%d)/, cc._formatString(arguments[o]));
        n("Assert: " + s);
      }
    }, t !== e.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
      n("WARN :  " + cc.formatStr.apply(cc, arguments));
    }), t === e.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
      n(cc.formatStr.apply(cc, arguments));
    })) : console && console.log.apply && (cc.error = Function.prototype.bind.call(console.error, console), console.assert ? cc.assert = Function.prototype.bind.call(console.assert, console) : cc.assert = function(r, s) {
      if (!r && s) {
        for (var o = 2; o < arguments.length; o++)
          s = s.replace(/(%s)|(%d)/, cc._formatString(arguments[o]));
        throw new Error(s);
      }
    }, t !== e.DEBUG_MODE_ERROR && (cc.warn = Function.prototype.bind.call(console.warn, console)), t === e.DEBUG_MODE_INFO && (cc.log = Function.prototype.bind.call(console.log, console)));
  }
};
cc.HashElement = cc.Class.extend({
  actions: null,
  target: null,
  actionIndex: 0,
  currentAction: null,
  currentActionSalvaged: !1,
  paused: !1,
  hh: null,
  ctor: function() {
    this.actions = [], this.target = null, this.actionIndex = 0, this.currentAction = null, this.currentActionSalvaged = !1, this.paused = !1, this.hh = null;
  }
});
cc.ActionManager = cc.Class.extend({
  _hashTargets: null,
  _arrayTargets: null,
  _currentTarget: null,
  _currentTargetSalvaged: !1,
  _searchElementByTarget: function(t, e) {
    for (var n = 0; n < t.length; n++)
      if (e === t[n].target)
        return t[n];
    return null;
  },
  ctor: function() {
    this._hashTargets = {}, this._arrayTargets = [], this._currentTarget = null, this._currentTargetSalvaged = !1;
  },
  addAction: function(t, e, n) {
    if (!t)
      throw new Error("cc.ActionManager.addAction(): action must be non-null");
    if (!e)
      throw new Error("cc.ActionManager.addAction(): action must be non-null");
    var r = (this || window)._hashTargets[e.__instanceId];
    r || (r = new cc.HashElement(), r.paused = n, r.target = e, this._hashTargets[e.__instanceId] = r, this._arrayTargets.push(r)), this._actionAllocWithHashElement(r), r.actions.push(t), t.startWithTarget(e);
  },
  removeAllActions: function() {
    for (var t = (this || window)._arrayTargets, e = 0; e < t.length; e++) {
      var n = t[e];
      n && this.removeAllActionsFromTarget(n.target, !0);
    }
  },
  removeAllActionsFromTarget: function(t, e) {
    if (t != null) {
      var n = (this || window)._hashTargets[t.__instanceId];
      n && (n.actions.indexOf(n.currentAction) !== -1 && !n.currentActionSalvaged && (n.currentActionSalvaged = !0), n.actions.length = 0, this._currentTarget === n && !e ? this._currentTargetSalvaged = !0 : this._deleteHashElement(n));
    }
  },
  removeAction: function(t) {
    if (t != null) {
      var e = t.getOriginalTarget(), n = (this || window)._hashTargets[e.__instanceId];
      if (n) {
        for (var r = 0; r < n.actions.length; r++)
          if (n.actions[r] === t) {
            n.actions.splice(r, 1);
            break;
          }
      } else
        cc.log(cc._LogInfos.ActionManager_removeAction);
    }
  },
  removeActionByTag: function(t, e) {
    t === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction), cc.assert(e, cc._LogInfos.ActionManager_addAction);
    var n = (this || window)._hashTargets[e.__instanceId];
    if (n)
      for (var r = n.actions.length, s = 0; s < r; ++s) {
        var o = n.actions[s];
        if (o && o.getTag() === t && o.getOriginalTarget() === e) {
          this._removeActionAtIndex(s, n);
          break;
        }
      }
  },
  getActionByTag: function(t, e) {
    t === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
    var n = (this || window)._hashTargets[e.__instanceId];
    if (n) {
      if (n.actions != null)
        for (var r = 0; r < n.actions.length; ++r) {
          var s = n.actions[r];
          if (s && s.getTag() === t)
            return s;
        }
      cc.log(cc._LogInfos.ActionManager_getActionByTag_2, t);
    }
    return null;
  },
  numberOfRunningActionsInTarget: function(t) {
    var e = (this || window)._hashTargets[t.__instanceId];
    return e && e.actions ? e.actions.length : 0;
  },
  pauseTarget: function(t) {
    var e = (this || window)._hashTargets[t.__instanceId];
    e && (e.paused = !0);
  },
  resumeTarget: function(t) {
    var e = (this || window)._hashTargets[t.__instanceId];
    e && (e.paused = !1);
  },
  pauseAllRunningActions: function() {
    for (var t = [], e = (this || window)._arrayTargets, n = 0; n < e.length; n++) {
      var r = e[n];
      r && !r.paused && (r.paused = !0, t.push(r.target));
    }
    return t;
  },
  resumeTargets: function(t) {
    if (t)
      for (var e = 0; e < t.length; e++)
        t[e] && this.resumeTarget(t[e]);
  },
  purgeSharedManager: function() {
    cc.director.getScheduler().unscheduleUpdate(this);
  },
  _removeActionAtIndex: function(t, e) {
    var n = e.actions[t];
    n === e.currentAction && !e.currentActionSalvaged && (e.currentActionSalvaged = !0), e.actions.splice(t, 1), e.actionIndex >= t && e.actionIndex--, e.actions.length === 0 && (this._currentTarget === e ? this._currentTargetSalvaged = !0 : this._deleteHashElement(e));
  },
  _deleteHashElement: function(t) {
    var e = !1;
    return t && (this._hashTargets[t.target.__instanceId] && (delete this._hashTargets[t.target.__instanceId], cc.arrayRemoveObject(this._arrayTargets, t), e = !0), t.actions = null, t.target = null), e;
  },
  _actionAllocWithHashElement: function(t) {
    t.actions == null && (t.actions = []);
  },
  update: function(t) {
    for (var e = (this || window)._arrayTargets, n, r = 0; r < e.length; r++) {
      if (this._currentTarget = e[r], n = (this || window)._currentTarget, !n.paused) {
        for (n.actionIndex = 0; n.actionIndex < (n.actions ? n.actions.length : 0); n.actionIndex++)
          if (n.currentAction = n.actions[n.actionIndex], !!n.currentAction) {
            if (n.currentActionSalvaged = !1, n.currentAction.step(t * (n.currentAction._speedMethod ? n.currentAction._speed : 1)), n.currentActionSalvaged)
              n.currentAction = null;
            else if (n.currentAction.isDone()) {
              n.currentAction.stop();
              var s = n.currentAction;
              n.currentAction = null, this.removeAction(s);
            }
            n.currentAction = null;
          }
      }
      this._currentTargetSalvaged && n.actions.length === 0 && this._deleteHashElement(n) && r--;
    }
  }
});
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
  originalTarget: null,
  target: null,
  tag: cc.ACTION_TAG_INVALID,
  ctor: function() {
    this.originalTarget = null, this.target = null, this.tag = cc.ACTION_TAG_INVALID;
  },
  copy: function() {
    return cc.log("copy is deprecated. Please use clone instead."), this.clone();
  },
  clone: function() {
    var t = new cc.Action();
    return t.originalTarget = null, t.target = null, t.tag = (this || window).tag, t;
  },
  isDone: function() {
    return !0;
  },
  startWithTarget: function(t) {
    this.originalTarget = t, this.target = t;
  },
  stop: function() {
    this.target = null;
  },
  step: function(t) {
    cc.log("[Action step]. override me");
  },
  update: function(t) {
    cc.log("[Action update]. override me");
  },
  getTarget: function() {
    return this.target;
  },
  setTarget: function(t) {
    this.target = t;
  },
  getOriginalTarget: function() {
    return this.originalTarget;
  },
  setOriginalTarget: function(t) {
    this.originalTarget = t;
  },
  getTag: function() {
    return this.tag;
  },
  setTag: function(t) {
    this.tag = t;
  },
  retain: function() {
  },
  release: function() {
  }
});
cc.action = function() {
  return new cc.Action();
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
  _duration: 0,
  ctor: function() {
    cc.Action.prototype.ctor.call(this), this._duration = 0;
  },
  getDuration: function() {
    return this._duration * (this._timesForRepeat || 1);
  },
  setDuration: function(t) {
    this._duration = t;
  },
  reverse: function() {
    return cc.log("cocos2d: FiniteTimeAction#reverse: Implement me"), null;
  },
  clone: function() {
    return new cc.FiniteTimeAction();
  }
});
cc.Speed = cc.Action.extend({
  _speed: 0,
  _innerAction: null,
  ctor: function(t, e) {
    cc.Action.prototype.ctor.call(this), this._speed = 0, this._innerAction = null, t && this.initWithAction(t, e);
  },
  getSpeed: function() {
    return this._speed;
  },
  setSpeed: function(t) {
    this._speed = t;
  },
  initWithAction: function(t, e) {
    if (!t)
      throw new Error("cc.Speed.initWithAction(): action must be non nil");
    return this._innerAction = t, this._speed = e, !0;
  },
  clone: function() {
    var t = new cc.Speed();
    return t.initWithAction(this._innerAction.clone(), this._speed), t;
  },
  startWithTarget: function(t) {
    cc.Action.prototype.startWithTarget.call(this, t), this._innerAction.startWithTarget(t);
  },
  stop: function() {
    this._innerAction.stop(), cc.Action.prototype.stop.call(this);
  },
  step: function(t) {
    this._innerAction.step(t * this._speed);
  },
  isDone: function() {
    return this._innerAction.isDone();
  },
  reverse: function() {
    return new cc.Speed(this._innerAction.reverse(), this._speed);
  },
  setInnerAction: function(t) {
    this._innerAction !== t && (this._innerAction = t);
  },
  getInnerAction: function() {
    return this._innerAction;
  }
});
cc.speed = function(t, e) {
  return new cc.Speed(t, e);
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
  _followedNode: null,
  _boundarySet: !1,
  _boundaryFullyCovered: !1,
  _halfScreenSize: null,
  _fullScreenSize: null,
  _worldRect: null,
  leftBoundary: 0,
  rightBoundary: 0,
  topBoundary: 0,
  bottomBoundary: 0,
  ctor: function(t, e) {
    cc.Action.prototype.ctor.call(this), this._followedNode = null, this._boundarySet = !1, this._boundaryFullyCovered = !1, this._halfScreenSize = null, this._fullScreenSize = null, this.leftBoundary = 0, this.rightBoundary = 0, this.topBoundary = 0, this.bottomBoundary = 0, this._worldRect = cc.rect(0, 0, 0, 0), t && (e ? this.initWithTarget(t, e) : this.initWithTarget(t));
  },
  clone: function() {
    var t = new cc.Follow(), e = (this || window)._worldRect, n = new cc.Rect(e.x, e.y, e.width, e.height);
    return t.initWithTarget(this._followedNode, n), t;
  },
  isBoundarySet: function() {
    return this._boundarySet;
  },
  setBoudarySet: function(t) {
    this._boundarySet = t;
  },
  initWithTarget: function(t, e) {
    if (!t)
      throw new Error("cc.Follow.initWithAction(): followedNode must be non nil");
    var n = (this || window);
    e = e || cc.rect(0, 0, 0, 0), n._followedNode = t, n._worldRect = e, n._boundarySet = !cc._rectEqualToZero(e), n._boundaryFullyCovered = !1;
    var r = cc.director.getWinSize();
    return n._fullScreenSize = cc.p(r.width, r.height), n._halfScreenSize = cc.pMult(n._fullScreenSize, 0.5), n._boundarySet && (n.leftBoundary = -(e.x + e.width - n._fullScreenSize.x), n.rightBoundary = -e.x, n.topBoundary = -e.y, n.bottomBoundary = -(e.y + e.height - n._fullScreenSize.y), n.rightBoundary < n.leftBoundary && (n.rightBoundary = n.leftBoundary = (n.leftBoundary + n.rightBoundary) / 2), n.topBoundary < n.bottomBoundary && (n.topBoundary = n.bottomBoundary = (n.topBoundary + n.bottomBoundary) / 2), n.topBoundary === n.bottomBoundary && n.leftBoundary === n.rightBoundary && (n._boundaryFullyCovered = !0)), !0;
  },
  step: function(t) {
    var e = (this || window)._followedNode.x, n = (this || window)._followedNode.y;
    if (e = (this || window)._halfScreenSize.x - e, n = (this || window)._halfScreenSize.y - n, this.target._renderCmd._dirtyFlag = 0, this._boundarySet) {
      if (this._boundaryFullyCovered)
        return;
      this.target.setPosition(cc.clampf(e, this.leftBoundary, this.rightBoundary), cc.clampf(n, this.bottomBoundary, this.topBoundary));
    } else
      this.target.setPosition(e, n);
  },
  isDone: function() {
    return !this._followedNode.running;
  },
  stop: function() {
    this.target = null, cc.Action.prototype.stop.call(this);
  }
});
cc.follow = function(t, e) {
  return new cc.Follow(t, e);
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
  _elapsed: 0,
  _firstTick: !1,
  _easeList: null,
  _timesForRepeat: 1,
  _repeatForever: !1,
  _repeatMethod: !1,
  //Compatible with repeat class, Discard after can be deleted
  _speed: 1,
  _speedMethod: !1,
  //Compatible with speed class, Discard after can be deleted
  ctor: function(t) {
    this._speed = 1, this._timesForRepeat = 1, this._repeatForever = !1, this.MAX_VALUE = 2, this._repeatMethod = !1, this._speedMethod = !1, cc.FiniteTimeAction.prototype.ctor.call(this), t !== void 0 && this.initWithDuration(t);
  },
  getElapsed: function() {
    return this._elapsed;
  },
  initWithDuration: function(t) {
    return this._duration = t === 0 ? cc.FLT_EPSILON : t, this._elapsed = 0, this._firstTick = !0, !0;
  },
  isDone: function() {
    return this._elapsed >= (this || window)._duration;
  },
  _cloneDecoration: function(t) {
    t._repeatForever = (this || window)._repeatForever, t._speed = (this || window)._speed, t._timesForRepeat = (this || window)._timesForRepeat, t._easeList = (this || window)._easeList, t._speedMethod = (this || window)._speedMethod, t._repeatMethod = (this || window)._repeatMethod;
  },
  _reverseEaseList: function(t) {
    if (this._easeList) {
      t._easeList = [];
      for (var e = 0; e < this._easeList.length; e++)
        t._easeList.push(this._easeList[e].reverse());
    }
  },
  clone: function() {
    var t = new cc.ActionInterval(this._duration);
    return this._cloneDecoration(t), t;
  },
  easing: function(t) {
    this._easeList ? this._easeList.length = 0 : this._easeList = [];
    for (var e = 0; e < arguments.length; e++)
      this._easeList.push(arguments[e]);
    return (this || window)
  },
  _computeEaseTime: function(t) {
    var e = (this || window)._easeList;
    if (!e || e.length === 0)
      return t;
    for (var n = 0, r = e.length; n < r; n++)
      t = e[n].easing(t);
    return t;
  },
  step: function(t) {
    this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += t;
    var e = (this || window)._elapsed / (this._duration > 1192092896e-16 ? this._duration : 1192092896e-16);
    e = 1 > e ? e : 1, this.update(e > 0 ? e : 0), this._repeatMethod && this._timesForRepeat > 1 && this.isDone() && (this._repeatForever || this._timesForRepeat--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration));
  },
  startWithTarget: function(t) {
    cc.Action.prototype.startWithTarget.call(this, t), this._elapsed = 0, this._firstTick = !0;
  },
  reverse: function() {
    return cc.log("cc.IntervalAction: reverse not implemented."), null;
  },
  setAmplitudeRate: function(t) {
    cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.");
  },
  getAmplitudeRate: function() {
    return cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass."), 0;
  },
  speed: function(t) {
    return t <= 0 ? (cc.log("The speed parameter error"), this) : (this._speedMethod = !0, this._speed *= t, this);
  },
  getSpeed: function() {
    return this._speed;
  },
  setSpeed: function(t) {
    return this._speed = t, (this || window)
  },
  repeat: function(t) {
    return t = Math.round(t), isNaN(t) || t < 1 ? (cc.log("The repeat parameter error"), this) : (this._repeatMethod = !0, this._timesForRepeat *= t, this);
  },
  repeatForever: function() {
    return this._repeatMethod = !0, this._timesForRepeat = (this || window).MAX_VALUE, this._repeatForever = !0, (this || window)
  }
});
cc.actionInterval = function(t) {
  return new cc.ActionInterval(t);
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
  _actions: null,
  _split: null,
  _last: 0,
  ctor: function(t) {
    cc.ActionInterval.prototype.ctor.call(this), this._actions = [];
    var e = t instanceof Array ? t : arguments, n = e.length - 1;
    if (n >= 0 && e[n] == null && cc.log("parameters should not be ending with null in Javascript"), n >= 0) {
      for (var r = e[0], s, o = 1; o < n; o++)
        e[o] && (s = r, r = cc.Sequence._actionOneTwo(s, e[o]));
      this.initWithTwoActions(r, e[n]);
    }
  },
  initWithTwoActions: function(t, e) {
    if (!t || !e)
      throw new Error("cc.Sequence.initWithTwoActions(): arguments must all be non nil");
    var n = t._duration + e._duration;
    return this.initWithDuration(n), this._actions[0] = t, this._actions[1] = e, !0;
  },
  clone: function() {
    var t = new cc.Sequence();
    return this._cloneDecoration(t), t.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone()), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._split = (this || window)._actions[0]._duration / this._duration, this._last = -1;
  },
  stop: function() {
    this._last !== -1 && this._actions[this._last].stop(), cc.Action.prototype.stop.call(this);
  },
  update: function(t) {
    var e, n = 0, r = (this || window)._split, s = (this || window)._actions, o = (this || window)._last, a;
    t = (this || window)._computeEaseTime(t), t < r ? (e = r !== 0 ? t / r : 1, n === 0 && o === 1 && (s[1].update(0), s[1].stop())) : (n = 1, e = r === 1 ? 1 : (t - r) / (1 - r), o === -1 && (s[0].startWithTarget(this.target), s[0].update(1), s[0].stop()), o || (s[0].update(1), s[0].stop())), a = s[n], !(o === n && a.isDone()) && (o !== n && a.startWithTarget(this.target), e = e * a._timesForRepeat, a.update(e > 1 ? e % 1 : e), this._last = n);
  },
  reverse: function() {
    var t = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  }
});
cc.sequence = function(t) {
  var e = t instanceof Array ? t : arguments;
  e.length > 0 && e[e.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
  for (var n, r, s, o; e && e.length > 0; )
    for (r = Array.prototype.shift.call(e), o = r._timesForRepeat || 1, r._repeatMethod = !1, r._timesForRepeat = 1, s = 0, n || (n = r, s = 1), s; s < o; s++)
      n = cc.Sequence._actionOneTwo(n, r);
  return n;
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function(t, e) {
  var n = new cc.Sequence();
  return n.initWithTwoActions(t, e), n;
};
cc.Repeat = cc.ActionInterval.extend({
  _times: 0,
  _total: 0,
  _nextDt: 0,
  _actionInstant: !1,
  _innerAction: null,
  ctor: function(t, e) {
    cc.ActionInterval.prototype.ctor.call(this), e !== void 0 && this.initWithAction(t, e);
  },
  initWithAction: function(t, e) {
    var n = t._duration * e;
    return this.initWithDuration(n) ? (this._times = e, this._innerAction = t, t instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1;
  },
  clone: function() {
    var t = new cc.Repeat();
    return this._cloneDecoration(t), t.initWithAction(this._innerAction.clone(), this._times), t;
  },
  startWithTarget: function(t) {
    this._total = 0, this._nextDt = (this || window)._innerAction._duration / this._duration, cc.ActionInterval.prototype.startWithTarget.call(this, t), this._innerAction.startWithTarget(t);
  },
  stop: function() {
    this._innerAction.stop(), cc.Action.prototype.stop.call(this);
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t);
    var e = (this || window)._innerAction, n = (this || window)._duration, r = (this || window)._times, s = (this || window)._nextDt;
    if (t >= s) {
      for (; t > s && this._total < r; )
        e.update(1), this._total++, e.stop(), e.startWithTarget(this.target), s += e._duration / n, this._nextDt = s;
      t >= 1 && this._total < r && this._total++, this._actionInstant || (this._total === r ? (e.update(1), e.stop()) : e.update(t - (s - e._duration / n)));
    } else
      e.update(t * r % 1);
  },
  isDone: function() {
    return this._total === (this || window)._times;
  },
  reverse: function() {
    var t = new cc.Repeat(this._innerAction.reverse(), this._times);
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  },
  setInnerAction: function(t) {
    this._innerAction !== t && (this._innerAction = t);
  },
  getInnerAction: function() {
    return this._innerAction;
  }
});
cc.repeat = function(t, e) {
  return new cc.Repeat(t, e);
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
  _innerAction: null,
  ctor: function(t) {
    cc.ActionInterval.prototype.ctor.call(this), this._innerAction = null, t && this.initWithAction(t);
  },
  initWithAction: function(t) {
    if (!t)
      throw new Error("cc.RepeatForever.initWithAction(): action must be non null");
    return this._innerAction = t, !0;
  },
  clone: function() {
    var t = new cc.RepeatForever();
    return this._cloneDecoration(t), t.initWithAction(this._innerAction.clone()), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._innerAction.startWithTarget(t);
  },
  step: function(t) {
    var e = (this || window)._innerAction;
    e.step(t), e.isDone() && (e.startWithTarget(this.target), e.step(e.getElapsed() - e._duration));
  },
  isDone: function() {
    return !1;
  },
  reverse: function() {
    var t = new cc.RepeatForever(this._innerAction.reverse());
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  },
  setInnerAction: function(t) {
    this._innerAction !== t && (this._innerAction = t);
  },
  getInnerAction: function() {
    return this._innerAction;
  }
});
cc.repeatForever = function(t) {
  return new cc.RepeatForever(t);
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
  _one: null,
  _two: null,
  ctor: function(t) {
    cc.ActionInterval.prototype.ctor.call(this), this._one = null, this._two = null;
    var e = t instanceof Array ? t : arguments, n = e.length - 1;
    if (n >= 0 && e[n] == null && cc.log("parameters should not be ending with null in Javascript"), n >= 0) {
      for (var r = e[0], s, o = 1; o < n; o++)
        e[o] && (s = r, r = cc.Spawn._actionOneTwo(s, e[o]));
      this.initWithTwoActions(r, e[n]);
    }
  },
  initWithTwoActions: function(t, e) {
    if (!t || !e)
      throw new Error("cc.Spawn.initWithTwoActions(): arguments must all be non null");
    var n = !1, r = t._duration, s = e._duration;
    return this.initWithDuration(Math.max(r, s)) && (this._one = t, this._two = e, r > s ? this._two = cc.Sequence._actionOneTwo(e, cc.delayTime(r - s)) : r < s && (this._one = cc.Sequence._actionOneTwo(t, cc.delayTime(s - r))), n = !0), n;
  },
  clone: function() {
    var t = new cc.Spawn();
    return this._cloneDecoration(t), t.initWithTwoActions(this._one.clone(), this._two.clone()), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._one.startWithTarget(t), this._two.startWithTarget(t);
  },
  stop: function() {
    this._one.stop(), this._two.stop(), cc.Action.prototype.stop.call(this);
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t), this._one && this._one.update(t), this._two && this._two.update(t);
  },
  reverse: function() {
    var t = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  }
});
cc.spawn = function(t) {
  var e = t instanceof Array ? t : arguments;
  e.length > 0 && e[e.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
  for (var n = e[0], r = 1; r < e.length; r++)
    e[r] != null && (n = cc.Spawn._actionOneTwo(n, e[r]));
  return n;
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function(t, e) {
  var n = new cc.Spawn();
  return n.initWithTwoActions(t, e), n;
};
cc.RotateTo = cc.ActionInterval.extend({
  _dstAngleX: 0,
  _startAngleX: 0,
  _diffAngleX: 0,
  _dstAngleY: 0,
  _startAngleY: 0,
  _diffAngleY: 0,
  ctor: function(t, e, n) {
    cc.ActionInterval.prototype.ctor.call(this), e !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._dstAngleX = e || 0, this._dstAngleY = n || this._dstAngleX, !0) : !1;
  },
  clone: function() {
    var t = new cc.RotateTo();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t);
    var e = t.rotationX % 360, n = (this || window)._dstAngleX - e;
    n > 180 && (n -= 360), n < -180 && (n += 360), this._startAngleX = e, this._diffAngleX = n, this._startAngleY = t.rotationY % 360;
    var r = (this || window)._dstAngleY - this._startAngleY;
    r > 180 && (r -= 360), r < -180 && (r += 360), this._diffAngleY = r;
  },
  reverse: function() {
    cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.");
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t), this.target && (this.target.rotationX = (this || window)._startAngleX + this._diffAngleX * t, this.target.rotationY = (this || window)._startAngleY + this._diffAngleY * t);
  }
});
cc.rotateTo = function(t, e, n) {
  return new cc.RotateTo(t, e, n);
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
  _angleX: 0,
  _startAngleX: 0,
  _angleY: 0,
  _startAngleY: 0,
  ctor: function(t, e, n) {
    cc.ActionInterval.prototype.ctor.call(this), e !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._angleX = e || 0, this._angleY = n || this._angleX, !0) : !1;
  },
  clone: function() {
    var t = new cc.RotateBy();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._angleX, this._angleY), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._startAngleX = t.rotationX, this._startAngleY = t.rotationY;
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t), this.target && (this.target.rotationX = (this || window)._startAngleX + this._angleX * t, this.target.rotationY = (this || window)._startAngleY + this._angleY * t);
  },
  reverse: function() {
    var t = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  }
});
cc.rotateBy = function(t, e, n) {
  return new cc.RotateBy(t, e, n);
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
  _positionDelta: null,
  _startPosition: null,
  _previousPosition: null,
  ctor: function(t, e, n) {
    cc.ActionInterval.prototype.ctor.call(this), this._positionDelta = cc.p(0, 0), this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), e !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (e.x !== void 0 && (n = e.y, e = e.x), this._positionDelta.x = e, this._positionDelta.y = n, !0) : !1;
  },
  clone: function() {
    var t = new cc.MoveBy();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._positionDelta), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t);
    var e = t.getPositionX(), n = t.getPositionY();
    this._previousPosition.x = e, this._previousPosition.y = n, this._startPosition.x = e, this._startPosition.y = n;
  },
  update: function(t) {
    if (t = (this || window)._computeEaseTime(t), this.target) {
      var e = (this || window)._positionDelta.x * t, n = (this || window)._positionDelta.y * t, r = (this || window)._startPosition;
      if (cc.ENABLE_STACKABLE_ACTIONS) {
        var s = (this || window).target.getPositionX(), o = (this || window).target.getPositionY(), a = (this || window)._previousPosition;
        r.x = r.x + s - a.x, r.y = r.y + o - a.y, e = e + r.x, n = n + r.y, a.x = e, a.y = n, this.target.setPosition(e, n);
      } else
        this.target.setPosition(r.x + e, r.y + n);
    }
  },
  reverse: function() {
    var t = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  }
});
cc.moveBy = function(t, e, n) {
  return new cc.MoveBy(t, e, n);
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
  _endPosition: null,
  ctor: function(t, e, n) {
    cc.MoveBy.prototype.ctor.call(this), this._endPosition = cc.p(0, 0), e !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    return cc.MoveBy.prototype.initWithDuration.call(this, t, e, n) ? (e.x !== void 0 && (n = e.y, e = e.x), this._endPosition.x = e, this._endPosition.y = n, !0) : !1;
  },
  clone: function() {
    var t = new cc.MoveTo();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._endPosition), t;
  },
  startWithTarget: function(t) {
    cc.MoveBy.prototype.startWithTarget.call(this, t), this._positionDelta.x = (this || window)._endPosition.x - t.getPositionX(), this._positionDelta.y = (this || window)._endPosition.y - t.getPositionY();
  }
});
cc.moveTo = function(t, e, n) {
  return new cc.MoveTo(t, e, n);
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
  _skewX: 0,
  _skewY: 0,
  _startSkewX: 0,
  _startSkewY: 0,
  _endSkewX: 0,
  _endSkewY: 0,
  _deltaX: 0,
  _deltaY: 0,
  ctor: function(t, e, n) {
    cc.ActionInterval.prototype.ctor.call(this), n !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    var r = !1;
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) && (this._endSkewX = e, this._endSkewY = n, r = !0), r;
  },
  clone: function() {
    var t = new cc.SkewTo();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._endSkewX, this._endSkewY), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._startSkewX = t.skewX % 180, this._deltaX = (this || window)._endSkewX - this._startSkewX, this._deltaX > 180 && (this._deltaX -= 360), this._deltaX < -180 && (this._deltaX += 360), this._startSkewY = t.skewY % 360, this._deltaY = (this || window)._endSkewY - this._startSkewY, this._deltaY > 180 && (this._deltaY -= 360), this._deltaY < -180 && (this._deltaY += 360);
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t), this.target.skewX = (this || window)._startSkewX + this._deltaX * t, this.target.skewY = (this || window)._startSkewY + this._deltaY * t;
  }
});
cc.skewTo = function(t, e, n) {
  return new cc.SkewTo(t, e, n);
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
  ctor: function(t, e, n) {
    cc.SkewTo.prototype.ctor.call(this), n !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    var r = !1;
    return cc.SkewTo.prototype.initWithDuration.call(this, t, e, n) && (this._skewX = e, this._skewY = n, r = !0), r;
  },
  clone: function() {
    var t = new cc.SkewBy();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._skewX, this._skewY), t;
  },
  startWithTarget: function(t) {
    cc.SkewTo.prototype.startWithTarget.call(this, t), this._deltaX = (this || window)._skewX, this._deltaY = (this || window)._skewY, this._endSkewX = (this || window)._startSkewX + this._deltaX, this._endSkewY = (this || window)._startSkewY + this._deltaY;
  },
  reverse: function() {
    var t = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  }
});
cc.skewBy = function(t, e, n) {
  return new cc.SkewBy(t, e, n);
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
  _startPosition: null,
  _delta: null,
  _height: 0,
  _jumps: 0,
  _previousPosition: null,
  ctor: function(t, e, n, r, s) {
    cc.ActionInterval.prototype.ctor.call(this), this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), this._delta = cc.p(0, 0), r !== void 0 && this.initWithDuration(t, e, n, r, s);
  },
  initWithDuration: function(t, e, n, r, s) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (s === void 0 && (s = r, r = n, n = e.y, e = e.x), this._delta.x = e, this._delta.y = n, this._height = r, this._jumps = s, !0) : !1;
  },
  clone: function() {
    var t = new cc.JumpBy();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._delta, this._height, this._jumps), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t);
    var e = t.getPositionX(), n = t.getPositionY();
    this._previousPosition.x = e, this._previousPosition.y = n, this._startPosition.x = e, this._startPosition.y = n;
  },
  update: function(t) {
    if (t = (this || window)._computeEaseTime(t), this.target) {
      var e = t * this._jumps % 1, n = (this || window)._height * 4 * e * (1 - e);
      n += (this || window)._delta.y * t;
      var r = (this || window)._delta.x * t, s = (this || window)._startPosition;
      if (cc.ENABLE_STACKABLE_ACTIONS) {
        var o = (this || window).target.getPositionX(), a = (this || window).target.getPositionY(), c = (this || window)._previousPosition;
        s.x = s.x + o - c.x, s.y = s.y + a - c.y, r = r + s.x, n = n + s.y, c.x = r, c.y = n, this.target.setPosition(r, n);
      } else
        this.target.setPosition(s.x + r, s.y + n);
    }
  },
  reverse: function() {
    var t = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  }
});
cc.jumpBy = function(t, e, n, r, s) {
  return new cc.JumpBy(t, e, n, r, s);
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
  _endPosition: null,
  ctor: function(t, e, n, r, s) {
    cc.JumpBy.prototype.ctor.call(this), this._endPosition = cc.p(0, 0), r !== void 0 && this.initWithDuration(t, e, n, r, s);
  },
  initWithDuration: function(t, e, n, r, s) {
    return cc.JumpBy.prototype.initWithDuration.call(this, t, e, n, r, s) ? (s === void 0 && (n = e.y, e = e.x), this._endPosition.x = e, this._endPosition.y = n, !0) : !1;
  },
  startWithTarget: function(t) {
    cc.JumpBy.prototype.startWithTarget.call(this, t), this._delta.x = (this || window)._endPosition.x - this._startPosition.x, this._delta.y = (this || window)._endPosition.y - this._startPosition.y;
  },
  clone: function() {
    var t = new cc.JumpTo();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._endPosition, this._height, this._jumps), t;
  }
});
cc.jumpTo = function(t, e, n, r, s) {
  return new cc.JumpTo(t, e, n, r, s);
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function(t, e, n, r, s) {
  return Math.pow(1 - s, 3) * t + 3 * s * Math.pow(1 - s, 2) * e + 3 * Math.pow(s, 2) * (1 - s) * n + Math.pow(s, 3) * r;
};
cc.BezierBy = cc.ActionInterval.extend({
  _config: null,
  _startPosition: null,
  _previousPosition: null,
  ctor: function(t, e) {
    cc.ActionInterval.prototype.ctor.call(this), this._config = [], this._startPosition = cc.p(0, 0), this._previousPosition = cc.p(0, 0), e && this.initWithDuration(t, e);
  },
  initWithDuration: function(t, e) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._config = e, !0) : !1;
  },
  clone: function() {
    var t = new cc.BezierBy();
    this._cloneDecoration(t);
    for (var e = [], n = 0; n < this._config.length; n++) {
      var r = (this || window)._config[n];
      e.push(cc.p(r.x, r.y));
    }
    return t.initWithDuration(this._duration, e), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t);
    var e = t.getPositionX(), n = t.getPositionY();
    this._previousPosition.x = e, this._previousPosition.y = n, this._startPosition.x = e, this._startPosition.y = n;
  },
  update: function(t) {
    if (t = (this || window)._computeEaseTime(t), this.target) {
      var e = (this || window)._config, n = 0, r = e[0].x, s = e[1].x, o = e[2].x, a = 0, c = e[0].y, l = e[1].y, h = e[2].y, u = cc.bezierAt(n, r, s, o, t), _ = cc.bezierAt(a, c, l, h, t), d = (this || window)._startPosition;
      if (cc.ENABLE_STACKABLE_ACTIONS) {
        var f = (this || window).target.getPositionX(), C = (this || window).target.getPositionY(), m = (this || window)._previousPosition;
        d.x = d.x + f - m.x, d.y = d.y + C - m.y, u = u + d.x, _ = _ + d.y, m.x = u, m.y = _, this.target.setPosition(u, _);
      } else
        this.target.setPosition(d.x + u, d.y + _);
    }
  },
  reverse: function() {
    var t = (this || window)._config, e = [
      cc.pAdd(t[1], cc.pNeg(t[2])),
      cc.pAdd(t[0], cc.pNeg(t[2])),
      cc.pNeg(t[2])
    ], n = new cc.BezierBy(this._duration, e);
    return this._cloneDecoration(n), this._reverseEaseList(n), n;
  }
});
cc.bezierBy = function(t, e) {
  return new cc.BezierBy(t, e);
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
  _toConfig: null,
  ctor: function(t, e) {
    cc.BezierBy.prototype.ctor.call(this), this._toConfig = [], e && this.initWithDuration(t, e);
  },
  initWithDuration: function(t, e) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._toConfig = e, !0) : !1;
  },
  clone: function() {
    var t = new cc.BezierTo();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._toConfig), t;
  },
  startWithTarget: function(t) {
    cc.BezierBy.prototype.startWithTarget.call(this, t);
    var e = (this || window)._startPosition, n = (this || window)._toConfig, r = (this || window)._config;
    r[0] = cc.pSub(n[0], e), r[1] = cc.pSub(n[1], e), r[2] = cc.pSub(n[2], e);
  }
});
cc.bezierTo = function(t, e) {
  return new cc.BezierTo(t, e);
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
  _scaleX: 1,
  _scaleY: 1,
  _startScaleX: 1,
  _startScaleY: 1,
  _endScaleX: 0,
  _endScaleY: 0,
  _deltaX: 0,
  _deltaY: 0,
  ctor: function(t, e, n) {
    cc.ActionInterval.prototype.ctor.call(this), e !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._endScaleX = e, this._endScaleY = n != null ? n : e, !0) : !1;
  },
  clone: function() {
    var t = new cc.ScaleTo();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._endScaleX, this._endScaleY), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._startScaleX = t.scaleX, this._startScaleY = t.scaleY, this._deltaX = (this || window)._endScaleX - this._startScaleX, this._deltaY = (this || window)._endScaleY - this._startScaleY;
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t), this.target && (this.target.scaleX = (this || window)._startScaleX + this._deltaX * t, this.target.scaleY = (this || window)._startScaleY + this._deltaY * t);
  }
});
cc.scaleTo = function(t, e, n) {
  return new cc.ScaleTo(t, e, n);
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
  startWithTarget: function(t) {
    cc.ScaleTo.prototype.startWithTarget.call(this, t), this._deltaX = (this || window)._startScaleX * this._endScaleX - this._startScaleX, this._deltaY = (this || window)._startScaleY * this._endScaleY - this._startScaleY;
  },
  reverse: function() {
    var t = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  },
  clone: function() {
    var t = new cc.ScaleBy();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._endScaleX, this._endScaleY), t;
  }
});
cc.scaleBy = function(t, e, n) {
  return new cc.ScaleBy(t, e, n);
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
  _times: 0,
  _originalState: !1,
  ctor: function(t, e) {
    cc.ActionInterval.prototype.ctor.call(this), e !== void 0 && this.initWithDuration(t, e);
  },
  initWithDuration: function(t, e) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._times = e, !0) : !1;
  },
  clone: function() {
    var t = new cc.Blink();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._times), t;
  },
  update: function(t) {
    if (t = (this || window)._computeEaseTime(t), this.target && !this.isDone()) {
      var e = 1 / this._times, n = t % e;
      this.target.visible = n > e / 2;
    }
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._originalState = t.visible;
  },
  stop: function() {
    this.target.visible = (this || window)._originalState, cc.ActionInterval.prototype.stop.call(this);
  },
  reverse: function() {
    var t = new cc.Blink(this._duration, this._times);
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  }
});
cc.blink = function(t, e) {
  return new cc.Blink(t, e);
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
  _toOpacity: 0,
  _fromOpacity: 0,
  ctor: function(t, e) {
    cc.ActionInterval.prototype.ctor.call(this), e !== void 0 && this.initWithDuration(t, e);
  },
  initWithDuration: function(t, e) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._toOpacity = e, !0) : !1;
  },
  clone: function() {
    var t = new cc.FadeTo();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._toOpacity), t;
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t);
    var e = (this || window)._fromOpacity !== void 0 ? this._fromOpacity : 255;
    this.target.opacity = e + (this._toOpacity - e) * t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._fromOpacity = t.opacity;
  }
});
cc.fadeTo = function(t, e) {
  return new cc.FadeTo(t, e);
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
  _reverseAction: null,
  ctor: function(t) {
    cc.FadeTo.prototype.ctor.call(this), t == null && (t = 0), this.initWithDuration(t, 255);
  },
  reverse: function() {
    var t = new cc.FadeOut();
    return t.initWithDuration(this._duration, 0), this._cloneDecoration(t), this._reverseEaseList(t), t;
  },
  clone: function() {
    var t = new cc.FadeIn();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._toOpacity), t;
  },
  startWithTarget: function(t) {
    this._reverseAction && (this._toOpacity = (this || window)._reverseAction._fromOpacity), cc.FadeTo.prototype.startWithTarget.call(this, t);
  }
});
cc.fadeIn = function(t) {
  return new cc.FadeIn(t);
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
  ctor: function(t) {
    cc.FadeTo.prototype.ctor.call(this), t == null && (t = 0), this.initWithDuration(t, 0);
  },
  reverse: function() {
    var t = new cc.FadeIn();
    return t._reverseAction = (this || window), t.initWithDuration(this._duration, 255), this._cloneDecoration(t), this._reverseEaseList(t), t;
  },
  clone: function() {
    var t = new cc.FadeOut();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._toOpacity), t;
  }
});
cc.fadeOut = function(t) {
  return new cc.FadeOut(t);
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
  _to: null,
  _from: null,
  ctor: function(t, e, n, r) {
    cc.ActionInterval.prototype.ctor.call(this), this._to = cc.color(0, 0, 0), this._from = cc.color(0, 0, 0), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  initWithDuration: function(t, e, n, r) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._to = cc.color(e, n, r), !0) : !1;
  },
  clone: function() {
    var t = new cc.TintTo();
    this._cloneDecoration(t);
    var e = (this || window)._to;
    return t.initWithDuration(this._duration, e.r, e.g, e.b), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._from = (this || window).target.color;
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t);
    var e = (this || window)._from, n = (this || window)._to;
    e && this.target.setColor(
      cc.color(
        e.r + (n.r - e.r) * t,
        e.g + (n.g - e.g) * t,
        e.b + (n.b - e.b) * t
      )
    );
  }
});
cc.tintTo = function(t, e, n, r) {
  return new cc.TintTo(t, e, n, r);
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
  _deltaR: 0,
  _deltaG: 0,
  _deltaB: 0,
  _fromR: 0,
  _fromG: 0,
  _fromB: 0,
  ctor: function(t, e, n, r) {
    cc.ActionInterval.prototype.ctor.call(this), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  initWithDuration: function(t, e, n, r) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._deltaR = e, this._deltaG = n, this._deltaB = r, !0) : !1;
  },
  clone: function() {
    var t = new cc.TintBy();
    return this._cloneDecoration(t), t.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t);
    var e = t.color;
    this._fromR = e.r, this._fromG = e.g, this._fromB = e.b;
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t), this.target.color = cc.color(
      this._fromR + this._deltaR * t,
      this._fromG + this._deltaG * t,
      this._fromB + this._deltaB * t
    );
  },
  reverse: function() {
    var t = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  }
});
cc.tintBy = function(t, e, n, r) {
  return new cc.TintBy(t, e, n, r);
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
  update: function(t) {
  },
  reverse: function() {
    var t = new cc.DelayTime(this._duration);
    return this._cloneDecoration(t), this._reverseEaseList(t), t;
  },
  clone: function() {
    var t = new cc.DelayTime();
    return this._cloneDecoration(t), t.initWithDuration(this._duration), t;
  }
});
cc.delayTime = function(t) {
  return new cc.DelayTime(t);
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
  _other: null,
  ctor: function(t) {
    cc.ActionInterval.prototype.ctor.call(this), this._other = null, t && this.initWithAction(t);
  },
  initWithAction: function(t) {
    if (!t)
      throw new Error("cc.ReverseTime.initWithAction(): action must be non null");
    if (t === (this || window)._other)
      throw new Error("cc.ReverseTime.initWithAction(): the action was already passed in.");
    return cc.ActionInterval.prototype.initWithDuration.call(this, t._duration) ? (this._other = t, !0) : !1;
  },
  clone: function() {
    var t = new cc.ReverseTime();
    return this._cloneDecoration(t), t.initWithAction(this._other.clone()), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._other.startWithTarget(t);
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t), this._other && this._other.update(1 - t);
  },
  reverse: function() {
    return this._other.clone();
  },
  stop: function() {
    this._other.stop(), cc.Action.prototype.stop.call(this);
  }
});
cc.reverseTime = function(t) {
  return new cc.ReverseTime(t);
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
  _animation: null,
  _nextFrame: 0,
  _origFrame: null,
  _executedLoops: 0,
  _splitTimes: null,
  _currFrameIndex: 0,
  ctor: function(t) {
    cc.ActionInterval.prototype.ctor.call(this), this._splitTimes = [], t && this.initWithAnimation(t);
  },
  getAnimation: function() {
    return this._animation;
  },
  setAnimation: function(t) {
    this._animation = t;
  },
  getCurrentFrameIndex: function() {
    return this._currFrameIndex;
  },
  initWithAnimation: function(t) {
    if (!t)
      throw new Error("cc.Animate.initWithAnimation(): animation must be non-NULL");
    var e = t.getDuration();
    if (this.initWithDuration(e * t.getLoops())) {
      this._nextFrame = 0, this.setAnimation(t), this._origFrame = null, this._executedLoops = 0;
      var n = (this || window)._splitTimes;
      n.length = 0;
      var r = 0, s = e / t.getTotalDelayUnits(), o = t.getFrames();
      cc.arrayVerifyType(o, cc.AnimationFrame);
      for (var a = 0; a < o.length; a++) {
        var c = o[a], l = r * s / e;
        r += c.getDelayUnits(), n.push(l);
      }
      return !0;
    }
    return !1;
  },
  clone: function() {
    var t = new cc.Animate();
    return this._cloneDecoration(t), t.initWithAnimation(this._animation.clone()), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._animation.getRestoreOriginalFrame() && (this._origFrame = t.displayFrame()), this._nextFrame = 0, this._executedLoops = 0;
  },
  update: function(t) {
    if (t = (this || window)._computeEaseTime(t), t < 1) {
      t *= (this || window)._animation.getLoops();
      var e = 0 | t;
      e > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), t = t % 1;
    }
    for (var n = (this || window)._animation.getFrames(), r = n.length, s = (this || window)._splitTimes, o = (this || window)._nextFrame; o < r && s[o] <= t; o++)
      _currFrameIndex = o, this.target.setSpriteFrame(n[_currFrameIndex].getSpriteFrame()), this._nextFrame = o + 1;
  },
  reverse: function() {
    var t = (this || window)._animation, e = t.getFrames(), n = [];
    if (cc.arrayVerifyType(e, cc.AnimationFrame), e.length > 0)
      for (var r = e.length - 1; r >= 0; r--) {
        var s = e[r];
        if (!s)
          break;
        n.push(s.clone());
      }
    var o = new cc.Animation(n, t.getDelayPerUnit(), t.getLoops());
    o.setRestoreOriginalFrame(t.getRestoreOriginalFrame());
    var a = new cc.Animate(o);
    return this._cloneDecoration(a), this._reverseEaseList(a), a;
  },
  stop: function() {
    this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame), cc.Action.prototype.stop.call(this);
  }
});
cc.animate = function(t) {
  return new cc.Animate(t);
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
  _action: null,
  _forcedTarget: null,
  ctor: function(t, e) {
    cc.ActionInterval.prototype.ctor.call(this), e && this.initWithTarget(t, e);
  },
  initWithTarget: function(t, e) {
    return this.initWithDuration(e._duration) ? (this._forcedTarget = t, this._action = e, !0) : !1;
  },
  clone: function() {
    var t = new cc.TargetedAction();
    return this._cloneDecoration(t), t.initWithTarget(this._forcedTarget, this._action.clone()), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._action.startWithTarget(this._forcedTarget);
  },
  stop: function() {
    this._action.stop();
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t), this._action.update(t);
  },
  getForcedTarget: function() {
    return this._forcedTarget;
  },
  setForcedTarget: function(t) {
    this._forcedTarget !== t && (this._forcedTarget = t);
  }
});
cc.targetedAction = function(t, e) {
  return new cc.TargetedAction(t, e);
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
  isDone: function() {
    return !0;
  },
  step: function(t) {
    this.update(1);
  },
  update: function(t) {
  },
  reverse: function() {
    return this.clone();
  },
  clone: function() {
    return new cc.ActionInstant();
  }
});
cc.Show = cc.ActionInstant.extend({
  update: function(t) {
    this.target.visible = !0;
  },
  reverse: function() {
    return new cc.Hide();
  },
  clone: function() {
    return new cc.Show();
  }
});
cc.show = function() {
  return new cc.Show();
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
  update: function(t) {
    this.target.visible = !1;
  },
  reverse: function() {
    return new cc.Show();
  },
  clone: function() {
    return new cc.Hide();
  }
});
cc.hide = function() {
  return new cc.Hide();
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
  update: function(t) {
    this.target.visible = !this.target.visible;
  },
  reverse: function() {
    return new cc.ToggleVisibility();
  },
  clone: function() {
    return new cc.ToggleVisibility();
  }
});
cc.toggleVisibility = function() {
  return new cc.ToggleVisibility();
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
  _isNeedCleanUp: !0,
  ctor: function(t) {
    cc.FiniteTimeAction.prototype.ctor.call(this), t !== void 0 && this.init(t);
  },
  update: function(t) {
    this.target.removeFromParent(this._isNeedCleanUp);
  },
  /**
       * Initialization of the node, please do not call this function by yourself, you should pass the parameters to constructor to initialize it
  .
       * @param isNeedCleanUp
       * @returns {boolean}
       */
  init: function(t) {
    return this._isNeedCleanUp = t, !0;
  },
  reverse: function() {
    return new cc.RemoveSelf(this._isNeedCleanUp);
  },
  clone: function() {
    return new cc.RemoveSelf(this._isNeedCleanUp);
  }
});
cc.removeSelf = function(t) {
  return new cc.RemoveSelf(t);
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
  _flippedX: !1,
  ctor: function(t) {
    cc.FiniteTimeAction.prototype.ctor.call(this), this._flippedX = !1, t !== void 0 && this.initWithFlipX(t);
  },
  initWithFlipX: function(t) {
    return this._flippedX = t, !0;
  },
  update: function(t) {
    this.target.flippedX = (this || window)._flippedX;
  },
  reverse: function() {
    return new cc.FlipX(!this._flippedX);
  },
  clone: function() {
    var t = new cc.FlipX();
    return t.initWithFlipX(this._flippedX), t;
  }
});
cc.flipX = function(t) {
  return new cc.FlipX(t);
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
  _flippedY: !1,
  ctor: function(t) {
    cc.FiniteTimeAction.prototype.ctor.call(this), this._flippedY = !1, t !== void 0 && this.initWithFlipY(t);
  },
  initWithFlipY: function(t) {
    return this._flippedY = t, !0;
  },
  update: function(t) {
    this.target.flippedY = (this || window)._flippedY;
  },
  reverse: function() {
    return new cc.FlipY(!this._flippedY);
  },
  clone: function() {
    var t = new cc.FlipY();
    return t.initWithFlipY(this._flippedY), t;
  }
});
cc.flipY = function(t) {
  return new cc.FlipY(t);
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
  _x: 0,
  _y: 0,
  ctor: function(t, e) {
    cc.FiniteTimeAction.prototype.ctor.call(this), this._x = 0, this._y = 0, t !== void 0 && (t.x !== void 0 && (e = t.y, t = t.x), this.initWithPosition(t, e));
  },
  initWithPosition: function(t, e) {
    return this._x = t, this._y = e, !0;
  },
  update: function(t) {
    this.target.setPosition(this._x, this._y);
  },
  clone: function() {
    var t = new cc.Place();
    return t.initWithPosition(this._x, this._y), t;
  }
});
cc.place = function(t, e) {
  return new cc.Place(t, e);
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
  _selectorTarget: null,
  _function: null,
  _data: null,
  ctor: function(t, e, n) {
    cc.FiniteTimeAction.prototype.ctor.call(this), this.initWithFunction(t, e, n);
  },
  initWithFunction: function(t, e, n) {
    return t && (this._function = t), e && (this._selectorTarget = e), n !== void 0 && (this._data = n), !0;
  },
  execute: function() {
    this._function && this._function.call(this._selectorTarget, this.target, this._data);
  },
  update: function(t) {
    this.execute();
  },
  getTargetCallback: function() {
    return this._selectorTarget;
  },
  setTargetCallback: function(t) {
    t !== (this || window)._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = t);
  },
  clone: function() {
    var t = new cc.CallFunc();
    return t.initWithFunction(this._function, this._selectorTarget, this._data), t;
  }
});
cc.callFunc = function(t, e, n) {
  return new cc.CallFunc(t, e, n);
};
cc.CallFunc.create = cc.callFunc;
cc.ActionEase = cc.ActionInterval.extend({
  _inner: null,
  ctor: function(t) {
    cc.ActionInterval.prototype.ctor.call(this), t && this.initWithAction(t);
  },
  initWithAction: function(t) {
    if (!t)
      throw new Error("cc.ActionEase.initWithAction(): action must be non nil");
    return this.initWithDuration(t.getDuration()) ? (this._inner = t, !0) : !1;
  },
  clone: function() {
    var t = new cc.ActionEase();
    return t.initWithAction(this._inner.clone()), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._inner.startWithTarget(this.target);
  },
  stop: function() {
    this._inner.stop(), cc.ActionInterval.prototype.stop.call(this);
  },
  update: function(t) {
    this._inner.update(t);
  },
  reverse: function() {
    return new cc.ActionEase(this._inner.reverse());
  },
  getInnerAction: function() {
    return this._inner;
  }
});
cc.actionEase = function(t) {
  return new cc.ActionEase(t);
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
  _rate: 0,
  ctor: function(t, e) {
    cc.ActionEase.prototype.ctor.call(this), e !== void 0 && this.initWithAction(t, e);
  },
  setRate: function(t) {
    this._rate = t;
  },
  getRate: function() {
    return this._rate;
  },
  initWithAction: function(t, e) {
    return cc.ActionEase.prototype.initWithAction.call(this, t) ? (this._rate = e, !0) : !1;
  },
  clone: function() {
    var t = new cc.EaseRateAction();
    return t.initWithAction(this._inner.clone(), this._rate), t;
  },
  reverse: function() {
    return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate);
  }
});
cc.easeRateAction = function(t, e) {
  return new cc.EaseRateAction(t, e);
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
  update: function(t) {
    this._inner.update(Math.pow(t, this._rate));
  },
  reverse: function() {
    return new cc.EaseIn(this._inner.reverse(), 1 / this._rate);
  },
  clone: function() {
    var t = new cc.EaseIn();
    return t.initWithAction(this._inner.clone(), this._rate), t;
  }
});
cc.EaseIn.create = function(t, e) {
  return new cc.EaseIn(t, e);
};
cc.easeIn = function(t) {
  return {
    _rate: t,
    easing: function(e) {
      return Math.pow(e, this._rate);
    },
    reverse: function() {
      return cc.easeIn(1 / this._rate);
    }
  };
};
cc.EaseOut = cc.EaseRateAction.extend({
  update: function(t) {
    this._inner.update(Math.pow(t, 1 / this._rate));
  },
  reverse: function() {
    return new cc.EaseOut(this._inner.reverse(), 1 / this._rate);
  },
  clone: function() {
    var t = new cc.EaseOut();
    return t.initWithAction(this._inner.clone(), this._rate), t;
  }
});
cc.EaseOut.create = function(t, e) {
  return new cc.EaseOut(t, e);
};
cc.easeOut = function(t) {
  return {
    _rate: t,
    easing: function(e) {
      return Math.pow(e, 1 / this._rate);
    },
    reverse: function() {
      return cc.easeOut(1 / this._rate);
    }
  };
};
cc.EaseInOut = cc.EaseRateAction.extend({
  update: function(t) {
    t *= 2, t < 1 ? this._inner.update(0.5 * Math.pow(t, this._rate)) : this._inner.update(1 - 0.5 * Math.pow(2 - t, this._rate));
  },
  clone: function() {
    var t = new cc.EaseInOut();
    return t.initWithAction(this._inner.clone(), this._rate), t;
  },
  reverse: function() {
    return new cc.EaseInOut(this._inner.reverse(), this._rate);
  }
});
cc.EaseInOut.create = function(t, e) {
  return new cc.EaseInOut(t, e);
};
cc.easeInOut = function(t) {
  return {
    _rate: t,
    easing: function(e) {
      return e *= 2, e < 1 ? 0.5 * Math.pow(e, this._rate) : 1 - 0.5 * Math.pow(2 - e, this._rate);
    },
    reverse: function() {
      return cc.easeInOut(this._rate);
    }
  };
};
cc.EaseExponentialIn = cc.ActionEase.extend({
  update: function(t) {
    this._inner.update(t === 0 ? 0 : Math.pow(2, 10 * (t - 1)));
  },
  reverse: function() {
    return new cc.EaseExponentialOut(this._inner.reverse());
  },
  clone: function() {
    var t = new cc.EaseExponentialIn();
    return t.initWithAction(this._inner.clone()), t;
  }
});
cc.EaseExponentialIn.create = function(t) {
  return new cc.EaseExponentialIn(t);
};
cc._easeExponentialInObj = {
  easing: function(t) {
    return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
  },
  reverse: function() {
    return cc._easeExponentialOutObj;
  }
};
cc.easeExponentialIn = function() {
  return cc._easeExponentialInObj;
};
cc.EaseExponentialOut = cc.ActionEase.extend({
  update: function(t) {
    this._inner.update(t === 1 ? 1 : -Math.pow(2, -10 * t) + 1);
  },
  reverse: function() {
    return new cc.EaseExponentialIn(this._inner.reverse());
  },
  clone: function() {
    var t = new cc.EaseExponentialOut();
    return t.initWithAction(this._inner.clone()), t;
  }
});
cc.EaseExponentialOut.create = function(t) {
  return new cc.EaseExponentialOut(t);
};
cc._easeExponentialOutObj = {
  easing: function(t) {
    return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
  },
  reverse: function() {
    return cc._easeExponentialInObj;
  }
};
cc.easeExponentialOut = function() {
  return cc._easeExponentialOutObj;
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
  update: function(t) {
    t !== 1 && t !== 0 && (t *= 2, t < 1 ? t = 0.5 * Math.pow(2, 10 * (t - 1)) : t = 0.5 * (-Math.pow(2, -10 * (t - 1)) + 2)), this._inner.update(t);
  },
  reverse: function() {
    return new cc.EaseExponentialInOut(this._inner.reverse());
  },
  clone: function() {
    var t = new cc.EaseExponentialInOut();
    return t.initWithAction(this._inner.clone()), t;
  }
});
cc.EaseExponentialInOut.create = function(t) {
  return new cc.EaseExponentialInOut(t);
};
cc._easeExponentialInOutObj = {
  easing: function(t) {
    return t !== 1 && t !== 0 ? (t *= 2, t < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (-Math.pow(2, -10 * (t - 1)) + 2)) : t;
  },
  reverse: function() {
    return cc._easeExponentialInOutObj;
  }
};
cc.easeExponentialInOut = function() {
  return cc._easeExponentialInOutObj;
};
cc.EaseSineIn = cc.ActionEase.extend({
  update: function(t) {
    t = t === 0 || t === 1 ? t : -1 * Math.cos(t * Math.PI / 2) + 1, this._inner.update(t);
  },
  reverse: function() {
    return new cc.EaseSineOut(this._inner.reverse());
  },
  clone: function() {
    var t = new cc.EaseSineIn();
    return t.initWithAction(this._inner.clone()), t;
  }
});
cc.EaseSineIn.create = function(t) {
  return new cc.EaseSineIn(t);
};
cc._easeSineInObj = {
  easing: function(t) {
    return t === 0 || t === 1 ? t : -1 * Math.cos(t * Math.PI / 2) + 1;
  },
  reverse: function() {
    return cc._easeSineOutObj;
  }
};
cc.easeSineIn = function() {
  return cc._easeSineInObj;
};
cc.EaseSineOut = cc.ActionEase.extend({
  update: function(t) {
    t = t === 0 || t === 1 ? t : Math.sin(t * Math.PI / 2), this._inner.update(t);
  },
  reverse: function() {
    return new cc.EaseSineIn(this._inner.reverse());
  },
  clone: function() {
    var t = new cc.EaseSineOut();
    return t.initWithAction(this._inner.clone()), t;
  }
});
cc.EaseSineOut.create = function(t) {
  return new cc.EaseSineOut(t);
};
cc._easeSineOutObj = {
  easing: function(t) {
    return t === 0 || t === 1 ? t : Math.sin(t * Math.PI / 2);
  },
  reverse: function() {
    return cc._easeSineInObj;
  }
};
cc.easeSineOut = function() {
  return cc._easeSineOutObj;
};
cc.EaseSineInOut = cc.ActionEase.extend({
  update: function(t) {
    t = t === 0 || t === 1 ? t : -0.5 * (Math.cos(Math.PI * t) - 1), this._inner.update(t);
  },
  clone: function() {
    var t = new cc.EaseSineInOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseSineInOut(this._inner.reverse());
  }
});
cc.EaseSineInOut.create = function(t) {
  return new cc.EaseSineInOut(t);
};
cc._easeSineInOutObj = {
  easing: function(t) {
    return t === 0 || t === 1 ? t : -0.5 * (Math.cos(Math.PI * t) - 1);
  },
  reverse: function() {
    return cc._easeSineInOutObj;
  }
};
cc.easeSineInOut = function() {
  return cc._easeSineInOutObj;
};
cc.EaseElastic = cc.ActionEase.extend({
  _period: 0.3,
  ctor: function(t, e) {
    cc.ActionEase.prototype.ctor.call(this), t && this.initWithAction(t, e);
  },
  getPeriod: function() {
    return this._period;
  },
  setPeriod: function(t) {
    this._period = t;
  },
  initWithAction: function(t, e) {
    return cc.ActionEase.prototype.initWithAction.call(this, t), this._period = e == null ? 0.3 : e, !0;
  },
  reverse: function() {
    return cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass."), null;
  },
  clone: function() {
    var t = new cc.EaseElastic();
    return t.initWithAction(this._inner.clone(), this._period), t;
  }
});
cc.EaseElastic.create = function(t, e) {
  return new cc.EaseElastic(t, e);
};
cc.EaseElasticIn = cc.EaseElastic.extend({
  update: function(t) {
    var e = 0;
    if (t === 0 || t === 1)
      e = t;
    else {
      var n = (this || window)._period / 4;
      t = t - 1, e = -Math.pow(2, 10 * t) * Math.sin((t - n) * Math.PI * 2 / this._period);
    }
    this._inner.update(e);
  },
  reverse: function() {
    return new cc.EaseElasticOut(this._inner.reverse(), this._period);
  },
  clone: function() {
    var t = new cc.EaseElasticIn();
    return t.initWithAction(this._inner.clone(), this._period), t;
  }
});
cc.EaseElasticIn.create = function(t, e) {
  return new cc.EaseElasticIn(t, e);
};
cc._easeElasticInObj = {
  easing: function(t) {
    return t === 0 || t === 1 ? t : (t = t - 1, -Math.pow(2, 10 * t) * Math.sin((t - 0.3 / 4) * Math.PI * 2 / 0.3));
  },
  reverse: function() {
    return cc._easeElasticOutObj;
  }
};
cc.easeElasticIn = function(t) {
  return t && t !== 0.3 ? {
    _period: t,
    easing: function(e) {
      return e === 0 || e === 1 ? e : (e = e - 1, -Math.pow(2, 10 * e) * Math.sin((e - this._period / 4) * Math.PI * 2 / this._period));
    },
    reverse: function() {
      return cc.easeElasticOut(this._period);
    }
  } : cc._easeElasticInObj;
};
cc.EaseElasticOut = cc.EaseElastic.extend({
  update: function(t) {
    var e = 0;
    if (t === 0 || t === 1)
      e = t;
    else {
      var n = (this || window)._period / 4;
      e = Math.pow(2, -10 * t) * Math.sin((t - n) * Math.PI * 2 / this._period) + 1;
    }
    this._inner.update(e);
  },
  reverse: function() {
    return new cc.EaseElasticIn(this._inner.reverse(), this._period);
  },
  clone: function() {
    var t = new cc.EaseElasticOut();
    return t.initWithAction(this._inner.clone(), this._period), t;
  }
});
cc.EaseElasticOut.create = function(t, e) {
  return new cc.EaseElasticOut(t, e);
};
cc._easeElasticOutObj = {
  easing: function(t) {
    return t === 0 || t === 1 ? t : Math.pow(2, -10 * t) * Math.sin((t - 0.3 / 4) * Math.PI * 2 / 0.3) + 1;
  },
  reverse: function() {
    return cc._easeElasticInObj;
  }
};
cc.easeElasticOut = function(t) {
  return t && t !== 0.3 ? {
    _period: t,
    easing: function(e) {
      return e === 0 || e === 1 ? e : Math.pow(2, -10 * e) * Math.sin((e - this._period / 4) * Math.PI * 2 / this._period) + 1;
    },
    reverse: function() {
      return cc.easeElasticIn(this._period);
    }
  } : cc._easeElasticOutObj;
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
  update: function(t) {
    var e = 0, n = (this || window)._period;
    if (t === 0 || t === 1)
      e = t;
    else {
      t = t * 2, n || (n = (this || window)._period = 0.3 * 1.5);
      var r = n / 4;
      t = t - 1, t < 0 ? e = -0.5 * Math.pow(2, 10 * t) * Math.sin((t - r) * Math.PI * 2 / n) : e = Math.pow(2, -10 * t) * Math.sin((t - r) * Math.PI * 2 / n) * 0.5 + 1;
    }
    this._inner.update(e);
  },
  reverse: function() {
    return new cc.EaseElasticInOut(this._inner.reverse(), this._period);
  },
  clone: function() {
    var t = new cc.EaseElasticInOut();
    return t.initWithAction(this._inner.clone(), this._period), t;
  }
});
cc.EaseElasticInOut.create = function(t, e) {
  return new cc.EaseElasticInOut(t, e);
};
cc.easeElasticInOut = function(t) {
  return t = t || 0.3, {
    _period: t,
    easing: function(e) {
      var n = 0, r = (this || window)._period;
      if (e === 0 || e === 1)
        n = e;
      else {
        e = e * 2, r || (r = (this || window)._period = 0.3 * 1.5);
        var s = r / 4;
        e = e - 1, e < 0 ? n = -0.5 * Math.pow(2, 10 * e) * Math.sin((e - s) * Math.PI * 2 / r) : n = Math.pow(2, -10 * e) * Math.sin((e - s) * Math.PI * 2 / r) * 0.5 + 1;
      }
      return n;
    },
    reverse: function() {
      return cc.easeElasticInOut(this._period);
    }
  };
};
cc.EaseBounce = cc.ActionEase.extend({
  bounceTime: function(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? (t -= 1.5 / 2.75, 7.5625 * t * t + 0.75) : t < 2.5 / 2.75 ? (t -= 2.25 / 2.75, 7.5625 * t * t + 0.9375) : (t -= 2.625 / 2.75, 7.5625 * t * t + 0.984375);
  },
  clone: function() {
    var t = new cc.EaseBounce();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseBounce(this._inner.reverse());
  }
});
cc.EaseBounce.create = function(t) {
  return new cc.EaseBounce(t);
};
cc.EaseBounceIn = cc.EaseBounce.extend({
  update: function(t) {
    var e = 1 - this.bounceTime(1 - t);
    this._inner.update(e);
  },
  reverse: function() {
    return new cc.EaseBounceOut(this._inner.reverse());
  },
  clone: function() {
    var t = new cc.EaseBounceIn();
    return t.initWithAction(this._inner.clone()), t;
  }
});
cc.EaseBounceIn.create = function(t) {
  return new cc.EaseBounceIn(t);
};
cc._bounceTime = function(t) {
  return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? (t -= 1.5 / 2.75, 7.5625 * t * t + 0.75) : t < 2.5 / 2.75 ? (t -= 2.25 / 2.75, 7.5625 * t * t + 0.9375) : (t -= 2.625 / 2.75, 7.5625 * t * t + 0.984375);
};
cc._easeBounceInObj = {
  easing: function(t) {
    return 1 - cc._bounceTime(1 - t);
  },
  reverse: function() {
    return cc._easeBounceOutObj;
  }
};
cc.easeBounceIn = function() {
  return cc._easeBounceInObj;
};
cc.EaseBounceOut = cc.EaseBounce.extend({
  update: function(t) {
    var e = (this || window).bounceTime(t);
    this._inner.update(e);
  },
  reverse: function() {
    return new cc.EaseBounceIn(this._inner.reverse());
  },
  clone: function() {
    var t = new cc.EaseBounceOut();
    return t.initWithAction(this._inner.clone()), t;
  }
});
cc.EaseBounceOut.create = function(t) {
  return new cc.EaseBounceOut(t);
};
cc._easeBounceOutObj = {
  easing: function(t) {
    return cc._bounceTime(t);
  },
  reverse: function() {
    return cc._easeBounceInObj;
  }
};
cc.easeBounceOut = function() {
  return cc._easeBounceOutObj;
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
  update: function(t) {
    var e = 0;
    t < 0.5 ? (t = t * 2, e = (1 - this.bounceTime(1 - t)) * 0.5) : e = (this || window).bounceTime(t * 2 - 1) * 0.5 + 0.5, this._inner.update(e);
  },
  clone: function() {
    var t = new cc.EaseBounceInOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseBounceInOut(this._inner.reverse());
  }
});
cc.EaseBounceInOut.create = function(t) {
  return new cc.EaseBounceInOut(t);
};
cc._easeBounceInOutObj = {
  easing: function(t) {
    var e;
    return t < 0.5 ? (t = t * 2, e = (1 - cc._bounceTime(1 - t)) * 0.5) : e = cc._bounceTime(t * 2 - 1) * 0.5 + 0.5, e;
  },
  reverse: function() {
    return cc._easeBounceInOutObj;
  }
};
cc.easeBounceInOut = function() {
  return cc._easeBounceInOutObj;
};
cc.EaseBackIn = cc.ActionEase.extend({
  update: function(t) {
    var e = 1.70158;
    t = t === 0 || t === 1 ? t : t * t * ((e + 1) * t - e), this._inner.update(t);
  },
  reverse: function() {
    return new cc.EaseBackOut(this._inner.reverse());
  },
  clone: function() {
    var t = new cc.EaseBackIn();
    return t.initWithAction(this._inner.clone()), t;
  }
});
cc.EaseBackIn.create = function(t) {
  return new cc.EaseBackIn(t);
};
cc._easeBackInObj = {
  easing: function(t) {
    var e = 1.70158;
    return t === 0 || t === 1 ? t : t * t * ((e + 1) * t - e);
  },
  reverse: function() {
    return cc._easeBackOutObj;
  }
};
cc.easeBackIn = function() {
  return cc._easeBackInObj;
};
cc.EaseBackOut = cc.ActionEase.extend({
  update: function(t) {
    var e = 1.70158;
    t = t - 1, this._inner.update(t * t * ((e + 1) * t + e) + 1);
  },
  reverse: function() {
    return new cc.EaseBackIn(this._inner.reverse());
  },
  clone: function() {
    var t = new cc.EaseBackOut();
    return t.initWithAction(this._inner.clone()), t;
  }
});
cc.EaseBackOut.create = function(t) {
  return new cc.EaseBackOut(t);
};
cc._easeBackOutObj = {
  easing: function(t) {
    var e = 1.70158;
    return t = t - 1, t * t * ((e + 1) * t + e) + 1;
  },
  reverse: function() {
    return cc._easeBackInObj;
  }
};
cc.easeBackOut = function() {
  return cc._easeBackOutObj;
};
cc.EaseBackInOut = cc.ActionEase.extend({
  update: function(t) {
    var e = 2.5949095;
    t = t * 2, t < 1 ? this._inner.update(t * t * ((e + 1) * t - e) / 2) : (t = t - 2, this._inner.update(t * t * ((e + 1) * t + e) / 2 + 1));
  },
  clone: function() {
    var t = new cc.EaseBackInOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseBackInOut(this._inner.reverse());
  }
});
cc.EaseBackInOut.create = function(t) {
  return new cc.EaseBackInOut(t);
};
cc._easeBackInOutObj = {
  easing: function(t) {
    var e = 2.5949095;
    return t = t * 2, t < 1 ? t * t * ((e + 1) * t - e) / 2 : (t = t - 2, t * t * ((e + 1) * t + e) / 2 + 1);
  },
  reverse: function() {
    return cc._easeBackInOutObj;
  }
};
cc.easeBackInOut = function() {
  return cc._easeBackInOutObj;
};
cc.EaseBezierAction = cc.ActionEase.extend({
  _p0: null,
  _p1: null,
  _p2: null,
  _p3: null,
  ctor: function(t) {
    cc.ActionEase.prototype.ctor.call(this, t);
  },
  _updateTime: function(t, e, n, r, s) {
    return Math.pow(1 - s, 3) * t + 3 * s * Math.pow(1 - s, 2) * e + 3 * Math.pow(s, 2) * (1 - s) * n + Math.pow(s, 3) * r;
  },
  update: function(t) {
    var e = (this || window)._updateTime(this._p0, this._p1, this._p2, this._p3, t);
    this._inner.update(e);
  },
  clone: function() {
    var t = new cc.EaseBezierAction();
    return t.initWithAction(this._inner.clone()), t.setBezierParamer(this._p0, this._p1, this._p2, this._p3), t;
  },
  reverse: function() {
    var t = new cc.EaseBezierAction(this._inner.reverse());
    return t.setBezierParamer(this._p3, this._p2, this._p1, this._p0), t;
  },
  setBezierParamer: function(t, e, n, r) {
    this._p0 = t || 0, this._p1 = e || 0, this._p2 = n || 0, this._p3 = r || 0;
  }
});
cc.EaseBezierAction.create = function(t) {
  return new cc.EaseBezierAction(t);
};
cc.easeBezierAction = function(t, e, n, r) {
  return {
    easing: function(s) {
      return cc.EaseBezierAction.prototype._updateTime(t, e, n, r, s);
    },
    reverse: function() {
      return cc.easeBezierAction(r, n, e, t);
    }
  };
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
  _updateTime: function(t) {
    return Math.pow(t, 2);
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseQuadraticActionIn();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseQuadraticActionIn(this._inner.reverse());
  }
});
cc.EaseQuadraticActionIn.create = function(t) {
  return new cc.EaseQuadraticActionIn(t);
};
cc._easeQuadraticActionIn = {
  easing: cc.EaseQuadraticActionIn.prototype._updateTime,
  reverse: function() {
    return cc._easeQuadraticActionIn;
  }
};
cc.easeQuadraticActionIn = function() {
  return cc._easeQuadraticActionIn;
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    return -t * (t - 2);
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseQuadraticActionOut();
    return t.initWithAction(), t;
  },
  reverse: function() {
    return new cc.EaseQuadraticActionOut(this._inner.reverse());
  }
});
cc.EaseQuadraticActionOut.create = function(t) {
  return new cc.EaseQuadraticActionOut(t);
};
cc._easeQuadraticActionOut = {
  easing: cc.EaseQuadraticActionOut.prototype._updateTime,
  reverse: function() {
    return cc._easeQuadraticActionOut;
  }
};
cc.easeQuadraticActionOut = function() {
  return cc._easeQuadraticActionOut;
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    var e = t;
    return t *= 2, t < 1 ? e = t * t * 0.5 : (--t, e = -0.5 * (t * (t - 2) - 1)), e;
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseQuadraticActionInOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseQuadraticActionInOut(this._inner.reverse());
  }
});
cc.EaseQuadraticActionInOut.create = function(t) {
  return new cc.EaseQuadraticActionInOut(t);
};
cc._easeQuadraticActionInOut = {
  easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
  reverse: function() {
    return cc._easeQuadraticActionInOut;
  }
};
cc.easeQuadraticActionInOut = function() {
  return cc._easeQuadraticActionInOut;
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t * t * t * t;
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseQuarticActionIn();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseQuarticActionIn(this._inner.reverse());
  }
});
cc.EaseQuarticActionIn.create = function(t) {
  return new cc.EaseQuarticActionIn(t);
};
cc._easeQuarticActionIn = {
  easing: cc.EaseQuarticActionIn.prototype._updateTime,
  reverse: function() {
    return cc._easeQuarticActionIn;
  }
};
cc.easeQuarticActionIn = function() {
  return cc._easeQuarticActionIn;
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t -= 1, -(t * t * t * t - 1);
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseQuarticActionOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseQuarticActionOut(this._inner.reverse());
  }
});
cc.EaseQuarticActionOut.create = function(t) {
  return new cc.EaseQuarticActionOut(t);
};
cc._easeQuarticActionOut = {
  easing: cc.EaseQuarticActionOut.prototype._updateTime,
  reverse: function() {
    return cc._easeQuarticActionOut;
  }
};
cc.easeQuarticActionOut = function() {
  return cc._easeQuarticActionOut;
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t = t * 2, t < 1 ? 0.5 * t * t * t * t : (t -= 2, -0.5 * (t * t * t * t - 2));
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseQuarticActionInOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseQuarticActionInOut(this._inner.reverse());
  }
});
cc.EaseQuarticActionInOut.create = function(t) {
  return new cc.EaseQuarticActionInOut(t);
};
cc._easeQuarticActionInOut = {
  easing: cc.EaseQuarticActionInOut.prototype._updateTime,
  reverse: function() {
    return cc._easeQuarticActionInOut;
  }
};
cc.easeQuarticActionInOut = function() {
  return cc._easeQuarticActionInOut;
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t * t * t * t * t;
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseQuinticActionIn();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseQuinticActionIn(this._inner.reverse());
  }
});
cc.EaseQuinticActionIn.create = function(t) {
  return new cc.EaseQuinticActionIn(t);
};
cc._easeQuinticActionIn = {
  easing: cc.EaseQuinticActionIn.prototype._updateTime,
  reverse: function() {
    return cc._easeQuinticActionIn;
  }
};
cc.easeQuinticActionIn = function() {
  return cc._easeQuinticActionIn;
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t -= 1, t * t * t * t * t + 1;
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseQuinticActionOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseQuinticActionOut(this._inner.reverse());
  }
});
cc.EaseQuinticActionOut.create = function(t) {
  return new cc.EaseQuinticActionOut(t);
};
cc._easeQuinticActionOut = {
  easing: cc.EaseQuinticActionOut.prototype._updateTime,
  reverse: function() {
    return cc._easeQuinticActionOut;
  }
};
cc.easeQuinticActionOut = function() {
  return cc._easeQuinticActionOut;
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t = t * 2, t < 1 ? 0.5 * t * t * t * t * t : (t -= 2, 0.5 * (t * t * t * t * t + 2));
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseQuinticActionInOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseQuinticActionInOut(this._inner.reverse());
  }
});
cc.EaseQuinticActionInOut.create = function(t) {
  return new cc.EaseQuinticActionInOut(t);
};
cc._easeQuinticActionInOut = {
  easing: cc.EaseQuinticActionInOut.prototype._updateTime,
  reverse: function() {
    return cc._easeQuinticActionInOut;
  }
};
cc.easeQuinticActionInOut = function() {
  return cc._easeQuinticActionInOut;
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
  _updateTime: function(t) {
    return -1 * (Math.sqrt(1 - t * t) - 1);
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseCircleActionIn();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseCircleActionIn(this._inner.reverse());
  }
});
cc.EaseCircleActionIn.create = function(t) {
  return new cc.EaseCircleActionIn(t);
};
cc._easeCircleActionIn = {
  easing: cc.EaseCircleActionIn.prototype._updateTime,
  reverse: function() {
    return cc._easeCircleActionIn;
  }
};
cc.easeCircleActionIn = function() {
  return cc._easeCircleActionIn;
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t = t - 1, Math.sqrt(1 - t * t);
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseCircleActionOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseCircleActionOut(this._inner.reverse());
  }
});
cc.EaseCircleActionOut.create = function(t) {
  return new cc.EaseCircleActionOut(t);
};
cc._easeCircleActionOut = {
  easing: cc.EaseCircleActionOut.prototype._updateTime,
  reverse: function() {
    return cc._easeCircleActionOut;
  }
};
cc.easeCircleActionOut = function() {
  return cc._easeCircleActionOut;
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t = t * 2, t < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : (t -= 2, 0.5 * (Math.sqrt(1 - t * t) + 1));
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseCircleActionInOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseCircleActionInOut(this._inner.reverse());
  }
});
cc.EaseCircleActionInOut.create = function(t) {
  return new cc.EaseCircleActionInOut(t);
};
cc._easeCircleActionInOut = {
  easing: cc.EaseCircleActionInOut.prototype._updateTime,
  reverse: function() {
    return cc._easeCircleActionInOut;
  }
};
cc.easeCircleActionInOut = function() {
  return cc._easeCircleActionInOut;
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t * t * t;
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseCubicActionIn();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseCubicActionIn(this._inner.reverse());
  }
});
cc.EaseCubicActionIn.create = function(t) {
  return new cc.EaseCubicActionIn(t);
};
cc._easeCubicActionIn = {
  easing: cc.EaseCubicActionIn.prototype._updateTime,
  reverse: function() {
    return cc._easeCubicActionIn;
  }
};
cc.easeCubicActionIn = function() {
  return cc._easeCubicActionIn;
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t -= 1, t * t * t + 1;
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseCubicActionOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseCubicActionOut(this._inner.reverse());
  }
});
cc.EaseCubicActionOut.create = function(t) {
  return new cc.EaseCubicActionOut(t);
};
cc._easeCubicActionOut = {
  easing: cc.EaseCubicActionOut.prototype._updateTime,
  reverse: function() {
    return cc._easeCubicActionOut;
  }
};
cc.easeCubicActionOut = function() {
  return cc._easeCubicActionOut;
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
  _updateTime: function(t) {
    return t = t * 2, t < 1 ? 0.5 * t * t * t : (t -= 2, 0.5 * (t * t * t + 2));
  },
  update: function(t) {
    this._inner.update(this._updateTime(t));
  },
  clone: function() {
    var t = new cc.EaseCubicActionInOut();
    return t.initWithAction(this._inner.clone()), t;
  },
  reverse: function() {
    return new cc.EaseCubicActionInOut(this._inner.reverse());
  }
});
cc.EaseCubicActionInOut.create = function(t) {
  return new cc.EaseCubicActionInOut(t);
};
cc._easeCubicActionInOut = {
  easing: cc.EaseCubicActionInOut.prototype._updateTime,
  reverse: function() {
    return cc._easeCubicActionInOut;
  }
};
cc.easeCubicActionInOut = function() {
  return cc._easeCubicActionInOut;
};
cc.cardinalSplineAt = function(t, e, n, r, s, o) {
  var a = o * o, c = a * o, l = (1 - s) / 2, h = l * (-c + 2 * a - o), u = l * (-c + a) + (2 * c - 3 * a + 1), _ = l * (c - 2 * a + o) + (-2 * c + 3 * a), d = l * (c - a), f = t.x * h + e.x * u + n.x * _ + r.x * d, C = t.y * h + e.y * u + n.y * _ + r.y * d;
  return cc.p(f, C);
};
cc.reverseControlPoints = function(t) {
  for (var e = [], n = t.length - 1; n >= 0; n--)
    e.push(cc.p(t[n].x, t[n].y));
  return e;
};
cc.cloneControlPoints = function(t) {
  for (var e = [], n = 0; n < t.length; n++)
    e.push(cc.p(t[n].x, t[n].y));
  return e;
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function(t, e) {
  var n = Math.min(t.length - 1, Math.max(e, 0));
  return t[n];
};
cc.reverseControlPointsInline = function(t) {
  for (var e = t.length, n = 0 | e / 2, r = 0; r < n; ++r) {
    var s = t[r];
    t[r] = t[e - r - 1], t[e - r - 1] = s;
  }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
  _points: null,
  _deltaT: 0,
  _tension: 0,
  _previousPosition: null,
  _accumulatedDiff: null,
  ctor: function(t, e, n) {
    cc.ActionInterval.prototype.ctor.call(this), this._points = [], n !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    if (!e || e.length === 0)
      throw new Error("Invalid configuration. It must at least have one control point");
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this.setPoints(e), this._tension = n, !0) : !1;
  },
  clone: function() {
    var t = new cc.CardinalSplineTo();
    return t.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._deltaT = 1 / (this._points.length - 1), this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY()), this._accumulatedDiff = cc.p(0, 0);
  },
  update: function(t) {
    t = (this || window)._computeEaseTime(t);
    var e, n, r = (this || window)._points;
    if (t === 1)
      e = r.length - 1, n = 1;
    else {
      var s = (this || window)._deltaT;
      e = 0 | t / s, n = (t - s * e) / s;
    }
    var o = cc.cardinalSplineAt(
      cc.getControlPointAt(r, e - 1),
      cc.getControlPointAt(r, e - 0),
      cc.getControlPointAt(r, e + 1),
      cc.getControlPointAt(r, e + 2),
      this._tension,
      n
    );
    if (cc.ENABLE_STACKABLE_ACTIONS) {
      var a, c;
      if (a = (this || window).target.getPositionX() - this._previousPosition.x, c = (this || window).target.getPositionY() - this._previousPosition.y, a !== 0 || c !== 0) {
        var l = (this || window)._accumulatedDiff;
        a = l.x + a, c = l.y + c, l.x = a, l.y = c, o.x += a, o.y += c;
      }
    }
    this.updatePosition(o);
  },
  reverse: function() {
    var t = cc.reverseControlPoints(this._points);
    return cc.cardinalSplineTo(this._duration, t, this._tension);
  },
  updatePosition: function(t) {
    this.target.setPosition(t), this._previousPosition = t;
  },
  getPoints: function() {
    return this._points;
  },
  setPoints: function(t) {
    this._points = t;
  }
});
cc.cardinalSplineTo = function(t, e, n) {
  return new cc.CardinalSplineTo(t, e, n);
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
  _startPosition: null,
  ctor: function(t, e, n) {
    cc.CardinalSplineTo.prototype.ctor.call(this), this._startPosition = cc.p(0, 0), n !== void 0 && this.initWithDuration(t, e, n);
  },
  startWithTarget: function(t) {
    cc.CardinalSplineTo.prototype.startWithTarget.call(this, t), this._startPosition.x = t.getPositionX(), this._startPosition.y = t.getPositionY();
  },
  reverse: function() {
    for (var t = (this || window)._points.slice(), e, n = t[0], r = 1; r < t.length; ++r)
      e = t[r], t[r] = cc.pSub(e, n), n = e;
    var s = cc.reverseControlPoints(t);
    n = s[s.length - 1], s.pop(), n.x = -n.x, n.y = -n.y, s.unshift(n);
    for (var r = 1; r < s.length; ++r)
      e = s[r], e.x = -e.x, e.y = -e.y, e.x += n.x, e.y += n.y, s[r] = e, n = e;
    return cc.cardinalSplineBy(this._duration, s, this._tension);
  },
  updatePosition: function(t) {
    var e = (this || window)._startPosition, n = t.x + e.x, r = t.y + e.y;
    this._previousPosition.x = n, this._previousPosition.y = r, this.target.setPosition(n, r);
  },
  clone: function() {
    var t = new cc.CardinalSplineBy();
    return t.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension), t;
  }
});
cc.cardinalSplineBy = function(t, e, n) {
  return new cc.CardinalSplineBy(t, e, n);
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
  ctor: function(t, e) {
    e && this.initWithDuration(t, e);
  },
  initWithDuration: function(t, e) {
    return cc.CardinalSplineTo.prototype.initWithDuration.call(this, t, e, 0.5);
  },
  clone: function() {
    var t = new cc.CatmullRomTo();
    return t.initWithDuration(this._duration, cc.copyControlPoints(this._points)), t;
  }
});
cc.catmullRomTo = function(t, e) {
  return new cc.CatmullRomTo(t, e);
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
  ctor: function(t, e) {
    cc.CardinalSplineBy.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  initWithDuration: function(t, e) {
    return cc.CardinalSplineTo.prototype.initWithDuration.call(this, t, e, 0.5);
  },
  clone: function() {
    var t = new cc.CatmullRomBy();
    return t.initWithDuration(this._duration, cc.copyControlPoints(this._points)), t;
  }
});
cc.catmullRomBy = function(t, e) {
  return new cc.CatmullRomBy(t, e);
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
  updateTweenAction: function(t, e) {
  }
});
cc.ActionTween = cc.ActionInterval.extend({
  key: "",
  from: 0,
  to: 0,
  delta: 0,
  ctor: function(t, e, n, r) {
    cc.ActionInterval.prototype.ctor.call(this), this.key = "", r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  initWithDuration: function(t, e, n, r) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this.key = e, this.to = r, this.from = n, !0) : !1;
  },
  startWithTarget: function(t) {
    if (!t || !t.updateTweenAction)
      throw new Error("cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function");
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this.delta = (this || window).to - this.from;
  },
  update: function(t) {
    this.target.updateTweenAction(this.to - this.delta * (1 - t), this.key);
  },
  reverse: function() {
    return new cc.ActionTween(this.duration, this.key, this.to, this.from);
  },
  clone: function() {
    var t = new cc.ActionTween();
    return t.initWithDuration(this._duration, this.key, this.from, this.to), t;
  }
});
cc.actionTween = function(t, e, n, r) {
  return new cc.ActionTween(t, e, n, r);
};
cc.ActionTween.create = cc.actionTween;
(function() {
  var t = cc.sys;
  t.browserVersion;
  var e = !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext), n = { ONLY_ONE: !1, WEB_AUDIO: e, DELAY_CREATE_CTX: !1, ONE_SOURCE: !1 };
  t.browserType === t.BROWSER_TYPE_FIREFOX && (n.DELAY_CREATE_CTX = !0, n.USE_LOADER_EVENT = "canplay"), t.os === t.OS_IOS && (n.USE_LOADER_EVENT = "loadedmetadata"), t.os === t.OS_ANDROID && t.browserType === t.BROWSER_TYPE_UC && (n.ONE_SOURCE = !0), window.__audioSupport = n;
})();
cc.Audio = cc.Class.extend({
  src: null,
  _element: null,
  _AUDIO_TYPE: "AUDIO",
  ctor: function(t) {
    this.src = t;
  },
  setBuffer: function(t) {
    this._AUDIO_TYPE = "WEBAUDIO", this._element = new cc.Audio.WebAudio(t);
  },
  setElement: function(t) {
    this._AUDIO_TYPE = "AUDIO", this._element = t, t.addEventListener("ended", function() {
      t.loop || (t.paused = !0);
    });
  },
  play: function(t, e) {
    this._element && (this._element.loop = e, this._element.play(), this._AUDIO_TYPE === "AUDIO" && this._element.paused && (this.stop(), cc.Audio.touchPlayList.push({ loop: e, offset: t, audio: this._element })), cc.Audio.bindTouch === !1 && (cc.Audio.bindTouch = !0, cc.game.canvas.addEventListener("touchstart", cc.Audio.touchStart)));
  },
  getPlaying: function() {
    return this._element ? !this._element.paused : !0;
  },
  stop: function() {
    if (this._element) {
      this._element.pause();
      try {
        this._element.currentTime = 0;
      } catch (t) {
      }
    }
  },
  pause: function() {
    this._element && this._element.pause();
  },
  resume: function() {
    this._element && this._element.play();
  },
  setVolume: function(t) {
    this._element && (this._element.volume = t);
  },
  getVolume: function() {
    if (this._element)
      return this._element.volume;
  },
  cloneNode: function() {
    var t = new cc.Audio(this.src);
    if (this._AUDIO_TYPE === "AUDIO") {
      for (var e = document.createElement("audio"), n = e.getElementsByTagName("source"), r = 0; r < n.length; r++)
        e.appendChild(n[r]);
      e.src = (this || window).src, t.setElement(e);
    } else
      t.setBuffer(this._element.buffer);
    return t;
  }
});
cc.Audio.touchPlayList = [];
cc.Audio.bindTouch = !1;
cc.Audio.touchStart = function() {
  for (var t = cc.Audio.touchPlayList, e = null; e = t.pop(); )
    e.audio.loop = !!e.loop, e.audio.play(e.offset);
};
cc.Audio.WebAudio = function(t) {
  this.buffer = t, this.context = cc.Audio._context;
  var e = (this || window).context.createGain();
  e.gain.value = 1, e.connect(this.context.destination), this._volume = e, this._loop = !1, this._startTime = -1, this._currentSource = null, this.playedLength = 0, this._currextTimer = null;
};
cc.Audio.WebAudio.prototype = {
  constructor: cc.Audio.WebAudio,
  get paused() {
    return this._currentSource && this._currentSource.loop ? !1 : this._startTime === -1 ? !0 : this.context.currentTime - this._startTime > this.buffer.duration;
  },
  set paused(t) {
  },
  get loop() {
    return this._loop;
  },
  set loop(t) {
    return this._loop = t;
  },
  get volume() {
    return this._volume.gain.value;
  },
  set volume(t) {
    return this._volume.gain.value = t;
  },
  get currentTime() {
    return this.playedLength;
  },
  set currentTime(t) {
    return this.playedLength = t;
  },
  play: function(t) {
    this._currentSource && !this.paused && (this._currentSource.stop(0), this.playedLength = 0);
    var e = (this || window).context.createBufferSource();
    e.buffer = (this || window).buffer, e.connect(this._volume), e.loop = (this || window)._loop, this._startTime = (this || window).context.currentTime, t = t || this.playedLength;
    var n = (this || window).buffer.duration;
    if (this._loop ? e.start ? e.start(0) : e.notoGrainOn ? e.noteGrainOn(0) : e.noteOn(0) : e.start ? e.start(0, t, n - t) : e.notoGrainOn ? e.noteGrainOn(0, t, n - t) : e.noteOn(0, t, n - t), this._currentSource = e, this.context.currentTime === 0) {
      var r = (this || window);
      clearTimeout(this._currextTimer), this._currextTimer = setTimeout(function() {
        r.context.currentTime === 0 && cc.Audio.touchPlayList.push({
          offset: t,
          audio: r
        });
      }, 10);
    }
  },
  pause: function() {
    this.playedLength = (this || window).context.currentTime - this._startTime, this.playedLength %= (this || window).buffer.duration;
    var t = (this || window)._currentSource;
    this._currentSource = null, this._startTime = -1, t && t.stop(0);
  }
};
(function(t) {
  var e = t.WEB_AUDIO, n = t.ONLY_ONE, r = [];
  (function() {
    var a = document.createElement("audio");
    if (a.canPlayType) {
      var c = a.canPlayType('audio/ogg; codecs="vorbis"');
      c && c !== "" && r.push(".ogg");
      var l = a.canPlayType("audio/mpeg");
      l && l !== "" && r.push(".mp3");
      var h = a.canPlayType('audio/wav; codecs="1"');
      h && h !== "" && r.push(".wav");
      var u = a.canPlayType("audio/mp4");
      u && u !== "" && r.push(".mp4");
      var _ = a.canPlayType("audio/x-m4a");
      _ && _ !== "" && r.push(".m4a");
    }
  })();
  try {
    if (e) {
      var s = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
      cc.Audio._context = s, t.DELAY_CREATE_CTX && setTimeout(function() {
        s = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)(), cc.Audio._context = s;
      }, 0);
    }
  } catch (a) {
    e = !1, cc.log("browser don't support web audio");
  }
  var o = {
    cache: {},
    useWebAudio: !1,
    loadBuffer: function(a, c) {
      if (e) {
        var l = new XMLHttpRequest();
        l.open("GET", a, !0), l.responseType = "arraybuffer", l.onload = function() {
          s.decodeAudioData(l.response, function(h) {
            c(null, h);
          }, function() {
            c("decode error - " + a);
          });
        }, l.onerror = function() {
          c("request error - " + a);
        }, l.send();
      }
    },
    load: function(a, c, l, h) {
      if (r.length === 0)
        return h("can not support audio!");
      var u = cc.loader.getRes(c);
      if (u)
        return h(null, u);
      var _;
      cc.loader.audioPath && (a = cc.path.join(cc.loader.audioPath, a));
      var d = cc.path.extname(a), f = [d];
      for (_ = 0; _ < r.length; _++)
        d !== r[_] && f.push(r[_]);
      return u = new cc.Audio(a), cc.loader.cache[c] = u, this.loadAudioFromExtList(a, f, u, h), u;
    },
    loadAudioFromExtList: function(a, c, l, h) {
      if (c.length === 0) {
        var u = "can not found the resource of audio! Last match url is : ";
        return u += a.replace(/\.(.*)?$/, "("), r.forEach(function(A) {
          u += A + "|";
        }), u = u.replace(/\|$/, ")"), h({ status: 520, errorMessage: u }, null);
      }
      if (e && this.useWebAudio) {
        this.loadBuffer(a, function(A, D) {
          A && cc.log(A), D && l.setBuffer(D), h(null, l);
        });
        return;
      }
      for (var _ = t.ONE_SOURCE ? 1 : c.length, d = document.createElement("audio"), f = 0; f < _; f++) {
        var C = document.createElement("source");
        C.src = cc.path.changeExtname(a, c[f]), d.appendChild(C);
      }
      l.setElement(d);
      var m = setTimeout(function() {
        d.readyState === 0 ? y() : g();
      }, 8e3), g = /* @__PURE__ */ H(function() {
        d.removeEventListener("canplaythrough", g, !1), d.removeEventListener("error", y, !1), d.removeEventListener("emptied", g, !1), t.USE_LOADER_EVENT && d.removeEventListener(t.USE_LOADER_EVENT, g, !1), clearTimeout(m), h(null, l);
      }, "success"), y = /* @__PURE__ */ H(function() {
        cc.log("load audio failure - " + a), g();
      }, "failure");
      d.addEventListener("canplaythrough", g, !1), d.addEventListener("error", y, !1), t.USE_LOADER_EVENT && d.addEventListener(t.USE_LOADER_EVENT, g, !1);
    }
  };
  cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], o), cc.audioEngine = {
    _currMusic: null,
    _musicVolume: 1,
    features: t,
    willPlayMusic: function() {
      return !1;
    },
    playMusic: function(a, c) {
      var l = (this || window)._currMusic;
      l && l.getPlaying() && l.stop();
      var h = cc.loader.getRes(a);
      h || (cc.loader.load(a), h = cc.loader.getRes(a)), h.setVolume(this._musicVolume), h.play(0, c || !1), this._currMusic = h;
    },
    stopMusic: function(a) {
      var c = (this || window)._currMusic;
      c && (c.stop(), this._currMusic = null, a && cc.loader.release(c.src));
    },
    pauseMusic: function() {
      var a = (this || window)._currMusic;
      a && a.pause();
    },
    resumeMusic: function() {
      var a = (this || window)._currMusic;
      a && a.resume();
    },
    rewindMusic: function() {
      var a = (this || window)._currMusic;
      a && (a.stop(), a.play());
    },
    getMusicVolume: function() {
      return this._musicVolume;
    },
    setMusicVolume: function(a) {
      a = a - 0, isNaN(a) && (a = 1), a > 1 && (a = 1), a < 0 && (a = 0), this._musicVolume = a;
      var c = (this || window)._currMusic;
      c && c.setVolume(a);
    },
    isMusicPlaying: function() {
      var a = (this || window)._currMusic;
      return a ? a.getPlaying() : !1;
    },
    _audioPool: {},
    _maxAudioInstance: 10,
    _effectVolume: 1,
    playEffect: function(a, c) {
      if (n && this._currMusic && this._currMusic.getPlaying())
        return cc.log("Browser is only allowed to play one audio"), null;
      var l = (this || window)._audioPool[a];
      l || (l = (this || window)._audioPool[a] = []);
      var h;
      for (h = 0; h < l.length && l[h].getPlaying(); h++)
        ;
      if (!e && h > this._maxAudioInstance) {
        var u = l.shift();
        u.stop(), l.push(u), h = l.length - 1;
      }
      var _;
      if (l[h])
        return _ = l[h], _.setVolume(this._effectVolume), _.play(0, c || !1), _;
      if (_ = cc.loader.getRes(a), _ && e && _._AUDIO_TYPE === "AUDIO" && (cc.loader.release(a), _ = null), _)
        if (e && _._AUDIO_TYPE === "AUDIO")
          o.loadBuffer(a, function(d, f) {
            _.setBuffer(f), _.setVolume(cc.audioEngine._effectVolume), _.getPlaying() || _.play(0, c || !1);
          });
        else
          return _ = _.cloneNode(), _.setVolume(this._effectVolume), _.play(0, c || !1), l.push(_), _;
      return o.useWebAudio = !0, cc.loader.load(a, function(d) {
        d = cc.loader.getRes(a), d = d.cloneNode(), d.setVolume(cc.audioEngine._effectVolume), d.play(0, c || !1), l.push(d);
      }), o.useWebAudio = !1, _;
    },
    setEffectsVolume: function(a) {
      a = a - 0, isNaN(a) && (a = 1), a > 1 && (a = 1), a < 0 && (a = 0), this._effectVolume = a;
      var c = (this || window)._audioPool;
      for (var l in c) {
        var h = c[l];
        if (Array.isArray(h))
          for (var u = 0; u < h.length; u++)
            h[u].setVolume(a);
      }
    },
    getEffectsVolume: function() {
      return this._effectVolume;
    },
    pauseEffect: function(a) {
      a && a.pause();
    },
    pauseAllEffects: function() {
      var a = (this || window)._audioPool;
      for (var c in a)
        for (var l = a[c], h = 0; h < a[c].length; h++)
          l[h].getPlaying() && l[h].pause();
    },
    resumeEffect: function(a) {
      a && a.resume();
    },
    resumeAllEffects: function() {
      var a = (this || window)._audioPool;
      for (var c in a)
        for (var l = a[c], h = 0; h < a[c].length; h++)
          l[h].resume();
    },
    stopEffect: function(a) {
      a && a.stop();
    },
    stopAllEffects: function() {
      var a = (this || window)._audioPool;
      for (var c in a) {
        for (var l = a[c], h = 0; h < l.length; h++)
          l[h].stop();
        l.length = 0;
      }
    },
    unloadEffect: function(a) {
      if (a) {
        cc.loader.release(a);
        var c = (this || window)._audioPool[a];
        c && (c.length = 0), delete this._audioPool[a];
      }
    },
    end: function() {
      this.stopMusic(), this.stopAllEffects();
    },
    _pauseCache: [],
    _pausePlaying: function() {
      var a = (this || window)._currMusic;
      a && a.getPlaying() && (a.pause(), this._pauseCache.push(a));
      var c = (this || window)._audioPool;
      for (var l in c)
        for (var h = c[l], u = 0; u < c[l].length; u++)
          h[u].getPlaying() && (h[u].pause(), this._pauseCache.push(h[u]));
    },
    _resumePlaying: function() {
      for (var a = (this || window)._pauseCache, c = 0; c < a.length; c++)
        a[c].resume();
      a.length = 0;
    }
  };
})(window.__audioSupport);
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.MenuItem = cc.Node.extend({
  _enabled: !1,
  _target: null,
  _callback: null,
  _isSelected: !1,
  _className: "MenuItem",
  ctor: function(t, e) {
    var n = cc.Node.prototype;
    n.ctor.call(this), this._target = null, this._callback = null, this._isSelected = !1, this._enabled = !1, n.setAnchorPoint.call(this, 0.5, 0.5), this._target = e || null, this._callback = t || null, this._callback && (this._enabled = !0);
  },
  isSelected: function() {
    return this._isSelected;
  },
  setOpacityModifyRGB: function(t) {
  },
  isOpacityModifyRGB: function() {
    return !1;
  },
  setTarget: function(t, e) {
    this._target = e, this._callback = t;
  },
  isEnabled: function() {
    return this._enabled;
  },
  setEnabled: function(t) {
    this._enabled = t;
  },
  initWithCallback: function(t, e) {
    return this.anchorX = 0.5, this.anchorY = 0.5, this._target = e, this._callback = t, this._enabled = !0, this._isSelected = !1, !0;
  },
  rect: function() {
    var t = (this || window)._position, e = (this || window)._contentSize, n = (this || window)._anchorPoint;
    return cc.rect(
      t.x - e.width * n.x,
      t.y - e.height * n.y,
      e.width,
      e.height
    );
  },
  selected: function() {
    this._isSelected = !0;
  },
  unselected: function() {
    this._isSelected = !1;
  },
  setCallback: function(t, e) {
    this._target = e, this._callback = t;
  },
  activate: function() {
    if (this._enabled) {
      var t = (this || window)._target, e = (this || window)._callback;
      if (!e)
        return;
      t && cc.isString(e) ? t[e](this) : t && cc.isFunction(e) ? e.call(t, this) : e(this);
    }
  }
});
var _p = cc.MenuItem.prototype;
_p.enabled;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function(t, e) {
  return new cc.MenuItem(t, e);
};
cc.MenuItemLabel = cc.MenuItem.extend({
  _disabledColor: null,
  _label: null,
  _originalScale: 0,
  _colorBackup: null,
  ctor: function(t, e, n) {
    cc.MenuItem.prototype.ctor.call(this, e, n), this._disabledColor = null, this._label = null, this._colorBackup = null, t && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(t), t.textureLoaded && !t.textureLoaded() && t.addEventListener("load", function(r) {
      this.width = r.width, this.height = r.height, this.parent instanceof cc.Menu && this.parent.updateAlign();
    }, this), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0));
  },
  getDisabledColor: function() {
    return this._disabledColor;
  },
  setDisabledColor: function(t) {
    this._disabledColor = t;
  },
  getLabel: function() {
    return this._label;
  },
  setLabel: function(t) {
    t && (this.addChild(t), t.anchorX = 0, t.anchorY = 0, this.width = t.width, this.height = t.height, t.setCascadeColorEnabled(!0)), this._label && this.removeChild(this._label, !0), this._label = t;
  },
  setEnabled: function(t) {
    this._enabled !== t && (t ? this.setColor(this._colorBackup) : (this._colorBackup = (this || window).color, this.setColor(this._disabledColor))), cc.MenuItem.prototype.setEnabled.call(this, t);
  },
  initWithLabel: function(t, e, n) {
    return this.initWithCallback(e, n), this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(t), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), !0;
  },
  setString: function(t) {
    this._label.string = t, this.width = (this || window)._label.width, this.height = (this || window)._label.height;
  },
  getString: function() {
    return this._label.string;
  },
  activate: function() {
    this._enabled && (this.stopAllActions(), this.scale = (this || window)._originalScale, cc.MenuItem.prototype.activate.call(this));
  },
  selected: function() {
    if (this._enabled) {
      cc.MenuItem.prototype.selected.call(this);
      var t = (this || window).getActionByTag(cc.ZOOM_ACTION_TAG);
      t ? this.stopAction(t) : this._originalScale = (this || window).scale;
      var e = cc.scaleTo(0.1, this._originalScale * 1.2);
      e.setTag(cc.ZOOM_ACTION_TAG), this.runAction(e);
    }
  },
  unselected: function() {
    if (this._enabled) {
      cc.MenuItem.prototype.unselected.call(this), this.stopActionByTag(cc.ZOOM_ACTION_TAG);
      var t = cc.scaleTo(0.1, this._originalScale);
      t.setTag(cc.ZOOM_ACTION_TAG), this.runAction(t);
    }
  }
});
var _p = cc.MenuItemLabel.prototype;
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p.disabledColor;
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
_p.label;
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function(t, e, n) {
  return new cc.MenuItemLabel(t, e, n);
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
  ctor: function(t, e, n, r, s, o, a) {
    var c;
    t && t.length > 0 && (c = new cc.LabelAtlas(t, e, n, r, s)), cc.MenuItemLabel.prototype.ctor.call(this, c, o, a);
  },
  initWithString: function(t, e, n, r, s, o, a) {
    if (!t || t.length === 0)
      throw new Error("cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0");
    var c = new cc.LabelAtlas();
    return c.initWithString(t, e, n, r, s), this.initWithLabel(c, o, a), !0;
  }
});
cc.MenuItemAtlasFont.create = function(t, e, n, r, s, o, a) {
  return new cc.MenuItemAtlasFont(t, e, n, r, s, o, a);
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
  _fontSize: null,
  _fontName: null,
  ctor: function(t, e, n) {
    var r;
    t && t.length > 0 ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, r = new cc.LabelTTF(t, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = ""), cc.MenuItemLabel.prototype.ctor.call(this, r, e, n);
  },
  initWithString: function(t, e, n) {
    if (!t || t.length === 0)
      throw new Error("Value should be non-null and its length should be greater than 0");
    this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize;
    var r = new cc.LabelTTF(t, this._fontName, this._fontSize);
    return this.initWithLabel(r, e, n), !0;
  },
  setFontSize: function(t) {
    this._fontSize = t, this._recreateLabel();
  },
  getFontSize: function() {
    return this._fontSize;
  },
  setFontName: function(t) {
    this._fontName = t, this._recreateLabel();
  },
  getFontName: function() {
    return this._fontName;
  },
  _recreateLabel: function() {
    var t = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
    this.setLabel(t);
  }
});
cc.MenuItemFont.setFontSize = function(t) {
  cc._globalFontSize = t;
};
cc.MenuItemFont.fontSize = function() {
  return cc._globalFontSize;
};
cc.MenuItemFont.setFontName = function(t) {
  cc._globalFontNameRelease && (cc._globalFontName = ""), cc._globalFontName = t, cc._globalFontNameRelease = !0;
};
var _p = cc.MenuItemFont.prototype;
_p.fontSize;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
_p.fontName;
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function() {
  return cc._globalFontName;
};
cc.MenuItemFont.create = function(t, e, n) {
  return new cc.MenuItemFont(t, e, n);
};
cc.MenuItemSprite = cc.MenuItem.extend({
  _normalImage: null,
  _selectedImage: null,
  _disabledImage: null,
  ctor: function(t, e, n, r, s) {
    if (cc.MenuItem.prototype.ctor.call(this), this._normalImage = null, this._selectedImage = null, this._disabledImage = null, this._loader = new cc.Sprite.LoadManager(), t !== void 0) {
      e = e || null;
      var o, a, c;
      return s !== void 0 ? (o = n, c = r, a = s) : r !== void 0 && cc.isFunction(r) ? (o = n, c = r) : r !== void 0 && cc.isFunction(n) ? (a = r, c = n, o = null) : n === void 0 && (o = null), this._loader.clear(), t.textureLoaded && !t.textureLoaded() ? (this._loader.once(t, function() {
        this.initWithNormalSprite(t, e, o, c, a);
      }, this), !1) : (this.initWithNormalSprite(t, e, o, c, a), !0);
    }
  },
  getNormalImage: function() {
    return this._normalImage;
  },
  setNormalImage: function(t) {
    this._normalImage !== t && (t && (this.addChild(t, 0, cc.NORMAL_TAG), t.anchorX = 0, t.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = t, this._normalImage && (this.width = (this || window)._normalImage.width, this.height = (this || window)._normalImage.height, this._updateImagesVisibility(), t.textureLoaded && !t.textureLoaded() && t.addEventListener("load", function(e) {
      this.width = e.width, this.height = e.height, this.parent instanceof cc.Menu && this.parent.updateAlign();
    }, this)));
  },
  getSelectedImage: function() {
    return this._selectedImage;
  },
  setSelectedImage: function(t) {
    this._selectedImage !== t && (t && (this.addChild(t, 0, cc.SELECTED_TAG), t.anchorX = 0, t.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = t, this._updateImagesVisibility());
  },
  getDisabledImage: function() {
    return this._disabledImage;
  },
  setDisabledImage: function(t) {
    this._disabledImage !== t && (t && (this.addChild(t, 0, cc.DISABLE_TAG), t.anchorX = 0, t.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = t, this._updateImagesVisibility());
  },
  initWithNormalSprite: function(t, e, n, r, s) {
    if (this._loader.clear(), t.textureLoaded && !t.textureLoaded())
      return this._loader.once(t, function() {
        this.initWithNormalSprite(t, e, n, r, s);
      }, this), !1;
    this.initWithCallback(r, s), this.setNormalImage(t), this.setSelectedImage(e), this.setDisabledImage(n);
    var o = (this || window)._normalImage;
    return o && (this.width = o.width, this.height = o.height), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), !0;
  },
  selected: function() {
    cc.MenuItem.prototype.selected.call(this), this._normalImage && (this._disabledImage && (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0);
  },
  unselected: function() {
    cc.MenuItem.prototype.unselected.call(this), this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1));
  },
  setEnabled: function(t) {
    this._enabled !== t && (cc.MenuItem.prototype.setEnabled.call(this, t), this._updateImagesVisibility());
  },
  _updateImagesVisibility: function() {
    var t = (this || window)._normalImage, e = (this || window)._selectedImage, n = (this || window)._disabledImage;
    this._enabled ? (t && (t.visible = !0), e && (e.visible = !1), n && (n.visible = !1)) : n ? (t && (t.visible = !1), e && (e.visible = !1), n && (n.visible = !0)) : (t && (t.visible = !0), e && (e.visible = !1));
  }
});
var _p = cc.MenuItemSprite.prototype;
_p.normalImage;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
_p.selectedImage;
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
_p.disabledImage;
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function(t, e, n, r, s) {
  return new cc.MenuItemSprite(t, e, n, r, s || void 0);
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
  ctor: function(t, e, n, r, s) {
    var o = null, a = null, c = null, l = null, h = null;
    t == null ? cc.MenuItemSprite.prototype.ctor.call(this) : (o = new cc.Sprite(t), e && (a = new cc.Sprite(e)), r === void 0 ? l = n : s === void 0 ? (l = n, h = r) : s && (c = new cc.Sprite(n), l = r, h = s), cc.MenuItemSprite.prototype.ctor.call(this, o, a, c, l, h));
  },
  setNormalSpriteFrame: function(t) {
    this.setNormalImage(new cc.Sprite(t));
  },
  setSelectedSpriteFrame: function(t) {
    this.setSelectedImage(new cc.Sprite(t));
  },
  setDisabledSpriteFrame: function(t) {
    this.setDisabledImage(new cc.Sprite(t));
  },
  initWithNormalImage: function(t, e, n, r, s) {
    var o = null, a = null, c = null;
    return t && (o = new cc.Sprite(t)), e && (a = new cc.Sprite(e)), n && (c = new cc.Sprite(n)), this.initWithNormalSprite(o, a, c, r, s);
  }
});
cc.MenuItemImage.create = function(t, e, n, r, s) {
  return new cc.MenuItemImage(t, e, n, r, s);
};
cc.MenuItemToggle = cc.MenuItem.extend({
  subItems: null,
  _selectedIndex: 0,
  _opacity: null,
  _color: null,
  ctor: function() {
    cc.MenuItem.prototype.ctor.call(this), this._selectedIndex = 0, this.subItems = [], this._opacity = 0, this._color = cc.color.WHITE, arguments.length > 0 && this.initWithItems(Array.prototype.slice.apply(arguments));
  },
  getOpacity: function() {
    return this._opacity;
  },
  setOpacity: function(t) {
    if (this._opacity = t, this.subItems && this.subItems.length > 0)
      for (var e = 0; e < this.subItems.length; e++)
        this.subItems[e].opacity = t;
    this._color.a = t;
  },
  getColor: function() {
    var t = (this || window)._color;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  setColor: function(t) {
    var e = (this || window)._color;
    if (e.r = t.r, e.g = t.g, e.b = t.b, this.subItems && this.subItems.length > 0)
      for (var n = 0; n < this.subItems.length; n++)
        this.subItems[n].setColor(t);
    t.a !== void 0 && !t.a_undefined && this.setOpacity(t.a);
  },
  getSelectedIndex: function() {
    return this._selectedIndex;
  },
  setSelectedIndex: function(t) {
    if (t !== (this || window)._selectedIndex) {
      this._selectedIndex = t;
      var e = (this || window).getChildByTag(cc.CURRENT_ITEM);
      e && e.removeFromParent(!1);
      var n = (this || window).subItems[this._selectedIndex];
      this.addChild(n, 0, cc.CURRENT_ITEM);
      var r = n.width, s = n.height;
      this.width = r, this.height = s, n.setPosition(r / 2, s / 2);
    }
  },
  getSubItems: function() {
    return this.subItems;
  },
  setSubItems: function(t) {
    this.subItems = t;
  },
  initWithItems: function(t) {
    var e = t.length;
    cc.isFunction(t[t.length - 2]) ? (this.initWithCallback(t[t.length - 2], t[t.length - 1]), e = e - 2) : cc.isFunction(t[t.length - 1]) ? (this.initWithCallback(t[t.length - 1], null), e = e - 1) : this.initWithCallback(null, null);
    var n = (this || window).subItems;
    n.length = 0;
    for (var r = 0; r < e; r++)
      t[r] && n.push(t[r]);
    return this._selectedIndex = cc.UINT_MAX, this.setSelectedIndex(0), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), !0;
  },
  addSubItem: function(t) {
    this.subItems.push(t);
  },
  activate: function() {
    if (this._enabled) {
      var t = (this._selectedIndex + 1) % this.subItems.length;
      this.setSelectedIndex(t);
    }
    cc.MenuItem.prototype.activate.call(this);
  },
  selected: function() {
    cc.MenuItem.prototype.selected.call(this), this.subItems[this._selectedIndex].selected();
  },
  unselected: function() {
    cc.MenuItem.prototype.unselected.call(this), this.subItems[this._selectedIndex].unselected();
  },
  setEnabled: function(t) {
    if (this._enabled !== t) {
      cc.MenuItem.prototype.setEnabled.call(this, t);
      var e = (this || window).subItems;
      if (e && e.length > 0)
        for (var n = 0; n < e.length; n++)
          e[n].enabled = t;
    }
  },
  selectedItem: function() {
    return this.subItems[this._selectedIndex];
  },
  getSelectedItem: function() {
    return this.subItems[this._selectedIndex];
  },
  onEnter: function() {
    cc.Node.prototype.onEnter.call(this), this.setSelectedIndex(this._selectedIndex);
  }
});
var _p = cc.MenuItemToggle.prototype;
_p.selectedIndex;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function() {
  arguments.length > 0 && arguments[arguments.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
  var t = new cc.MenuItemToggle();
  return t.initWithItems(Array.prototype.slice.apply(arguments)), t;
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
  enabled: !1,
  _selectedItem: null,
  _state: -1,
  _touchListener: null,
  _className: "Menu",
  ctor: function(t) {
    cc.Layer.prototype.ctor.call(this), this._color = cc.color.WHITE, this.enabled = !1, this._opacity = 255, this._selectedItem = null, this._state = -1, this._touchListener = cc.EventListener.create({
      event: cc.EventListener.TOUCH_ONE_BY_ONE,
      swallowTouches: !0,
      onTouchBegan: this._onTouchBegan,
      onTouchMoved: this._onTouchMoved,
      onTouchEnded: this._onTouchEnded,
      onTouchCancelled: this._onTouchCancelled
    }), arguments.length > 0 && arguments[arguments.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
    var e = arguments.length, n;
    if (e === 0)
      n = [];
    else if (e === 1)
      t instanceof Array ? n = t : n = [t];
    else if (e > 1) {
      n = [];
      for (var r = 0; r < e; r++)
        arguments[r] && n.push(arguments[r]);
    }
    this.initWithArray(n);
  },
  onEnter: function() {
    var t = (this || window)._touchListener;
    t._isRegistered() || cc.eventManager.addListener(t, this), cc.Node.prototype.onEnter.call(this);
  },
  isEnabled: function() {
    return this.enabled;
  },
  setEnabled: function(t) {
    this.enabled = t;
  },
  initWithItems: function(t) {
    var e = [];
    if (t)
      for (var n = 0; n < t.length; n++)
        t[n] && e.push(t[n]);
    return this.initWithArray(e);
  },
  initWithArray: function(t) {
    if (cc.Layer.prototype.init.call(this)) {
      this.enabled = !0;
      var e = cc.winSize;
      if (this.setPosition(e.width / 2, e.height / 2), this.setContentSize(e), this.setAnchorPoint(0.5, 0.5), this.ignoreAnchorPointForPosition(!0), t)
        for (var n = 0; n < t.length; n++)
          this.addChild(t[n], n);
      return this._selectedItem = null, this._state = cc.MENU_STATE_WAITING, this.cascadeColor = !0, this.cascadeOpacity = !0, !0;
    }
    return !1;
  },
  addChild: function(t, e, n) {
    if (!(t instanceof cc.MenuItem))
      throw new Error("cc.Menu.addChild() : Menu only supports MenuItem objects as children");
    cc.Layer.prototype.addChild.call(this, t, e, n);
  },
  updateAlign: function() {
    switch (this._align) {
      case "vertically":
        this.alignItemsVertically();
        break;
      case "horizontally":
        this.alignItemsHorizontally();
        break;
    }
  },
  alignItemsVertically: function() {
    this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING);
  },
  alignItemsVerticallyWithPadding: function(t) {
    this._align = "vertically";
    var e = -t, n = (this || window)._children, r, s, o, a, c;
    if (n && n.length > 0) {
      for (s = 0, r = n.length; s < r; s++)
        e += n[s].height * n[s].scaleY + t;
      var l = e / 2;
      for (s = 0, r = n.length; s < r; s++)
        c = n[s], a = c.height, o = c.scaleY, c.setPosition(0, l - a * o / 2), l -= a * o + t;
    }
  },
  alignItemsHorizontally: function() {
    this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING);
  },
  alignItemsHorizontallyWithPadding: function(t) {
    this._align = "horizontally";
    var e = -t, n = (this || window)._children, r, s, o, a, c;
    if (n && n.length > 0) {
      for (r = 0, s = n.length; r < s; r++)
        e += n[r].width * n[r].scaleX + t;
      var l = -e / 2;
      for (r = 0, s = n.length; r < s; r++)
        c = n[r], o = c.scaleX, a = n[r].width, c.setPosition(l + a * o / 2, 0), l += a * o + t;
    }
  },
  alignItemsInColumns: function() {
    arguments.length > 0 && arguments[arguments.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
    for (var t = [], e = 0; e < arguments.length; e++)
      t.push(arguments[e]);
    var n = -5, r = 0, s = 0, o = 0, a, c, l, h = (this || window)._children;
    if (h && h.length > 0)
      for (e = 0, l = h.length; e < l; e++)
        r >= t.length || (a = t[r], a && (c = h[e].height, s = s >= c || isNaN(c) ? s : c, ++o, o >= a && (n += s + 5, o = 0, s = 0, ++r)));
    var u = cc.director.getWinSize();
    r = 0, s = 0, a = 0;
    var _ = 0, d = 0, f = n / 2;
    if (h && h.length > 0)
      for (e = 0, l = h.length; e < l; e++) {
        var C = h[e];
        a === 0 && (a = t[r], _ = u.width / (1 + a), d = _), c = C._getHeight(), s = s >= c || isNaN(c) ? s : c, C.setPosition(d - u.width / 2, f - c / 2), d += _, ++o, o >= a && (f -= s + 5, o = 0, a = 0, s = 0, ++r);
      }
  },
  alignItemsInRows: function() {
    arguments.length > 0 && arguments[arguments.length - 1] == null && cc.log("parameters should not be ending with null in Javascript");
    var t = [], e;
    for (e = 0; e < arguments.length; e++)
      t.push(arguments[e]);
    var n = [], r = [], s = -10, o = -5, a = 0, c = 0, l = 0, h, u, _, d, f = (this || window)._children;
    if (f && f.length > 0)
      for (e = 0, _ = f.length; e < _; e++)
        u = f[e], !(a >= t.length) && (h = t[a], h && (d = u.width, c = c >= d || isNaN(d) ? c : d, o += u.height + 5, ++l, l >= h && (n.push(c), r.push(o), s += c + 10, l = 0, c = 0, o = -5, ++a)));
    var C = cc.director.getWinSize();
    a = 0, c = 0, h = 0;
    var m = -s / 2, g = 0;
    if (f && f.length > 0)
      for (e = 0, _ = f.length; e < _; e++)
        u = f[e], h === 0 && (h = t[a], g = r[a]), d = u._getWidth(), c = c >= d || isNaN(d) ? c : d, u.setPosition(m + n[a] / 2, g - C.height / 2), g -= u.height + 10, ++l, l >= h && (m += c + 5, l = 0, h = 0, c = 0, ++a);
  },
  removeChild: function(t, e) {
    if (t != null) {
      if (!(t instanceof cc.MenuItem)) {
        cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children");
        return;
      }
      this._selectedItem === t && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, t, e);
    }
  },
  _onTouchBegan: function(t, e) {
    var n = e.getCurrentTarget();
    if (n._state !== cc.MENU_STATE_WAITING || !n._visible || !n.enabled)
      return !1;
    for (var r = n.parent; r != null; r = r.parent)
      if (!r.isVisible())
        return !1;
    return n._selectedItem = n._itemForTouch(t), n._selectedItem ? (n._state = cc.MENU_STATE_TRACKING_TOUCH, n._selectedItem.selected(), n._selectedItem.setNodeDirty(), !0) : !1;
  },
  _onTouchEnded: function(t, e) {
    var n = e.getCurrentTarget();
    if (n._state !== cc.MENU_STATE_TRACKING_TOUCH) {
      cc.log("cc.Menu.onTouchEnded(): invalid state");
      return;
    }
    n._selectedItem && (n._selectedItem.unselected(), n._selectedItem.setNodeDirty(), n._selectedItem.activate()), n._state = cc.MENU_STATE_WAITING;
  },
  _onTouchCancelled: function(t, e) {
    var n = e.getCurrentTarget();
    if (n._state !== cc.MENU_STATE_TRACKING_TOUCH) {
      cc.log("cc.Menu.onTouchCancelled(): invalid state");
      return;
    }
    n._selectedItem && (n._selectedItem.unselected(), n._selectedItem.setNodeDirty()), n._state = cc.MENU_STATE_WAITING;
  },
  _onTouchMoved: function(t, e) {
    var n = e.getCurrentTarget();
    if (n._state !== cc.MENU_STATE_TRACKING_TOUCH) {
      cc.log("cc.Menu.onTouchMoved(): invalid state");
      return;
    }
    var r = n._itemForTouch(t);
    r !== n._selectedItem && (n._selectedItem && (n._selectedItem.unselected(), n._selectedItem.setNodeDirty()), n._selectedItem = r, n._selectedItem && (n._selectedItem.selected(), n._selectedItem.setNodeDirty()));
  },
  onExit: function() {
    this._state === cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING), cc.Node.prototype.onExit.call(this);
  },
  setOpacityModifyRGB: function(t) {
  },
  isOpacityModifyRGB: function() {
    return !1;
  },
  _itemForTouch: function(t) {
    var e = t.getLocation(), n = (this || window)._children, r;
    if (n && n.length > 0) {
      for (var s = n.length - 1; s >= 0; s--)
        if (r = n[s], r.isVisible() && r.isEnabled()) {
          var o = r.convertToNodeSpace(e), a = r.rect();
          if (a.x = 0, a.y = 0, cc.rectContainsPoint(a, o))
            return r;
        }
    }
    return null;
  }
});
var _p = cc.Menu.prototype;
_p.enabled;
cc.Menu.create = function(t) {
  var e = arguments.length;
  e > 0 && arguments[e - 1] == null && cc.log("parameters should not be ending with null in Javascript");
  var n;
  return e === 0 ? n = new cc.Menu() : e === 1 ? n = new cc.Menu(t) : n = new cc.Menu(Array.prototype.slice.call(arguments, 0)), n;
};
cc.math = cc.math || {};
cc.math.EPSILON = 1 / 64;
cc.math.square = function(t) {
  return t * t;
};
cc.math.almostEqual = function(t, e) {
  return t + cc.math.EPSILON > e && t - cc.math.EPSILON < e;
};
(function(t) {
  t.math.Vec2 = function(n, r) {
    r === void 0 ? (this.x = n.x, this.y = n.y) : (this.x = n || 0, this.y = r || 0);
  };
  var e = t.math.Vec2.prototype;
  e.fill = function(n, r) {
    this.x = n, this.y = r;
  }, e.length = function() {
    return Math.sqrt(t.math.square(this.x) + t.math.square(this.y));
  }, e.lengthSq = function() {
    return t.math.square(this.x) + t.math.square(this.y);
  }, e.normalize = function() {
    var n = 1 / this.length();
    return this.x *= n, this.y *= n, (this || window)
  }, t.math.Vec2.add = function(n, r, s) {
    return n.x = r.x + s.x, n.y = r.y + s.y, n;
  }, e.add = function(n) {
    return this.x += n.x, this.y += n.y, (this || window)
  }, e.dot = function(n) {
    return this.x * n.x + this.y * n.y;
  }, t.math.Vec2.subtract = function(n, r, s) {
    return n.x = r.x - s.x, n.y = r.y - s.y, n;
  }, e.subtract = function(n) {
    return this.x -= n.x, this.y -= n.y, (this || window)
  }, e.transform = function(n) {
    var r = (this || window).x, s = (this || window).y;
    return this.x = r * n.mat[0] + s * n.mat[3] + n.mat[6], this.y = r * n.mat[1] + s * n.mat[4] + n.mat[7], (this || window)
  }, t.math.Vec2.scale = function(n, r, s) {
    return n.x = r.x * s, n.y = r.y * s, n;
  }, e.scale = function(n) {
    return this.x *= n, this.y *= n, (this || window)
  }, e.equals = function(n) {
    return this.x < n.x + t.math.EPSILON && this.x > n.x - t.math.EPSILON && this.y < n.y + t.math.EPSILON && this.y > n.y - t.math.EPSILON;
  };
})(cc);
(function(t) {
  t.math.Vec3 = t.kmVec3 = function(n, r, s) {
    n && r === void 0 ? (this.x = n.x, this.y = n.y, this.z = n.z) : (this.x = n || 0, this.y = r || 0, this.z = s || 0);
  }, t.math.vec3 = function(n, r, s) {
    return new t.math.Vec3(n, r, s);
  };
  var e = t.math.Vec3.prototype;
  e.fill = function(n, r, s) {
    return n && r === void 0 ? (this.x = n.x, this.y = n.y, this.z = n.z) : (this.x = n, this.y = r, this.z = s), (this || window)
  }, e.length = function() {
    return Math.sqrt(t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z));
  }, e.lengthSq = function() {
    return t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z);
  }, e.normalize = function() {
    var n = 1 / this.length();
    return this.x *= n, this.y *= n, this.z *= n, (this || window)
  }, e.cross = function(n) {
    var r = (this || window).x, s = (this || window).y, o = (this || window).z;
    return this.x = s * n.z - o * n.y, this.y = o * n.x - r * n.z, this.z = r * n.y - s * n.x, (this || window)
  }, e.dot = function(n) {
    return this.x * n.x + this.y * n.y + this.z * n.z;
  }, e.add = function(n) {
    return this.x += n.x, this.y += n.y, this.z += n.z, (this || window)
  }, e.subtract = function(n) {
    return this.x -= n.x, this.y -= n.y, this.z -= n.z, (this || window)
  }, e.transform = function(n) {
    var r = (this || window).x, s = (this || window).y, o = (this || window).z, a = n.mat;
    return this.x = r * a[0] + s * a[4] + o * a[8] + a[12], this.y = r * a[1] + s * a[5] + o * a[9] + a[13], this.z = r * a[2] + s * a[6] + o * a[10] + a[14], (this || window)
  }, e.transformNormal = function(n) {
    var r = (this || window).x, s = (this || window).y, o = (this || window).z, a = n.mat;
    return this.x = r * a[0] + s * a[4] + o * a[8], this.y = r * a[1] + s * a[5] + o * a[9], this.z = r * a[2] + s * a[6] + o * a[10], (this || window)
  }, e.transformCoord = function(n) {
    var r = new t.math.Vec4(this.x, this.y, this.z, 1);
    return r.transform(n), this.x = r.x / r.w, this.y = r.y / r.w, this.z = r.z / r.w, (this || window)
  }, e.scale = function(n) {
    return this.x *= n, this.y *= n, this.z *= n, (this || window)
  }, e.equals = function(n) {
    var r = t.math.EPSILON;
    return this.x < n.x + r && this.x > n.x - r && this.y < n.y + r && this.y > n.y - r && this.z < n.z + r && this.z > n.z - r;
  }, e.inverseTransform = function(n) {
    var r = n.mat, s = new t.math.Vec3(this.x - r[12], this.y - r[13], this.z - r[14]);
    return this.x = s.x * r[0] + s.y * r[1] + s.z * r[2], this.y = s.x * r[4] + s.y * r[5] + s.z * r[6], this.z = s.x * r[8] + s.y * r[9] + s.z * r[10], (this || window)
  }, e.inverseTransformNormal = function(n) {
    var r = (this || window).x, s = (this || window).y, o = (this || window).z, a = n.mat;
    return this.x = r * a[0] + s * a[1] + o * a[2], this.y = r * a[4] + s * a[5] + o * a[6], this.z = r * a[8] + s * a[9] + o * a[10], (this || window)
  }, e.assignFrom = function(n) {
    return n ? (this.x = n.x, this.y = n.y, this.z = n.z, this) : (this || window)
  }, t.math.Vec3.zero = function(n) {
    return n.x = n.y = n.z = 0, n;
  }, e.toTypeArray = function() {
    var n = new Float32Array(3);
    return n[0] = (this || window).x, n[1] = (this || window).y, n[2] = (this || window).z, n;
  };
})(cc);
(function(t) {
  t.math.Vec4 = function(n, r, s, o) {
    n && r === void 0 ? (this.x = n.x, this.y = n.y, this.z = n.z, this.w = n.w) : (this.x = n || 0, this.y = r || 0, this.z = s || 0, this.w = o || 0);
  }, t.kmVec4 = t.math.Vec4;
  var e = t.math.Vec4.prototype;
  e.fill = function(n, r, s, o) {
    n && r === void 0 ? (this.x = n.x, this.y = n.y, this.z = n.z, this.w = n.w) : (this.x = n, this.y = r, this.z = s, this.w = o);
  }, e.add = function(n) {
    return n ? (this.x += n.x, this.y += n.y, this.z += n.z, this.w += n.w, this) : (this || window)
  }, e.dot = function(n) {
    return this.x * n.x + this.y * n.y + this.z * n.z + this.w * n.w;
  }, e.length = function() {
    return Math.sqrt(t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z) + t.math.square(this.w));
  }, e.lengthSq = function() {
    return t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z) + t.math.square(this.w);
  }, e.lerp = function(n, r) {
    return (this || window)
  }, e.normalize = function() {
    var n = 1 / this.length();
    return this.x *= n, this.y *= n, this.z *= n, this.w *= n, (this || window)
  }, e.scale = function(n) {
    return this.normalize(), this.x *= n, this.y *= n, this.z *= n, this.w *= n, (this || window)
  }, e.subtract = function(n) {
    this.x -= n.x, this.y -= n.y, this.z -= n.z, this.w -= n.w;
  }, e.transform = function(n) {
    var r = (this || window).x, s = (this || window).y, o = (this || window).z, a = (this || window).w, c = n.mat;
    return this.x = r * c[0] + s * c[4] + o * c[8] + a * c[12], this.y = r * c[1] + s * c[5] + o * c[9] + a * c[13], this.z = r * c[2] + s * c[6] + o * c[10] + a * c[14], this.w = r * c[3] + s * c[7] + o * c[11] + a * c[15], (this || window)
  }, t.math.Vec4.transformArray = function(n, r) {
    for (var s = [], o = 0; o < n.length; o++) {
      var a = new t.math.Vec4(n[o]);
      a.transform(r), s.push(a);
    }
    return s;
  }, e.equals = function(n) {
    var r = t.math.EPSILON;
    return this.x < n.x + r && this.x > n.x - r && this.y < n.y + r && this.y > n.y - r && this.z < n.z + r && this.z > n.z - r && this.w < n.w + r && this.w > n.w - r;
  }, e.assignFrom = function(n) {
    return this.x = n.x, this.y = n.y, this.z = n.z, this.w = n.w, (this || window)
  }, e.toTypeArray = function() {
    var n = new Float32Array(4);
    return n[0] = (this || window).x, n[1] = (this || window).y, n[2] = (this || window).z, n[3] = (this || window).w, n;
  };
})(cc);
(function(t) {
  t.math.Ray2 = function(n, r) {
    this.start = n || new t.math.Vec2(), this.dir = r || new t.math.Vec2();
  }, t.math.Ray2.prototype.fill = function(n, r, s, o) {
    this.start.x = n, this.start.y = r, this.dir.x = s, this.dir.y = o;
  }, t.math.Ray2.prototype.intersectLineSegment = function(n, r, s) {
    var o = (this || window).start.x, a = (this || window).start.y, c = (this || window).start.x + this.dir.x, l = (this || window).start.y + this.dir.y, h = n.x, u = n.y, _ = r.x, d = r.y, f = (d - u) * (c - o) - (_ - h) * (l - a), C, m, g;
    return f > -t.math.EPSILON && f < t.math.EPSILON || (C = ((_ - h) * (a - u) - (d - u) * (o - h)) / f, m = o + C * (c - o), g = a + C * (l - a), m < Math.min(n.x, r.x) - t.math.EPSILON || m > Math.max(n.x, r.x) + t.math.EPSILON || g < Math.min(n.y, r.y) - t.math.EPSILON || g > Math.max(n.y, r.y) + t.math.EPSILON) || m < Math.min(o, c) - t.math.EPSILON || m > Math.max(o, c) + t.math.EPSILON || g < Math.min(a, l) - t.math.EPSILON || g > Math.max(a, l) + t.math.EPSILON ? !1 : (s.x = m, s.y = g, !0);
  };
  function e(n, r, s) {
    var o = new t.math.Vec2(r);
    o.subtract(n), s.x = -o.y, s.y = o.x, s.normalize();
  }
  H(e, "calculate_line_normal"), t.math.Ray2.prototype.intersectTriangle = function(n, r, s, o, a) {
    var c = new t.math.Vec2(), l = new t.math.Vec2(), h = new t.math.Vec2(), u = 1e4, _ = !1, d;
    return this.intersectLineSegment(n, r, c) && (_ = !0, d = c.subtract(this.start).length(), d < u && (l.x = c.x, l.y = c.y, u = d, e(n, r, h))), this.intersectLineSegment(r, s, c) && (_ = !0, d = c.subtract(this.start).length(), d < u && (l.x = c.x, l.y = c.y, u = d, e(r, s, h))), this.intersectLineSegment(s, n, c) && (_ = !0, d = c.subtract(this.start).length(), d < u && (l.x = c.x, l.y = c.y, u = d, e(s, n, h))), _ && (o.x = l.x, o.y = l.y, a && (a.x = h.x, a.y = h.y)), _;
  };
})(cc);
window.Uint16Array = window.Uint16Array || window.Array;
window.Float32Array = window.Float32Array || window.Array;
(function(t) {
  t.math.Matrix3 = function(r) {
    r && r.mat ? this.mat = new Float32Array(r.mat) : this.mat = new Float32Array(9);
  }, t.kmMat3 = t.math.Matrix3;
  var e = t.math.Matrix3.prototype;
  e.fill = function(r) {
    var s = (this || window).mat, o = r.mat;
    return s[0] = o[0], s[1] = o[1], s[2] = o[2], s[3] = o[3], s[4] = o[4], s[5] = o[5], s[6] = o[6], s[7] = o[7], s[8] = o[8], (this || window)
  }, e.adjugate = function() {
    var r = (this || window).mat, s = r[0], o = r[1], a = r[2], c = r[3], l = r[4], h = r[5], u = r[6], _ = r[7], d = r[8];
    return r[0] = l * d - h * _, r[1] = a * _ - o * d, r[2] = o * h - a * l, r[3] = h * u - c * d, r[4] = s * d - a * u, r[5] = a * c - s * h, r[6] = c * _ - l * u, r[8] = s * l - o * c, (this || window)
  }, e.identity = function() {
    var r = (this || window).mat;
    return r[1] = r[2] = r[3] = r[5] = r[6] = r[7] = 0, r[0] = r[4] = r[8] = 1, (this || window)
  };
  var n = new t.math.Matrix3();
  e.inverse = function(r) {
    if (r === 0)
      return (this || window)
    n.assignFrom(this);
    var s = 1 / r;
    return this.adjugate(), this.multiplyScalar(s), (this || window)
  }, e.isIdentity = function() {
    var r = (this || window).mat;
    return r[0] === 1 && r[1] === 0 && r[2] === 0 && r[3] === 0 && r[4] === 1 && r[5] === 0 && r[6] === 0 && r[7] === 0 && r[8] === 1;
  }, e.transpose = function() {
    var r = (this || window).mat, s = r[1], o = r[2], a = r[3], c = r[5], l = r[6], h = r[7];
    return r[1] = a, r[2] = l, r[3] = s, r[5] = h, r[6] = o, r[7] = c, (this || window)
  }, e.determinant = function() {
    var r = (this || window).mat, s = r[0] * r[4] * r[8] + r[1] * r[5] * r[6] + r[2] * r[3] * r[7];
    return s -= r[2] * r[4] * r[6] + r[0] * r[5] * r[7] + r[1] * r[3] * r[8], s;
  }, e.multiply = function(r) {
    var s = (this || window).mat, o = r.mat, a = s[0], c = s[1], l = s[2], h = s[3], u = s[4], _ = s[5], d = s[6], f = s[7], C = s[8], m = o[0], g = o[1], y = o[2], A = o[3], D = o[4], N = o[5], z = o[6], M = o[7], Z = o[8];
    return s[0] = a * m + h * g + d * y, s[1] = c * m + u * g + f * y, s[2] = l * m + _ * g + C * y, s[3] = l * m + _ * g + C * y, s[4] = c * A + u * D + f * N, s[5] = l * A + _ * D + C * N, s[6] = a * z + h * M + d * Z, s[7] = c * z + u * M + f * Z, s[8] = l * z + _ * M + C * Z, (this || window)
  }, e.multiplyScalar = function(r) {
    var s = (this || window).mat;
    return s[0] *= r, s[1] *= r, s[2] *= r, s[3] *= r, s[4] *= r, s[5] *= r, s[6] *= r, s[7] *= r, s[8] *= r, (this || window)
  }, t.math.Matrix3.rotationAxisAngle = function(r, s) {
    var o = Math.cos(s), a = Math.sin(s), c = new t.math.Matrix3(), l = c.mat;
    return l[0] = o + r.x * r.x * (1 - o), l[1] = r.z * a + r.y * r.x * (1 - o), l[2] = -r.y * a + r.z * r.x * (1 - o), l[3] = -r.z * a + r.x * r.y * (1 - o), l[4] = o + r.y * r.y * (1 - o), l[5] = r.x * a + r.z * r.y * (1 - o), l[6] = r.y * a + r.x * r.z * (1 - o), l[7] = -r.x * a + r.y * r.z * (1 - o), l[8] = o + r.z * r.z * (1 - o), c;
  }, e.assignFrom = function(r) {
    if (this === r)
      return t.log("cc.math.Matrix3.assign(): current matrix equals matIn"), (this || window)
    var s = (this || window).mat, o = r.mat;
    return s[0] = o[0], s[1] = o[1], s[2] = o[2], s[3] = o[3], s[4] = o[4], s[5] = o[5], s[6] = o[6], s[7] = o[7], s[8] = o[8], (this || window)
  }, e.equals = function(r) {
    if (this === r)
      return !0;
    for (var s = t.math.EPSILON, o = (this || window).mat, a = r.mat, c = 0; c < 9; ++c)
      if (!(o[c] + s > a[c] && o[c] - s < a[c]))
        return !1;
    return !0;
  }, t.math.Matrix3.createByRotationX = function(r) {
    var s = new t.math.Matrix3(), o = s.mat;
    return o[0] = 1, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = Math.cos(r), o[5] = Math.sin(r), o[6] = 0, o[7] = -Math.sin(r), o[8] = Math.cos(r), s;
  }, t.math.Matrix3.createByRotationY = function(r) {
    var s = new t.math.Matrix3(), o = s.mat;
    return o[0] = Math.cos(r), o[1] = 0, o[2] = -Math.sin(r), o[3] = 0, o[4] = 1, o[5] = 0, o[6] = Math.sin(r), o[7] = 0, o[8] = Math.cos(r), s;
  }, t.math.Matrix3.createByRotationZ = function(r) {
    var s = new t.math.Matrix3(), o = s.mat;
    return o[0] = Math.cos(r), o[1] = -Math.sin(r), o[2] = 0, o[3] = Math.sin(r), o[4] = Math.cos(r), o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, s;
  }, t.math.Matrix3.createByRotation = function(r) {
    var s = new t.math.Matrix3(), o = s.mat;
    return o[0] = Math.cos(r), o[1] = Math.sin(r), o[2] = 0, o[3] = -Math.sin(r), o[4] = Math.cos(r), o[5] = 0, o[6] = 0, o[7] = 0, o[8] = 1, s;
  }, t.math.Matrix3.createByScale = function(r, s) {
    var o = new t.math.Matrix3();
    return o.identity(), o.mat[0] = r, o.mat[4] = s, o;
  }, t.math.Matrix3.createByTranslation = function(r, s) {
    var o = new t.math.Matrix3();
    return o.identity(), o.mat[6] = r, o.mat[7] = s, o;
  }, t.math.Matrix3.createByQuaternion = function(r) {
    if (!r)
      return null;
    var s = new t.math.Matrix3(), o = s.mat;
    return o[0] = 1 - 2 * (r.y * r.y + r.z * r.z), o[1] = 2 * (r.x * r.y - r.w * r.z), o[2] = 2 * (r.x * r.z + r.w * r.y), o[3] = 2 * (r.x * r.y + r.w * r.z), o[4] = 1 - 2 * (r.x * r.x + r.z * r.z), o[5] = 2 * (r.y * r.z - r.w * r.x), o[6] = 2 * (r.x * r.z - r.w * r.y), o[7] = 2 * (r.y * r.z + r.w * r.x), o[8] = 1 - 2 * (r.x * r.x + r.y * r.y), s;
  }, e.rotationToAxisAngle = function() {
    return t.math.Quaternion.rotationMatrix(this).toAxisAndAngle();
  };
})(cc);
(function(t) {
  t.math.Matrix4 = function(s) {
    s && s.mat ? this.mat = new Float32Array(s.mat) : this.mat = new Float32Array(16);
  }, t.kmMat4 = t.math.Matrix4;
  var e = t.math.Matrix4.prototype;
  e.fill = function(s) {
    for (var o = (this || window).mat, a = 0; a < 16; a++)
      o[a] = s[a];
    return (this || window)
  }, t.kmMat4Identity = function(s) {
    var o = s.mat;
    return o[1] = o[2] = o[3] = o[4] = o[6] = o[7] = o[8] = o[9] = o[11] = o[12] = o[13] = o[14] = 0, o[0] = o[5] = o[10] = o[15] = 1, s;
  }, e.identity = function() {
    var s = (this || window).mat;
    return s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[8] = s[9] = s[11] = s[12] = s[13] = s[14] = 0, s[0] = s[5] = s[10] = s[15] = 1, (this || window)
  }, e.get = function(s, o) {
    return this.mat[s + 4 * o];
  }, e.set = function(s, o, a) {
    this.mat[s + 4 * o] = a;
  }, e.swap = function(s, o, a, c) {
    var l = (this || window).mat, h = l[s + 4 * o];
    l[s + 4 * o] = l[a + 4 * c], l[a + 4 * c] = h;
  }, t.math.Matrix4._gaussj = function(s, o) {
    var a, c = 0, l = 0, h, u, _, d, f = 4, C = 4, m, g, y, A, D = [0, 0, 0, 0], N = [0, 0, 0, 0], z = [0, 0, 0, 0];
    for (a = 0; a < f; a++) {
      for (g = 0, h = 0; h < f; h++)
        if (z[h] !== 1)
          for (u = 0; u < f; u++)
            z[u] === 0 && (m = Math.abs(s.get(h, u)), m >= g && (g = m, l = h, c = u));
      if (++z[c], l !== c) {
        for (_ = 0; _ < f; _++)
          s.swap(l, _, c, _);
        for (_ = 0; _ < C; _++)
          o.swap(l, _, c, _);
      }
      if (N[a] = l, D[a] = c, s.get(c, c) === 0)
        return !1;
      for (A = 1 / s.get(c, c), s.set(c, c, 1), _ = 0; _ < f; _++)
        s.set(c, _, s.get(c, _) * A);
      for (_ = 0; _ < C; _++)
        o.set(c, _, o.get(c, _) * A);
      for (d = 0; d < f; d++)
        if (d !== c) {
          for (y = s.get(d, c), s.set(d, c, 0), _ = 0; _ < f; _++)
            s.set(d, _, s.get(d, _) - s.get(c, _) * y);
          for (_ = 0; _ < C; _++)
            o.set(d, _, s.get(d, _) - o.get(c, _) * y);
        }
    }
    for (_ = f - 1; _ >= 0; _--)
      if (N[_] !== D[_])
        for (u = 0; u < f; u++)
          s.swap(u, N[_], u, D[_]);
    return !0;
  };
  var n = new t.math.Matrix4().identity();
  t.kmMat4Inverse = function(s, o) {
    var a = new t.math.Matrix4(o), c = new t.math.Matrix4(n);
    return t.math.Matrix4._gaussj(a, c) === !1 ? null : (s.assignFrom(a), s);
  }, e.inverse = function() {
    var s = new t.math.Matrix4(this), o = new t.math.Matrix4(n);
    return t.math.Matrix4._gaussj(s, o) === !1 ? null : s;
  }, e.isIdentity = function() {
    var s = (this || window).mat;
    return s[0] === 1 && s[1] === 0 && s[2] === 0 && s[3] === 0 && s[4] === 0 && s[5] === 1 && s[6] === 0 && s[7] === 0 && s[8] === 0 && s[9] === 0 && s[10] === 1 && s[11] === 0 && s[12] === 0 && s[13] === 0 && s[14] === 0 && s[15] === 1;
  }, e.transpose = function() {
    var s = (this || window).mat, o = s[1], a = s[2], c = s[3], l = s[4], h = s[6], u = s[7], _ = s[8], d = s[9], f = s[11], C = s[12], m = s[13], g = s[14];
    return s[1] = l, s[2] = _, s[3] = C, s[4] = o, s[6] = d, s[7] = m, s[8] = a, s[9] = h, s[11] = g, s[12] = c, s[13] = u, s[14] = f, (this || window)
  }, t.kmMat4Multiply = function(s, o, a) {
    var c = s.mat, l = o.mat, h = a.mat, u = l[0], _ = l[1], d = l[2], f = l[3], C = l[4], m = l[5], g = l[6], y = l[7], A = l[8], D = l[9], N = l[10], z = l[11], M = l[12], Z = l[13], U = l[14], Q = l[15], et = h[0], rt = h[1], w = h[2], L = h[3], G = h[4], I = h[5], O = h[6], K = h[7], $ = h[8], S = h[9], b = h[10], W = h[11], x = h[12], E = h[13], R = h[14], F = h[15];
    return c[0] = et * u + rt * C + w * A + L * M, c[1] = et * _ + rt * m + w * D + L * Z, c[2] = et * d + rt * g + w * N + L * U, c[3] = et * f + rt * y + w * z + L * Q, c[4] = G * u + I * C + O * A + K * M, c[5] = G * _ + I * m + O * D + K * Z, c[6] = G * d + I * g + O * N + K * U, c[7] = G * f + I * y + O * z + K * Q, c[8] = $ * u + S * C + b * A + W * M, c[9] = $ * _ + S * m + b * D + W * Z, c[10] = $ * d + S * g + b * N + W * U, c[11] = $ * f + S * y + b * z + W * Q, c[12] = x * u + E * C + R * A + F * M, c[13] = x * _ + E * m + R * D + F * Z, c[14] = x * d + E * g + R * N + F * U, c[15] = x * f + E * y + R * z + F * Q, s;
  }, e.multiply = function(s) {
    var o = (this || window).mat, a = s.mat, c = o[0], l = o[1], h = o[2], u = o[3], _ = o[4], d = o[5], f = o[6], C = o[7], m = o[8], g = o[9], y = o[10], A = o[11], D = o[12], N = o[13], z = o[14], M = o[15], Z = a[0], U = a[1], Q = a[2], et = a[3], rt = a[4], w = a[5], L = a[6], G = a[7], I = a[8], O = a[9], K = a[10], $ = a[11], S = a[12], b = a[13], W = a[14], x = a[15];
    return o[0] = Z * c + U * _ + Q * m + et * D, o[1] = Z * l + U * d + Q * g + et * N, o[2] = Z * h + U * f + Q * y + et * z, o[3] = Z * u + U * C + Q * A + et * M, o[4] = rt * c + w * _ + L * m + G * D, o[5] = rt * l + w * d + L * g + G * N, o[6] = rt * h + w * f + L * y + G * z, o[7] = rt * u + w * C + L * A + G * M, o[8] = I * c + O * _ + K * m + $ * D, o[9] = I * l + O * d + K * g + $ * N, o[10] = I * h + O * f + K * y + $ * z, o[11] = I * u + O * C + K * A + $ * M, o[12] = S * c + b * _ + W * m + x * D, o[13] = S * l + b * d + W * g + x * N, o[14] = S * h + b * f + W * y + x * z, o[15] = S * u + b * C + W * A + x * M, (this || window)
  }, t.getMat4MultiplyValue = function(s, o) {
    var a = s.mat, c = o.mat, l = new Float32Array(16);
    return l[0] = a[0] * c[0] + a[4] * c[1] + a[8] * c[2] + a[12] * c[3], l[1] = a[1] * c[0] + a[5] * c[1] + a[9] * c[2] + a[13] * c[3], l[2] = a[2] * c[0] + a[6] * c[1] + a[10] * c[2] + a[14] * c[3], l[3] = a[3] * c[0] + a[7] * c[1] + a[11] * c[2] + a[15] * c[3], l[4] = a[0] * c[4] + a[4] * c[5] + a[8] * c[6] + a[12] * c[7], l[5] = a[1] * c[4] + a[5] * c[5] + a[9] * c[6] + a[13] * c[7], l[6] = a[2] * c[4] + a[6] * c[5] + a[10] * c[6] + a[14] * c[7], l[7] = a[3] * c[4] + a[7] * c[5] + a[11] * c[6] + a[15] * c[7], l[8] = a[0] * c[8] + a[4] * c[9] + a[8] * c[10] + a[12] * c[11], l[9] = a[1] * c[8] + a[5] * c[9] + a[9] * c[10] + a[13] * c[11], l[10] = a[2] * c[8] + a[6] * c[9] + a[10] * c[10] + a[14] * c[11], l[11] = a[3] * c[8] + a[7] * c[9] + a[11] * c[10] + a[15] * c[11], l[12] = a[0] * c[12] + a[4] * c[13] + a[8] * c[14] + a[12] * c[15], l[13] = a[1] * c[12] + a[5] * c[13] + a[9] * c[14] + a[13] * c[15], l[14] = a[2] * c[12] + a[6] * c[13] + a[10] * c[14] + a[14] * c[15], l[15] = a[3] * c[12] + a[7] * c[13] + a[11] * c[14] + a[15] * c[15], l;
  }, t.kmMat4Assign = function(s, o) {
    if (s === o)
      return t.log("cc.kmMat4Assign(): pOut equals pIn"), s;
    var a = s.mat, c = o.mat;
    return a[0] = c[0], a[1] = c[1], a[2] = c[2], a[3] = c[3], a[4] = c[4], a[5] = c[5], a[6] = c[6], a[7] = c[7], a[8] = c[8], a[9] = c[9], a[10] = c[10], a[11] = c[11], a[12] = c[12], a[13] = c[13], a[14] = c[14], a[15] = c[15], s;
  }, e.assignFrom = function(s) {
    if (this === s)
      return t.log("cc.mat.Matrix4.assignFrom(): mat4 equals current matrix"), (this || window)
    var o = (this || window).mat, a = s.mat;
    return o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3], o[4] = a[4], o[5] = a[5], o[6] = a[6], o[7] = a[7], o[8] = a[8], o[9] = a[9], o[10] = a[10], o[11] = a[11], o[12] = a[12], o[13] = a[13], o[14] = a[14], o[15] = a[15], (this || window)
  }, e.equals = function(s) {
    if (this === s)
      return t.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
    for (var o = (this || window).mat, a = s.mat, c = t.math.EPSILON, l = 0; l < 16; l++)
      if (!(o[l] + c > a[l] && o[l] - c < a[l]))
        return !1;
    return !0;
  }, t.math.Matrix4.createByRotationX = function(s, o) {
    o = o || new t.math.Matrix4();
    var a = o.mat;
    return a[0] = 1, a[3] = a[2] = a[1] = 0, a[4] = 0, a[5] = Math.cos(s), a[6] = Math.sin(s), a[7] = 0, a[8] = 0, a[9] = -Math.sin(s), a[10] = Math.cos(s), a[11] = 0, a[14] = a[13] = a[12] = 0, a[15] = 1, o;
  }, t.math.Matrix4.createByRotationY = function(s, o) {
    o = o || new t.math.Matrix4();
    var a = o.mat;
    return a[0] = Math.cos(s), a[1] = 0, a[2] = -Math.sin(s), a[3] = 0, a[7] = a[6] = a[4] = 0, a[5] = 1, a[8] = Math.sin(s), a[9] = 0, a[10] = Math.cos(s), a[11] = 0, a[14] = a[13] = a[12] = 0, a[15] = 1, o;
  }, t.math.Matrix4.createByRotationZ = function(s, o) {
    o = o || new t.math.Matrix4();
    var a = o.mat;
    return a[0] = Math.cos(s), a[1] = Math.sin(s), a[3] = a[2] = 0, a[4] = -Math.sin(s), a[5] = Math.cos(s), a[7] = a[6] = 0, a[11] = a[9] = a[8] = 0, a[10] = 1, a[14] = a[13] = a[12] = 0, a[15] = 1, o;
  }, t.math.Matrix4.createByPitchYawRoll = function(s, o, a, c) {
    c = c || new t.math.Matrix4();
    var l = Math.cos(s), h = Math.sin(s), u = Math.cos(o), _ = Math.sin(o), d = Math.cos(a), f = Math.sin(a), C = h * _, m = l * _, g = c.mat;
    return g[0] = u * d, g[4] = u * f, g[8] = -_, g[1] = C * d - l * f, g[5] = C * f + l * d, g[9] = h * u, g[2] = m * d + h * f, g[6] = m * f - h * d, g[10] = l * u, g[3] = g[7] = g[11] = 0, g[15] = 1, c;
  }, t.math.Matrix4.createByQuaternion = function(s, o) {
    o = o || new t.math.Matrix4();
    var a = o.mat;
    return a[0] = 1 - 2 * (s.y * s.y + s.z * s.z), a[1] = 2 * (s.x * s.y + s.z * s.w), a[2] = 2 * (s.x * s.z - s.y * s.w), a[3] = 0, a[4] = 2 * (s.x * s.y - s.z * s.w), a[5] = 1 - 2 * (s.x * s.x + s.z * s.z), a[6] = 2 * (s.z * s.y + s.x * s.w), a[7] = 0, a[8] = 2 * (s.x * s.z + s.y * s.w), a[9] = 2 * (s.y * s.z - s.x * s.w), a[10] = 1 - 2 * (s.x * s.x + s.y * s.y), a[11] = 0, a[14] = a[13] = a[12] = 0, a[15] = 1, o;
  }, t.math.Matrix4.createByRotationTranslation = function(s, o, a) {
    a = a || new t.math.Matrix4();
    var c = a.mat, l = s.mat;
    return c[0] = l[0], c[1] = l[1], c[2] = l[2], c[3] = 0, c[4] = l[3], c[5] = l[4], c[6] = l[5], c[7] = 0, c[8] = l[6], c[9] = l[7], c[10] = l[8], c[11] = 0, c[12] = o.x, c[13] = o.y, c[14] = o.z, c[15] = 1, a;
  }, t.math.Matrix4.createByScale = function(s, o, a, c) {
    c = c || new t.math.Matrix4();
    var l = c.mat;
    return l[0] = s, l[5] = o, l[10] = a, l[15] = 1, l[1] = l[2] = l[3] = l[4] = l[6] = l[7] = l[8] = l[9] = l[11] = l[12] = l[13] = l[14] = 0, c;
  }, t.kmMat4Translation = function(s, o, a, c) {
    return s.mat[0] = s.mat[5] = s.mat[10] = s.mat[15] = 1, s.mat[1] = s.mat[2] = s.mat[3] = s.mat[4] = s.mat[6] = s.mat[7] = s.mat[8] = s.mat[9] = s.mat[11] = 0, s.mat[12] = o, s.mat[13] = a, s.mat[14] = c, s;
  }, t.math.Matrix4.createByTranslation = function(s, o, a, c) {
    return c = c || new t.math.Matrix4(), c.identity(), c.mat[12] = s, c.mat[13] = o, c.mat[14] = a, c;
  }, e.getUpVec3 = function() {
    var s = (this || window).mat, o = new t.math.Vec3(s[4], s[5], s[6]);
    return o.normalize();
  }, e.getRightVec3 = function() {
    var s = (this || window).mat, o = new t.math.Vec3(s[0], s[1], s[2]);
    return o.normalize();
  }, e.getForwardVec3 = function() {
    var s = (this || window).mat, o = new t.math.Vec3(s[8], s[9], s[10]);
    return o.normalize();
  }, t.kmMat4PerspectiveProjection = function(s, o, a, c, l) {
    var h = t.degreesToRadians(o / 2), u = l - c, _ = Math.sin(h);
    if (u === 0 || _ === 0 || a === 0)
      return null;
    var d = Math.cos(h) / _;
    return s.identity(), s.mat[0] = d / a, s.mat[5] = d, s.mat[10] = -(l + c) / u, s.mat[11] = -1, s.mat[14] = -2 * c * l / u, s.mat[15] = 0, s;
  }, t.math.Matrix4.createPerspectiveProjection = function(s, o, a, c) {
    var l = t.degreesToRadians(s / 2), h = c - a, u = Math.sin(l);
    if (h === 0 || u === 0 || o === 0)
      return null;
    var _ = Math.cos(l) / u, d = new t.math.Matrix4(), f = d.mat;
    return d.identity(), f[0] = _ / o, f[5] = _, f[10] = -(c + a) / h, f[11] = -1, f[14] = -2 * a * c / h, f[15] = 0, d;
  }, t.kmMat4OrthographicProjection = function(s, o, a, c, l, h, u) {
    return s.identity(), s.mat[0] = 2 / (a - o), s.mat[5] = 2 / (l - c), s.mat[10] = -2 / (u - h), s.mat[12] = -((a + o) / (a - o)), s.mat[13] = -((l + c) / (l - c)), s.mat[14] = -((u + h) / (u - h)), s;
  }, t.math.Matrix4.createOrthographicProjection = function(s, o, a, c, l, h) {
    var u = new t.math.Matrix4(), _ = u.mat;
    return u.identity(), _[0] = 2 / (o - s), _[5] = 2 / (c - a), _[10] = -2 / (h - l), _[12] = -((o + s) / (o - s)), _[13] = -((c + a) / (c - a)), _[14] = -((h + l) / (h - l)), u;
  }, t.kmMat4LookAt = function(s, o, a, c) {
    var l = new t.math.Vec3(a), h = new t.math.Vec3(c);
    l.subtract(o), l.normalize(), h.normalize();
    var u = new t.math.Vec3(l);
    u.cross(h), u.normalize();
    var _ = new t.math.Vec3(u);
    _.cross(l), u.normalize(), s.identity(), s.mat[0] = u.x, s.mat[4] = u.y, s.mat[8] = u.z, s.mat[1] = _.x, s.mat[5] = _.y, s.mat[9] = _.z, s.mat[2] = -l.x, s.mat[6] = -l.y, s.mat[10] = -l.z;
    var d = t.math.Matrix4.createByTranslation(-o.x, -o.y, -o.z);
    return s.multiply(d), s;
  };
  var r = new t.math.Matrix4();
  e.lookAt = function(s, o, a) {
    var c = new t.math.Vec3(o), l = new t.math.Vec3(a), h = (this || window).mat;
    c.subtract(s), c.normalize(), l.normalize();
    var u = new t.math.Vec3(c);
    u.cross(l), u.normalize();
    var _ = new t.math.Vec3(u);
    return _.cross(c), u.normalize(), this.identity(), h[0] = u.x, h[4] = u.y, h[8] = u.z, h[1] = _.x, h[5] = _.y, h[9] = _.z, h[2] = -c.x, h[6] = -c.y, h[10] = -c.z, r = t.math.Matrix4.createByTranslation(-s.x, -s.y, -s.z, r), this.multiply(r), (this || window)
  }, t.kmMat4RotationAxisAngle = function(s, o, a) {
    var c = Math.cos(a), l = Math.sin(a), h = new t.math.Vec3(o);
    return h.normalize(), s.mat[0] = c + h.x * h.x * (1 - c), s.mat[1] = h.z * l + h.y * h.x * (1 - c), s.mat[2] = -h.y * l + h.z * h.x * (1 - c), s.mat[3] = 0, s.mat[4] = -h.z * l + h.x * h.y * (1 - c), s.mat[5] = c + h.y * h.y * (1 - c), s.mat[6] = h.x * l + h.z * h.y * (1 - c), s.mat[7] = 0, s.mat[8] = h.y * l + h.x * h.z * (1 - c), s.mat[9] = -h.x * l + h.y * h.z * (1 - c), s.mat[10] = c + h.z * h.z * (1 - c), s.mat[11] = 0, s.mat[12] = 0, s.mat[13] = 0, s.mat[14] = 0, s.mat[15] = 1, s;
  }, t.math.Matrix4.createByAxisAndAngle = function(s, o, a) {
    a = a || new t.math.Matrix4();
    var c = (this || window).mat, l = Math.cos(o), h = Math.sin(o), u = new t.math.Vec3(s);
    return u.normalize(), c[0] = l + u.x * u.x * (1 - l), c[1] = u.z * h + u.y * u.x * (1 - l), c[2] = -u.y * h + u.z * u.x * (1 - l), c[3] = 0, c[4] = -u.z * h + u.x * u.y * (1 - l), c[5] = l + u.y * u.y * (1 - l), c[6] = u.x * h + u.z * u.y * (1 - l), c[7] = 0, c[8] = u.y * h + u.x * u.z * (1 - l), c[9] = -u.x * h + u.y * u.z * (1 - l), c[10] = l + u.z * u.z * (1 - l), c[11] = 0, c[12] = c[13] = c[14] = 0, c[15] = 1, a;
  }, e.extractRotation = function() {
    var s = new t.math.Matrix3(), o = (this || window).mat, a = s.mat;
    return a[0] = o[0], a[1] = o[1], a[2] = o[2], a[3] = o[4], a[4] = o[5], a[5] = o[6], a[6] = o[8], a[7] = o[9], a[8] = o[10], s;
  }, e.extractPlane = function(s) {
    var o = new t.math.Plane(), a = (this || window).mat;
    switch (s) {
      case t.math.Plane.RIGHT:
        o.a = a[3] - a[0], o.b = a[7] - a[4], o.c = a[11] - a[8], o.d = a[15] - a[12];
        break;
      case t.math.Plane.LEFT:
        o.a = a[3] + a[0], o.b = a[7] + a[4], o.c = a[11] + a[8], o.d = a[15] + a[12];
        break;
      case t.math.Plane.BOTTOM:
        o.a = a[3] + a[1], o.b = a[7] + a[5], o.c = a[11] + a[9], o.d = a[15] + a[13];
        break;
      case t.math.Plane.TOP:
        o.a = a[3] - a[1], o.b = a[7] - a[5], o.c = a[11] - a[9], o.d = a[15] - a[13];
        break;
      case t.math.Plane.FAR:
        o.a = a[3] - a[2], o.b = a[7] - a[6], o.c = a[11] - a[10], o.d = a[15] - a[14];
        break;
      case t.math.Plane.NEAR:
        o.a = a[3] + a[2], o.b = a[7] + a[6], o.c = a[11] + a[10], o.d = a[15] + a[14];
        break;
      default:
        t.log("cc.math.Matrix4.extractPlane: Invalid plane index");
        break;
    }
    var c = Math.sqrt(o.a * o.a + o.b * o.b + o.c * o.c);
    return o.a /= c, o.b /= c, o.c /= c, o.d /= c, o;
  }, e.toAxisAndAngle = function() {
    var s = (this || window).extractRotation(), o = t.math.Quaternion.rotationMatrix(s);
    return o.toAxisAndAngle();
  };
})(cc);
(function(t) {
  t.math.Plane = function(n, r, s, o) {
    n && r === void 0 ? (this.a = n.a, this.b = n.b, this.c = n.c, this.d = n.d) : (this.a = n || 0, this.b = r || 0, this.c = s || 0, this.d = o || 0);
  }, t.kmPlane = t.math.Plane;
  var e = t.math.Plane.prototype;
  t.math.Plane.LEFT = 0, t.math.Plane.RIGHT = 1, t.math.Plane.BOTTOM = 2, t.math.Plane.TOP = 3, t.math.Plane.NEAR = 4, t.math.Plane.FAR = 5, t.math.Plane.POINT_INFRONT_OF_PLANE = 0, t.math.Plane.POINT_BEHIND_PLANE = 1, t.math.Plane.POINT_ON_PLANE = 2, e.dot = function(n) {
    return this.a * n.x + this.b * n.y + this.c * n.z + this.d * n.w;
  }, e.dotCoord = function(n) {
    return this.a * n.x + this.b * n.y + this.c * n.z + this.d;
  }, e.dotNormal = function(n) {
    return this.a * n.x + this.b * n.y + this.c * n.z;
  }, t.math.Plane.fromPointNormal = function(n, r) {
    return new t.math.Plane(r.x, r.y, r.z, -r.dot(n));
  }, t.math.Plane.fromPoints = function(n, r, s) {
    var o = new t.math.Vec3(r), a = new t.math.Vec3(s), c = new t.math.Plane();
    return o.subtract(n), a.subtract(n), o.cross(a), o.normalize(), c.a = o.x, c.b = o.y, c.c = o.z, c.d = o.scale(-1).dot(n), c;
  }, e.normalize = function() {
    var n = new t.math.Vec3(this.a, this.b, this.c), r = 1 / n.length();
    return n.normalize(), this.a = n.x, this.b = n.y, this.c = n.z, this.d = (this || window).d * r, (this || window)
  }, e.classifyPoint = function(n) {
    var r = (this || window).a * n.x + this.b * n.y + this.c * n.z + this.d;
    return r > 1e-3 ? t.math.Plane.POINT_INFRONT_OF_PLANE : r < -1e-3 ? t.math.Plane.POINT_BEHIND_PLANE : t.math.Plane.POINT_ON_PLANE;
  };
})(cc);
(function(t) {
  t.math.Quaternion = function(n, r, s, o) {
    n && r === void 0 ? (this.x = n.x, this.y = n.y, this.z = n.z, this.w = n.w) : (this.x = n || 0, this.y = r || 0, this.z = s || 0, this.w = o || 0);
  }, t.kmQuaternion = t.math.Quaternion;
  var e = t.math.Quaternion.prototype;
  e.conjugate = function(n) {
    return this.x = -n.x, this.y = -n.y, this.z = -n.z, this.w = n.w, (this || window)
  }, e.dot = function(n) {
    return this.w * n.w + this.x * n.x + this.y * n.y + this.z * n.z;
  }, e.exponential = function() {
    return (this || window)
  }, e.identity = function() {
    return this.x = 0, this.y = 0, this.z = 0, this.w = 1, (this || window)
  }, e.inverse = function() {
    var n = (this || window).length();
    return Math.abs(n) > t.math.EPSILON ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0, this) : (this.conjugate(this).scale(1 / n), this);
  }, e.isIdentity = function() {
    return this.x === 0 && this.y === 0 && this.z === 0 && this.w === 1;
  }, e.length = function() {
    return Math.sqrt(this.lengthSq());
  }, e.lengthSq = function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }, e.multiply = function(n) {
    var r = (this || window).x, s = (this || window).y, o = (this || window).z, a = (this || window).w;
    return this.w = a * n.w - r * n.x - s * n.y - o * n.z, this.x = a * n.x + r * n.w + s * n.z - o * n.y, this.y = a * n.y + s * n.w + o * n.x - r * n.z, this.z = a * n.z + o * n.w + r * n.y - s * n.x, (this || window)
  }, e.normalize = function() {
    var n = (this || window).length();
    if (Math.abs(n) <= t.math.EPSILON)
      throw new Error("current quaternion is an invalid value");
    return this.scale(1 / n), (this || window)
  }, e.rotationAxis = function(n, r) {
    var s = r * 0.5, o = Math.sin(s);
    return this.w = Math.cos(s), this.x = n.x * o, this.y = n.y * o, this.z = n.z * o, (this || window)
  }, t.math.Quaternion.rotationMatrix = function(n) {
    if (!n)
      return null;
    var r, s, o, a, c = [], l = n.mat, h = 0;
    c[0] = l[0], c[1] = l[3], c[2] = l[6], c[4] = l[1], c[5] = l[4], c[6] = l[7], c[8] = l[2], c[9] = l[5], c[10] = l[8], c[15] = 1;
    var u = c[0], _ = u[0] + u[5] + u[10] + 1;
    return _ > t.math.EPSILON ? (h = Math.sqrt(_) * 2, r = (u[9] - u[6]) / h, s = (u[2] - u[8]) / h, o = (u[4] - u[1]) / h, a = 0.25 * h) : u[0] > u[5] && u[0] > u[10] ? (h = Math.sqrt(1 + u[0] - u[5] - u[10]) * 2, r = 0.25 * h, s = (u[4] + u[1]) / h, o = (u[2] + u[8]) / h, a = (u[9] - u[6]) / h) : u[5] > u[10] ? (h = Math.sqrt(1 + u[5] - u[0] - u[10]) * 2, r = (u[4] + u[1]) / h, s = 0.25 * h, o = (u[9] + u[6]) / h, a = (u[2] - u[8]) / h) : (h = Math.sqrt(1 + u[10] - u[0] - u[5]) * 2, r = (u[2] + u[8]) / h, s = (u[9] + u[6]) / h, o = 0.25 * h, a = (u[4] - u[1]) / h), new t.math.Quaternion(r, s, o, a);
  }, t.math.Quaternion.rotationYawPitchRoll = function(n, r, s) {
    var o, a, c, l, h, u, _, d, f, C, m;
    o = t.degreesToRadians(r) / 2, a = t.degreesToRadians(n) / 2, c = t.degreesToRadians(s) / 2, l = Math.cos(o), h = Math.cos(a), u = Math.cos(c), _ = Math.sin(o), d = Math.sin(a), f = Math.sin(c), C = h * u, m = d * f;
    var g = new t.math.Quaternion();
    return g.w = l * C + _ * m, g.x = _ * C - l * m, g.y = l * d * u + _ * h * f, g.z = l * h * f - _ * d * u, g.normalize(), g;
  }, e.slerp = function(n, r) {
    if (this.x === n.x && this.y === n.y && this.z === n.z && this.w === n.w)
      return (this || window)
    var s = (this || window).dot(n), o = Math.acos(s), a = Math.sqrt(1 - t.math.square(s)), c = Math.sin(r * o) / a, l = Math.sin((1 - r) * o) / a, h = new t.math.Quaternion(n);
    return this.scale(l), h.scale(c), this.add(h), (this || window)
  }, e.toAxisAndAngle = function() {
    var n, r, s, o = new t.math.Vec3();
    return n = Math.acos(this.w), r = Math.sqrt(t.math.square(this.x) + t.math.square(this.y) + t.math.square(this.z)), r > -t.math.EPSILON && r < t.math.EPSILON || r < 2 * Math.PI + t.math.EPSILON && r > 2 * Math.PI - t.math.EPSILON ? (s = 0, o.x = 0, o.y = 0, o.z = 1) : (s = n * 2, o.x = (this || window).x / r, o.y = (this || window).y / r, o.z = (this || window).z / r, o.normalize()), { axis: o, angle: s };
  }, e.scale = function(n) {
    return this.x *= n, this.y *= n, this.z *= n, this.w *= n, (this || window)
  }, e.assignFrom = function(n) {
    return this.x = n.x, this.y = n.y, this.z = n.z, this.w = n.w, (this || window)
  }, e.add = function(n) {
    return this.x += n.x, this.y += n.y, this.z += n.z, this.w += n.w, (this || window)
  }, t.math.Quaternion.rotationBetweenVec3 = function(n, r, s) {
    var o = new t.math.Vec3(n), a = new t.math.Vec3(r);
    o.normalize(), a.normalize();
    var c = o.dot(a), l = new t.math.Quaternion();
    if (c >= 1)
      return l.identity(), l;
    if (c < 1e-6 - 1)
      if (Math.abs(s.lengthSq()) < t.math.EPSILON)
        l.rotationAxis(s, Math.PI);
      else {
        var h = new t.math.Vec3(1, 0, 0);
        h.cross(n), Math.abs(h.lengthSq()) < t.math.EPSILON && (h.fill(0, 1, 0), h.cross(n)), h.normalize(), l.rotationAxis(h, Math.PI);
      }
    else {
      var u = Math.sqrt((1 + c) * 2), _ = 1 / u;
      o.cross(a), l.x = o.x * _, l.y = o.y * _, l.z = o.z * _, l.w = u * 0.5, l.normalize();
    }
    return l;
  }, e.multiplyVec3 = function(n) {
    var r = (this || window).x, s = (this || window).y, o = (this || window).z, a = new t.math.Vec3(n), c = new t.math.Vec3(r, s, o), l = new t.math.Vec3(r, s, o);
    return c.cross(n), l.cross(c), c.scale(2 * q.w), l.scale(2), a.add(c), a.add(l), a;
  };
})(cc);
cc.math.AABB = function(t, e) {
  this.min = t || new cc.math.Vec3(), this.max = e || new cc.math.Vec3();
};
cc.math.AABB.prototype.containsPoint = function(t) {
  return t.x >= (this || window).min.x && t.x <= (this || window).max.x && t.y >= (this || window).min.y && t.y <= (this || window).max.y && t.z >= (this || window).min.z && t.z <= (this || window).max.z;
};
cc.math.AABB.containsPoint = function(t, e) {
  return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y && t.z >= e.min.z && t.z <= e.max.z;
};
cc.math.AABB.prototype.assignFrom = function(t) {
  this.min.assignFrom(t.min), this.max.assignFrom(t.max);
};
cc.math.AABB.assign = function(t, e) {
  return t.min.assignFrom(e.min), t.max.assignFrom(e.max), t;
};
(function(t) {
  t.math.Matrix4Stack = function(n, r) {
    this.top = n, this.stack = r || [];
  }, t.km_mat4_stack = t.math.Matrix4Stack;
  var e = t.math.Matrix4Stack.prototype;
  e.initialize = function() {
    this.stack.length = 0, this.top = null;
  }, t.km_mat4_stack_push = function(n, r) {
    n.stack.push(n.top), n.top = new t.math.Matrix4(r);
  }, t.km_mat4_stack_pop = function(n, r) {
    n.top = n.stack.pop();
  }, t.km_mat4_stack_release = function(n) {
    n.stack = null, n.top = null;
  }, e.push = function(n) {
    n = n || this.top, this.stack.push(this.top), this.top = new t.math.Matrix4(n);
  }, e.pop = function() {
    this.top = (this || window).stack.pop();
  }, e.release = function() {
    this.stack = null, this.top = null, this._matrixPool = null;
  }, e._getFromPool = function(n) {
    var r = (this || window)._matrixPool;
    if (r.length === 0)
      return new t.math.Matrix4(n);
    var s = r.pop();
    return s.assignFrom(n), s;
  }, e._putInPool = function(n) {
    this._matrixPool.push(n);
  };
})(cc);
(function(t) {
  t.KM_GL_MODELVIEW = 5888, t.KM_GL_PROJECTION = 5889, t.KM_GL_TEXTURE = 5890, t.modelview_matrix_stack = new t.math.Matrix4Stack(), t.projection_matrix_stack = new t.math.Matrix4Stack(), t.texture_matrix_stack = new t.math.Matrix4Stack(), t.current_stack = null, t.lazyInitialize = function() {
    {
      var r = new t.math.Matrix4();
      t.modelview_matrix_stack.initialize(), t.projection_matrix_stack.initialize(), t.texture_matrix_stack.initialize(), t.current_stack = t.modelview_matrix_stack, t.initialized = !0, r.identity(), t.modelview_matrix_stack.push(r), t.projection_matrix_stack.push(r), t.texture_matrix_stack.push(r);
    }
  }, t.lazyInitialize(), t.kmGLFreeAll = function() {
    t.modelview_matrix_stack.release(), t.modelview_matrix_stack = null, t.projection_matrix_stack.release(), t.projection_matrix_stack = null, t.texture_matrix_stack.release(), t.texture_matrix_stack = null, t.initialized = !1, t.current_stack = null;
  }, t.kmGLPushMatrix = function() {
    t.current_stack.push(t.current_stack.top);
  }, t.kmGLPushMatrixWitMat4 = function(r) {
    t.current_stack.stack.push(t.current_stack.top), r.assignFrom(t.current_stack.top), t.current_stack.top = r;
  }, t.kmGLPopMatrix = function() {
    t.current_stack.top = t.current_stack.stack.pop();
  }, t.kmGLMatrixMode = function(r) {
    switch (r) {
      case t.KM_GL_MODELVIEW:
        t.current_stack = t.modelview_matrix_stack;
        break;
      case t.KM_GL_PROJECTION:
        t.current_stack = t.projection_matrix_stack;
        break;
      case t.KM_GL_TEXTURE:
        t.current_stack = t.texture_matrix_stack;
        break;
      default:
        throw new Error("Invalid matrix mode specified");
    }
  }, t.kmGLLoadIdentity = function() {
    t.current_stack.top.identity();
  }, t.kmGLLoadMatrix = function(r) {
    t.current_stack.top.assignFrom(r);
  }, t.kmGLMultMatrix = function(r) {
    t.current_stack.top.multiply(r);
  };
  var e = new t.math.Matrix4();
  t.kmGLTranslatef = function(r, s, o) {
    var a = t.math.Matrix4.createByTranslation(r, s, o, e);
    t.current_stack.top.multiply(a);
  };
  var n = new t.math.Vec3();
  t.kmGLRotatef = function(r, s, o, a) {
    n.fill(s, o, a);
    var c = t.math.Matrix4.createByAxisAndAngle(n, t.degreesToRadians(r), e);
    t.current_stack.top.multiply(c);
  }, t.kmGLScalef = function(r, s, o) {
    var a = t.math.Matrix4.createByScale(r, s, o, e);
    t.current_stack.top.multiply(a);
  }, t.kmGLGetMatrix = function(r, s) {
    switch (r) {
      case t.KM_GL_MODELVIEW:
        s.assignFrom(t.modelview_matrix_stack.top);
        break;
      case t.KM_GL_PROJECTION:
        s.assignFrom(t.projection_matrix_stack.top);
        break;
      case t.KM_GL_TEXTURE:
        s.assignFrom(t.texture_matrix_stack.top);
        break;
      default:
        throw new Error("Invalid matrix mode specified");
    }
  };
})(cc);
cc.SHADER_POSITION_UCOLOR_FRAG = `precision lowp float;
varying vec4 v_fragmentColor;
void main()                              
{ 
    gl_FragColor = v_fragmentColor;      
}
`;
cc.SHADER_POSITION_UCOLOR_VERT = `attribute vec4 a_position;
uniform    vec4 u_color;
uniform float u_pointSize;
varying lowp vec4 v_fragmentColor; 
void main(void)   
{
    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  
    gl_PointSize = u_pointSize;          
    v_fragmentColor = u_color;           
}`;
cc.SHADER_POSITION_COLOR_FRAG = `precision lowp float; 
varying vec4 v_fragmentColor; 
void main() 
{ 
     gl_FragColor = v_fragmentColor; 
} `;
cc.SHADER_POSITION_COLOR_VERT = `attribute vec4 a_position;
attribute vec4 a_color;
varying lowp vec4 v_fragmentColor;
void main()
{
    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  
    v_fragmentColor = a_color;             
}`;
cc.SHADER_SPRITE_POSITION_COLOR_VERT = `attribute vec4 a_position;
attribute vec4 a_color;
varying lowp vec4 v_fragmentColor;
void main()
{
    gl_Position = CC_PMatrix * a_position;  
    v_fragmentColor = a_color;             
}`;
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = `// #extension GL_OES_standard_derivatives : enable
varying mediump vec4 v_color;
varying mediump vec2 v_texcoord;
void main()	
{ 
// #if defined GL_OES_standard_derivatives	
// gl_FragColor = v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); 
// #else	
gl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord)); 
// #endif 
}`;
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = `attribute mediump vec4 a_position; 
attribute mediump vec2 a_texcoord; 
attribute mediump vec4 a_color;	
varying mediump vec4 v_color; 
varying mediump vec2 v_texcoord;	
void main() 
{ 
     v_color = a_color;//vec4(a_color.rgb * a_color.a, a_color.a); 
     v_texcoord = a_texcoord; 
    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  
}`;
cc.SHADER_POSITION_TEXTURE_FRAG = `precision lowp float;   
varying vec2 v_texCoord;  
void main() 
{  
    gl_FragColor =  texture2D(CC_Texture0, v_texCoord);   
}`;
cc.SHADER_POSITION_TEXTURE_VERT = `attribute vec4 a_position; 
attribute vec2 a_texCoord; 
varying mediump vec2 v_texCoord; 
void main() 
{ 
    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  
    v_texCoord = a_texCoord;               
}`;
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = `precision lowp float;  
uniform vec4 u_color; 
varying vec2 v_texCoord; 
void main() 
{  
    gl_FragColor =  texture2D(CC_Texture0, v_texCoord) * u_color;    
}`;
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = `attribute vec4 a_position;
attribute vec2 a_texCoord; 
varying mediump vec2 v_texCoord; 
void main() 
{ 
    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  
    v_texCoord = a_texCoord;                 
}`;
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = `precision lowp float;  
varying vec4 v_fragmentColor; 
varying vec2 v_texCoord; 
void main() 
{ 
    gl_FragColor = vec4( v_fragmentColor.rgb,         
        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   
    ); 
}`;
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = `attribute vec4 a_position; 
attribute vec2 a_texCoord; 
attribute vec4 a_color;  
varying lowp vec4 v_fragmentColor; 
varying mediump vec2 v_texCoord; 
void main() 
{ 
    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  
    v_fragmentColor = a_color; 
    v_texCoord = a_texCoord; 
}`;
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = `precision lowp float;
varying vec4 v_fragmentColor; 
varying vec2 v_texCoord; 
void main() 
{ 
    gl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord); 
}`;
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = `attribute vec4 a_position; 
attribute vec2 a_texCoord; 
attribute vec4 a_color;  
varying lowp vec4 v_fragmentColor; 
varying mediump vec2 v_texCoord; 
void main() 
{ 
    gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;  
    v_fragmentColor = a_color; 
    v_texCoord = a_texCoord; 
}`;
cc.SHADER_SPRITE_POSITION_TEXTURE_COLOR_VERT = `attribute vec4 a_position; 
attribute vec2 a_texCoord; 
attribute vec4 a_color;  
varying lowp vec4 v_fragmentColor; 
varying mediump vec2 v_texCoord; 
void main() 
{ 
    gl_Position = CC_PMatrix * a_position;  
    v_fragmentColor = a_color; 
    v_texCoord = a_texCoord; 
}`;
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = `precision lowp float;   
varying vec4 v_fragmentColor; 
varying vec2 v_texCoord;   
uniform float CC_alpha_value; 
void main() 
{  
    vec4 texColor = texture2D(CC_Texture0, v_texCoord);  
    if ( texColor.a <= CC_alpha_value )          
        discard; 
    gl_FragColor = texColor * v_fragmentColor;  
}`;
cc.SHADEREX_SWITCHMASK_FRAG = `precision lowp float; 
varying vec4 v_fragmentColor; 
varying vec2 v_texCoord; 
uniform sampler2D u_texture;  
uniform sampler2D   u_mask;   
void main()  
{  
    vec4 texColor   = texture2D(u_texture, v_texCoord);  
    vec4 maskColor  = texture2D(u_mask, v_texCoord); 
    vec4 finalColor = vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        
    gl_FragColor    = v_fragmentColor * finalColor; 
}`;
cc.shaderCache = {
  TYPE_POSITION_TEXTURECOLOR: 0,
  TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
  TYPE_POSITION_COLOR: 2,
  TYPE_POSITION_TEXTURE: 3,
  TYPE_POSITION_TEXTURE_UCOLOR: 4,
  TYPE_POSITION_TEXTURE_A8COLOR: 5,
  TYPE_POSITION_UCOLOR: 6,
  TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
  TYPE_SPRITE_POSITION_TEXTURECOLOR: 8,
  TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST: 9,
  TYPE_SPRITE_POSITION_COLOR: 10,
  TYPE_MAX: 10,
  _programs: {},
  _init: function() {
    return this.loadDefaultShaders(), !0;
  },
  _loadDefaultShader: function(t, e) {
    switch (e) {
      case this.TYPE_POSITION_TEXTURECOLOR:
        t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
        break;
      case this.TYPE_SPRITE_POSITION_TEXTURECOLOR:
        t.initWithVertexShaderByteArray(cc.SHADER_SPRITE_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
        break;
      case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
        t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
        break;
      case this.TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST:
        t.initWithVertexShaderByteArray(cc.SHADER_SPRITE_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
        break;
      case this.TYPE_POSITION_COLOR:
        t.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
        break;
      case this.TYPE_SPRITE_POSITION_COLOR:
        t.initWithVertexShaderByteArray(cc.SHADER_SPRITE_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
        break;
      case this.TYPE_POSITION_TEXTURE:
        t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
        break;
      case this.TYPE_POSITION_TEXTURE_UCOLOR:
        t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
        break;
      case this.TYPE_POSITION_TEXTURE_A8COLOR:
        t.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT, cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
        break;
      case this.TYPE_POSITION_UCOLOR:
        t.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG), t.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
        break;
      case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
        t.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT, cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG), t.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), t.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS), t.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
        break;
      default:
        cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
        return;
    }
    t.link(), t.updateUniforms();
  },
  loadDefaultShaders: function() {
    var t = new cc.GLProgram();
    this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR), this._programs[cc.SHADER_POSITION_TEXTURECOLOR] = t, this._programs.ShaderPositionTextureColor = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_SPRITE_POSITION_TEXTURECOLOR), this._programs[cc.SHADER_SPRITE_POSITION_TEXTURECOLOR] = t, this._programs.ShaderSpritePositionTextureColor = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST), this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = t, this._programs.ShaderPositionTextureColorAlphaTest = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST), this._programs[cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST] = t, this._programs.ShaderSpritePositionTextureColorAlphaTest = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_POSITION_COLOR), this._programs[cc.SHADER_POSITION_COLOR] = t, this._programs.ShaderPositionColor = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_SPRITE_POSITION_COLOR), this._programs[cc.SHADER_SPRITE_POSITION_COLOR] = t, this._programs.ShaderSpritePositionColor = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE), this._programs[cc.SHADER_POSITION_TEXTURE] = t, this._programs.ShaderPositionTexture = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_UCOLOR), this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = t, this._programs.ShaderPositionTextureUColor = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_A8COLOR), this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = t, this._programs.ShaderPositionTextureA8Color = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_POSITION_UCOLOR), this._programs[cc.SHADER_POSITION_UCOLOR] = t, this._programs.ShaderPositionUColor = t, t = new cc.GLProgram(), this._loadDefaultShader(t, this.TYPE_POSITION_LENGTH_TEXTURECOLOR), this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = t, this._programs.ShaderPositionLengthTextureColor = t;
  },
  reloadDefaultShaders: function() {
    var t = (this || window).programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
    t.reset(), this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR), t = (this || window).programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLOR), t.reset(), this._loadDefaultShader(t, this.TYPE_SPRITE_POSITION_TEXTURECOLOR), t = (this || window).programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), t.reset(), this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST), t = (this || window).programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST), t.reset(), this._loadDefaultShader(t, this.TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST), t = (this || window).programForKey(cc.SHADER_POSITION_COLOR), t.reset(), this._loadDefaultShader(t, this.TYPE_POSITION_COLOR), t = (this || window).programForKey(cc.SHADER_POSITION_TEXTURE), t.reset(), this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE), t = (this || window).programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR), t.reset(), this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_UCOLOR), t = (this || window).programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR), t.reset(), this._loadDefaultShader(t, this.TYPE_POSITION_TEXTURE_A8COLOR), t = (this || window).programForKey(cc.SHADER_POSITION_UCOLOR), t.reset(), this._loadDefaultShader(t, this.TYPE_POSITION_UCOLOR);
  },
  programForKey: function(t) {
    return this._programs[t];
  },
  getProgram: function(t) {
    return this._programs[t];
  },
  addProgram: function(t, e) {
    this._programs[e] = t;
  }
};
cc.GLProgram = cc.Class.extend({
  _glContext: null,
  _programObj: null,
  _vertShader: null,
  _fragShader: null,
  _uniforms: null,
  _hashForUniforms: null,
  _usesTime: !1,
  _updateUniformLocation: function(t) {
    if (!t)
      return !1;
    var e, n = (this || window)._hashForUniforms[t];
    if (!n)
      n = [
        arguments[1],
        arguments[2],
        arguments[3],
        arguments[4]
      ], this._hashForUniforms[t] = n, e = !0;
    else {
      e = !1;
      for (var r = arguments.length - 1, s = 0; s < r; ++s)
        arguments[s + 1] !== n[s] && (n[s] = arguments[s + 1], e = !0);
    }
    return e;
  },
  _description: function() {
    return "<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">";
  },
  _compileShader: function(t, e, n) {
    if (!n || !t)
      return !1;
    var r = cc.GLProgram._isHighpSupported() ? `precision highp float;
` : `precision mediump float;
`;
    n = r + `uniform mat4 CC_PMatrix;         
uniform mat4 CC_MVMatrix;        
uniform mat4 CC_MVPMatrix;       
uniform vec4 CC_Time;            
uniform vec4 CC_SinTime;         
uniform vec4 CC_CosTime;         
uniform vec4 CC_Random01;        
uniform sampler2D CC_Texture0;   
//CC INCLUDES END                
` + n, this._glContext.shaderSource(t, n), this._glContext.compileShader(t);
    var s = (this || window)._glContext.getShaderParameter(t, this._glContext.COMPILE_STATUS);
    return s || (cc.log(`cocos2d: ERROR: Failed to compile shader:
` + this._glContext.getShaderSource(t)), e === (this || window)._glContext.VERTEX_SHADER ? cc.log(`cocos2d: 
` + this.vertexShaderLog()) : cc.log(`cocos2d: 
` + this.fragmentShaderLog())), s === !0;
  },
  ctor: function(t, e, n) {
    this._uniforms = {}, this._hashForUniforms = {}, this._glContext = n || cc._renderContext, t && e && this.init(t, e);
  },
  destroyProgram: function() {
    this._vertShader = null, this._fragShader = null, this._uniforms = null, this._hashForUniforms = null, this._glContext.deleteProgram(this._programObj);
  },
  initWithVertexShaderByteArray: function(t, e) {
    var n = (this || window)._glContext;
    this._programObj = n.createProgram(), this._vertShader = null, this._fragShader = null, t && (this._vertShader = n.createShader(n.VERTEX_SHADER), this._compileShader(this._vertShader, n.VERTEX_SHADER, t) || cc.log("cocos2d: ERROR: Failed to compile vertex shader")), e && (this._fragShader = n.createShader(n.FRAGMENT_SHADER), this._compileShader(this._fragShader, n.FRAGMENT_SHADER, e) || cc.log("cocos2d: ERROR: Failed to compile fragment shader")), this._vertShader && n.attachShader(this._programObj, this._vertShader), cc.checkGLErrorDebug(), this._fragShader && n.attachShader(this._programObj, this._fragShader);
    for (var r in this._hashForUniforms)
      delete this._hashForUniforms[r];
    return cc.checkGLErrorDebug(), !0;
  },
  initWithString: function(t, e) {
    return this.initWithVertexShaderByteArray(t, e);
  },
  initWithVertexShaderFilename: function(t, e) {
    var n = cc.loader.getRes(t);
    if (!n)
      throw new Error("Please load the resource firset : " + t);
    var r = cc.loader.getRes(e);
    if (!r)
      throw new Error("Please load the resource firset : " + e);
    return this.initWithVertexShaderByteArray(n, r);
  },
  init: function(t, e) {
    return this.initWithVertexShaderFilename(t, e);
  },
  addAttribute: function(t, e) {
    this._glContext.bindAttribLocation(this._programObj, e, t);
  },
  link: function() {
    if (!this._programObj)
      return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
    if (this._glContext.linkProgram(this._programObj), this._vertShader && this._glContext.deleteShader(this._vertShader), this._fragShader && this._glContext.deleteShader(this._fragShader), this._vertShader = null, this._fragShader = null, cc.game.config[cc.game.CONFIG_KEY.debugMode]) {
      var t = (this || window)._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS);
      if (!t)
        return cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1;
    }
    return !0;
  },
  use: function() {
    cc.glUseProgram(this._programObj);
  },
  updateUniforms: function() {
    this._uniforms[cc.UNIFORM_PMATRIX_S] = (this || window)._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S), this._uniforms[cc.UNIFORM_MVMATRIX_S] = (this || window)._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S), this._uniforms[cc.UNIFORM_MVPMATRIX_S] = (this || window)._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S), this._uniforms[cc.UNIFORM_TIME_S] = (this || window)._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S), this._uniforms[cc.UNIFORM_SINTIME_S] = (this || window)._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S), this._uniforms[cc.UNIFORM_COSTIME_S] = (this || window)._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S), this._usesTime = (this || window)._uniforms[cc.UNIFORM_TIME_S] != null || this._uniforms[cc.UNIFORM_SINTIME_S] != null || this._uniforms[cc.UNIFORM_COSTIME_S] != null, this._uniforms[cc.UNIFORM_RANDOM01_S] = (this || window)._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S), this._uniforms[cc.UNIFORM_SAMPLER_S] = (this || window)._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S), this.use(), this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER_S], 0);
  },
  _addUniformLocation: function(t) {
    var e = (this || window)._glContext.getUniformLocation(this._programObj, t);
    this._uniforms[t] = e;
  },
  getUniformLocationForName: function(t) {
    if (!t)
      throw new Error("cc.GLProgram.getUniformLocationForName(): uniform name should be non-null");
    if (!this._programObj)
      throw new Error("cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized");
    var e = (this || window)._uniforms[t] || this._glContext.getUniformLocation(this._programObj, t);
    return e;
  },
  getUniformMVPMatrix: function() {
    return this._uniforms[cc.UNIFORM_MVPMATRIX_S];
  },
  getUniformSampler: function() {
    return this._uniforms[cc.UNIFORM_SAMPLER_S];
  },
  setUniformLocationWith1i: function(t, e) {
    var n = (this || window)._glContext;
    if (typeof t == "string") {
      var r = (this || window)._updateUniformLocation(t, e);
      if (r) {
        var s = (this || window).getUniformLocationForName(t);
        n.uniform1i(s, e);
      }
    } else
      n.uniform1i(t, e);
  },
  setUniformLocationWith2i: function(t, e, n) {
    var r = (this || window)._glContext;
    if (typeof t == "string") {
      var s = (this || window)._updateUniformLocation(t, e, n);
      if (s) {
        var o = (this || window).getUniformLocationForName(t);
        r.uniform2i(o, e, n);
      }
    } else
      r.uniform2i(t, e, n);
  },
  setUniformLocationWith3i: function(t, e, n, r) {
    var s = (this || window)._glContext;
    if (typeof t == "string") {
      var o = (this || window)._updateUniformLocation(t, e, n, r);
      if (o) {
        var a = (this || window).getUniformLocationForName(t);
        s.uniform3i(a, e, n, r);
      }
    } else
      s.uniform3i(t, e, n, r);
  },
  setUniformLocationWith4i: function(t, e, n, r, s) {
    var o = (this || window)._glContext;
    if (typeof t == "string") {
      var a = (this || window)._updateUniformLocation(t, e, n, r, s);
      if (a) {
        var c = (this || window).getUniformLocationForName(t);
        o.uniform4i(c, e, n, r, s);
      }
    } else
      o.uniform4i(t, e, n, r, s);
  },
  setUniformLocationWith2iv: function(t, e) {
    var n = typeof t == "string" ? this.getUniformLocationForName(t) : t;
    this._glContext.uniform2iv(n, e);
  },
  setUniformLocationWith3iv: function(t, e) {
    var n = typeof t == "string" ? this.getUniformLocationForName(t) : t;
    this._glContext.uniform3iv(n, e);
  },
  setUniformLocationWith4iv: function(t, e) {
    var n = typeof t == "string" ? this.getUniformLocationForName(t) : t;
    this._glContext.uniform4iv(n, e);
  },
  setUniformLocationI32: function(t, e) {
    this.setUniformLocationWith1i(t, e);
  },
  setUniformLocationWith1f: function(t, e) {
    var n = (this || window)._glContext;
    if (typeof t == "string") {
      var r = (this || window)._updateUniformLocation(t, e);
      if (r) {
        var s = (this || window).getUniformLocationForName(t);
        n.uniform1f(s, e);
      }
    } else
      n.uniform1f(t, e);
  },
  setUniformLocationWith2f: function(t, e, n) {
    var r = (this || window)._glContext;
    if (typeof t == "string") {
      var s = (this || window)._updateUniformLocation(t, e, n);
      if (s) {
        var o = (this || window).getUniformLocationForName(t);
        r.uniform2f(o, e, n);
      }
    } else
      r.uniform2f(t, e, n);
  },
  setUniformLocationWith3f: function(t, e, n, r) {
    var s = (this || window)._glContext;
    if (typeof t == "string") {
      var o = (this || window)._updateUniformLocation(t, e, n, r);
      if (o) {
        var a = (this || window).getUniformLocationForName(t);
        s.uniform3f(a, e, n, r);
      }
    } else
      s.uniform3f(t, e, n, r);
  },
  setUniformLocationWith4f: function(t, e, n, r, s) {
    var o = (this || window)._glContext;
    if (typeof t == "string") {
      var a = (this || window)._updateUniformLocation(t, e, n, r, s);
      if (a) {
        var c = (this || window).getUniformLocationForName(t);
        o.uniform4f(c, e, n, r, s);
      }
    } else
      o.uniform4f(t, e, n, r, s);
  },
  setUniformLocationWith2fv: function(t, e) {
    var n = typeof t == "string" ? this.getUniformLocationForName(t) : t;
    this._glContext.uniform2fv(n, e);
  },
  setUniformLocationWith3fv: function(t, e) {
    var n = typeof t == "string" ? this.getUniformLocationForName(t) : t;
    this._glContext.uniform3fv(n, e);
  },
  setUniformLocationWith4fv: function(t, e) {
    var n = typeof t == "string" ? this.getUniformLocationForName(t) : t;
    this._glContext.uniform4fv(n, e);
  },
  setUniformLocationWithMatrix4fv: function(t, e) {
    var n = typeof t == "string" ? this.getUniformLocationForName(t) : t;
    this._glContext.uniformMatrix4fv(n, !1, e);
  },
  setUniformLocationF32: function() {
    if (!(arguments.length < 2))
      switch (arguments.length) {
        case 2:
          this.setUniformLocationWith1f(arguments[0], arguments[1]);
          break;
        case 3:
          this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
          break;
        case 4:
          this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
          break;
        case 5:
          this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
          break;
      }
  },
  setUniformsForBuiltins: function() {
    var t = new cc.math.Matrix4(), e = new cc.math.Matrix4(), n = new cc.math.Matrix4();
    if (cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, t), cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, e), cc.kmMat4Multiply(n, t, e), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S], t.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX_S], e.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX_S], n.mat, 1), this._usesTime) {
      var r = cc.director, s = r.getTotalFrames() * r.getAnimationInterval();
      this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME_S], s / 10, s, s * 2, s * 4), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME_S], s / 8, s / 4, s / 2, Math.sin(s)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME_S], s / 8, s / 4, s / 2, Math.cos(s));
    }
    this._uniforms[cc.UNIFORM_RANDOM01_S] !== -1 && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01_S], Math.random(), Math.random(), Math.random(), Math.random());
  },
  _setUniformsForBuiltinsForRenderer: function(t) {
    if (!(!t || !t._renderCmd)) {
      var e = new cc.math.Matrix4(), n = new cc.math.Matrix4();
      if (cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, e), cc.kmMat4Multiply(n, e, t._renderCmd._stackMatrix), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S], e.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX_S], t._renderCmd._stackMatrix.mat, 1), this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX_S], n.mat, 1), this._usesTime) {
        var r = cc.director, s = r.getTotalFrames() * r.getAnimationInterval();
        this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME_S], s / 10, s, s * 2, s * 4), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME_S], s / 8, s / 4, s / 2, Math.sin(s)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME_S], s / 8, s / 4, s / 2, Math.cos(s));
      }
      this._uniforms[cc.UNIFORM_RANDOM01_S] !== -1 && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01_S], Math.random(), Math.random(), Math.random(), Math.random());
    }
  },
  setUniformForModelViewProjectionMatrix: function() {
    this._glContext.uniformMatrix4fv(
      this._uniforms[cc.UNIFORM_MVPMATRIX_S],
      !1,
      cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top)
    );
  },
  setUniformForModelViewProjectionMatrixWithMat4: function(t) {
    cc.kmMat4Multiply(t, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top), this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX_S], !1, t.mat);
  },
  setUniformForModelViewAndProjectionMatrixWithMat4: function() {
    this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX_S], !1, cc.modelview_matrix_stack.top.mat), this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S], !1, cc.projection_matrix_stack.top.mat);
  },
  _setUniformForMVPMatrixWithMat4: function(t) {
    if (!t)
      throw new Error("modelView matrix is undefined.");
    this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX_S], !1, t.mat), this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S], !1, cc.projection_matrix_stack.top.mat);
  },
  _updateProjectionUniform: function() {
    this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX_S], !1, cc.projection_matrix_stack.top.mat);
  },
  vertexShaderLog: function() {
    return this._glContext.getShaderInfoLog(this._vertShader);
  },
  getVertexShaderLog: function() {
    return this._glContext.getShaderInfoLog(this._vertShader);
  },
  getFragmentShaderLog: function() {
    return this._glContext.getShaderInfoLog(this._vertShader);
  },
  fragmentShaderLog: function() {
    return this._glContext.getShaderInfoLog(this._fragShader);
  },
  programLog: function() {
    return this._glContext.getProgramInfoLog(this._programObj);
  },
  getProgramLog: function() {
    return this._glContext.getProgramInfoLog(this._programObj);
  },
  reset: function() {
    this._vertShader = null, this._fragShader = null, this._uniforms.length = 0, this._glContext.deleteProgram(this._programObj), this._programObj = null;
    for (var t in this._hashForUniforms)
      this._hashForUniforms[t].length = 0, delete this._hashForUniforms[t];
  },
  getProgram: function() {
    return this._programObj;
  },
  retain: function() {
  },
  release: function() {
  }
});
cc.GLProgram.create = function(t, e) {
  return new cc.GLProgram(t, e);
};
cc.GLProgram._highpSupported = null;
cc.GLProgram._isHighpSupported = function() {
  if (cc.GLProgram._highpSupported == null) {
    var t = cc._renderContext, e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
    cc.GLProgram._highpSupported = e.precision !== 0;
  }
  return cc.GLProgram._highpSupported;
};
cc.setProgram = function(t, e) {
  t.shaderProgram = e;
  var n = t.children;
  if (n)
    for (var r = 0; r < n.length; r++)
      cc.setProgram(n[r], e);
};
cc._currentProjectionMatrix = -1;
if (cc.ENABLE_GL_STATE_CACHE) {
  cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0);
  var _currBuffers = {};
  WebGLRenderingContext.prototype.glBindBuffer = WebGLRenderingContext.prototype.bindBuffer, WebGLRenderingContext.prototype.bindBuffer = function(t, e) {
    return _currBuffers[t] !== e ? (this.glBindBuffer(t, e), _currBuffers[t] = e, !1) : !0;
  }, WebGLRenderingContext.prototype.glEnableVertexAttribArray = WebGLRenderingContext.prototype.enableVertexAttribArray, WebGLRenderingContext.prototype.enableVertexAttribArray = function(t) {
    t === cc.VERTEX_ATTRIB_FLAG_POSITION ? this._vertexAttribPosition || (this.glEnableVertexAttribArray(t), this._vertexAttribPosition = !0) : t === cc.VERTEX_ATTRIB_FLAG_COLOR ? this._vertexAttribColor || (this.glEnableVertexAttribArray(t), this._vertexAttribColor = !0) : t === cc.VERTEX_ATTRIB_FLAG_TEX_COORDS ? this._vertexAttribTexCoords || (this.glEnableVertexAttribArray(t), this._vertexAttribTexCoords = !0) : this.glEnableVertexAttribArray(t);
  }, WebGLRenderingContext.prototype.glDisableVertexAttribArray = WebGLRenderingContext.prototype.disableVertexAttribArray, WebGLRenderingContext.prototype.disableVertexAttribArray = function(t) {
    t === cc.VERTEX_ATTRIB_FLAG_COLOR ? this._vertexAttribColor && (this.glDisableVertexAttribArray(t), this._vertexAttribColor = !1) : t === cc.VERTEX_ATTRIB_FLAG_TEX_COORDS ? this._vertexAttribTexCoords && (this.glDisableVertexAttribArray(t), this._vertexAttribTexCoords = !1) : t !== 0 && this.glDisableVertexAttribArray(t);
  };
}
cc.glInvalidateStateCache = function() {
  if (cc.kmGLFreeAll(), cc._currentProjectionMatrix = -1, cc.ENABLE_GL_STATE_CACHE) {
    cc._currentShaderProgram = -1;
    for (var t = 0; t < cc.MAX_ACTIVETEXTURE; t++)
      cc._currentBoundTexture[t] = -1;
    cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0;
  }
};
cc.glUseProgram = cc.ENABLE_GL_STATE_CACHE ? function(t) {
  t !== cc._currentShaderProgram && (cc._currentShaderProgram = t, cc._renderContext.useProgram(t));
} : function(t) {
  cc._renderContext.useProgram(t);
};
cc.glDeleteProgram = function(t) {
  cc.ENABLE_GL_STATE_CACHE && t === cc._currentShaderProgram && (cc._currentShaderProgram = -1), gl.deleteProgram(t);
};
cc.setBlending = function(t, e) {
  var n = cc._renderContext;
  t === n.ONE && e === n.ZERO ? n.disable(n.BLEND) : (n.enable(n.BLEND), cc._renderContext.blendFunc(t, e));
};
cc.glBlendFunc = cc.ENABLE_GL_STATE_CACHE ? function(t, e) {
  (t !== cc._blendingSource || e !== cc._blendingDest) && (cc._blendingSource = t, cc._blendingDest = e, cc.setBlending(t, e));
} : cc.setBlending;
cc.glBlendFuncForParticle = function(t, e) {
  if (t !== cc._blendingSource || e !== cc._blendingDest) {
    cc._blendingSource = t, cc._blendingDest = e;
    var n = cc._renderContext;
    t === n.ONE && e === n.ZERO ? n.disable(n.BLEND) : (n.enable(n.BLEND), n.blendFuncSeparate(n.SRC_ALPHA, e, t, e));
  }
};
cc.glBlendResetToCache = function() {
  var t = cc._renderContext;
  t.blendEquation(t.FUNC_ADD), cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(t.BLEND_SRC, t.BLEND_DST);
};
cc.setProjectionMatrixDirty = function() {
  cc._currentProjectionMatrix = -1;
};
cc.glBindTexture2D = function(t) {
  cc.glBindTexture2DN(0, t);
};
cc.glBindTexture2DN = cc.ENABLE_GL_STATE_CACHE ? function(t, e) {
  if (cc._currentBoundTexture[t] !== e) {
    cc._currentBoundTexture[t] = e;
    var n = cc._renderContext;
    n.activeTexture(n.TEXTURE0 + t), e ? n.bindTexture(n.TEXTURE_2D, e._webTextureObj) : n.bindTexture(n.TEXTURE_2D, null);
  }
} : function(t, e) {
  var n = cc._renderContext;
  n.activeTexture(n.TEXTURE0 + t), e ? n.bindTexture(n.TEXTURE_2D, e._webTextureObj) : n.bindTexture(n.TEXTURE_2D, null);
};
cc.glDeleteTexture = function(t) {
  cc.glDeleteTextureN(0, t);
};
cc.glDeleteTextureN = function(t, e) {
  cc.ENABLE_GL_STATE_CACHE && e === cc._currentBoundTexture[t] && (cc._currentBoundTexture[t] = -1), cc._renderContext.deleteTexture(e._webTextureObj);
};
cc.glBindVAO = function(t) {
  cc.TEXTURE_ATLAS_USE_VAO && cc.ENABLE_GL_STATE_CACHE && cc._uVAO !== t && (cc._uVAO = t);
};
cc.glEnable = function(t) {
  cc.ENABLE_GL_STATE_CACHE;
};
cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 9;
cc.NextPOT = function(t) {
  return t = t - 1, t = t | t >> 1, t = t | t >> 2, t = t | t >> 4, t = t | t >> 8, t = t | t >> 16, t + 1;
};
cc.RenderTexture = cc.Node.extend({
  sprite: null,
  clearFlags: 0,
  clearDepthVal: 0,
  autoDraw: !1,
  _texture: null,
  _pixelFormat: 0,
  clearStencilVal: 0,
  _clearColor: null,
  _className: "RenderTexture",
  ctor: function(t, e, n, r) {
    cc.Node.prototype.ctor.call(this), this._cascadeColorEnabled = !0, this._cascadeOpacityEnabled = !0, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this._clearColor = new cc.Color(0, 0, 0, 255), t !== void 0 && e !== void 0 && (n = n || cc.Texture2D.PIXEL_FORMAT_RGBA8888, r = r || 0, this.initWithWidthAndHeight(t, e, n, r)), this.setAnchorPoint(0, 0);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.RenderTexture.CanvasRenderCmd(this) : new cc.RenderTexture.WebGLRenderCmd(this);
  },
  cleanup: function() {
    cc.Node.prototype.onExit.call(this), this._renderCmd.cleanup();
  },
  getSprite: function() {
    return this.sprite;
  },
  setSprite: function(t) {
    this.sprite = t;
  },
  setVirtualViewport: function(t, e, n) {
    this._renderCmd.setVirtualViewport(t, e, n);
  },
  initWithWidthAndHeight: function(t, e, n, r) {
    return this._renderCmd.initWithWidthAndHeight(t, e, n, r);
  },
  begin: function() {
    cc.renderer._turnToCacheMode(this.__instanceId), this._renderCmd.begin();
  },
  beginWithClear: function(t, e, n, r, s, o) {
    var a = cc._renderContext;
    s = s || a.COLOR_BUFFER_BIT, o = o || a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT, this._beginWithClear(t, e, n, r, s, o, a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT | a.STENCIL_BUFFER_BIT);
  },
  _beginWithClear: function(t, e, n, r, s, o, a) {
    this.begin(), this._renderCmd._beginWithClear(t, e, n, r, s, o, a);
  },
  end: function() {
    this._renderCmd.end();
  },
  clear: function(t, e, n, r) {
    this.beginWithClear(t, e, n, r), this.end();
  },
  clearRect: function(t, e, n, r) {
    this._renderCmd.clearRect(t, e, n, r);
  },
  clearDepth: function(t) {
    this._renderCmd.clearDepth(t);
  },
  clearStencil: function(t) {
    this._renderCmd.clearStencil(t);
  },
  getClearFlags: function() {
    return this.clearFlags;
  },
  setClearFlags: function(t) {
    this.clearFlags = t;
  },
  getClearColor: function() {
    return this._clearColor;
  },
  setClearColor: function(t) {
    var e = (this || window)._clearColor;
    e.r = t.r, e.g = t.g, e.b = t.b, e.a = t.a, this._renderCmd.updateClearColor(t);
  },
  getClearDepth: function() {
    return this.clearDepthVal;
  },
  setClearDepth: function(t) {
    this.clearDepthVal = t;
  },
  getClearStencil: function() {
    return this.clearStencilVal;
  },
  setClearStencil: function(t) {
    this.clearStencilVal = t;
  },
  isAutoDraw: function() {
    return this.autoDraw;
  },
  setAutoDraw: function(t) {
    this.autoDraw = t;
  },
  saveToFile: function(t, e) {
    cc.log("saveToFile isn't supported on Cocos2d-Html5");
  },
  newCCImage: function(t) {
    return cc.log("saveToFile isn't supported on cocos2d-html5"), null;
  },
  listenToBackground: function(t) {
  },
  listenToForeground: function(t) {
  }
});
var _p = cc.RenderTexture.prototype;
_p.clearColorVal;
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
cc.RenderTexture.create = function(t, e, n, r) {
  return new cc.RenderTexture(t, e, n, r);
};
(function() {
  cc.RenderTexture.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !0, this._clearColorStr = "rgba(255,255,255,1)", this._cacheCanvas = document.createElement("canvas"), this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"));
  };
  var t = cc.RenderTexture.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.RenderTexture.CanvasRenderCmd, t.cleanup = function() {
    this._cacheContext = null, this._cacheCanvas = null;
  }, t.clearStencil = function(e) {
  }, t.setVirtualViewport = function(e, n, r) {
  }, t.updateClearColor = function(e) {
    this._clearColorStr = "rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")";
  }, t.initWithWidthAndHeight = function(e, n, r, s) {
    var o = (this || window)._node, a = (this || window)._cacheCanvas, c = cc.contentScaleFactor();
    a.width = 0 | e * c, a.height = 0 | n * c;
    var l = new cc.Texture2D();
    l.initWithElement(a), l.handleLoadedTexture();
    var h = o.sprite = new cc.Sprite(l);
    return h.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA), o.autoDraw = !1, o.addChild(h), !0;
  }, t.begin = function() {
  }, t._beginWithClear = function(e, n, r, s, o, a, c) {
    e = e || 0, n = n || 0, r = r || 0, s = isNaN(s) ? 255 : s;
    var l = (this || window)._cacheContext.getContext(), h = (this || window)._cacheCanvas;
    l.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.setFillStyle("rgba(" + (0 | e) + "," + (0 | n) + "," + (0 | r) + "," + s / 255 + ")"), l.clearRect(0, 0, h.width, h.height), l.fillRect(0, 0, h.width, h.height);
  }, t.end = function() {
    var e = (this || window)._node, n = cc.contentScaleFactor();
    cc.renderer._renderingToCacheCanvas(this._cacheContext, e.__instanceId, n, n);
    var r = e.sprite._renderCmd;
    r._notifyRegionStatus && r._notifyRegionStatus(cc.Node.CanvasRenderCmd.RegionStatus.Dirty);
  }, t.clearRect = function(e, n, r, s) {
    this._cacheContext.clearRect(e, n, r, -s);
  }, t.clearDepth = function(e) {
    cc.log("clearDepth isn't supported on Cocos2d-Html5");
  }, t.visit = function(e) {
    var n = (this || window)._node;
    this._syncStatus(e), n.sprite.visit(this), this._dirtyFlag = 0;
  };
})();
(function() {
  cc.RenderTexture.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._fBO = null, this._oldFBO = null, this._textureCopy = null, this._depthRenderBuffer = null, this._rtTextureRect = new cc.Rect(), this._fullRect = new cc.Rect(), this._fullViewport = new cc.Rect();
  };
  var t = cc.RenderTexture.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.RenderTexture.WebGLRenderCmd, t.setVirtualViewport = function(e, n, r) {
    this._rtTextureRect.x = e.x, this._rtTextureRect.y = e.y, this._fullRect = n, this._fullViewport = r;
  }, t.needDraw = function() {
    return this._needDraw && this._node.autoDraw;
  }, t.rendering = function(e) {
    var n = e || cc._renderContext, r = (this || window)._node;
    if (r.autoDraw) {
      r.begin();
      var s = r.clearFlags;
      if (s) {
        var o = [0, 0, 0, 0], a = 0, c = 0;
        s & n.COLOR_BUFFER_BIT && (o = n.getParameter(n.COLOR_CLEAR_VALUE), n.clearColor(r._clearColor.r / 255, r._clearColor.g / 255, r._clearColor.b / 255, r._clearColor.a / 255)), s & n.DEPTH_BUFFER_BIT && (a = n.getParameter(n.DEPTH_CLEAR_VALUE), n.clearDepth(r.clearDepthVal)), s & n.STENCIL_BUFFER_BIT && (c = n.getParameter(n.STENCIL_CLEAR_VALUE), n.clearStencil(r.clearStencilVal)), n.clear(s), s & n.COLOR_BUFFER_BIT && n.clearColor(o[0], o[1], o[2], o[3]), s & n.DEPTH_BUFFER_BIT && n.clearDepth(a), s & n.STENCIL_BUFFER_BIT && n.clearStencil(c);
      }
      r.sortAllChildren();
      for (var l = r._children, h = 0; h < l.length; h++) {
        var u = l[h];
        u !== r.sprite && u._renderCmd.visit(r.sprite._renderCmd);
      }
      r.end();
    }
  }, t.clearStencil = function(e) {
    var n = cc._renderContext, r = n.getParameter(n.STENCIL_CLEAR_VALUE);
    n.clearStencil(e), n.clear(n.STENCIL_BUFFER_BIT), n.clearStencil(r);
  }, t.cleanup = function() {
    this._node, this._textureCopy = null;
    var e = cc._renderContext;
    e.deleteFramebuffer(this._fBO), this._depthRenderBuffer && e.deleteRenderbuffer(this._depthRenderBuffer);
  }, t.updateClearColor = function(e) {
  }, t.initWithWidthAndHeight = function(e, n, r, s) {
    var o = (this || window)._node;
    r === cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
    var a = cc._renderContext, c = cc.contentScaleFactor();
    this._fullRect = new cc.Rect(0, 0, e, n), this._fullViewport = new cc.Rect(0, 0, e, n), e = 0 | e * c, n = 0 | n * c, this._oldFBO = a.getParameter(a.FRAMEBUFFER_BINDING);
    var l, h;
    cc.configuration.supportsNPOT() ? (l = e, h = n) : (l = cc.NextPOT(e), h = cc.NextPOT(n));
    for (var u = l * h * 4, _ = new Uint8Array(u), d = 0; d < l * h * 4; d++)
      _[d] = 0;
    this._pixelFormat = r;
    var f = o._texture = new cc.Texture2D();
    if (!o._texture)
      return !1;
    f.initWithData(_, o._pixelFormat, l, h, cc.size(e, n));
    var C = a.getParameter(a.RENDERBUFFER_BINDING);
    if (cc.configuration.checkForGLExtension("GL_QCOM")) {
      if (this._textureCopy = new cc.Texture2D(), !this._textureCopy)
        return !1;
      this._textureCopy.initWithData(_, o._pixelFormat, l, h, cc.size(e, n));
    }
    this._fBO = a.createFramebuffer(), a.bindFramebuffer(a.FRAMEBUFFER, this._fBO), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, f._webTextureObj, 0), s !== 0 && (this._depthRenderBuffer = a.createRenderbuffer(), a.bindRenderbuffer(a.RENDERBUFFER, this._depthRenderBuffer), a.renderbufferStorage(a.RENDERBUFFER, s, l, h), s === a.DEPTH_STENCIL ? a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, this._depthRenderBuffer) : s === a.STENCIL_INDEX || s === a.STENCIL_INDEX8 ? a.framebufferRenderbuffer(a.FRAMEBUFFER, a.STENCIL_ATTACHMENT, a.RENDERBUFFER, this._depthRenderBuffer) : s === a.DEPTH_COMPONENT16 && a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, this._depthRenderBuffer)), a.checkFramebufferStatus(a.FRAMEBUFFER) !== a.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer"), f.setAliasTexParameters();
    var m = o.sprite = new cc.Sprite(f);
    return m.scaleY = -1, m.setBlendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA), a.bindRenderbuffer(a.RENDERBUFFER, C), a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO), o.autoDraw = !1, o.addChild(m), !0;
  }, t.begin = function() {
    var e = (this || window)._node;
    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPushMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix();
    var n = cc._renderContext, r = cc.director;
    r.setProjection(r.getProjection());
    var s = e._texture.getContentSizeInPixels(), o = cc.director.getWinSizeInPixels(), a = o.width / s.width, c = o.height / s.height, l = cc.math.Matrix4.createOrthographicProjection(
      -1 / a,
      1 / a,
      -1 / c,
      1 / c,
      -1,
      1
    );
    cc.kmGLMultMatrix(l);
    var h = new cc.Rect(0, 0, 0, 0);
    h.width = (this || window)._fullViewport.width, h.height = (this || window)._fullViewport.height;
    var u = h.width / this._fullRect.width, _ = h.height / this._fullRect.height;
    h.x = (this._fullRect.x - this._rtTextureRect.x) * u, h.y = (this._fullRect.y - this._rtTextureRect.y) * _, n.viewport(h.x, h.y, h.width, h.height), this._oldFBO = n.getParameter(n.FRAMEBUFFER_BINDING), n.bindFramebuffer(n.FRAMEBUFFER, this._fBO), cc.configuration.checkForGLExtension("GL_QCOM") && (n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, this._textureCopy._webTextureObj, 0), n.clear(n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e._texture._webTextureObj, 0));
  }, t._beginWithClear = function(e, n, r, s, o, a, c) {
    e = e / 255, n = n / 255, r = r / 255, s = s / 255;
    var l = cc._renderContext, h = [0, 0, 0, 0], u = 0, _ = 0;
    c & l.COLOR_BUFFER_BIT && (h = l.getParameter(l.COLOR_CLEAR_VALUE), l.clearColor(e, n, r, s)), c & l.DEPTH_BUFFER_BIT && (u = l.getParameter(l.DEPTH_CLEAR_VALUE), l.clearDepth(o)), c & l.STENCIL_BUFFER_BIT && (_ = l.getParameter(l.STENCIL_CLEAR_VALUE), l.clearStencil(a)), l.clear(c), c & l.COLOR_BUFFER_BIT && l.clearColor(h[0], h[1], h[2], h[3]), c & l.DEPTH_BUFFER_BIT && l.clearDepth(u), c & l.STENCIL_BUFFER_BIT && l.clearStencil(_);
  }, t.end = function() {
    var e = (this || window)._node;
    cc.renderer._renderingToBuffer(e.__instanceId);
    var n = cc._renderContext, r = cc.director;
    n.bindFramebuffer(n.FRAMEBUFFER, this._oldFBO), r.setViewport(), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLPopMatrix(), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPopMatrix();
  }, t.clearRect = function(e, n, r, s) {
  }, t.clearDepth = function(e) {
    var n = (this || window)._node;
    n.begin();
    var r = cc._renderContext, s = r.getParameter(r.DEPTH_CLEAR_VALUE);
    r.clearDepth(e), r.clear(r.DEPTH_BUFFER_BIT), r.clearDepth(s), n.end();
  }, t.visit = function(e) {
    var n = (this || window)._node;
    n._visible && (cc.kmGLPushMatrix(), this._syncStatus(e), cc.renderer.pushRenderCommand(this), n.sprite.visit(this), this._dirtyFlag = 0, cc.kmGLPopMatrix());
  };
})();
cc.SpriteBatchNode = cc.Node.extend({
  _blendFunc: null,
  _texture: null,
  _className: "SpriteBatchNode",
  ctor: function(t) {
    cc.Node.prototype.ctor.call(this), this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
    var e;
    cc.isString(t) ? (e = cc.textureCache.getTextureForKey(t), e || (e = cc.textureCache.addImage(t))) : t instanceof cc.Texture2D && (e = t), e && this.initWithTexture(e);
  },
  addSpriteWithoutQuad: function(t, e, n) {
    return this.addChild(t, e, n), (this || window)
  },
  getTextureAtlas: function() {
    return null;
  },
  setTextureAtlas: function(t) {
  },
  getDescendants: function() {
    return this._children;
  },
  initWithFile: function(t, e) {
    var n = cc.textureCache.getTextureForKey(t);
    return n || (n = cc.textureCache.addImage(t)), this.initWithTexture(n, e);
  },
  init: function(t, e) {
    var n = cc.textureCache.getTextureForKey(t);
    return n || (n = cc.textureCache.addImage(t)), this.initWithTexture(n, e);
  },
  increaseAtlasCapacity: function() {
  },
  removeChildAtIndex: function(t, e) {
    this.removeChild(this._children[t], e);
  },
  rebuildIndexInOrder: function(t, e) {
    return e;
  },
  highestAtlasIndexInChild: function(t) {
    var e = t.children;
    return !e || e.length === 0 ? t.zIndex : this.highestAtlasIndexInChild(e[e.length - 1]);
  },
  lowestAtlasIndexInChild: function(t) {
    var e = t.children;
    return !e || e.length === 0 ? t.zIndex : this.lowestAtlasIndexInChild(e[e.length - 1]);
  },
  atlasIndexForChild: function(t) {
    return t.zIndex;
  },
  reorderBatch: function(t) {
    this._reorderChildDirty = t;
  },
  setBlendFunc: function(t, e) {
    e === void 0 ? this._blendFunc = t : this._blendFunc = { src: t, dst: e };
  },
  getBlendFunc: function() {
    return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
  },
  updateQuadFromSprite: function(t, e) {
    if (cc.assert(t, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2), !(t instanceof cc.Sprite)) {
      cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite);
      return;
    }
    t.dirty = !0, t._renderCmd.transform(this._renderCmd, !0);
  },
  insertQuadFromSprite: function(t, e) {
    this.addChild(t, e);
  },
  insertChild: function(t, e) {
    this.addChild(t, e);
  },
  appendChild: function(t) {
    this.sortAllChildren(), this._children[this._children.length - 1]._localZOrder, this.addChild(t.lastLocalZOrder + 1);
  },
  removeSpriteFromAtlas: function(t, e) {
    this.removeChild(t, e);
  },
  initWithTexture: function(t) {
    return this.setTexture(t), !0;
  },
  getTexture: function() {
    return this._texture;
  },
  setTexture: function(t) {
    if (this._texture = t, t._textureLoaded) {
      var e = (this || window)._children, n, r = e.length;
      for (n = 0; n < r; ++n)
        e[n].setTexture(t);
    } else
      t.addEventListener("load", function() {
        var s = (this || window)._children, o, a = s.length;
        for (o = 0; o < a; ++o)
          s[o].setTexture(t);
      }, this);
  },
  setShaderProgram: function(t) {
    this._renderCmd.setShaderProgram(t);
    var e = (this || window)._children, n, r = e.length;
    for (n = 0; n < r; ++n)
      e[n].setShaderProgram(t);
  },
  addChild: function(t, e, n) {
    cc.assert(t !== void 0, cc._LogInfos.CCSpriteBatchNode_addChild_3), this._isValidChild(t) && (e = e === void 0 ? t.zIndex : e, n = n === void 0 ? t.tag : n, cc.Node.prototype.addChild.call(this, t, e, n), this._renderCmd._shaderProgram && (t.shaderProgram = (this || window)._renderCmd._shaderProgram));
  },
  _isValidChild: function(t) {
    return t instanceof cc.Sprite ? t.texture !== (this || window)._texture ? (cc.log(cc._LogInfos.Sprite_addChild_5), !1) : !0 : (cc.log(cc._LogInfos.Sprite_addChild_4), !1);
  }
});
var _p = cc.SpriteBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "shaderProgram", _p.getShaderProgram, _p.setShaderProgram);
cc.SpriteBatchNode.create = function(t) {
  return new cc.SpriteBatchNode(t);
};
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
cc.LabelAtlas = cc.AtlasNode.extend({
  _string: null,
  _mapStartChar: null,
  _textureLoaded: !1,
  _className: "LabelAtlas",
  ctor: function(t, e, n, r, s) {
    cc.AtlasNode.prototype.ctor.call(this), this._renderCmd.setCascade(), e && cc.LabelAtlas.prototype.initWithString.call(this, t, e, n, r, s);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelAtlas.WebGLRenderCmd(this) : new cc.LabelAtlas.CanvasRenderCmd(this);
  },
  textureLoaded: function() {
    return this._textureLoaded;
  },
  addLoadedEventListener: function(t, e) {
    this.addEventListener("load", t, e);
  },
  initWithString: function(t, e, n, r, s) {
    var o = t + "", a, c, l, h;
    if (n === void 0) {
      var u = cc.loader.getRes(e);
      if (parseInt(u.version, 10) !== 1)
        return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
      a = cc.path.changeBasename(e, u.textureFilename);
      var _ = cc.contentScaleFactor();
      c = parseInt(u.itemWidth, 10) / _, l = parseInt(u.itemHeight, 10) / _, h = String.fromCharCode(parseInt(u.firstChar, 10));
    } else
      a = e, c = n || 0, l = r || 0, h = s || " ";
    var d = null;
    a instanceof cc.Texture2D ? d = a : d = cc.textureCache.addImage(a);
    var f = d.isLoaded();
    return this._textureLoaded = f, f || (this._string = o, d.addEventListener("load", function(C) {
      this.initWithTexture(d, c, l, o.length), this.string = (this || window)._string, this.setColor(this._renderCmd._displayedColor), this.dispatchEvent("load");
    }, this)), this.initWithTexture(d, c, l, o.length) ? (this._mapStartChar = h, this.string = o, !0) : !1;
  },
  setColor: function(t) {
    cc.AtlasNode.prototype.setColor.call(this, t), this._renderCmd.updateAtlasValues();
  },
  getString: function() {
    return this._string;
  },
  addChild: function(t, e, n) {
    this._renderCmd._addChild(t), cc.Node.prototype.addChild.call(this, t, e, n);
  },
  updateAtlasValues: function() {
    this._renderCmd.updateAtlasValues();
  },
  setString: function(t) {
    t = String(t);
    var e = t.length;
    this._string = t, this.setContentSize(e * this._itemWidth, this._itemHeight), this._renderCmd.setString(t), this._renderCmd.updateAtlasValues(), this.quadsToDraw = e;
  }
});
(function() {
  var t = cc.LabelAtlas.prototype;
  cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity), cc.defineGetterSetter(t, "color", t.getColor, t.setColor), t.string, cc.defineGetterSetter(t, "string", t.getString, t.setString);
})();
cc.LabelAtlas.create = function(t, e, n, r, s) {
  return new cc.LabelAtlas(t, e, n, r, s);
};
(function() {
  cc.LabelAtlas.CanvasRenderCmd = function(e) {
    cc.AtlasNode.CanvasRenderCmd.call(this, e), this._needDraw = !1;
  };
  var t = cc.LabelAtlas.CanvasRenderCmd.prototype = Object.create(cc.AtlasNode.CanvasRenderCmd.prototype);
  t.constructor = cc.LabelAtlas.CanvasRenderCmd, t.setCascade = function() {
    var e = (this || window)._node;
    e._cascadeOpacityEnabled = !0, e._cascadeColorEnabled = !1;
  }, t.updateAtlasValues = function() {
    for (var e = (this || window)._node, n = e._string || "", r = n.length, s = (this || window)._textureToRender, o = e._itemWidth, a = e._itemHeight, c = 0, l = -1; c < r; c++) {
      var h = n.charCodeAt(c) - e._mapStartChar.charCodeAt(0), u = parseInt(h % e._itemsPerRow, 10), _ = parseInt(h / e._itemsPerRow, 10);
      if (!(u < 0 || _ < 0)) {
        var d = cc.rect(u * o, _ * a, o, a), f = s._contentSize;
        if (!(d.x < 0 || d.y < 0 || d.x + d.width > f.width || d.y + d.height > f.height)) {
          l++;
          var C = n.charCodeAt(c), m = e.getChildByTag(c);
          m ? C === 32 ? (m.init(), m.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (m.initWithTexture(s, d), m.visible = !0) : (m = new cc.Sprite(), C === 32 ? (m.init(), m.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : m.initWithTexture(s, d), cc.Node.prototype.addChild.call(e, m, 0, c)), m.setPosition(l * o + o / 2, a / 2);
        }
      }
    }
    this.updateContentSize(c, l + 1);
  }, t.updateContentSize = function(e, n) {
    var r = (this || window)._node, s = r._contentSize;
    e !== n && e * r._itemWidth === s.width && r._itemHeight === s.height && r.setContentSize(n * r._itemWidth, r._itemHeight);
  }, t.setString = function(e) {
    var n = (this || window)._node;
    if (n._children)
      for (var r = n._children, s = r.length, o = 0; o < s; o++) {
        var a = r[o];
        a && !a._lateChild && (a.visible = !1);
      }
  }, t._addChild = function() {
    child._lateChild = !0;
  };
})();
cc.LabelBMFont = cc.SpriteBatchNode.extend({
  _opacityModifyRGB: !1,
  _string: "",
  _config: null,
  _fntFile: "",
  _initialString: "",
  _alignment: cc.TEXT_ALIGNMENT_CENTER,
  _width: -1,
  _lineBreakWithoutSpaces: !1,
  _imageOffset: null,
  _textureLoaded: !1,
  _className: "LabelBMFont",
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelBMFont.WebGLRenderCmd(this) : new cc.LabelBMFont.CanvasRenderCmd(this);
  },
  _setString: function(t, e) {
    e ? this._initialString = t : this._string = t;
    var n = (this || window)._children;
    if (n)
      for (var r = 0; r < n.length; r++) {
        var s = n[r];
        s && s.setVisible(!1);
      }
    this._textureLoaded && (this.createFontChars(), e && this.updateLabel());
  },
  ctor: function(t, e, n, r, s) {
    cc.SpriteBatchNode.prototype.ctor.call(this), this._imageOffset = cc.p(0, 0), this._cascadeColorEnabled = !0, this._cascadeOpacityEnabled = !0, this.initWithString(t, e, n, r, s);
  },
  textureLoaded: function() {
    return this._textureLoaded;
  },
  addLoadedEventListener: function(t, e) {
    this.addEventListener("load", t, e);
  },
  isOpacityModifyRGB: function() {
    return this._opacityModifyRGB;
  },
  setOpacityModifyRGB: function(t) {
    this._opacityModifyRGB = t;
    var e = (this || window)._children;
    if (e)
      for (var n = 0; n < e.length; n++) {
        var r = e[n];
        r && (r.opacityModifyRGB = (this || window)._opacityModifyRGB);
      }
  },
  _changeTextureColor: function() {
    this._renderCmd._changeTextureColor();
  },
  /**
       * Initialization of the node, please do not call this function by yourself, you should pass the parameters to constructor to initialize it
  .
       */
  init: function() {
    return this.initWithString(null, null, null, null, null);
  },
  initWithString: function(t, e, n, r, s) {
    var o = (this || window), a = t || "";
    o._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
    var c;
    if (e) {
      var l = cc.loader.getRes(e);
      if (!l)
        return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
      o._config = l, o._fntFile = e, c = cc.textureCache.addImage(l.atlasName);
      var h = c.isLoaded();
      o._textureLoaded = h, h || c.addEventListener("load", function(_) {
        var d = (this || window);
        d._textureLoaded = !0, d.initWithTexture(_, d._initialString.length), d.setString(d._initialString, !0), d.dispatchEvent("load");
      }, o);
    } else {
      c = new cc.Texture2D();
      var u = new Image();
      c.initWithElement(u), o._textureLoaded = !1;
    }
    return o.initWithTexture(c, a.length) ? (o._alignment = r || cc.TEXT_ALIGNMENT_LEFT, o._imageOffset = s || cc.p(0, 0), o._width = n === void 0 ? -1 : n, o._realOpacity = 255, o._realColor = cc.color(255, 255, 255, 255), o._contentSize.width = 0, o._contentSize.height = 0, o.setAnchorPoint(0.5, 0.5), o.setString(a, !0), !0) : !1;
  },
  createFontChars: function() {
    var t = (this || window), e = (this || window)._renderCmd, n = e._texture || this._texture, r = 0, s = cc.size(0, 0), o = 0, a = 1, c = t._string, l = c ? c.length : 0;
    if (l !== 0) {
      var h, u = t._config, _ = u.kerningDict, d = u.commonHeight, f = u.fontDefDictionary;
      for (h = 0; h < l - 1; h++)
        c.charCodeAt(h) === 10 && a++;
      var C = d * a, m = -(d - d * a), g = -1, y;
      for (h = 0; h < l; h++) {
        var A = c.charCodeAt(h);
        if (A !== 0) {
          if (A === 10) {
            r = 0, m -= u.commonHeight;
            continue;
          }
          var D = _[g << 16 | A & 65535] || 0;
          y = f[A], y || (cc.log("cocos2d: LabelBMFont: character not found " + c[h]), y = {
            rect: {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            },
            xOffset: 0,
            yOffset: 0,
            xAdvance: 0
          });
          var N = cc.rect(y.rect.x, y.rect.y, y.rect.width, y.rect.height);
          N = cc.rectPixelsToPoints(N), N.x += t._imageOffset.x, N.y += t._imageOffset.y;
          var z = t.getChildByTag(h);
          z ? e._updateCharTexture(z, N, A) : (z = new cc.Sprite(), z.initWithTexture(n, N, !1), z._newTextureWhenChangeColor = !0, this.addChild(z, 0, h)), z.opacityModifyRGB = (this || window)._opacityModifyRGB, e._updateCharColorAndOpacity(z);
          var M = u.commonHeight - y.yOffset, Z = cc.p(
            r + y.xOffset + y.rect.width * 0.5 + D,
            m + M - N.height * 0.5 * cc.contentScaleFactor()
          );
          z.setPosition(cc.pointPixelsToPoints(Z)), r += y.xAdvance + D, g = A, o < r && (o = r);
        }
      }
      y && y.xAdvance < y.rect.width ? s.width = o - y.xAdvance + y.rect.width : s.width = o, s.height = C, t.setContentSize(cc.sizePixelsToPoints(s));
    }
  },
  updateString: function(t) {
    var e = (this || window), n = e._children;
    if (n)
      for (var r = 0, s = n.length; r < s; r++) {
        var o = n[r];
        o && (o.visible = !1);
      }
    e._config && e.createFontChars(), t || e.updateLabel();
  },
  getString: function() {
    return this._initialString;
  },
  setString: function(t, e) {
    t = String(t), e == null && (e = !0), (t == null || !cc.isString(t)) && (t = t + ""), this._initialString = t, this._setString(t, e);
  },
  _setStringForSetter: function(t) {
    this.setString(t, !1);
  },
  setCString: function(t) {
    this.setString(t, !0);
  },
  _getCharsWidth: function(t, e) {
    if (e <= 0)
      return 0;
    var n = (this || window).getChildByTag(t), r = (this || window).getChildByTag(t + e);
    return this._getLetterPosXLeft(r) - this._getLetterPosXLeft(n);
  },
  _checkWarp: function(t, e, n, r) {
    for (var s = (this || window), o = t[e], a = 0, c = 0; c < e; c++)
      a += t[c].length;
    a = a + e - r;
    var l = s._getCharsWidth(a, t[e].length - 1);
    if (l > n && o.length > 1) {
      for (var h = o.length * (n / l) | 0, u = o.substr(h), _ = l - this._getCharsWidth(a + h, u.length - 1), d, f = 0, C = 0; _ > n && C++ < 100; )
        h *= n / _, h = h | 0, u = o.substr(h), _ = l - this._getCharsWidth(a + h, u.length - 1);
      for (C = 0; _ < n && C++ < 100; ) {
        if (u) {
          var m = cc.LabelTTF._wordRex.exec(u);
          f = m ? m[0].length : 1, d = u;
        }
        s._lineBreakWithoutSpaces && (f = 0), h = h + f, u = o.substr(h), _ = l - this._getCharsWidth(a + h, u.length - 1);
      }
      h -= f, h === 0 && (h = 1, d = d.substr(1));
      var g = o.substr(0, h), y;
      cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(d || u) && (y = cc.LabelTTF._lastWordRex.exec(g), f = y ? y[0].length : 0, s._lineBreakWithoutSpaces && (f = 0), h -= f, d = o.substr(h), g = o.substr(0, h)), cc.LabelTTF._firsrEnglish.test(d) && (y = cc.LabelTTF._lastEnglish.exec(g), y && g !== y[0] && (f = y[0].length, s._lineBreakWithoutSpaces && (f = 0), h -= f, d = o.substr(h), g = o.substr(0, h))), t[e] = d || u, t.splice(e, 0, g);
    }
  },
  updateLabel: function() {
    var t = (this || window);
    t.string = t._initialString;
    var e, n, r;
    if (t._width > 0) {
      var s = t.string.split(`
`), o = "", a = 0, c = 0;
      for (e = 0; e < s.length; e++)
        c = s.length, this._checkWarp(s, e, t._width * this._scaleX, a), c < s.length && a++, e > 0 && (o += `
`), o += s[e];
      o = o + String.fromCharCode(0), t._setString(o, !1);
    }
    if (t._alignment !== cc.TEXT_ALIGNMENT_LEFT) {
      e = 0;
      for (var l = 0, h = t._string.length, u = [], _ = 0; _ < h; _++) {
        if (t._string[_].charCodeAt(0) === 10 || t._string[_].charCodeAt(0) === 0) {
          var d = 0, f = u.length;
          if (f === 0) {
            l++;
            continue;
          }
          var C = e + f - 1 + l;
          if (C < 0)
            continue;
          var m = t.getChildByTag(C);
          if (m == null)
            continue;
          d = m.getPositionX() + m._getWidth() / 2;
          var g = 0;
          switch (t._alignment) {
            case cc.TEXT_ALIGNMENT_CENTER:
              g = t.width / 2 - d / 2;
              break;
            case cc.TEXT_ALIGNMENT_RIGHT:
              g = t.width - d;
              break;
          }
          if (g !== 0)
            for (n = 0; n < f; n++)
              C = e + n + l, !(C < 0) && (r = t.getChildByTag(C), r && (r.x += g));
          e += f, l++, u.length = 0;
          continue;
        }
        u.push(t._string[e]);
      }
    }
  },
  setAlignment: function(t) {
    this._alignment = t, this.updateLabel();
  },
  _getAlignment: function() {
    return this._alignment;
  },
  setBoundingWidth: function(t) {
    this._width = t, this.updateLabel();
  },
  _getBoundingWidth: function() {
    return this._width;
  },
  setLineBreakWithoutSpace: function(t) {
    this._lineBreakWithoutSpaces = t, this.updateLabel();
  },
  setScale: function(t, e) {
    cc.Node.prototype.setScale.call(this, t, e), this.updateLabel();
  },
  setScaleX: function(t) {
    cc.Node.prototype.setScaleX.call(this, t), this.updateLabel();
  },
  setScaleY: function(t) {
    cc.Node.prototype.setScaleY.call(this, t), this.updateLabel();
  },
  setFntFile: function(t) {
    var e = (this || window);
    if (t != null && t !== e._fntFile) {
      var n = cc.loader.getRes(t);
      if (!n) {
        cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file");
        return;
      }
      e._fntFile = t, e._config = n;
      var r = cc.textureCache.addImage(n.atlasName), s = r.isLoaded();
      e._textureLoaded = s, s ? (e.setTexture(r), e.createFontChars()) : r.addEventListener("load", function(o) {
        var a = (this || window);
        a._textureLoaded = !0, a.setTexture(o), a.createFontChars(), a._changeTextureColor(), a.updateLabel(), a.dispatchEvent("load");
      }, e);
    }
  },
  getFntFile: function() {
    return this._fntFile;
  },
  setTexture: function(t) {
    this._texture = t, this._renderCmd.setTexture(t);
  },
  setAnchorPoint: function(t, e) {
    cc.Node.prototype.setAnchorPoint.call(this, t, e), this.updateLabel();
  },
  _setAnchorX: function(t) {
    cc.Node.prototype._setAnchorX.call(this, t), this.updateLabel();
  },
  _setAnchorY: function(t) {
    cc.Node.prototype._setAnchorY.call(this, t), this.updateLabel();
  },
  _atlasNameFromFntFile: function(t) {
  },
  _kerningAmountForFirst: function(t, e) {
    var n = 0, r = t << 16 | e & 65535;
    if (this._configuration.kerningDictionary) {
      var s = (this || window)._configuration.kerningDictionary[r.toString()];
      s && (n = s.amount);
    }
    return n;
  },
  _getLetterPosXLeft: function(t) {
    return t.getPositionX() * this._scaleX - t._getWidth() * this._scaleX * t._getAnchorX();
  },
  _getLetterPosXRight: function(t) {
    return t.getPositionX() * this._scaleX + t._getWidth() * this._scaleX * t._getAnchorX();
  },
  _isspace_unicode: function(t) {
    return t = t.charCodeAt(0), t >= 9 && t <= 13 || t === 32 || t === 133 || t === 160 || t === 5760 || t >= 8192 && t <= 8202 || t === 8232 || t === 8233 || t === 8239 || t === 8287 || t === 12288;
  },
  _utf8_trim_ws: function(t) {
    var e = t.length;
    if (!(e <= 0)) {
      var n = e - 1;
      if (this._isspace_unicode(t[n])) {
        for (var r = n - 1; r >= 0 && this._isspace_unicode(t[r]); --r)
          n = r;
        this._utf8_trim_from(t, n);
      }
    }
  },
  _utf8_trim_from: function(t, e) {
    var n = t.length;
    e >= n || e < 0 || t.splice(e, n);
  }
});
(function() {
  var t = cc.LabelBMFont.prototype;
  cc.EventHelper.prototype.apply(t), t.string, cc.defineGetterSetter(t, "string", t.getString, t._setStringForSetter), t.boundingWidth, cc.defineGetterSetter(t, "boundingWidth", t._getBoundingWidth, t.setBoundingWidth), t.textAlign, cc.defineGetterSetter(t, "textAlign", t._getAlignment, t.setAlignment), cc.defineGetterSetter(t, "texture", t.getTexture, t.setTexture);
})();
cc.LabelBMFont.create = function(t, e, n, r, s) {
  return new cc.LabelBMFont(t, e, n, r, s);
};
var _fntLoader = {
  INFO_EXP: /info [^\n]*(\n|$)/gi,
  COMMON_EXP: /common [^\n]*(\n|$)/gi,
  PAGE_EXP: /page [^\n]*(\n|$)/gi,
  CHAR_EXP: /char [^\n]*(\n|$)/gi,
  KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
  ITEM_EXP: /\w+=[^ \r\n]+/gi,
  INT_EXP: /^[\-]?\d+$/,
  _parseStrToObj: function(t) {
    var e = t.match(this.ITEM_EXP), n = {};
    if (e)
      for (var r = 0, s = e.length; r < s; r++) {
        var o = e[r], a = o.indexOf("="), c = o.substring(0, a), l = o.substring(a + 1);
        l.match(this.INT_EXP) ? l = parseInt(l) : l[0] === '"' && (l = l.substring(1, l.length - 1)), n[c] = l;
      }
    return n;
  },
  parseFnt: function(t, e) {
    var n = (this || window), r = {}, s = n._parseStrToObj(t.match(n.INFO_EXP)[0]), o = s.padding.split(",");
    parseInt(o[0]), parseInt(o[1]), parseInt(o[2]), parseInt(o[3]);
    var a = n._parseStrToObj(t.match(n.COMMON_EXP)[0]);
    if (r.commonHeight = a.lineHeight, cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
      var c = cc.configuration.getMaxTextureSize();
      (a.scaleW > c.width || a.scaleH > c.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported");
    }
    a.pages !== 1 && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
    var l = n._parseStrToObj(t.match(n.PAGE_EXP)[0]);
    l.id !== 0 && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found"), r.atlasName = cc.path.changeBasename(e, l.file);
    for (var h = t.match(n.CHAR_EXP), u = r.fontDefDictionary = {}, _ = 0, d = h.length; _ < d; _++) {
      var f = n._parseStrToObj(h[_]), C = f.id;
      u[C] = {
        rect: { x: f.x, y: f.y, width: f.width, height: f.height },
        xOffset: f.xoffset,
        yOffset: f.yoffset,
        xAdvance: f.xadvance
      };
    }
    var m = r.kerningDict = {}, g = t.match(n.KERNING_EXP);
    if (g)
      for (var _ = 0, d = g.length; _ < d; _++) {
        var y = n._parseStrToObj(g[_]);
        m[y.first << 16 | y.second & 65535] = y.amount;
      }
    return r;
  },
  load: function(t, e, n, r) {
    var s = (this || window);
    cc.loader.loadTxt(t, function(o, a) {
      if (o)
        return r(o);
      r(null, s.parseFnt(a, e));
    });
  }
};
cc.loader.register(["fnt"], _fntLoader);
(function() {
  cc.LabelBMFont.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e);
  };
  var t = cc.LabelBMFont.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.LabelBMFont.CanvasRenderCmd, t._updateCharTexture = function(e, n, r) {
    r === 32 ? e.setTextureRect(n, !1, cc.size(0, 0)) : (e.setTextureRect(n, !1), e.visible = !0);
  }, t._updateCharColorAndOpacity = function(e) {
    e._displayedColor = (this || window)._displayedColor, e._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty), e._displayedOpacity = (this || window)._displayedOpacity, e._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty);
  }, t.setTexture = function(e) {
    for (var n = (this || window)._node, r = n._children, s = (this || window)._displayedColor, o = 0; o < r.length; o++) {
      var a = r[o], c = a._renderCmd, l = c._displayedColor;
      n._texture !== c._texture && (l.r !== s.r || l.g !== s.g || l.b !== s.b) || (a.texture = e);
    }
    n._texture = e;
  }, t._changeTextureColor = function() {
    var e = (this || window)._node, n = e._texture, r = n.getContentSize(), s = e._texture, o = s.getHtmlElementObj(), a = (this || window)._displayedColor, c = cc.rect(0, 0, o.width, o.height);
    if (n && r.width > 0) {
      if (!o)
        return;
      var l = s._generateColorTexture(a.r, a.g, a.b, c);
      e.setTexture(l);
    }
  }, t._updateChildrenDisplayedOpacity = function(e) {
    cc.Node.prototype.updateDisplayedOpacity.call(e, this._displayedOpacity);
  }, t._updateChildrenDisplayedColor = function(e) {
    cc.Node.prototype.updateDisplayedColor.call(e, this._displayedColor);
  };
})();
(function() {
  cc.LabelAtlas.WebGLRenderCmd = function(e) {
    cc.AtlasNode.WebGLRenderCmd.call(this, e), this._needDraw = !0;
  };
  var t = cc.LabelAtlas.WebGLRenderCmd.prototype = Object.create(cc.AtlasNode.WebGLRenderCmd.prototype);
  t.constructor = cc.LabelAtlas.WebGLRenderCmd, t._updateColor = function() {
    if (this._colorF32Array) {
      var e = (this || window)._displayedColor, n = (this || window)._displayedOpacity / 255;
      this._node._opacityModifyRGB ? (this._colorF32Array[0] = e.r * n / 255, this._colorF32Array[1] = e.g * n / 255, this._colorF32Array[2] = e.b * n / 255, this._colorF32Array[3] = n) : (this._colorF32Array[0] = e.r / 255, this._colorF32Array[1] = e.g / 255, this._colorF32Array[2] = e.b / 255, this._colorF32Array[3] = n);
    }
  }, t.setCascade = function() {
    var e = (this || window)._node;
    e._cascadeOpacityEnabled = !0, e._cascadeColorEnabled = !0;
  }, t.rendering = function(e) {
    if (cc.AtlasNode.WebGLRenderCmd.prototype.rendering.call(this, e), cc.LABELATLAS_DEBUG_DRAW) {
      var n = (this || window)._node, r = n.getContentSize(), s = n.getBoundingBoxToWorld(), o = s.x, a = s.y;
      r.width = s.width, r.height = s.height;
      var c = [
        cc.p(o, a),
        cc.p(o + r.width, a),
        cc.p(r.width + o, r.height + a),
        cc.p(o, a + r.height)
      ];
      cc._drawingUtil.drawPoly(c, 4, !0);
    }
  }, t.updateAtlasValues = function() {
    var e = (this || window)._node, n = e._string, r = n.length, s = (this || window)._textureAtlas, o = s.texture, a = o.pixelsWidth, c = o.pixelsHeight, l = e._itemWidth, h = e._itemHeight;
    e._ignoreContentScaleFactor || (l = e._itemWidth * cc.contentScaleFactor(), h = e._itemHeight * cc.contentScaleFactor()), r > s.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
    for (var u = s.quads, _ = e._itemWidth, d = e._itemHeight, f = 0, C = -1; f < r; f++) {
      var m = n.charCodeAt(f) - e._mapStartChar.charCodeAt(0), g = m % e._itemsPerRow, y = 0 | m / e._itemsPerRow;
      if (!(g < 0 || y < 0) && !(g * _ + _ > a || y * d + d > c)) {
        C++;
        var A, D, N, z;
        cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (A = (2 * g * l + 1) / (2 * a), D = A + (l * 2 - 2) / (2 * a), N = (2 * y * h + 1) / (2 * c), z = N + (h * 2 - 2) / (2 * c)) : (A = g * l / a, D = A + l / a, N = y * h / c, z = N + h / c);
        var M = u[f], Z = M.tl, U = M.tr, Q = M.bl, et = M.br;
        Z.texCoords.u = A, Z.texCoords.v = N, U.texCoords.u = D, U.texCoords.v = N, Q.texCoords.u = A, Q.texCoords.v = z, et.texCoords.u = D, et.texCoords.v = z, Q.vertices.x = C * _, Q.vertices.y = 0, Q.vertices.z = 0, et.vertices.x = C * _ + _, et.vertices.y = 0, et.vertices.z = 0, Z.vertices.x = C * _, Z.vertices.y = e._itemHeight, Z.vertices.z = 0, U.vertices.x = C * _ + _, U.vertices.y = e._itemHeight, U.vertices.z = 0;
      }
    }
    if (this._updateColor(), this.updateContentSize(f, C + 1), r > 0) {
      s.dirty = !0;
      var rt = s.totalQuads;
      r > rt && s.increaseTotalQuadsWith(r - rt);
    }
  }, t.updateContentSize = function(e, n) {
    var r = (this || window)._node, s = r._contentSize;
    e !== n && e * r._itemWidth === s.width && r._itemHeight === s.height && r.setContentSize(n * r._itemWidth, r._itemHeight);
  }, t.setString = function(e) {
    var n = e.length;
    n > this._textureAtlas.totalQuads && this._textureAtlas.resizeCapacity(n);
  }, t._addChild = function() {
  };
})();
(function() {
  cc.LabelBMFont.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e);
  };
  var t = cc.LabelBMFont.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.LabelBMFont.WebGLRenderCmd, t.setTexture = function(e) {
    this._node.setOpacityModifyRGB(this._node._texture.hasPremultipliedAlpha());
  }, t._updateCharTexture = function(e, n, r) {
    e.setTextureRect(n, !1), e.visible = !0;
  }, t._changeTextureColor = function() {
  }, t._updateCharColorAndOpacity = function() {
  };
})();
cc.MotionStreak = cc.Node.extend({
  texture: null,
  fastMode: !1,
  startingPositionInitialized: !1,
  _blendFunc: null,
  _stroke: 0,
  _fadeDelta: 0,
  _minSeg: 0,
  _maxPoints: 0,
  _nuPoints: 0,
  _previousNuPoints: 0,
  _pointVertexes: null,
  _pointState: null,
  _vertices: null,
  _colorPointer: null,
  _texCoords: null,
  _verticesBuffer: null,
  _colorPointerBuffer: null,
  _texCoordsBuffer: null,
  _className: "MotionStreak",
  ctor: function(t, e, n, r, s) {
    cc.Node.prototype.ctor.call(this), this._positionR = cc.p(0, 0), this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA), this.fastMode = !1, this.startingPositionInitialized = !1, this.texture = null, this._stroke = 0, this._fadeDelta = 0, this._minSeg = 0, this._maxPoints = 0, this._nuPoints = 0, this._previousNuPoints = 0, this._pointVertexes = null, this._pointState = null, this._vertices = null, this._colorPointer = null, this._texCoords = null, this._verticesBuffer = null, this._colorPointerBuffer = null, this._texCoordsBuffer = null, s !== void 0 && this.initWithFade(t, e, n, r, s);
  },
  getTexture: function() {
    return this.texture;
  },
  setTexture: function(t) {
    this.texture !== t && (this.texture = t);
  },
  getBlendFunc: function() {
    return this._blendFunc;
  },
  setBlendFunc: function(t, e) {
    e === void 0 ? this._blendFunc = t : (this._blendFunc.src = t, this._blendFunc.dst = e);
  },
  getOpacity: function() {
    return cc.log("cc.MotionStreak.getOpacity has not been supported."), 0;
  },
  setOpacity: function(t) {
    cc.log("cc.MotionStreak.setOpacity has not been supported.");
  },
  setOpacityModifyRGB: function(t) {
  },
  isOpacityModifyRGB: function() {
    return !1;
  },
  isFastMode: function() {
    return this.fastMode;
  },
  setFastMode: function(t) {
    this.fastMode = t;
  },
  isStartingPositionInitialized: function() {
    return this.startingPositionInitialized;
  },
  setStartingPositionInitialized: function(t) {
    this.startingPositionInitialized = t;
  },
  getStroke: function() {
    return this._stroke;
  },
  setStroke: function(t) {
    this._stroke = t;
  },
  initWithFade: function(t, e, n, r, s) {
    if (!s)
      throw new Error("cc.MotionStreak.initWithFade(): Invalid filename or texture");
    cc.isString(s) && (s = cc.textureCache.addImage(s)), cc.Node.prototype.setPosition.call(this, cc.p(0, 0)), this.anchorX = 0, this.anchorY = 0, this.ignoreAnchor = !0, this.startingPositionInitialized = !1, this.fastMode = !0, this._minSeg = e === -1 ? n / 5 : e, this._minSeg *= (this || window)._minSeg, this._stroke = n, this._fadeDelta = 1 / t;
    var o = (0 | t * 60) + 2;
    return this._maxPoints = o, this._nuPoints = 0, this._pointState = new Float32Array(o), this._pointVertexes = new Float32Array(o * 2), this._vertices = new Float32Array(o * 4), this._texCoords = new Float32Array(o * 4), this._colorPointer = new Uint8Array(o * 8), this._verticesBuffer = gl.createBuffer(), this._texCoordsBuffer = gl.createBuffer(), this._colorPointerBuffer = gl.createBuffer(), this._blendFunc.src = gl.SRC_ALPHA, this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA, this.texture = s, this.color = r, this.scheduleUpdate(), gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer), gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW), gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer), gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW), gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer), gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW), !0;
  },
  tintWithColor: function(t) {
    this.color = t;
    for (var e = (this || window)._colorPointer, n = 0, r = (this || window)._nuPoints * 2; n < r; n++)
      e[n * 4] = t.r, e[n * 4 + 1] = t.g, e[n * 4 + 2] = t.b;
  },
  reset: function() {
    this._nuPoints = 0;
  },
  setPosition: function(t, e) {
    this.startingPositionInitialized = !0, e === void 0 ? (this._positionR.x = t.x, this._positionR.y = t.y) : (this._positionR.x = t, this._positionR.y = e);
  },
  getPositionX: function() {
    return this._positionR.x;
  },
  setPositionX: function(t) {
    this._positionR.x = t, this.startingPositionInitialized || (this.startingPositionInitialized = !0);
  },
  getPositionY: function() {
    return this._positionR.y;
  },
  setPositionY: function(t) {
    this._positionR.y = t, this.startingPositionInitialized || (this.startingPositionInitialized = !0);
  },
  update: function(t) {
    if (this.startingPositionInitialized) {
      this._renderCmd._updateDisplayColor(), t *= (this || window)._fadeDelta;
      var e, n, r, s, o = 0, a = (this || window)._nuPoints, c = (this || window)._pointState, l = (this || window)._pointVertexes, h = (this || window)._vertices, u = (this || window)._colorPointer;
      for (r = 0; r < a; r++)
        if (c[r] -= t, c[r] <= 0)
          o++;
        else {
          e = r - o, o > 0 ? (c[e] = c[r], l[e * 2] = l[r * 2], l[e * 2 + 1] = l[r * 2 + 1], s = r * 2, n = e * 2, h[n * 2] = h[s * 2], h[n * 2 + 1] = h[s * 2 + 1], h[(n + 1) * 2] = h[(s + 1) * 2], h[(n + 1) * 2 + 1] = h[(s + 1) * 2 + 1], s *= 4, n *= 4, u[n + 0] = u[s + 0], u[n + 1] = u[s + 1], u[n + 2] = u[s + 2], u[n + 4] = u[s + 4], u[n + 5] = u[s + 5], u[n + 6] = u[s + 6]) : n = e * 8;
          var _ = c[e] * 255;
          u[n + 3] = _, u[n + 7] = _;
        }
      a -= o;
      var d = !0;
      if (a >= (this || window)._maxPoints)
        d = !1;
      else if (a > 0) {
        var f = cc.pDistanceSQ(
          cc.p(l[(a - 1) * 2], l[(a - 1) * 2 + 1]),
          this._positionR
        ) < this._minSeg, C = a === 1 ? !1 : cc.pDistanceSQ(
          cc.p(l[(a - 2) * 2], l[(a - 2) * 2 + 1]),
          this._positionR
        ) < this._minSeg * 2;
        (f || C) && (d = !1);
      }
      if (d) {
        l[a * 2] = (this || window)._positionR.x, l[a * 2 + 1] = (this || window)._positionR.y, c[a] = 1;
        var m = a * 8, g = (this || window).getDisplayedColor();
        u[m] = g.r, u[m + 1] = g.g, u[m + 2] = g.b, u[m + 4] = g.r, u[m + 5] = g.g, u[m + 6] = g.b, u[m + 3] = 255, u[m + 7] = 255, a > 0 && this.fastMode && (a > 1 ? cc.vertexLineToPolygon(l, this._stroke, this._vertices, a, 1) : cc.vertexLineToPolygon(l, this._stroke, this._vertices, 0, 2)), a++;
      }
      if (this.fastMode || cc.vertexLineToPolygon(l, this._stroke, this._vertices, 0, a), a && this._previousNuPoints !== a) {
        var y = 1 / a, A = (this || window)._texCoords;
        for (r = 0; r < a; r++)
          A[r * 4] = 0, A[r * 4 + 1] = y * r, A[(r * 2 + 1) * 2] = 1, A[(r * 2 + 1) * 2 + 1] = y * r;
        this._previousNuPoints = a;
      }
      this._nuPoints = a;
    }
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.MotionStreak.WebGLRenderCmd(this) : null;
  }
});
cc.MotionStreak.create = function(t, e, n, r, s) {
  return new cc.MotionStreak(t, e, n, r, s);
};
cc.MotionStreak.WebGLRenderCmd = function(t) {
  cc.Node.WebGLRenderCmd.call(this, t), this._needDraw = !0, this._matrix = new cc.math.Matrix4(), this._matrix.identity(), this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
};
cc.MotionStreak.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
cc.MotionStreak.WebGLRenderCmd.prototype.constructor = cc.Sprite.WebGLRenderCmd;
cc.MotionStreak.WebGLRenderCmd.prototype.rendering = function(t) {
  var e = (this || window)._node;
  if (!(e._nuPoints <= 1) && e.texture && e.texture.isLoaded()) {
    t = t || cc._renderContext;
    var n = (this || window)._worldTransform;
    this._matrix.mat[0] = n.a, this._matrix.mat[4] = n.c, this._matrix.mat[12] = n.tx, this._matrix.mat[1] = n.b, this._matrix.mat[5] = n.d, this._matrix.mat[13] = n.ty, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix), cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst), cc.glBindTexture2D(e.texture), t.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), t.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), t.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), t.bindBuffer(t.ARRAY_BUFFER, e._verticesBuffer), t.bufferData(t.ARRAY_BUFFER, e._vertices, t.DYNAMIC_DRAW), t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, 0, 0), t.bindBuffer(t.ARRAY_BUFFER, e._texCoordsBuffer), t.bufferData(t.ARRAY_BUFFER, e._texCoords, t.DYNAMIC_DRAW), t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, 0, 0), t.bindBuffer(t.ARRAY_BUFFER, e._colorPointerBuffer), t.bufferData(t.ARRAY_BUFFER, e._colorPointer, t.DYNAMIC_DRAW), t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, 0, 0), t.drawArrays(t.TRIANGLE_STRIP, 0, e._nuPoints * 2), cc.g_NumberOfDraws++;
  }
};
cc.NodeGrid = cc.Node.extend({
  grid: null,
  _target: null,
  _gridRect: null,
  ctor: function(t) {
    cc.Node.prototype.ctor.call(this), t === void 0 && (t = cc.rect()), this._gridRect = t;
  },
  getGrid: function() {
    return this.grid;
  },
  setGrid: function(t) {
    this.grid = t;
  },
  setGridRect: function(t) {
    this._gridRect = t;
  },
  getGridRect: function() {
    return this._gridRect;
  },
  setTarget: function(t) {
    this._target = t;
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.NodeGrid.WebGLRenderCmd(this) : new cc.Node.CanvasRenderCmd(this);
  }
});
var _p = cc.NodeGrid.prototype;
_p.grid;
_p.target;
cc.defineGetterSetter(_p, "target", null, _p.setTarget);
cc.NodeGrid.create = function() {
  return new cc.NodeGrid();
};
(function() {
  cc.NodeGrid.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !1, this._gridBeginCommand = new cc.CustomRenderCmd(this, this.onGridBeginDraw), this._gridEndCommand = new cc.CustomRenderCmd(this, this.onGridEndDraw);
  };
  var t = cc.NodeGrid.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.NodeGrid.WebGLRenderCmd, t.visit = function(e) {
    var n = (this || window)._node;
    if (n._visible) {
      e = e || this.getParentRenderCmd(), n._parent && n._parent._renderCmd && (this._curLevel = n._parent._renderCmd._curLevel + 1);
      var r = cc.current_stack;
      r.stack.push(r.top), this._syncStatus(e), r.top = (this || window)._stackMatrix, cc.renderer.pushRenderCommand(this._gridBeginCommand), n._target && n._target.visit();
      var s = n._children;
      if (s && s.length > 0) {
        var o = s.length;
        n.sortAllChildren();
        for (var a = 0; a < o; a++) {
          var c = s[a];
          c && c.visit();
        }
      }
      cc.renderer.pushRenderCommand(this._gridEndCommand), this._dirtyFlag = 0, r.top = r.stack.pop();
    }
  }, t.onGridBeginDraw = function() {
    var e = (this || window)._node.grid;
    e && e._active && e.beforeDraw();
  }, t.onGridEndDraw = function() {
    var e = (this || window)._node.grid;
    e && e._active && e.afterDraw(this._node);
  };
})();
cc.v2fzero = function() {
  return { x: 0, y: 0 };
};
cc.v2f = function(t, e) {
  return { x: t, y: e };
};
cc.v2fadd = function(t, e) {
  return cc.v2f(t.x + e.x, t.y + e.y);
};
cc.v2fsub = function(t, e) {
  return cc.v2f(t.x - e.x, t.y - e.y);
};
cc.v2fmult = function(t, e) {
  return cc.v2f(t.x * e, t.y * e);
};
cc.v2fperp = function(t) {
  return cc.v2f(-t.y, t.x);
};
cc.v2fneg = function(t) {
  return cc.v2f(-t.x, -t.y);
};
cc.v2fdot = function(t, e) {
  return t.x * e.x + t.y * e.y;
};
cc.v2fforangle = function(t) {
  return cc.v2f(Math.cos(t), Math.sin(t));
};
cc.v2fnormalize = function(t) {
  var e = cc.pNormalize(cc.p(t.x, t.y));
  return cc.v2f(e.x, e.y);
};
cc.__v2f = function(t) {
  return cc.v2f(t.x, t.y);
};
cc.__t = function(t) {
  return { u: t.x, v: t.y };
};
cc.DrawNode = cc.Node.extend({
  _buffer: null,
  _blendFunc: null,
  _lineWidth: 1,
  _drawColor: null,
  getBlendFunc: function() {
    return this._blendFunc;
  },
  setBlendFunc: function(t, e) {
    e === void 0 ? (this._blendFunc.src = t.src, this._blendFunc.dst = t.dst) : (this._blendFunc.src = t, this._blendFunc.dst = e);
  },
  setLineWidth: function(t) {
    this._lineWidth = t;
  },
  getLineWidth: function() {
    return this._lineWidth;
  },
  setDrawColor: function(t) {
    var e = (this || window)._drawColor;
    e.r = t.r, e.g = t.g, e.b = t.b, e.a = t.a == null ? 255 : t.a;
  },
  getDrawColor: function() {
    return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a);
  }
});
cc.DrawNode.create = function() {
  return new cc.DrawNode();
};
cc.DrawNode.TYPE_DOT = 0;
cc.DrawNode.TYPE_SEGMENT = 1;
cc.DrawNode.TYPE_POLY = 2;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  cc._renderType === cc.game.RENDER_TYPE_CANVAS ? (cc._DrawNodeElement = function(t, e, n, r, s, o, a, c, l) {
    var h = (this || window);
    h.type = t, h.verts = e || null, h.fillColor = n || null, h.lineWidth = r || 0, h.lineColor = s || null, h.lineCap = o || "butt", h.isClosePolygon = a || !1, h.isFill = c || !1, h.isStroke = l || !1;
  }, cc.extend(cc.DrawNode.prototype, {
    _className: "DrawNodeCanvas",
    ctor: function() {
      cc.Node.prototype.ctor.call(this);
      var t = (this || window)._renderCmd;
      t._buffer = (this || window)._buffer = [], t._drawColor = (this || window)._drawColor = cc.color(255, 255, 255, 255), t._blendFunc = (this || window)._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA), this.init(), this._localBB = new cc.Rect();
    },
    setLocalBB: function(t, e, n, r) {
      var s = (this || window)._localBB;
      e === void 0 ? (s.x = t.x, s.y = t.y, s.width = t.width, s.height = t.height) : (s.x = t, s.y = e, s.width = n, s.height = r);
    },
    drawRect: function(t, e, n, r, s) {
      r = r == null ? this._lineWidth : r, s = s || this.getDrawColor(), s.a == null && (s.a = 255);
      var o = [
        t,
        cc.p(e.x, t.y),
        e,
        cc.p(t.x, e.y)
      ], a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
      a.verts = o, a.lineWidth = r, a.lineColor = s, a.isClosePolygon = !0, a.isStroke = !0, a.lineCap = "butt", a.fillColor = n, n && (n.a == null && (n.a = 255), a.isFill = !0), this._buffer.push(a);
    },
    drawCircle: function(t, e, n, r, s, o, a) {
      o = o || this._lineWidth, a = a || this.getDrawColor(), a.a == null && (a.a = 255);
      for (var c = 2 * Math.PI / r, l = [], h = 0; h <= r; h++) {
        var u = h * c, _ = e * Math.cos(u + n) + t.x, d = e * Math.sin(u + n) + t.y;
        l.push(cc.p(_, d));
      }
      s && l.push(cc.p(t.x, t.y));
      var f = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
      f.verts = l, f.lineWidth = o, f.lineColor = a, f.isClosePolygon = !0, f.isStroke = !0, this._buffer.push(f);
    },
    drawQuadBezier: function(t, e, n, r, s, o) {
      s = s || this._lineWidth, o = o || this.getDrawColor(), o.a == null && (o.a = 255);
      for (var a = [], c = 0, l = 0; l < r; l++) {
        var h = Math.pow(1 - c, 2) * t.x + 2 * (1 - c) * c * e.x + c * c * n.x, u = Math.pow(1 - c, 2) * t.y + 2 * (1 - c) * c * e.y + c * c * n.y;
        a.push(cc.p(h, u)), c += 1 / r;
      }
      a.push(cc.p(n.x, n.y));
      var _ = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
      _.verts = a, _.lineWidth = s, _.lineColor = o, _.isStroke = !0, _.lineCap = "round", this._buffer.push(_);
    },
    drawCubicBezier: function(t, e, n, r, s, o, a) {
      o = o || this._lineWidth, a = a || this.getDrawColor(), a.a == null && (a.a = 255);
      for (var c = [], l = 0, h = 0; h < s; h++) {
        var u = Math.pow(1 - l, 3) * t.x + 3 * Math.pow(1 - l, 2) * l * e.x + 3 * (1 - l) * l * l * n.x + l * l * l * r.x, _ = Math.pow(1 - l, 3) * t.y + 3 * Math.pow(1 - l, 2) * l * e.y + 3 * (1 - l) * l * l * n.y + l * l * l * r.y;
        c.push(cc.p(u, _)), l += 1 / s;
      }
      c.push(cc.p(r.x, r.y));
      var d = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
      d.verts = c, d.lineWidth = o, d.lineColor = a, d.isStroke = !0, d.lineCap = "round", this._buffer.push(d);
    },
    drawCatmullRom: function(t, e, n, r) {
      this.drawCardinalSpline(t, 0.5, e, n, r);
    },
    drawCardinalSpline: function(t, e, n, r, s) {
      r = r || this._lineWidth, s = s || this.getDrawColor(), s.a == null && (s.a = 255);
      for (var o = [], a, c, l = 1 / t.length, h = 0; h < n + 1; h++) {
        var u = h / n;
        u === 1 ? (a = t.length - 1, c = 1) : (a = 0 | u / l, c = (u - l * a) / l);
        var _ = cc.cardinalSplineAt(
          cc.getControlPointAt(t, a - 1),
          cc.getControlPointAt(t, a - 0),
          cc.getControlPointAt(t, a + 1),
          cc.getControlPointAt(t, a + 2),
          e,
          c
        );
        o.push(_);
      }
      var d = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
      d.verts = o, d.lineWidth = r, d.lineColor = s, d.isStroke = !0, d.lineCap = "round", this._buffer.push(d);
    },
    drawDot: function(t, e, n) {
      n = n || this.getDrawColor(), n.a == null && (n.a = 255);
      var r = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
      r.verts = [t], r.lineWidth = e, r.fillColor = n, this._buffer.push(r);
    },
    drawDots: function(t, e, n) {
      if (!(!t || t.length == 0)) {
        n = n || this.getDrawColor(), n.a == null && (n.a = 255);
        for (var r = 0, s = t.length; r < s; r++)
          this.drawDot(t[r], e, n);
      }
    },
    drawSegment: function(t, e, n, r) {
      n = n || this._lineWidth, r = r || this.getDrawColor(), r.a == null && (r.a = 255);
      var s = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
      s.verts = [t, e], s.lineWidth = n * 2, s.lineColor = r, s.isStroke = !0, s.lineCap = "round", this._buffer.push(s);
    },
    drawPoly_: function(t, e, n, r) {
      n = n == null ? this._lineWidth : n, r = r || this.getDrawColor(), r.a == null && (r.a = 255);
      var s = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
      s.verts = t, s.fillColor = e, s.lineWidth = n, s.lineColor = r, s.isClosePolygon = !0, s.isStroke = !0, s.lineCap = "round", e && (s.isFill = !0), this._buffer.push(s);
    },
    drawPoly: function(t, e, n, r) {
      for (var s = [], o = 0; o < t.length; o++)
        s.push(cc.p(t[o].x, t[o].y));
      return this.drawPoly_(s, e, n, r);
    },
    clear: function() {
      this._buffer.length = 0;
    },
    _createRenderCmd: function() {
      return new cc.DrawNode.CanvasRenderCmd(this);
    }
  })) : cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.extend(cc.DrawNode.prototype, {
    _bufferCapacity: 0,
    _trianglesArrayBuffer: null,
    _trianglesWebBuffer: null,
    _trianglesReader: null,
    _dirty: !1,
    _className: "DrawNodeWebGL",
    ctor: function() {
      cc.Node.prototype.ctor.call(this), this._buffer = [], this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA), this._drawColor = cc.color(255, 255, 255, 255), this.init();
    },
    init: function() {
      return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(64), this._trianglesWebBuffer = cc._renderContext.createBuffer(), this._dirty = !0, !0) : !1;
    },
    drawRect: function(t, e, n, r, s) {
      r = r == null ? this._lineWidth : r, s = s || this.getDrawColor(), s.a == null && (s.a = 255);
      var o = [t, cc.p(e.x, t.y), e, cc.p(t.x, e.y)];
      n == null ? this._drawSegments(o, r, s, !0) : this.drawPoly(o, n, r, s);
    },
    drawCircle: function(t, e, n, r, s, o, a) {
      o = o || this._lineWidth, a = a || this.getDrawColor(), a.a == null && (a.a = 255);
      var c = 2 * Math.PI / r, l = [], h, u;
      for (h = 0; h <= r; h++) {
        var _ = h * c, d = e * Math.cos(_ + n) + t.x, f = e * Math.sin(_ + n) + t.y;
        l.push(cc.p(d, f));
      }
      for (s && l.push(cc.p(t.x, t.y)), o *= 0.5, h = 0, u = l.length; h < u - 1; h++)
        this.drawSegment(l[h], l[h + 1], o, a);
    },
    drawQuadBezier: function(t, e, n, r, s, o) {
      s = s || this._lineWidth, o = o || this.getDrawColor(), o.a == null && (o.a = 255);
      for (var a = [], c = 0, l = 0; l < r; l++) {
        var h = Math.pow(1 - c, 2) * t.x + 2 * (1 - c) * c * e.x + c * c * n.x, u = Math.pow(1 - c, 2) * t.y + 2 * (1 - c) * c * e.y + c * c * n.y;
        a.push(cc.p(h, u)), c += 1 / r;
      }
      a.push(cc.p(n.x, n.y)), this._drawSegments(a, s, o, !1);
    },
    drawCubicBezier: function(t, e, n, r, s, o, a) {
      o = o || this._lineWidth, a = a || this.getDrawColor(), a.a == null && (a.a = 255);
      for (var c = [], l = 0, h = 0; h < s; h++) {
        var u = Math.pow(1 - l, 3) * t.x + 3 * Math.pow(1 - l, 2) * l * e.x + 3 * (1 - l) * l * l * n.x + l * l * l * r.x, _ = Math.pow(1 - l, 3) * t.y + 3 * Math.pow(1 - l, 2) * l * e.y + 3 * (1 - l) * l * l * n.y + l * l * l * r.y;
        c.push(cc.p(u, _)), l += 1 / s;
      }
      c.push(cc.p(r.x, r.y)), this._drawSegments(c, o, a, !1);
    },
    drawCatmullRom: function(t, e, n, r) {
      this.drawCardinalSpline(t, 0.5, e, n, r);
    },
    drawCardinalSpline: function(t, e, n, r, s) {
      r = r || this._lineWidth, s = s || this.getDrawColor(), s.a == null && (s.a = 255);
      for (var o = [], a, c, l = 1 / t.length, h = 0; h < n + 1; h++) {
        var u = h / n;
        u === 1 ? (a = t.length - 1, c = 1) : (a = 0 | u / l, c = (u - l * a) / l);
        var _ = cc.cardinalSplineAt(
          cc.getControlPointAt(t, a - 1),
          cc.getControlPointAt(t, a - 0),
          cc.getControlPointAt(t, a + 1),
          cc.getControlPointAt(t, a + 2),
          e,
          c
        );
        o.push(_);
      }
      r *= 0.5;
      for (var d = 0, f = o.length; d < f - 1; d++)
        this.drawSegment(o[d], o[d + 1], r, s);
    },
    _render: function() {
      var t = cc._renderContext;
      t.bindBuffer(t.ARRAY_BUFFER, this._trianglesWebBuffer), this._dirty && (t.bufferData(t.ARRAY_BUFFER, this._trianglesArrayBuffer, t.STREAM_DRAW), this._dirty = !1);
      var e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
      t.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), t.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), t.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), t.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, t.FLOAT, !1, e, 0), t.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, t.UNSIGNED_BYTE, !0, e, 8), t.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, t.FLOAT, !1, e, 12), t.drawArrays(t.TRIANGLES, 0, this._buffer.length * 3), cc.incrementGLDraws(1);
    },
    _ensureCapacity: function(t) {
      var e = (this || window), n = e._buffer;
      if (n.length + t > e._bufferCapacity) {
        var r = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
        if (e._bufferCapacity += Math.max(e._bufferCapacity, t), n == null || n.length === 0)
          e._buffer = [], e._trianglesArrayBuffer = new ArrayBuffer(r * e._bufferCapacity), e._trianglesReader = new Uint8Array(e._trianglesArrayBuffer);
        else {
          for (var s = [], o = new ArrayBuffer(r * e._bufferCapacity), a = 0; a < n.length; a++)
            s[a] = new cc.V2F_C4B_T2F_Triangle(
              n[a].a,
              n[a].b,
              n[a].c,
              o,
              a * r
            );
          e._trianglesReader = new Uint8Array(o), e._trianglesArrayBuffer = o, e._buffer = s;
        }
      }
    },
    drawDot: function(t, e, n) {
      n = n || this.getDrawColor(), n.a == null && (n.a = 255);
      var r = { r: 0 | n.r, g: 0 | n.g, b: 0 | n.b, a: 0 | n.a }, s = { vertices: { x: t.x - e, y: t.y - e }, colors: r, texCoords: { u: -1, v: -1 } }, o = { vertices: { x: t.x - e, y: t.y + e }, colors: r, texCoords: { u: -1, v: 1 } }, a = { vertices: { x: t.x + e, y: t.y + e }, colors: r, texCoords: { u: 1, v: 1 } }, c = { vertices: { x: t.x + e, y: t.y - e }, colors: r, texCoords: { u: 1, v: -1 } };
      this._ensureCapacity(2 * 3), this._buffer.push(new cc.V2F_C4B_T2F_Triangle(s, o, a, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)), this._buffer.push(new cc.V2F_C4B_T2F_Triangle(s, a, c, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT)), this._dirty = !0;
    },
    drawDots: function(t, e, n) {
      if (!(!t || t.length === 0)) {
        n = n || this.getDrawColor(), n.a == null && (n.a = 255);
        for (var r = 0, s = t.length; r < s; r++)
          this.drawDot(t[r], e, n);
      }
    },
    drawSegment: function(t, e, n, r) {
      r = r || this.getDrawColor(), r.a == null && (r.a = 255), n = n || this._lineWidth * 0.5;
      var s = 6 * 3;
      this._ensureCapacity(s);
      var o = { r: 0 | r.r, g: 0 | r.g, b: 0 | r.b, a: 0 | r.a }, a = cc.__v2f(t), c = cc.__v2f(e), l = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(c, a))), h = cc.v2fperp(l), u = cc.v2fmult(l, n), _ = cc.v2fmult(h, n), d = cc.v2fsub(c, cc.v2fadd(u, _)), f = cc.v2fadd(c, cc.v2fsub(u, _)), C = cc.v2fsub(c, u), m = cc.v2fadd(c, u), g = cc.v2fsub(a, u), y = cc.v2fadd(a, u), A = cc.v2fsub(a, cc.v2fsub(u, _)), D = cc.v2fadd(a, cc.v2fadd(u, _)), N = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, z = (this || window)._trianglesArrayBuffer, M = (this || window)._buffer;
      M.push(new cc.V2F_C4B_T2F_Triangle(
        { vertices: d, colors: o, texCoords: cc.__t(cc.v2fneg(cc.v2fadd(l, h))) },
        { vertices: f, colors: o, texCoords: cc.__t(cc.v2fsub(l, h)) },
        { vertices: C, colors: o, texCoords: cc.__t(cc.v2fneg(l)) },
        z,
        M.length * N
      )), M.push(new cc.V2F_C4B_T2F_Triangle(
        { vertices: m, colors: o, texCoords: cc.__t(l) },
        { vertices: f, colors: o, texCoords: cc.__t(cc.v2fsub(l, h)) },
        { vertices: C, colors: o, texCoords: cc.__t(cc.v2fneg(l)) },
        z,
        M.length * N
      )), M.push(new cc.V2F_C4B_T2F_Triangle(
        { vertices: m, colors: o, texCoords: cc.__t(l) },
        { vertices: g, colors: o, texCoords: cc.__t(cc.v2fneg(l)) },
        { vertices: C, colors: o, texCoords: cc.__t(cc.v2fneg(l)) },
        z,
        M.length * N
      )), M.push(new cc.V2F_C4B_T2F_Triangle(
        { vertices: m, colors: o, texCoords: cc.__t(l) },
        { vertices: g, colors: o, texCoords: cc.__t(cc.v2fneg(l)) },
        { vertices: y, colors: o, texCoords: cc.__t(l) },
        z,
        M.length * N
      )), M.push(new cc.V2F_C4B_T2F_Triangle(
        { vertices: A, colors: o, texCoords: cc.__t(cc.v2fsub(h, l)) },
        { vertices: g, colors: o, texCoords: cc.__t(cc.v2fneg(l)) },
        { vertices: y, colors: o, texCoords: cc.__t(l) },
        z,
        M.length * N
      )), M.push(new cc.V2F_C4B_T2F_Triangle(
        { vertices: A, colors: o, texCoords: cc.__t(cc.v2fsub(h, l)) },
        { vertices: D, colors: o, texCoords: cc.__t(cc.v2fadd(l, h)) },
        { vertices: y, colors: o, texCoords: cc.__t(l) },
        z,
        M.length * N
      )), this._dirty = !0;
    },
    drawPoly: function(t, e, n, r) {
      if (e == null) {
        this._drawSegments(t, n, r, !0);
        return;
      }
      e.a == null && (e.a = 255), r.a == null && (r.a = 255), n = n == null ? this._lineWidth : n, n *= 0.5;
      var s = { r: 0 | e.r, g: 0 | e.g, b: 0 | e.b, a: 0 | e.a }, o = { r: 0 | r.r, g: 0 | r.g, b: 0 | r.b, a: 0 | r.a }, a = [], c, l, h, u, _ = t.length;
      for (c = 0; c < _; c++) {
        l = cc.__v2f(t[(c - 1 + _) % _]), h = cc.__v2f(t[c]), u = cc.__v2f(t[(c + 1) % _]);
        var d = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, l))), f = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(u, h))), C = cc.v2fmult(cc.v2fadd(d, f), 1 / (cc.v2fdot(d, f) + 1));
        a[c] = { offset: C, n: f };
      }
      var m = n > 0, g = 3 * _ - 2, y = 3 * g;
      this._ensureCapacity(y);
      var A = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, D = (this || window)._trianglesArrayBuffer, N = (this || window)._buffer, z = m == !1 ? 0.5 : 0;
      for (c = 0; c < _ - 2; c++)
        l = cc.v2fsub(cc.__v2f(t[0]), cc.v2fmult(a[0].offset, z)), h = cc.v2fsub(cc.__v2f(t[c + 1]), cc.v2fmult(a[c + 1].offset, z)), u = cc.v2fsub(cc.__v2f(t[c + 2]), cc.v2fmult(a[c + 2].offset, z)), N.push(new cc.V2F_C4B_T2F_Triangle(
          { vertices: l, colors: s, texCoords: cc.__t(cc.v2fzero()) },
          { vertices: h, colors: s, texCoords: cc.__t(cc.v2fzero()) },
          { vertices: u, colors: s, texCoords: cc.__t(cc.v2fzero()) },
          D,
          N.length * A
        ));
      for (c = 0; c < _; c++) {
        var M = (c + 1) % _;
        l = cc.__v2f(t[c]), h = cc.__v2f(t[M]);
        var Z = a[c].n, U = a[c].offset, Q = a[M].offset, et = m ? cc.v2fsub(l, cc.v2fmult(U, n)) : cc.v2fsub(l, cc.v2fmult(U, 0.5)), rt = m ? cc.v2fsub(h, cc.v2fmult(Q, n)) : cc.v2fsub(h, cc.v2fmult(Q, 0.5)), w = m ? cc.v2fadd(l, cc.v2fmult(U, n)) : cc.v2fadd(l, cc.v2fmult(U, 0.5)), L = m ? cc.v2fadd(h, cc.v2fmult(Q, n)) : cc.v2fadd(h, cc.v2fmult(Q, 0.5));
        m ? (N.push(new cc.V2F_C4B_T2F_Triangle(
          { vertices: et, colors: o, texCoords: cc.__t(cc.v2fneg(Z)) },
          { vertices: rt, colors: o, texCoords: cc.__t(cc.v2fneg(Z)) },
          { vertices: L, colors: o, texCoords: cc.__t(Z) },
          D,
          N.length * A
        )), N.push(new cc.V2F_C4B_T2F_Triangle(
          { vertices: et, colors: o, texCoords: cc.__t(cc.v2fneg(Z)) },
          { vertices: w, colors: o, texCoords: cc.__t(Z) },
          { vertices: L, colors: o, texCoords: cc.__t(Z) },
          D,
          N.length * A
        ))) : (N.push(new cc.V2F_C4B_T2F_Triangle(
          { vertices: et, colors: s, texCoords: cc.__t(cc.v2fzero()) },
          { vertices: rt, colors: s, texCoords: cc.__t(cc.v2fzero()) },
          { vertices: L, colors: s, texCoords: cc.__t(Z) },
          D,
          N.length * A
        )), N.push(new cc.V2F_C4B_T2F_Triangle(
          { vertices: et, colors: s, texCoords: cc.__t(cc.v2fzero()) },
          { vertices: w, colors: s, texCoords: cc.__t(Z) },
          { vertices: L, colors: s, texCoords: cc.__t(Z) },
          D,
          N.length * A
        )));
      }
      a = null, this._dirty = !0;
    },
    _drawSegments: function(t, e, n, r) {
      if (e = e == null ? this._lineWidth : e, n = n || this._drawColor, n.a == null && (n.a = 255), e *= 0.5, !(e <= 0)) {
        var s = { r: 0 | n.r, g: 0 | n.g, b: 0 | n.b, a: 0 | n.a }, o = [], a, c, l, h, u = t.length;
        for (a = 0; a < u; a++) {
          c = cc.__v2f(t[(a - 1 + u) % u]), l = cc.__v2f(t[a]), h = cc.__v2f(t[(a + 1) % u]);
          var _ = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(l, c))), d = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, l))), f = cc.v2fmult(cc.v2fadd(_, d), 1 / (cc.v2fdot(_, d) + 1));
          o[a] = { offset: f, n: d };
        }
        var C = 3 * u - 2, m = 3 * C;
        this._ensureCapacity(m);
        var g = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, y = (this || window)._trianglesArrayBuffer, A = (this || window)._buffer, D = r ? u : u - 1;
        for (a = 0; a < D; a++) {
          var N = (a + 1) % u;
          c = cc.__v2f(t[a]), l = cc.__v2f(t[N]);
          var z = o[a].n, M = o[a].offset, Z = o[N].offset, U = cc.v2fsub(c, cc.v2fmult(M, e)), Q = cc.v2fsub(l, cc.v2fmult(Z, e)), et = cc.v2fadd(c, cc.v2fmult(M, e)), rt = cc.v2fadd(l, cc.v2fmult(Z, e));
          A.push(new cc.V2F_C4B_T2F_Triangle(
            { vertices: U, colors: s, texCoords: cc.__t(cc.v2fneg(z)) },
            { vertices: Q, colors: s, texCoords: cc.__t(cc.v2fneg(z)) },
            { vertices: rt, colors: s, texCoords: cc.__t(z) },
            y,
            A.length * g
          )), A.push(new cc.V2F_C4B_T2F_Triangle(
            { vertices: U, colors: s, texCoords: cc.__t(cc.v2fneg(z)) },
            { vertices: et, colors: s, texCoords: cc.__t(z) },
            { vertices: rt, colors: s, texCoords: cc.__t(z) },
            y,
            A.length * g
          ));
        }
        o = null, this._dirty = !0;
      }
    },
    clear: function() {
      this._buffer.length = 0, this._dirty = !0;
    },
    _createRenderCmd: function() {
      return new cc.DrawNode.WebGLRenderCmd(this);
    }
  });
});
(function() {
  cc.DrawNode.CanvasRenderCmd = function(t) {
    cc.Node.CanvasRenderCmd.call(this, t), this._needDraw = !0, this._buffer = null, this._drawColor = null, this._blendFunc = null;
  }, cc.DrawNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype), cc.DrawNode.CanvasRenderCmd.prototype.constructor = cc.DrawNode.CanvasRenderCmd, cc.DrawNode.CanvasRenderCmd.prototype.getLocalBB = function() {
    var t = (this || window)._node;
    return t._localBB;
  }, cc.extend(cc.DrawNode.CanvasRenderCmd.prototype, {
    rendering: function(t, e, n) {
      var r = t || cc._renderContext;
      r.getContext();
      var s = (this || window)._node, o = s._displayedOpacity / 255;
      if (o !== 0) {
        r.setTransform(this._worldTransform, e, n), r.setGlobalAlpha(o), this._blendFunc && this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE && r.setCompositeOperation("lighter");
        for (var a = (this || window)._buffer, c = 0, l = a.length; c < l; c++) {
          var h = a[c];
          switch (h.type) {
            case cc.DrawNode.TYPE_DOT:
              this._drawDot(r, h, e, n);
              break;
            case cc.DrawNode.TYPE_SEGMENT:
              this._drawSegment(r, h, e, n);
              break;
            case cc.DrawNode.TYPE_POLY:
              this._drawPoly(r, h, e, n);
              break;
          }
        }
      }
    },
    _drawDot: function(t, e) {
      var n = e.fillColor, r = e.verts[0], s = e.lineWidth, o = t.getContext();
      t.setFillStyle("rgba(" + (0 | n.r) + "," + (0 | n.g) + "," + (0 | n.b) + "," + n.a / 255 + ")"), o.beginPath(), o.arc(r.x, -r.y, s, 0, Math.PI * 2, !1), o.closePath(), o.fill();
    },
    _drawSegment: function(t, e, n) {
      var r = e.lineColor, s = e.verts[0], o = e.verts[1], a = e.lineWidth, c = e.lineCap, l = t.getContext();
      t.setStrokeStyle("rgba(" + (0 | r.r) + "," + (0 | r.g) + "," + (0 | r.b) + "," + r.a / 255 + ")"), l.lineWidth = a * n, l.beginPath(), l.lineCap = c, l.moveTo(s.x, -s.y), l.lineTo(o.x, -o.y), l.stroke();
    },
    _drawPoly: function(t, e, n) {
      var r = e.verts, s = e.lineCap;
      if (r != null) {
        var o = e.fillColor, a = e.lineWidth, c = e.lineColor, l = e.isClosePolygon, h = e.isFill, u = e.isStroke, _ = t.getContext(), d = r[0];
        _.lineCap = s, o && t.setFillStyle("rgba(" + (0 | o.r) + "," + (0 | o.g) + "," + (0 | o.b) + "," + o.a / 255 + ")"), a && (_.lineWidth = a * n), c && t.setStrokeStyle("rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b) + "," + c.a / 255 + ")"), _.beginPath(), _.moveTo(d.x, -d.y);
        for (var f = 1, C = r.length; f < C; f++)
          _.lineTo(r[f].x, -r[f].y);
        l && _.closePath(), h && _.fill(), u && _.stroke();
      }
    }
  });
})();
(function() {
  cc.DrawNode.WebGLRenderCmd = function(t) {
    cc.Node.WebGLRenderCmd.call(this, t), this._needDraw = !0, this._matrix = new cc.math.Matrix4(), this._matrix.identity();
  }, cc.DrawNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype), cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd, cc.DrawNode.WebGLRenderCmd.prototype.rendering = function(t) {
    var e = (this || window)._node;
    if (e._buffer.length > 0) {
      var n = (this || window)._worldTransform;
      this._matrix.mat[0] = n.a, this._matrix.mat[4] = n.c, this._matrix.mat[12] = n.tx, this._matrix.mat[1] = n.b, this._matrix.mat[5] = n.d, this._matrix.mat[13] = n.ty, cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst), this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix), e._render();
    }
  };
})();
cc.stencilBits = -1;
cc.ClippingNode = cc.Node.extend({
  alphaThreshold: 0,
  inverted: !1,
  _stencil: null,
  _className: "ClippingNode",
  ctor: function(t) {
    t = t || null, cc.Node.prototype.ctor.call(this), this._stencil = t, this.alphaThreshold = 1, this.inverted = !1, this._renderCmd.initStencilBits();
  },
  /**
       * Initialization of the node, please do not call this function by yourself, you should pass the parameters to constructor to initialize it
  .
       * @function
       * @param {cc.Node} [stencil=null]
       */
  init: function(t) {
    return this._stencil = t, this.alphaThreshold = 1, this.inverted = !1, this._renderCmd.initStencilBits(), !0;
  },
  onEnter: function() {
    cc.Node.prototype.onEnter.call(this), this._stencil.onEnter();
  },
  onEnterTransitionDidFinish: function() {
    cc.Node.prototype.onEnterTransitionDidFinish.call(this), this._stencil.onEnterTransitionDidFinish();
  },
  onExitTransitionDidStart: function() {
    this._stencil.onExitTransitionDidStart(), cc.Node.prototype.onExitTransitionDidStart.call(this);
  },
  onExit: function() {
    this._stencil.onExit(), cc.Node.prototype.onExit.call(this);
  },
  getAlphaThreshold: function() {
    return this.alphaThreshold;
  },
  setAlphaThreshold: function(t) {
    this.alphaThreshold = t;
  },
  isInverted: function() {
    return this.inverted;
  },
  setInverted: function(t) {
    this.inverted = t;
  },
  getStencil: function() {
    return this._stencil;
  },
  setStencil: function(t) {
    this._stencil !== t && this._renderCmd.setStencil(t);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this);
  }
});
var _p = cc.ClippingNode.prototype;
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
_p.stencil;
cc.ClippingNode.create = function(t) {
  return new cc.ClippingNode(t);
};
(function() {
  cc.ClippingNode.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !1, this._godhelpme = !1, this._clipElemType = !1, this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._saveCmdCallback), this._rendererClipCmd = new cc.CustomRenderCmd(this, this._clipCmdCallback), this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback);
  };
  var t = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.ClippingNode.CanvasRenderCmd, t.initStencilBits = function() {
  }, t.setStencil = function(e) {
    if (e != null)
      if (this._node._stencil = e, e instanceof cc.DrawNode) {
        if (e._buffer)
          for (var n = 0; n < e._buffer.length; n++)
            e._buffer[n].isFill = !1, e._buffer[n].isStroke = !1;
        e._renderCmd.rendering = function(r, s, o) {
        }, e._renderCmd._canUseDirtyRegion = !0, this._rendererSaveCmd._canUseDirtyRegion = !0, this._rendererClipCmd._canUseDirtyRegion = !0, this._rendererRestoreCmd._canUseDirtyRegion = !0;
      } else
        e._parent = (this || window)._node;
  }, t._saveCmdCallback = function(e, n, r) {
    var s = e || cc._renderContext, o = s.getContext();
    if (this._clipElemType) {
      var a = cc.ClippingNode.CanvasRenderCmd._getSharedCache(), c = o.canvas;
      a.width = c.width, a.height = c.height;
      var l = a.getContext("2d");
      l.drawImage(c, 0, 0);
    } else
      s.save(), s.setTransform(this._worldTransform, n, r), this._node.inverted && (o.beginPath(), o.rect(0, 0, o.canvas.width, -o.canvas.height), o.clip());
  }, t._setStencilCompositionOperation = function(e) {
    if (e) {
      var n = (this || window)._node;
      if (e._renderCmd && e._renderCmd._blendFuncStr && (e._renderCmd._blendFuncStr = n.inverted ? "destination-out" : "destination-in"), !!e._children)
        for (var r = e._children, s = 0, o = r.length; s < o; s++)
          this._setStencilCompositionOperation(r[s]);
    }
  }, t._clipCmdCallback = function(e) {
    var n = (this || window)._node, r = e || cc._renderContext, s = r.getContext();
    if (this._clipElemType)
      this._setStencilCompositionOperation(n._stencil);
    else {
      var o = (this || window)._node._stencil;
      if (o instanceof cc.DrawNode) {
        s.beginPath();
        var a = o._renderCmd._transform;
        s.transform(a.a, a.b, a.c, a.d, a.tx, -a.ty);
        for (var c = 0; c < o._buffer.length; c++) {
          var l = o._buffer[c].verts, h = l[0];
          s.moveTo(h.x, -h.y);
          for (var u = l.length - 1; u > 0; u--)
            s.lineTo(l[u].x, -l[u].y);
        }
      }
      s.clip();
    }
  }, t._restoreCmdCallback = function(e) {
    var n = cc.ClippingNode.CanvasRenderCmd._getSharedCache(), r = e || cc._renderContext, s = r.getContext();
    this._clipElemType ? (s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.globalCompositeOperation = "destination-over", s.drawImage(n, 0, 0), s.restore(), this._dirtyFlag = 0) : r.restore();
  }, t.transform = function(e, n) {
    cc.Node.CanvasRenderCmd.prototype.transform.call(this, e, n);
    var r = (this || window)._node;
    r._stencil && r._stencil._renderCmd && r._stencil._renderCmd.transform(this, n);
  }, t._cangodhelpme = function(e) {
    return (e === !0 || e === !1) && (cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme = e), cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme;
  }, t.visit = function(e) {
    var n = (this || window)._node;
    if (n._visible) {
      e = e || this.getParentRenderCmd(), e && (this._curLevel = e._curLevel + 1);
      var r = (this || window);
      if (this._clipElemType = !(!this._cangodhelpme() && n._stencil instanceof cc.DrawNode), !n._stencil || !n._stencil.visible) {
        this.inverted && this.originVisit(e);
        return;
      }
      if (this._syncStatus(e), cc.renderer.pushRenderCommand(this._rendererSaveCmd), this._clipElemType ? this.originVisit(e) : n._stencil.visit(this), cc.renderer.pushRenderCommand(this._rendererClipCmd), this._clipElemType)
        n._stencil.visit(r);
      else {
        var s, o = n._children;
        this._cangodhelpme(!0);
        var a = o.length;
        if (a > 0)
          for (n.sortAllChildren(), s = 0; s < a; s++)
            o[s]._renderCmd.visit(this);
        this._cangodhelpme(!1);
      }
      cc.renderer.pushRenderCommand(this._rendererRestoreCmd), this._dirtyFlag = 0;
    }
  }, cc.ClippingNode.CanvasRenderCmd._sharedCache = null, cc.ClippingNode.CanvasRenderCmd._getSharedCache = function() {
    return cc.ClippingNode.CanvasRenderCmd._sharedCache || (cc.ClippingNode.CanvasRenderCmd._sharedCache = document.createElement("canvas"));
  };
})();
(function() {
  cc.ClippingNode.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !1, this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit), this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil), this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit), this._currentStencilEnabled = null, this._mask_layer_le = null;
  };
  var t = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.ClippingNode.WebGLRenderCmd, cc.ClippingNode.WebGLRenderCmd._init_once = null, cc.ClippingNode.WebGLRenderCmd._visit_once = null, cc.ClippingNode.WebGLRenderCmd._layer = -1, t.initStencilBits = function() {
    cc.ClippingNode.WebGLRenderCmd._init_once = !0, cc.ClippingNode.WebGLRenderCmd._init_once && (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), cc.stencilBits <= 0 && cc.log("Stencil buffer is not enabled."), cc.ClippingNode.WebGLRenderCmd._init_once = !1);
  }, t.transform = function(e, n) {
    var r = (this || window)._node;
    this.originTransform(e, n), r._stencil && r._stencil._renderCmd.transform(this, n);
  }, t.visit = function(e) {
    var n = (this || window)._node;
    if (n._visible) {
      if (n._parent && n._parent._renderCmd && (this._curLevel = n._parent._renderCmd._curLevel + 1), cc.stencilBits < 1) {
        this.originVisit(e);
        return;
      }
      if (!n._stencil || !n._stencil.visible) {
        n.inverted && this.originVisit(e);
        return;
      }
      if (cc.ClippingNode.WebGLRenderCmd._layer + 1 === cc.stencilBits) {
        cc.ClippingNode.WebGLRenderCmd._visit_once = !0, cc.ClippingNode.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its children."), cc.ClippingNode.WebGLRenderCmd._visit_once = !1), this.originVisit(e);
        return;
      }
      cc.renderer.pushRenderCommand(this._beforeVisitCmd);
      var r = cc.current_stack;
      r.stack.push(r.top), this._syncStatus(e), r.top = (this || window)._stackMatrix, n._stencil._renderCmd.visit(this), cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
      var s = n._children;
      if (s && s.length > 0) {
        var o = s.length;
        n.sortAllChildren();
        for (var a = 0; a < o; a++)
          s[a]._renderCmd.visit(this);
      }
      cc.renderer.pushRenderCommand(this._afterVisitCmd), this._dirtyFlag = 0, r.top = r.stack.pop();
    }
  }, t.setStencil = function(e) {
    var n = (this || window)._node;
    n._stencil && (n._stencil._parent = null), n._stencil = e, n._stencil && (n._stencil._parent = n);
  }, t._onBeforeVisit = function(e) {
    var n = e || cc._renderContext, r = (this || window)._node;
    cc.ClippingNode.WebGLRenderCmd._layer++;
    var s = 1 << cc.ClippingNode.WebGLRenderCmd._layer, o = s - 1;
    if (this._mask_layer_le = s | o, this._currentStencilEnabled = n.isEnabled(n.STENCIL_TEST), n.clear(n.DEPTH_BUFFER_BIT), n.enable(n.STENCIL_TEST), n.depthMask(!1), n.stencilFunc(n.NEVER, s, s), n.stencilOp(n.REPLACE, n.KEEP, n.KEEP), n.stencilMask(s), n.clear(n.STENCIL_BUFFER_BIT), r.alphaThreshold < 1) {
      var a = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
      cc.glUseProgram(a.getProgram()), a.setUniformLocationWith1f(cc.UNIFORM_ALPHA_TEST_VALUE_S, r.alphaThreshold), a.setUniformLocationWithMatrix4fv(cc.UNIFORM_MVMATRIX_S, cc.renderer.mat4Identity.mat), cc.setProgram(r._stencil, a);
    }
  }, t._onAfterDrawStencil = function(e) {
    var n = e || cc._renderContext;
    n.depthMask(!0), n.stencilFunc(this._node.inverted ? n.NOTEQUAL : n.EQUAL, this._mask_layer_le, this._mask_layer_le), n.stencilOp(n.KEEP, n.KEEP, n.KEEP);
  }, t._onAfterVisit = function(e) {
    var n = e || cc._renderContext;
    if (cc.ClippingNode.WebGLRenderCmd._layer--, this._currentStencilEnabled) {
      var r = 1 << cc.ClippingNode.WebGLRenderCmd._layer, s = r - 1, o = r | s;
      n.stencilMask(r), n.stencilFunc(n.EQUAL, o, o);
    } else
      n.disable(n.STENCIL_TEST);
  };
})();
cc.GridBase = cc.Class.extend({
  _active: !1,
  _reuseGrid: 0,
  _gridSize: null,
  _gridRect: null,
  _texture: null,
  _step: null,
  _grabber: null,
  _isTextureFlipped: !1,
  _shaderProgram: null,
  _directorProjection: 0,
  _dirty: !1,
  ctor: function(t, e, n, r) {
    cc.sys._checkWebGLRenderMode(), this._active = !1, this._reuseGrid = 0, this._gridSize = null, this._gridRect = new cc.rect(), this._texture = null, this._step = cc.p(0, 0), this._grabber = null, this._isTextureFlipped = !1, this._shaderProgram = null, this._directorProjection = 0, this._dirty = !1, t !== void 0 && this.initWithSize(t, e, n, r);
  },
  isActive: function() {
    return this._active;
  },
  setActive: function(t) {
    if (this._active = t, !t) {
      var e = cc.director, n = e.getProjection();
      e.setProjection(n);
    }
  },
  getReuseGrid: function() {
    return this._reuseGrid;
  },
  setReuseGrid: function(t) {
    this._reuseGrid = t;
  },
  getGridSize: function() {
    return cc.size(this._gridSize.width, this._gridSize.height);
  },
  setGridSize: function(t) {
    this._gridSize.width = parseInt(t.width), this._gridSize.height = parseInt(t.height);
  },
  setGridRect: function(t) {
    this._gridRect = t;
  },
  getGridRect: function() {
    return this._gridRect;
  },
  getStep: function() {
    return cc.p(this._step.x, this._step.y);
  },
  setStep: function(t) {
    this._step.x = t.x, this._step.y = t.y;
  },
  isTextureFlipped: function() {
    return this._isTextureFlipped;
  },
  setTextureFlipped: function(t) {
    this._isTextureFlipped !== t && (this._isTextureFlipped = t, this.calculateVertexPoints());
  },
  initWithSize: function(t, e, n, r) {
    if (!e) {
      var s = cc.director, o = s.getWinSizeInPixels(), a = cc.NextPOT(o.width), c = cc.NextPOT(o.height), l = new Uint8Array(a * c * 4);
      if (!l)
        return cc.log("cocos2d: CCGrid: not enough memory."), !1;
      if (e = new cc.Texture2D(), e.initWithData(l, cc.Texture2D.PIXEL_FORMAT_RGBA8888, a, c, o), !e)
        return cc.log("cocos2d: CCGrid: error creating texture"), !1;
    }
    if (n = n || !1, this._active = !1, this._reuseGrid = 0, this._gridSize = t, this._texture = e, this._isTextureFlipped = n, r === void 0 || cc._rectEqualToZero(r)) {
      var h = (this || window)._texture.getContentSize();
      r = new cc.rect(0, 0, h.width, h.height);
    }
    return this._gridRect = r, this._step.x = (this || window)._gridRect.width / t.width, this._step.y = (this || window)._gridRect.height / t.height, this._grabber = new cc.Grabber(), this._grabber ? (this._grabber.grab(this._texture), this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), this.calculateVertexPoints(), !0) : !1;
  },
  beforeDraw: function() {
    this._directorProjection = cc.director.getProjection();
    var t = cc.director.getWinSizeInPixels();
    gl.viewport(0, 0, t.width, t.height), this._grabber.beforeRender(this._texture);
  },
  afterDraw: function(t) {
    this._grabber.afterRender(this._texture), cc.director.setViewport(), cc.glBindTexture2D(this._texture), this.beforeBlit(), this.blit(t), this.afterBlit();
  },
  beforeBlit: function() {
  },
  afterBlit: function() {
  },
  blit: function() {
    cc.log("cc.GridBase.blit(): Shall be overridden in subclass.");
  },
  reuse: function() {
    cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.");
  },
  calculateVertexPoints: function() {
    cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.");
  },
  set2DProjection: function() {
    var t = cc.director.getWinSizeInPixels(), e = cc._renderContext;
    e.viewport(0, 0, t.width, t.height), cc.kmGLMatrixMode(cc.KM_GL_PROJECTION), cc.kmGLLoadIdentity();
    var n = cc.math.Matrix4.createOrthographicProjection(0, t.width, 0, t.height, -1, 1);
    cc.kmGLMultMatrix(n), cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLLoadIdentity(), cc.setProjectionMatrixDirty();
  }
});
cc.GridBase.create = function(t, e, n, r) {
  return new cc.GridBase(t, e, n, r);
};
cc.Grid3D = cc.GridBase.extend({
  _texCoordinates: null,
  _vertices: null,
  _originalVertices: null,
  _indices: null,
  _texCoordinateBuffer: null,
  _verticesBuffer: null,
  _indicesBuffer: null,
  _needDepthTestForBlit: !1,
  _oldDepthTestValue: !1,
  _oldDepthWriteValue: !1,
  ctor: function(t, e, n, r) {
    cc.GridBase.prototype.ctor.call(this), this._texCoordinates = null, this._vertices = null, this._originalVertices = null, this._indices = null, this._texCoordinateBuffer = null, this._verticesBuffer = null, this._indicesBuffer = null, this._matrix = new cc.math.Matrix4(), this._matrix.identity(), t !== void 0 && this.initWithSize(t, e, n, r);
  },
  vertex: function(t) {
    return this.getVertex(t);
  },
  getVertex: function(t) {
    (t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.Grid3D.vertex() : Numbers must be integers");
    var e = 0 | (t.x * (this._gridSize.height + 1) + t.y) * 3, n = (this || window)._vertices;
    return new cc.Vertex3F(n[e], n[e + 1], n[e + 2]);
  },
  originalVertex: function(t) {
    return this.getOriginalVertex(t);
  },
  getOriginalVertex: function(t) {
    (t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
    var e = 0 | (t.x * (this._gridSize.height + 1) + t.y) * 3, n = (this || window)._originalVertices;
    return new cc.Vertex3F(n[e], n[e + 1], n[e + 2]);
  },
  setVertex: function(t, e) {
    (t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
    var n = 0 | (t.x * (this._gridSize.height + 1) + t.y) * 3, r = (this || window)._vertices;
    r[n] = e.x, r[n + 1] = e.y, r[n + 2] = e.z, this._dirty = !0;
  },
  beforeBlit: function() {
    if (this._needDepthTestForBlit) {
      var t = cc._renderContext;
      this._oldDepthTestValue = t.isEnabled(t.DEPTH_TEST), this._oldDepthWriteValue = t.getParameter(t.DEPTH_WRITEMASK), t.enable(t.DEPTH_TEST), t.depthMask(!0);
    }
  },
  afterBlit: function() {
    if (this._needDepthTestForBlit) {
      var t = cc._renderContext;
      this._oldDepthTestValue ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), t.depthMask(this._oldDepthWriteValue);
    }
  },
  blit: function(t) {
    var e = (this || window)._gridSize.width * this._gridSize.height, n = t._renderCmd._worldTransform;
    this._matrix.mat[0] = n.a, this._matrix.mat[4] = n.c, this._matrix.mat[12] = n.tx, this._matrix.mat[1] = n.b, this._matrix.mat[5] = n.d, this._matrix.mat[13] = n.ty, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix);
    var r = cc._renderContext, s = (this || window)._dirty;
    r.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), r.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), r.bindBuffer(r.ARRAY_BUFFER, this._verticesBuffer), s && r.bufferData(r.ARRAY_BUFFER, this._vertices, r.DYNAMIC_DRAW), r.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ARRAY_BUFFER, this._texCoordinateBuffer), s && r.bufferData(r.ARRAY_BUFFER, this._texCoordinates, r.DYNAMIC_DRAW), r.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, r.FLOAT, !1, 0, 0), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), s && r.bufferData(r.ELEMENT_ARRAY_BUFFER, this._indices, r.STATIC_DRAW), r.drawElements(r.TRIANGLES, e * 6, r.UNSIGNED_SHORT, 0), s && (this._dirty = !1), cc.incrementGLDraws(1);
  },
  reuse: function() {
    if (this._reuseGrid > 0) {
      for (var t = (this || window)._originalVertices, e = (this || window)._vertices, n = 0, r = (this || window)._vertices.length; n < r; n++)
        t[n] = e[n];
      --this._reuseGrid;
    }
  },
  calculateVertexPoints: function() {
    var t = cc._renderContext, e = (this || window)._texture.pixelsWidth, n = (this || window)._texture.pixelsHeight, r = (this || window)._texture.getContentSizeInPixels().height, s = (this || window)._gridSize, o = (s.width + 1) * (s.height + 1);
    this._vertices = new Float32Array(o * 3), this._texCoordinates = new Float32Array(o * 2), this._indices = new Uint16Array(s.width * s.height * 6), this._verticesBuffer && t.deleteBuffer(this._verticesBuffer), this._verticesBuffer = t.createBuffer(), this._texCoordinateBuffer && t.deleteBuffer(this._texCoordinateBuffer), this._texCoordinateBuffer = t.createBuffer(), this._indicesBuffer && t.deleteBuffer(this._indicesBuffer), this._indicesBuffer = t.createBuffer();
    var a, c, l, h = (this || window)._indices, u = (this || window)._texCoordinates, _ = (this || window)._isTextureFlipped, d = (this || window)._vertices;
    for (a = 0; a < s.width; ++a)
      for (c = 0; c < s.height; ++c) {
        var f = c * s.width + a, C = a * this._step.x + this._gridRect.x, m = C + this._step.x, g = c * this._step.y + this._gridRect.y, y = g + this._step.y, A = a * (s.height + 1) + c, D = (a + 1) * (s.height + 1) + c, N = (a + 1) * (s.height + 1) + (c + 1), z = a * (s.height + 1) + (c + 1);
        h[f * 6] = A, h[f * 6 + 1] = D, h[f * 6 + 2] = z, h[f * 6 + 3] = D, h[f * 6 + 4] = N, h[f * 6 + 5] = z;
        var M = [A * 3, D * 3, N * 3, z * 3], Z = { x: C, y: g, z: 0 }, U = { x: m, y: g, z: 0 }, Q = { x: m, y, z: 0 }, et = { x: C, y, z: 0 }, rt = [Z, U, Q, et], w = [A * 2, D * 2, N * 2, z * 2], L = [cc.p(C, g), cc.p(m, g), cc.p(m, y), cc.p(C, y)];
        for (l = 0; l < 4; ++l)
          d[M[l]] = rt[l].x, d[M[l] + 1] = rt[l].y, d[M[l] + 2] = rt[l].z, u[w[l]] = L[l].x / e, _ ? u[w[l] + 1] = (r - L[l].y) / n : u[w[l] + 1] = L[l].y / n;
      }
    this._originalVertices = new Float32Array(this._vertices), t.bindBuffer(t.ARRAY_BUFFER, this._verticesBuffer), t.bufferData(t.ARRAY_BUFFER, this._vertices, t.DYNAMIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this._texCoordinateBuffer), t.bufferData(t.ARRAY_BUFFER, this._texCoordinates, t.DYNAMIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._indices, t.STATIC_DRAW), this._dirty = !0;
  },
  setNeedDepthTestForBlit: function(t) {
    this._needDepthTestForBlit = t;
  },
  getNeedDepthTestForBlit: function() {
    return this._needDepthTestForBlit;
  }
});
cc.Grid3D.create = function(t, e, n) {
  return new cc.Grid3D(t, e, n);
};
cc.TiledGrid3D = cc.GridBase.extend({
  _texCoordinates: null,
  _vertices: null,
  _originalVertices: null,
  _indices: null,
  _texCoordinateBuffer: null,
  _verticesBuffer: null,
  _indicesBuffer: null,
  ctor: function(t, e, n, r) {
    cc.GridBase.prototype.ctor.call(this), this._texCoordinates = null, this._vertices = null, this._originalVertices = null, this._indices = null, this._texCoordinateBuffer = null, this._verticesBuffer = null, this._indicesBuffer = null, this._matrix = new cc.math.Matrix4(), this._matrix.identity(), t !== void 0 && this.initWithSize(t, e, n, r);
  },
  tile: function(t) {
    return this.getTile(t);
  },
  getTile: function(t) {
    (t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
    var e = (this._gridSize.height * t.x + t.y) * 4 * 3, n = (this || window)._vertices;
    return new cc.Quad3(
      new cc.Vertex3F(n[e], n[e + 1], n[e + 2]),
      new cc.Vertex3F(n[e + 3], n[e + 4], n[e + 5]),
      new cc.Vertex3F(n[e + 6], n[e + 7], n[e + 8]),
      new cc.Vertex3F(n[e + 9], n[e + 10], n[e + 11])
    );
  },
  getOriginalTile: function(t) {
    (t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
    var e = (this._gridSize.height * t.x + t.y) * 4 * 3, n = (this || window)._originalVertices;
    return new cc.Quad3(
      new cc.Vertex3F(n[e], n[e + 1], n[e + 2]),
      new cc.Vertex3F(n[e + 3], n[e + 4], n[e + 5]),
      new cc.Vertex3F(n[e + 6], n[e + 7], n[e + 8]),
      new cc.Vertex3F(n[e + 9], n[e + 10], n[e + 11])
    );
  },
  originalTile: function(t) {
    return this.getOriginalTile(t);
  },
  setTile: function(t, e) {
    (t.x !== (0 | t.x) || t.y !== (0 | t.y)) && cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
    var n = (this._gridSize.height * t.x + t.y) * 12, r = (this || window)._vertices;
    r[n] = e.bl.x, r[n + 1] = e.bl.y, r[n + 2] = e.bl.z, r[n + 3] = e.br.x, r[n + 4] = e.br.y, r[n + 5] = e.br.z, r[n + 6] = e.tl.x, r[n + 7] = e.tl.y, r[n + 8] = e.tl.z, r[n + 9] = e.tr.x, r[n + 10] = e.tr.y, r[n + 11] = e.tr.z, this._dirty = !0;
  },
  blit: function(t) {
    var e = (this || window)._gridSize.width * this._gridSize.height, n = t._renderCmd._worldTransform;
    this._matrix.mat[0] = n.a, this._matrix.mat[4] = n.c, this._matrix.mat[12] = n.tx, this._matrix.mat[1] = n.b, this._matrix.mat[5] = n.d, this._matrix.mat[13] = n.ty, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix);
    var r = cc._renderContext, s = (this || window)._dirty;
    r.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), r.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), r.bindBuffer(r.ARRAY_BUFFER, this._verticesBuffer), s && r.bufferData(r.ARRAY_BUFFER, this._vertices, r.DYNAMIC_DRAW), r.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, r.FLOAT, !1, 0, this._vertices), r.bindBuffer(r.ARRAY_BUFFER, this._texCoordinateBuffer), s && r.bufferData(r.ARRAY_BUFFER, this._texCoordinates, r.DYNAMIC_DRAW), r.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, r.FLOAT, !1, 0, this._texCoordinates), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), s && r.bufferData(r.ELEMENT_ARRAY_BUFFER, this._indices, r.STATIC_DRAW), r.drawElements(r.TRIANGLES, e * 6, r.UNSIGNED_SHORT, 0), s && (this._dirty = !1), cc.incrementGLDraws(1);
  },
  reuse: function() {
    if (this._reuseGrid > 0) {
      for (var t = (this || window)._vertices, e = (this || window)._originalVertices, n = 0; n < t.length; n++)
        e[n] = t[n];
      --this._reuseGrid;
    }
  },
  calculateVertexPoints: function() {
    var t = (this || window)._texture.pixelsWidth, e = (this || window)._texture.pixelsHeight, n = (this || window)._texture.getContentSizeInPixels().height, r = (this || window)._gridSize, s = r.width * r.height;
    this._vertices = new Float32Array(s * 12), this._texCoordinates = new Float32Array(s * 8), this._indices = new Uint16Array(s * 6);
    var o = cc._renderContext;
    this._verticesBuffer && o.deleteBuffer(this._verticesBuffer), this._verticesBuffer = o.createBuffer(), this._texCoordinateBuffer && o.deleteBuffer(this._texCoordinateBuffer), this._texCoordinateBuffer = o.createBuffer(), this._indicesBuffer && o.deleteBuffer(this._indicesBuffer), this._indicesBuffer = o.createBuffer();
    var a, c, l = 0, h = (this || window)._step, u = (this || window)._vertices, _ = (this || window)._texCoordinates, d = (this || window)._isTextureFlipped;
    for (a = 0; a < r.width; a++)
      for (c = 0; c < r.height; c++) {
        var f = a * h.x, C = f + h.x, m = c * h.y, g = m + h.y;
        u[l * 12] = f, u[l * 12 + 1] = m, u[l * 12 + 2] = 0, u[l * 12 + 3] = C, u[l * 12 + 4] = m, u[l * 12 + 5] = 0, u[l * 12 + 6] = f, u[l * 12 + 7] = g, u[l * 12 + 8] = 0, u[l * 12 + 9] = C, u[l * 12 + 10] = g, u[l * 12 + 11] = 0;
        var y = m, A = g;
        d && (y = n - m, A = n - g), _[l * 8] = f / t, _[l * 8 + 1] = y / e, _[l * 8 + 2] = C / t, _[l * 8 + 3] = y / e, _[l * 8 + 4] = f / t, _[l * 8 + 5] = A / e, _[l * 8 + 6] = C / t, _[l * 8 + 7] = A / e, l++;
      }
    var D = (this || window)._indices;
    for (a = 0; a < s; a++)
      D[a * 6 + 0] = a * 4 + 0, D[a * 6 + 1] = a * 4 + 1, D[a * 6 + 2] = a * 4 + 2, D[a * 6 + 3] = a * 4 + 1, D[a * 6 + 4] = a * 4 + 2, D[a * 6 + 5] = a * 4 + 3;
    this._originalVertices = new Float32Array(this._vertices), o.bindBuffer(o.ARRAY_BUFFER, this._verticesBuffer), o.bufferData(o.ARRAY_BUFFER, this._vertices, o.DYNAMIC_DRAW), o.bindBuffer(o.ARRAY_BUFFER, this._texCoordinateBuffer), o.bufferData(o.ARRAY_BUFFER, this._texCoordinates, o.DYNAMIC_DRAW), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, this._indicesBuffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, this._indices, o.DYNAMIC_DRAW), this._dirty = !0;
  }
});
cc.TiledGrid3D.create = function(t, e, n) {
  return new cc.TiledGrid3D(t, e, n);
};
cc.Grabber = cc.Class.extend({
  _FBO: null,
  _oldFBO: null,
  _oldClearColor: null,
  _gl: null,
  ctor: function() {
    cc.sys._checkWebGLRenderMode(), this._gl = cc._renderContext, this._oldClearColor = [0, 0, 0, 0], this._oldFBO = null, this._FBO = (this || window)._gl.createFramebuffer();
  },
  grab: function(t) {
    var e = (this || window)._gl;
    this._oldFBO = e.getParameter(e.FRAMEBUFFER_BINDING), e.bindFramebuffer(e.FRAMEBUFFER, this._FBO), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t._webTextureObj, 0);
    var n = e.checkFramebufferStatus(e.FRAMEBUFFER);
    n !== e.FRAMEBUFFER_COMPLETE && cc.log("Frame Grabber: could not attach texture to frmaebuffer"), e.bindFramebuffer(e.FRAMEBUFFER, this._oldFBO);
  },
  beforeRender: function(t) {
    var e = (this || window)._gl;
    this._oldFBO = e.getParameter(e.FRAMEBUFFER_BINDING), e.bindFramebuffer(e.FRAMEBUFFER, this._FBO), this._oldClearColor = e.getParameter(e.COLOR_CLEAR_VALUE), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT);
  },
  afterRender: function(t) {
    var e = (this || window)._gl;
    e.bindFramebuffer(e.FRAMEBUFFER, this._oldFBO), e.colorMask(!0, !0, !0, !0);
  },
  destroy: function() {
    this._gl.deleteFramebuffer(this._FBO);
  }
});
cc.GridAction = cc.ActionInterval.extend({
  _gridSize: null,
  _gridNodeTarget: null,
  ctor: function(t, e) {
    cc.sys._checkWebGLRenderMode(), cc.ActionInterval.prototype.ctor.call(this), this._gridSize = cc.size(0, 0), e && this.initWithDuration(t, e);
  },
  _cacheTargetAsGridNode: function(t) {
    this._gridNodeTarget = t;
  },
  clone: function() {
    var t = new cc.GridAction(), e = (this || window)._gridSize;
    return t.initWithDuration(this._duration, cc.size(e.width, e.height)), t;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), cc.renderer.childrenOrderDirty = !0, this._cacheTargetAsGridNode(t);
    var e = (this || window).getGrid(), n = (this || window)._gridNodeTarget.getGrid();
    if (n && n.getReuseGrid() > 0) {
      var r = n.getGridSize();
      n.isActive() && r.width === (this || window)._gridSize.width && r.height === (this || window)._gridSize.height && n.reuse();
    } else
      n && n.isActive() && n.setActive(!1), this._gridNodeTarget.setGrid(e), this._gridNodeTarget.getGrid().setActive(!0);
  },
  reverse: function() {
    return new cc.ReverseTime(this);
  },
  initWithDuration: function(t, e) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._gridSize.width = e.width, this._gridSize.height = e.height, !0) : !1;
  },
  getGrid: function() {
    cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.");
  }
});
cc.gridAction = function(t, e) {
  return new cc.GridAction(t, e);
};
cc.GridAction.create = cc.gridAction;
cc.Grid3DAction = cc.GridAction.extend({
  getGrid: function() {
    return new cc.Grid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect());
  },
  getGridRect: function() {
    return this._gridNodeTarget.getGridRect();
  },
  vertex: function(t) {
    return this.getVertex(t);
  },
  getVertex: function(t) {
    return this.target.grid.getVertex(t);
  },
  originalVertex: function(t) {
    return this.getOriginalVertex(t);
  },
  getOriginalVertex: function(t) {
    return this.target.grid.originalVertex(t);
  },
  setVertex: function(t, e) {
    this.target.grid.setVertex(t, e);
  }
});
cc.grid3DAction = function(t, e) {
  return new cc.Grid3DAction(t, e);
};
cc.Grid3DAction.create = cc.grid3DAction;
cc.TiledGrid3DAction = cc.GridAction.extend({
  tile: function(t) {
    return this.getTile(t);
  },
  getTile: function(t) {
    return this.target.grid.tile(t);
  },
  originalTile: function(t) {
    return this.getOriginalTile(t);
  },
  getOriginalTile: function(t) {
    return this.target.grid.originalTile(t);
  },
  setTile: function(t, e) {
    this.target.grid.setTile(t, e);
  },
  getGrid: function() {
    return new cc.TiledGrid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect());
  }
});
cc.tiledGrid3DAction = function(t, e) {
  return new cc.TiledGrid3DAction(t, e);
};
cc.TiledGrid3DAction.create = cc.tiledGrid3DAction;
cc.StopGrid = cc.ActionInstant.extend({
  startWithTarget: function(t) {
    cc.ActionInstant.prototype.startWithTarget.call(this, t), cc.renderer.childrenOrderDirty = !0;
    var e = (this || window).target.grid;
    e && e.isActive() && e.setActive(!1);
  }
});
cc.stopGrid = function() {
  return new cc.StopGrid();
};
cc.StopGrid.create = cc.stopGrid;
cc.ReuseGrid = cc.ActionInstant.extend({
  _times: null,
  ctor: function(t) {
    cc.ActionInstant.prototype.ctor.call(this), t !== void 0 && this.initWithTimes(t);
  },
  initWithTimes: function(t) {
    return this._times = t, !0;
  },
  startWithTarget: function(t) {
    cc.ActionInstant.prototype.startWithTarget.call(this, t), cc.renderer.childrenOrderDirty = !0, this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times);
  }
});
cc.reuseGrid = function(t) {
  return new cc.ReuseGrid(t);
};
cc.ReuseGrid.create = cc.reuseGrid;
cc.Waves3D = cc.Grid3DAction.extend({
  _waves: 0,
  _amplitude: 0,
  _amplitudeRate: 0,
  ctor: function(t, e, n, r) {
    cc.GridAction.prototype.ctor.call(this), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  getAmplitude: function() {
    return this._amplitude;
  },
  setAmplitude: function(t) {
    this._amplitude = t;
  },
  getAmplitudeRate: function() {
    return this._amplitudeRate;
  },
  setAmplitudeRate: function(t) {
    this._amplitudeRate = t;
  },
  initWithDuration: function(t, e, n, r) {
    return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._waves = n, this._amplitude = r, this._amplitudeRate = 1, !0) : !1;
  },
  update: function(t) {
    for (var e = (this || window)._gridSize, n = (this || window)._amplitude, r = cc.p(0, 0), s = (this || window)._amplitudeRate, o = (this || window)._waves, a = 0; a < e.width + 1; ++a)
      for (var c = 0; c < e.height + 1; ++c) {
        r.x = a, r.y = c;
        var l = (this || window).originalVertex(r);
        l.z += Math.sin(Math.PI * t * o * 2 + (l.y + l.x) * 0.01) * n * s, this.setVertex(r, l);
      }
  }
});
cc.waves3D = function(t, e, n, r) {
  return new cc.Waves3D(t, e, n, r);
};
cc.Waves3D.create = cc.waves3D;
cc.FlipX3D = cc.Grid3DAction.extend({
  ctor: function(t) {
    t !== void 0 ? cc.GridAction.prototype.ctor.call(this, t, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this);
  },
  initWithDuration: function(t) {
    return cc.Grid3DAction.prototype.initWithDuration.call(this, t, cc.size(1, 1));
  },
  initWithSize: function(t, e) {
    return t.width !== 1 || t.height !== 1 ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, e, t);
  },
  update: function(t) {
    var e = Math.PI * t, n = Math.sin(e);
    e = e / 2;
    var r = Math.cos(e), s = new cc.Vertex3F(), o = cc.p(0, 0);
    o.x = o.y = 1;
    var a = (this || window).originalVertex(o);
    o.x = o.y = 0;
    var c = (this || window).originalVertex(o), l = a.x, h = c.x, u, _, d, f, C;
    l > h ? (_ = cc.p(0, 0), d = cc.p(0, 1), f = cc.p(1, 0), C = cc.p(1, 1), u = l) : (f = cc.p(0, 0), C = cc.p(0, 1), _ = cc.p(1, 0), d = cc.p(1, 1), u = h), s.x = u - u * r, s.z = Math.abs(parseFloat(u * n / 4));
    var m = (this || window).originalVertex(_);
    m.x = s.x, m.z += s.z, this.setVertex(_, m), m = (this || window).originalVertex(d), m.x = s.x, m.z += s.z, this.setVertex(d, m), m = (this || window).originalVertex(f), m.x -= s.x, m.z -= s.z, this.setVertex(f, m), m = (this || window).originalVertex(C), m.x -= s.x, m.z -= s.z, this.setVertex(C, m);
  }
});
cc.flipX3D = function(t) {
  return new cc.FlipX3D(t);
};
cc.FlipX3D.create = cc.flipX3D;
cc.FlipY3D = cc.FlipX3D.extend({
  ctor: function(t) {
    t !== void 0 ? cc.GridAction.prototype.ctor.call(this, t, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this);
  },
  update: function(t) {
    var e = Math.PI * t, n = Math.sin(e);
    e = e / 2;
    var r = Math.cos(e), s = new cc.Vertex3F(), o = cc.p(0, 0);
    o.x = o.y = 1;
    var a = (this || window).originalVertex(o);
    o.x = o.y = 0;
    var c = (this || window).originalVertex(o), l = a.y, h = c.y, u, _, d, f, C;
    l > h ? (_ = cc.p(0, 0), d = cc.p(0, 1), f = cc.p(1, 0), C = cc.p(1, 1), u = l) : (d = cc.p(0, 0), _ = cc.p(0, 1), C = cc.p(1, 0), f = cc.p(1, 1), u = h), s.y = u - u * r, s.z = Math.abs(parseFloat(u * n) / 4);
    var m = (this || window).originalVertex(_);
    m.y = s.y, m.z += s.z, this.setVertex(_, m), m = (this || window).originalVertex(d), m.y -= s.y, m.z -= s.z, this.setVertex(d, m), m = (this || window).originalVertex(f), m.y = s.y, m.z += s.z, this.setVertex(f, m), m = (this || window).originalVertex(C), m.y -= s.y, m.z -= s.z, this.setVertex(C, m);
  }
});
cc.flipY3D = function(t) {
  return new cc.FlipY3D(t);
};
cc.FlipY3D.create = cc.flipY3D;
cc.Lens3D = cc.Grid3DAction.extend({
  _position: null,
  _radius: 0,
  _lensEffect: 0,
  _concave: !1,
  _dirty: !1,
  ctor: function(t, e, n, r) {
    cc.GridAction.prototype.ctor.call(this), this._position = cc.p(0, 0), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  getLensEffect: function() {
    return this._lensEffect;
  },
  setLensEffect: function(t) {
    this._lensEffect = t;
  },
  setConcave: function(t) {
    this._concave = t;
  },
  getPosition: function() {
    return this._position;
  },
  setPosition: function(t) {
    cc.pointEqualToPoint(t, this._position) || (this._position.x = t.x, this._position.y = t.y, this._dirty = !0);
  },
  initWithDuration: function(t, e, n, r) {
    return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this.setPosition(n), this._radius = r, this._lensEffect = 0.7, this._dirty = !0, !0) : !1;
  },
  update: function(t) {
    if (this._dirty) {
      for (var e = (this || window)._gridSize.width, n = (this || window)._gridSize.height, r = (this || window)._radius, s = (this || window)._lensEffect, o = cc.p(0, 0), a = cc.p(0, 0), c, l, h, u, _, d = 0; d < e + 1; ++d)
        for (var f = 0; f < n + 1; ++f)
          o.x = d, o.y = f, c = (this || window).originalVertex(o), a.x = (this || window)._position.x - c.x, a.y = (this || window)._position.y - c.y, l = cc.pLength(a), l < r && (l = r - l, _ = l / r, _ === 0 && (_ = 1e-3), h = Math.log(_) * s, u = Math.exp(h) * r, l = cc.pLength(a), l > 0 && (a.x = a.x / l, a.y = a.y / l, a.x = a.x * u, a.y = a.y * u, c.z += cc.pLength(a) * s)), this.setVertex(o, c);
      this._dirty = !1;
    }
  }
});
cc.lens3D = function(t, e, n, r) {
  return new cc.Lens3D(t, e, n, r);
};
cc.Lens3D.create = cc.lens3D;
cc.Ripple3D = cc.Grid3DAction.extend({
  _position: null,
  _radius: 0,
  _waves: 0,
  _amplitude: 0,
  _amplitudeRate: 0,
  ctor: function(t, e, n, r, s, o) {
    cc.GridAction.prototype.ctor.call(this), this._position = cc.p(0, 0), o !== void 0 && this.initWithDuration(t, e, n, r, s, o);
  },
  getPosition: function() {
    return this._position;
  },
  setPosition: function(t) {
    this._position.x = t.x, this._position.y = t.y;
  },
  getAmplitude: function() {
    return this._amplitude;
  },
  setAmplitude: function(t) {
    this._amplitude = t;
  },
  getAmplitudeRate: function() {
    return this._amplitudeRate;
  },
  setAmplitudeRate: function(t) {
    this._amplitudeRate = t;
  },
  initWithDuration: function(t, e, n, r, s, o) {
    return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this.setPosition(n), this._radius = r, this._waves = s, this._amplitude = o, this._amplitudeRate = 1, !0) : !1;
  },
  update: function(t) {
    for (var e = (this || window)._gridSize.width, n = (this || window)._gridSize.height, r = cc.p(0, 0), s = (this || window)._radius, o = (this || window)._waves, a = (this || window)._amplitude, c = (this || window)._amplitudeRate, l, h, u = cc.p(0, 0), _ = 0; _ < e + 1; ++_)
      for (var d = 0; d < n + 1; ++d) {
        if (r.x = _, r.y = d, l = (this || window).originalVertex(r), u.x = (this || window)._position.x - l.x, u.y = (this || window)._position.y - l.y, h = cc.pLength(u), h < s) {
          h = s - h;
          var f = Math.pow(h / s, 2);
          l.z += Math.sin(t * Math.PI * o * 2 + h * 0.1) * a * c * f;
        }
        this.setVertex(r, l);
      }
  }
});
cc.ripple3D = function(t, e, n, r, s, o) {
  return new cc.Ripple3D(t, e, n, r, s, o);
};
cc.Ripple3D.create = cc.ripple3D;
cc.Shaky3D = cc.Grid3DAction.extend({
  _randRange: 0,
  _shakeZ: !1,
  ctor: function(t, e, n, r) {
    cc.GridAction.prototype.ctor.call(this), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  initWithDuration: function(t, e, n, r) {
    return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._randRange = n, this._shakeZ = r, !0) : !1;
  },
  update: function(t) {
    for (var e = (this || window)._gridSize.width, n = (this || window)._gridSize.height, r = (this || window)._randRange, s = (this || window)._shakeZ, o = cc.p(0, 0), a, c = 0; c < e + 1; ++c)
      for (var l = 0; l < n + 1; ++l)
        o.x = c, o.y = l, a = (this || window).originalVertex(o), a.x += cc.rand() % (r * 2) - r, a.y += cc.rand() % (r * 2) - r, s && (a.z += cc.rand() % (r * 2) - r), this.setVertex(o, a);
  }
});
cc.shaky3D = function(t, e, n, r) {
  return new cc.Shaky3D(t, e, n, r);
};
cc.Shaky3D.create = cc.shaky3D;
cc.Liquid = cc.Grid3DAction.extend({
  _waves: 0,
  _amplitude: 0,
  _amplitudeRate: 0,
  ctor: function(t, e, n, r) {
    cc.GridAction.prototype.ctor.call(this), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  getAmplitude: function() {
    return this._amplitude;
  },
  setAmplitude: function(t) {
    this._amplitude = t;
  },
  getAmplitudeRate: function() {
    return this._amplitudeRate;
  },
  setAmplitudeRate: function(t) {
    this._amplitudeRate = t;
  },
  initWithDuration: function(t, e, n, r) {
    return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._waves = n, this._amplitude = r, this._amplitudeRate = 1, !0) : !1;
  },
  update: function(t) {
    for (var e = (this || window)._gridSize.width, n = (this || window)._gridSize.height, r = cc.p(0, 0), s = (this || window)._waves, o = (this || window)._amplitude, a = (this || window)._amplitudeRate, c, l = 1; l < e; ++l)
      for (var h = 1; h < n; ++h)
        r.x = l, r.y = h, c = (this || window).originalVertex(r), c.x = c.x + Math.sin(t * Math.PI * s * 2 + c.x * 0.01) * o * a, c.y = c.y + Math.sin(t * Math.PI * s * 2 + c.y * 0.01) * o * a, this.setVertex(r, c);
  }
});
cc.liquid = function(t, e, n, r) {
  return new cc.Liquid(t, e, n, r);
};
cc.Liquid.create = cc.liquid;
cc.Waves = cc.Grid3DAction.extend({
  _waves: 0,
  _amplitude: 0,
  _amplitudeRate: 0,
  _vertical: !1,
  _horizontal: !1,
  ctor: function(t, e, n, r, s, o) {
    cc.GridAction.prototype.ctor.call(this), o !== void 0 && this.initWithDuration(t, e, n, r, s, o);
  },
  getAmplitude: function() {
    return this._amplitude;
  },
  setAmplitude: function(t) {
    this._amplitude = t;
  },
  getAmplitudeRate: function() {
    return this._amplitudeRate;
  },
  setAmplitudeRate: function(t) {
    this._amplitudeRate = t;
  },
  initWithDuration: function(t, e, n, r, s, o) {
    return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._waves = n, this._amplitude = r, this._amplitudeRate = 1, this._horizontal = s, this._vertical = o, !0) : !1;
  },
  update: function(t) {
    for (var e = (this || window)._gridSize.width, n = (this || window)._gridSize.height, r = cc.p(0, 0), s = (this || window)._vertical, o = (this || window)._horizontal, a = (this || window)._waves, c = (this || window)._amplitude, l = (this || window)._amplitudeRate, h, u = 0; u < e + 1; ++u)
      for (var _ = 0; _ < n + 1; ++_)
        r.x = u, r.y = _, h = (this || window).originalVertex(r), s && (h.x = h.x + Math.sin(t * Math.PI * a * 2 + h.y * 0.01) * c * l), o && (h.y = h.y + Math.sin(t * Math.PI * a * 2 + h.x * 0.01) * c * l), this.setVertex(r, h);
  }
});
cc.waves = function(t, e, n, r, s, o) {
  return new cc.Waves(t, e, n, r, s, o);
};
cc.Waves.create = cc.waves;
cc.Twirl = cc.Grid3DAction.extend({
  _position: null,
  _twirls: 0,
  _amplitude: 0,
  _amplitudeRate: 0,
  ctor: function(t, e, n, r, s) {
    cc.GridAction.prototype.ctor.call(this), this._position = cc.p(0, 0), s !== void 0 && this.initWithDuration(t, e, n, r, s);
  },
  getPosition: function() {
    return this._position;
  },
  setPosition: function(t) {
    this._position.x = t.x, this._position.y = t.y;
  },
  getAmplitude: function() {
    return this._amplitude;
  },
  setAmplitude: function(t) {
    this._amplitude = t;
  },
  getAmplitudeRate: function() {
    return this._amplitudeRate;
  },
  setAmplitudeRate: function(t) {
    this._amplitudeRate = t;
  },
  initWithDuration: function(t, e, n, r, s) {
    return cc.Grid3DAction.prototype.initWithDuration.call(this, t, e) ? (this.setPosition(n), this._twirls = r, this._amplitude = s, this._amplitudeRate = 1, !0) : !1;
  },
  update: function(t) {
    for (var e = (this || window)._position, n = (this || window)._gridSize.width, r = (this || window)._gridSize.height, s = cc.p(0, 0), o = 0.1 * this._amplitude * this._amplitudeRate, a = (this || window)._twirls, c, l, h, u, _ = cc.p(0, 0), d = 0; d < n + 1; ++d)
      for (var f = 0; f < r + 1; ++f)
        s.x = d, s.y = f, c = (this || window).originalVertex(s), _.x = d - n / 2, _.y = f - r / 2, l = cc.pLength(_) * Math.cos(Math.PI / 2 + t * Math.PI * a * 2) * o, h = Math.sin(l) * (c.y - e.y) + Math.cos(l) * (c.x - e.x), u = Math.cos(l) * (c.y - e.y) - Math.sin(l) * (c.x - e.x), c.x = e.x + h, c.y = e.y + u, this.setVertex(s, c);
  }
});
cc.twirl = function(t, e, n, r, s) {
  return new cc.Twirl(t, e, n, r, s);
};
cc.Twirl.create = cc.twirl;
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
  _randRange: 0,
  _shakeZ: !1,
  ctor: function(t, e, n, r) {
    cc.GridAction.prototype.ctor.call(this), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  initWithDuration: function(t, e, n, r) {
    return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._randRange = n, this._shakeZ = r, !0) : !1;
  },
  update: function(t) {
    for (var e = (this || window)._gridSize, n = (this || window)._randRange, r = cc.p(0, 0), s = 0; s < e.width; ++s)
      for (var o = 0; o < e.height; ++o) {
        r.x = s, r.y = o;
        var a = (this || window).originalTile(r);
        a.bl.x += cc.rand() % (n * 2) - n, a.br.x += cc.rand() % (n * 2) - n, a.tl.x += cc.rand() % (n * 2) - n, a.tr.x += cc.rand() % (n * 2) - n, a.bl.y += cc.rand() % (n * 2) - n, a.br.y += cc.rand() % (n * 2) - n, a.tl.y += cc.rand() % (n * 2) - n, a.tr.y += cc.rand() % (n * 2) - n, this._shakeZ && (a.bl.z += cc.rand() % (n * 2) - n, a.br.z += cc.rand() % (n * 2) - n, a.tl.z += cc.rand() % (n * 2) - n, a.tr.z += cc.rand() % (n * 2) - n), this.setTile(r, a);
      }
  }
});
cc.shakyTiles3D = function(t, e, n, r) {
  return new cc.ShakyTiles3D(t, e, n, r);
};
cc.ShakyTiles3D.create = cc.shakyTiles3D;
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
  _randRange: 0,
  _once: !1,
  _shatterZ: !1,
  ctor: function(t, e, n, r) {
    cc.GridAction.prototype.ctor.call(this), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  initWithDuration: function(t, e, n, r) {
    return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._once = !1, this._randRange = n, this._shatterZ = r, !0) : !1;
  },
  update: function(t) {
    if (this._once === !1) {
      for (var e = (this || window)._gridSize, n = (this || window)._randRange, r, s = cc.p(0, 0), o = 0; o < e.width; ++o)
        for (var a = 0; a < e.height; ++a)
          s.x = o, s.y = a, r = (this || window).originalTile(s), r.bl.x += cc.rand() % (n * 2) - n, r.br.x += cc.rand() % (n * 2) - n, r.tl.x += cc.rand() % (n * 2) - n, r.tr.x += cc.rand() % (n * 2) - n, r.bl.y += cc.rand() % (n * 2) - n, r.br.y += cc.rand() % (n * 2) - n, r.tl.y += cc.rand() % (n * 2) - n, r.tr.y += cc.rand() % (n * 2) - n, this._shatterZ && (r.bl.z += cc.rand() % (n * 2) - n, r.br.z += cc.rand() % (n * 2) - n, r.tl.z += cc.rand() % (n * 2) - n, r.tr.z += cc.rand() % (n * 2) - n), this.setTile(s, r);
      this._once = !0;
    }
  }
});
cc.shatteredTiles3D = function(t, e, n, r) {
  return new cc.ShatteredTiles3D(t, e, n, r);
};
cc.ShatteredTiles3D.create = cc.shatteredTiles3D;
cc.Tile = function(t, e, n) {
  this.position = t || cc.p(0, 0), this.startPosition = e || cc.p(0, 0), this.delta = n || cc.p(0, 0);
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
  _seed: 0,
  _tilesCount: 0,
  _tilesOrder: null,
  _tiles: null,
  ctor: function(t, e, n) {
    cc.GridAction.prototype.ctor.call(this), this._tilesOrder = [], this._tiles = [], n !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._seed = n, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1;
  },
  shuffle: function(t, e) {
    for (var n = e - 1; n >= 0; n--) {
      var r = 0 | cc.rand() % (n + 1), s = t[n];
      t[n] = t[r], t[r] = s;
    }
  },
  getDelta: function(t) {
    var e = (this || window)._gridSize, n = t.width * e.height + t.height;
    return cc.size(
      this._tilesOrder[n] / e.height - t.width,
      this._tilesOrder[n] % e.height - t.height
    );
  },
  placeTile: function(t, e) {
    var n = (this || window).originalTile(t), r = (this || window).target.grid.getStep(), s = e.position;
    n.bl.x += s.x * r.x, n.bl.y += s.y * r.y, n.br.x += s.x * r.x, n.br.y += s.y * r.y, n.tl.x += s.x * r.x, n.tl.y += s.y * r.y, n.tr.x += s.x * r.x, n.tr.y += s.y * r.y, this.setTile(t, n);
  },
  startWithTarget: function(t) {
    cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t);
    var e = (this || window)._gridSize;
    this._tilesCount = e.width * e.height;
    var n = (this || window)._tilesOrder;
    n.length = 0;
    for (var r = 0; r < this._tilesCount; ++r)
      n[r] = r;
    this.shuffle(n, this._tilesCount);
    var s = (this || window)._tiles;
    s.length = 0;
    for (var o = 0, a = cc.size(0, 0), c = 0; c < e.width; ++c)
      for (var l = 0; l < e.height; ++l)
        s[o] = new cc.Tile(), s[o].position = cc.p(c, l), s[o].startPosition = cc.p(c, l), a.width = c, a.height = l, s[o].delta = (this || window).getDelta(a), ++o;
  },
  update: function(t) {
    for (var e = 0, n = (this || window)._gridSize, r = (this || window)._tiles, s, o = cc.p(0, 0), a = 0; a < n.width; ++a)
      for (var c = 0; c < n.height; ++c)
        o.x = a, o.y = c, s = r[e], s.position.x = s.delta.width * t, s.position.y = s.delta.height * t, this.placeTile(o, s), ++e;
  }
});
cc.shuffleTiles = function(t, e, n) {
  return new cc.ShuffleTiles(t, e, n);
};
cc.ShuffleTiles.create = cc.shuffleTiles;
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
  testFunc: function(t, e) {
    var n = (this || window)._gridSize.width * e, r = (this || window)._gridSize.height * e;
    return n === (this || window)._gridSize.width && r === (this || window)._gridSize.height ? 0 : n + r === 0 ? 1 : Math.pow((t.x + t.y) / (n + r), 6);
  },
  turnOnTile: function(t) {
    this.setTile(t, this.originalTile(t));
  },
  turnOffTile: function(t) {
    this.setTile(t, new cc.Quad3());
  },
  transformTile: function(t, e) {
    var n = (this || window).originalTile(t), r = (this || window).target.grid.getStep();
    n.bl.x += r.x / 2 * (1 - e), n.bl.y += r.y / 2 * (1 - e), n.br.x -= r.x / 2 * (1 - e), n.br.y += r.y / 2 * (1 - e), n.tl.x += r.x / 2 * (1 - e), n.tl.y -= r.y / 2 * (1 - e), n.tr.x -= r.x / 2 * (1 - e), n.tr.y -= r.y / 2 * (1 - e), this.setTile(t, n);
  },
  update: function(t) {
    for (var e = (this || window)._gridSize, n = cc.p(0, 0), r, s = 0; s < e.width; ++s)
      for (var o = 0; o < e.height; ++o)
        n.x = s, n.y = o, r = (this || window).testFunc(n, t), r === 0 ? this.turnOffTile(n) : r < 1 ? this.transformTile(n, r) : this.turnOnTile(n);
  }
});
cc.fadeOutTRTiles = function(t, e) {
  return new cc.FadeOutTRTiles(t, e);
};
cc.FadeOutTRTiles.create = cc.fadeOutTRTiles;
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
  testFunc: function(t, e) {
    var n = (this || window)._gridSize.width * (1 - e), r = (this || window)._gridSize.height * (1 - e);
    return n + r === 0 ? 0 : t.x + t.y === 0 ? 1 : Math.pow((n + r) / (t.x + t.y), 6);
  }
});
cc.fadeOutBLTiles = function(t, e) {
  return new cc.FadeOutBLTiles(t, e);
};
cc.FadeOutBLTiles.create = cc.fadeOutBLTiles;
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
  testFunc: function(t, e) {
    var n = (this || window)._gridSize.height * e;
    return n === (this || window)._gridSize.height ? 0 : n === 0 ? 1 : Math.pow(t.y / n, 6);
  },
  transformTile: function(t, e) {
    var n = (this || window).originalTile(t), r = (this || window).target.grid.getStep();
    n.bl.y += r.y / 2 * (1 - e), n.br.y += r.y / 2 * (1 - e), n.tl.y -= r.y / 2 * (1 - e), n.tr.y -= r.y / 2 * (1 - e), this.setTile(t, n);
  }
});
cc.fadeOutUpTiles = function(t, e) {
  return new cc.FadeOutUpTiles(t, e);
};
cc.FadeOutUpTiles.create = cc.fadeOutUpTiles;
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
  testFunc: function(t, e) {
    var n = (this || window)._gridSize.height * (1 - e);
    return n === 0 ? 0 : t.y === 0 ? 1 : Math.pow(n / t.y, 6);
  }
});
cc.fadeOutDownTiles = function(t, e) {
  return new cc.FadeOutDownTiles(t, e);
};
cc.FadeOutDownTiles.create = cc.fadeOutDownTiles;
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
  _seed: null,
  _tilesCount: 0,
  _tilesOrder: null,
  ctor: function(t, e, n) {
    cc.GridAction.prototype.ctor.call(this), this._tilesOrder = [], e !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._seed = n || 0, this._tilesOrder.length = 0, !0) : !1;
  },
  shuffle: function(t, e) {
    for (var n = e - 1; n >= 0; n--) {
      var r = 0 | cc.rand() % (n + 1), s = t[n];
      t[n] = t[r], t[r] = s;
    }
  },
  turnOnTile: function(t) {
    this.setTile(t, this.originalTile(t));
  },
  turnOffTile: function(t) {
    this.setTile(t, new cc.Quad3());
  },
  startWithTarget: function(t) {
    cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t), this._tilesCount = (this || window)._gridSize.width * this._gridSize.height;
    var e = (this || window)._tilesOrder;
    e.length = 0;
    for (var n = 0; n < this._tilesCount; ++n)
      e[n] = n;
    this.shuffle(e, this._tilesCount);
  },
  update: function(t) {
    for (var e = 0 | t * this._tilesCount, n = (this || window)._gridSize, r, s = cc.p(0, 0), o = (this || window)._tilesOrder, a = 0; a < this._tilesCount; a++)
      r = o[a], s.x = 0 | r / n.height, s.y = r % (0 | n.height), a < e ? this.turnOffTile(s) : this.turnOnTile(s);
  }
});
cc.turnOffTiles = function(t, e, n) {
  return new cc.TurnOffTiles(t, e, n);
};
cc.TurnOffTiles.create = cc.turnOffTiles;
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
  _waves: 0,
  _amplitude: 0,
  _amplitudeRate: 0,
  ctor: function(t, e, n, r) {
    cc.GridAction.prototype.ctor.call(this), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  getAmplitude: function() {
    return this._amplitude;
  },
  setAmplitude: function(t) {
    this._amplitude = t;
  },
  getAmplitudeRate: function() {
    return this._amplitudeRate;
  },
  setAmplitudeRate: function(t) {
    this._amplitudeRate = t;
  },
  initWithDuration: function(t, e, n, r) {
    return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._waves = n, this._amplitude = r, this._amplitudeRate = 1, !0) : !1;
  },
  update: function(t) {
    for (var e = (this || window)._gridSize, n = (this || window)._waves, r = (this || window)._amplitude, s = (this || window)._amplitudeRate, o = cc.p(0, 0), a, c = 0; c < e.width; c++)
      for (var l = 0; l < e.height; l++)
        o.x = c, o.y = l, a = (this || window).originalTile(o), a.bl.z = Math.sin(t * Math.PI * n * 2 + (a.bl.y + a.bl.x) * 0.01) * r * s, a.br.z = a.bl.z, a.tl.z = a.bl.z, a.tr.z = a.bl.z, this.setTile(o, a);
  }
});
cc.wavesTiles3D = function(t, e, n, r) {
  return new cc.WavesTiles3D(t, e, n, r);
};
cc.WavesTiles3D.create = cc.wavesTiles3D;
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
  _jumps: 0,
  _amplitude: 0,
  _amplitudeRate: 0,
  ctor: function(t, e, n, r) {
    cc.GridAction.prototype.ctor.call(this), r !== void 0 && this.initWithDuration(t, e, n, r);
  },
  getAmplitude: function() {
    return this._amplitude;
  },
  setAmplitude: function(t) {
    this._amplitude = t;
  },
  getAmplitudeRate: function() {
    return this._amplitudeRate;
  },
  setAmplitudeRate: function(t) {
    this._amplitudeRate = t;
  },
  initWithDuration: function(t, e, n, r) {
    return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, e) ? (this._jumps = n, this._amplitude = r, this._amplitudeRate = 1, !0) : !1;
  },
  update: function(t) {
    for (var e = Math.sin(Math.PI * t * this._jumps * 2) * this._amplitude * this._amplitudeRate, n = Math.sin(Math.PI * (t * this._jumps * 2 + 1)) * this._amplitude * this._amplitudeRate, r = (this || window)._gridSize, s = (this || window).target.grid, o, a = cc.p(0, 0), c = 0; c < r.width; c++)
      for (var l = 0; l < r.height; l++)
        a.x = c, a.y = l, o = s.originalTile(a), (c + l) % 2 === 0 ? (o.bl.z += e, o.br.z += e, o.tl.z += e, o.tr.z += e) : (o.bl.z += n, o.br.z += n, o.tl.z += n, o.tr.z += n), s.setTile(a, o);
  }
});
cc.jumpTiles3D = function(t, e, n, r) {
  return new cc.JumpTiles3D(t, e, n, r);
};
cc.JumpTiles3D.create = cc.jumpTiles3D;
cc.SplitRows = cc.TiledGrid3DAction.extend({
  _rows: 0,
  _winSize: null,
  ctor: function(t, e) {
    cc.GridAction.prototype.ctor.call(this), e !== void 0 && this.initWithDuration(t, e);
  },
  initWithDuration: function(t, e) {
    return this._rows = e, cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, cc.size(1, e));
  },
  update: function(t) {
    for (var e = (this || window)._gridSize, n = (this || window)._winSize.width, r, s, o = cc.p(0, 0), a = 0; a < e.height; ++a)
      o.y = a, r = (this || window).originalTile(o), s = 1, a % 2 === 0 && (s = -1), r.bl.x += s * n * t, r.br.x += s * n * t, r.tl.x += s * n * t, r.tr.x += s * n * t, this.setTile(o, r);
  },
  startWithTarget: function(t) {
    cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t), this._winSize = cc.director.getWinSizeInPixels();
  }
});
cc.splitRows = function(t, e) {
  return new cc.SplitRows(t, e);
};
cc.SplitRows.create = cc.splitRows;
cc.SplitCols = cc.TiledGrid3DAction.extend({
  _cols: 0,
  _winSize: null,
  ctor: function(t, e) {
    cc.GridAction.prototype.ctor.call(this), e !== void 0 && this.initWithDuration(t, e);
  },
  initWithDuration: function(t, e) {
    return this._cols = e, cc.TiledGrid3DAction.prototype.initWithDuration.call(this, t, cc.size(e, 1));
  },
  update: function(t) {
    for (var e = (this || window)._gridSize.width, n = (this || window)._winSize.height, r, s, o = cc.p(0, 0), a = 0; a < e; ++a)
      o.x = a, r = (this || window).originalTile(o), s = 1, a % 2 === 0 && (s = -1), r.bl.y += s * n * t, r.br.y += s * n * t, r.tl.y += s * n * t, r.tr.y += s * n * t, this.setTile(o, r);
    cc.renderer.childrenOrderDirty = !0;
  },
  startWithTarget: function(t) {
    cc.TiledGrid3DAction.prototype.startWithTarget.call(this, t), this._winSize = cc.director.getWinSizeInPixels();
  }
});
cc.splitCols = function(t, e) {
  return new cc.SplitCols(t, e);
};
cc.SplitCols.create = cc.splitCols;
cc.PageTurn3D = cc.Grid3DAction.extend({
  getGrid: function() {
    var t = new cc.Grid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect());
    return t.setNeedDepthTestForBlit(!0), t;
  },
  clone: function() {
    var t = new cc.PageTurn3D();
    return t.initWithDuration(this._duration, this._gridSize), t;
  },
  update: function(t) {
    for (var e = Math.max(0, t - 0.25), n = e * e * 500, r = -100 - n, s = Math.sqrt(t), o = s > 0.5 ? Math.PI / 2 * s : Math.PI / 2 * (1 - s), a = (2 - t) * Math.PI, c = Math.sin(o), l = Math.cos(o), h = (this || window)._gridSize, u = cc.p(0, 0), _ = 0; _ <= h.width; ++_)
      for (var d = 0; d <= h.height; ++d) {
        u.x = _, u.y = d;
        var f = (this || window).getOriginalVertex(u);
        f.x -= (this || window).getGridRect().x;
        var C = Math.sqrt(f.x * f.x + (f.y - r) * (f.y - r)), m = C * c, g = Math.asin(f.x / C), y = g / c, A = Math.cos(y);
        y <= Math.PI ? f.x = m * Math.sin(y) : f.x = 0, f.y = C + r - m * (1 - A) * c, f.z = m * (1 - A) * l, f.x = f.z * Math.sin(a) + f.x * Math.cos(a), f.z = f.z * Math.cos(a) - f.x * Math.cos(a), f.z /= 7, f.z < 0.5 && (f.z = 0.5), f.x += (this || window).getGridRect().x, this.setVertex(u, f);
      }
  }
});
cc.pageTurn3D = function(t, e) {
  return new cc.PageTurn3D(t, e);
};
cc.PageTurn3D.create = cc.pageTurn3D;
cc.ProgressTimer = cc.Node.extend({
  _type: null,
  _percentage: 0,
  _sprite: null,
  _midPoint: null,
  _barChangeRate: null,
  _reverseDirection: !1,
  _className: "ProgressTimer",
  ctor: function(t) {
    cc.Node.prototype.ctor.call(this), this._type = cc.ProgressTimer.TYPE_RADIAL, this._percentage = 0, this._midPoint = cc.p(0, 0), this._barChangeRate = cc.p(0, 0), this._reverseDirection = !1, this._sprite = null, t && this.initWithSprite(t);
  },
  onEnter: function() {
    this._super(), cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this._renderCmd.initCmd(), this._renderCmd._updateProgress());
  },
  cleanup: function() {
    cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._renderCmd.releaseData(), this._super();
  },
  getMidpoint: function() {
    return cc.p(this._midPoint.x, this._midPoint.y);
  },
  setMidpoint: function(t) {
    this._midPoint = cc.pClamp(t, cc.p(0, 0), cc.p(1, 1));
  },
  getBarChangeRate: function() {
    return cc.p(this._barChangeRate.x, this._barChangeRate.y);
  },
  setBarChangeRate: function(t) {
    this._barChangeRate = cc.pClamp(t, cc.p(0, 0), cc.p(1, 1));
  },
  getType: function() {
    return this._type;
  },
  getPercentage: function() {
    return this._percentage;
  },
  getSprite: function() {
    return this._sprite;
  },
  setPercentage: function(t) {
    this._percentage !== t && (this._percentage = cc.clampf(t, 0, 100), this._renderCmd._updateProgress());
  },
  setOpacityModifyRGB: function(t) {
  },
  isOpacityModifyRGB: function() {
    return !1;
  },
  isReverseDirection: function() {
    return this._reverseDirection;
  },
  setColor: function(t) {
    this._sprite.color = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
  },
  setOpacity: function(t) {
    this._sprite.opacity = t, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty);
  },
  getColor: function() {
    return this._sprite.color;
  },
  getOpacity: function() {
    return this._sprite.opacity;
  },
  setReverseProgress: function(t) {
    this._reverseDirection !== t && (this._reverseDirection = t, this._renderCmd.resetVertexData());
  },
  setSprite: function(t) {
    this._sprite !== t && (this._sprite = t, t ? (this.setContentSize(t.width, t.height), t.ignoreAnchorPointForPosition(!0)) : this.setContentSize(0, 0), this._renderCmd.resetVertexData());
  },
  setType: function(t) {
    t !== (this || window)._type && (this._type = t, this._renderCmd.resetVertexData());
  },
  setReverseDirection: function(t) {
    this._reverseDirection !== t && (this._reverseDirection = t, this._renderCmd.resetVertexData());
  },
  initWithSprite: function(t) {
    return this.percentage = 0, this.setAnchorPoint(0.5, 0.5), this._type = cc.ProgressTimer.TYPE_RADIAL, this._reverseDirection = !1, this.midPoint = cc.p(0.5, 0.5), this.barChangeRate = cc.p(1, 1), this.setSprite(t), this._renderCmd.resetVertexData(), !0;
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ProgressTimer.CanvasRenderCmd(this) : new cc.ProgressTimer.WebGLRenderCmd(this);
  }
});
var _p = cc.ProgressTimer.prototype;
_p.midPoint;
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
_p.barChangeRate;
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
_p.type;
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
_p.percentage;
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
_p.sprite;
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
_p.reverseDir;
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
cc.ProgressTimer.create = function(t) {
  return new cc.ProgressTimer(t);
};
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
cc.ProgressTimer.TEXTURE_COORDS = 75;
cc.ProgressTimer.TYPE_RADIAL = 0;
cc.ProgressTimer.TYPE_BAR = 1;
(function() {
  cc.ProgressTimer.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !0, this._PI180 = Math.PI / 180, this._barRect = cc.rect(0, 0, 0, 0), this._origin = cc.p(0, 0), this._radius = 0, this._startAngle = 270, this._endAngle = 270, this._counterClockWise = !1, this._canUseDirtyRegion = !0;
  };
  var t = cc.ProgressTimer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.ProgressTimer.CanvasRenderCmd, t.rendering = function(e, n, r) {
    var s = e || cc._renderContext, o = s.getContext(), a = (this || window)._node, c = a._sprite, l = c._renderCmd._textureCoord, h = c._renderCmd._displayedOpacity / 255;
    if (!(l.width === 0 || l.height === 0) && !(!c._texture || !l.validRect || h === 0)) {
      s.setTransform(this._worldTransform, n, r), s.setCompositeOperation(c._blendFuncStr), s.setGlobalAlpha(h);
      var u = c._rect, _ = c._offsetPosition, d = _.x, f = -_.y - u.height, C = u.width, m = u.height;
      if (s.save(), c._flippedX && (d = -d - C, o.scale(-1, 1)), c._flippedY && (f = _.y, o.scale(1, -1)), a._type === cc.ProgressTimer.TYPE_BAR) {
        var g = (this || window)._barRect;
        o.beginPath(), o.rect(g.x, g.y, g.width, g.height), o.clip(), o.closePath();
      } else if (a._type === cc.ProgressTimer.TYPE_RADIAL) {
        var y = (this || window)._origin.x, A = (this || window)._origin.y;
        o.beginPath(), o.arc(y, A, this._radius, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise), o.lineTo(y, A), o.clip(), o.closePath();
      }
      var D = c._renderCmd._textureToRender || c._texture, N = D.getHtmlElementObj();
      c._renderCmd._colorized ? o.drawImage(
        N,
        0,
        0,
        l.width,
        l.height,
        d,
        f,
        C,
        m
      ) : o.drawImage(
        N,
        l.renderX,
        l.renderY,
        l.width,
        l.height,
        d,
        f,
        C,
        m
      ), s.restore(), cc.g_NumberOfDraws++;
    }
  }, t.releaseData = function() {
  }, t.resetVertexData = function() {
  }, t._updateProgress = function() {
    this.setDirtyFlag(cc.Node._dirtyFlags.contentDirty);
    var e = (this || window)._node, n = e._sprite, r = n.width, s = n.height, o = e._midPoint;
    if (e._type === cc.ProgressTimer.TYPE_RADIAL) {
      this._radius = Math.round(Math.sqrt(r * r + s * s));
      var a, c, l = !1, h = (this || window)._origin;
      h.x = r * o.x, h.y = -s * o.y, e._reverseDirection ? (c = 270, a = 270 - 3.6 * e._percentage) : (a = -90, c = -90 + 3.6 * e._percentage), n._flippedX && (h.x -= r * (e._midPoint.x * 2), a = -a, c = -c, a -= 180, c -= 180, l = !l), n._flippedY && (h.y += s * (e._midPoint.y * 2), l = !l, a = -a, c = -c), this._startAngle = a, this._endAngle = c, this._counterClockWise = l;
    } else {
      var u = e._barChangeRate, _ = e._percentage / 100, d = (this || window)._barRect, f = cc.size(r * (1 - u.x), s * (1 - u.y)), C = cc.size((r - f.width) * _, (s - f.height) * _), m = cc.size(f.width + C.width, f.height + C.height), g = cc.p(r * o.x, s * o.y), y = g.x - m.width / 2;
      o.x > 0.5 && m.width / 2 >= r - g.x && (y = r - m.width);
      var A = g.y - m.height / 2;
      o.y > 0.5 && m.height / 2 >= s - g.y && (A = s - m.height), d.x = 0;
      var D = 1;
      n._flippedX && (d.x -= m.width, D = -1), y > 0 && (d.x += y * D), d.y = 0;
      var N = 1;
      n._flippedY && (d.y += m.height, N = -1), A > 0 && (d.y -= A * N), d.width = m.width, d.height = -m.height;
    }
  }, t._syncStatus = function(e) {
    var n = (this || window)._node;
    if (n._sprite) {
      var r = cc.Node._dirtyFlags, s = (this || window)._dirtyFlag, o = e ? e._node : null;
      o && o._cascadeColorEnabled && e._dirtyFlag & r.colorDirty && (s |= r.colorDirty), o && o._cascadeOpacityEnabled && e._dirtyFlag & r.opacityDirty && (s |= r.opacityDirty), e && e._dirtyFlag & r.transformDirty && (s |= r.transformDirty), this._dirtyFlag = s;
      var a = n._sprite._renderCmd, c = a._dirtyFlag, l = c & r.colorDirty, h = c & r.opacityDirty;
      l && (a._syncDisplayColor(), a._dirtyFlag = a._dirtyFlag & r.colorDirty ^ a._dirtyFlag, this._dirtyFlag = (this || window)._dirtyFlag & r.colorDirty ^ this._dirtyFlag), h && (a._syncDisplayOpacity(), a._dirtyFlag = a._dirtyFlag & r.opacityDirty ^ a._dirtyFlag, this._dirtyFlag = (this || window)._dirtyFlag & r.opacityDirty ^ this._dirtyFlag), (l || h) && a._updateColor(), s & r.transformDirty && this.transform(e), s & r.orderDirty && (this._dirtyFlag = (this || window)._dirtyFlag & r.orderDirty ^ this._dirtyFlag);
    }
  }, t.updateStatus = function() {
    var e = (this || window)._node;
    if (e._sprite) {
      var n = cc.Node._dirtyFlags, r = (this || window)._dirtyFlag, s = e._sprite._renderCmd, o = s._dirtyFlag, a = o & n.colorDirty, c = o & n.opacityDirty;
      a && (s._updateDisplayColor(), s._dirtyFlag = s._dirtyFlag & n.colorDirty ^ s._dirtyFlag, this._dirtyFlag = (this || window)._dirtyFlag & n.colorDirty ^ this._dirtyFlag), c && (s._updateDisplayOpacity(), s._dirtyFlag = s._dirtyFlag & n.opacityDirty ^ s._dirtyFlag, this._dirtyFlag = (this || window)._dirtyFlag & n.opacityDirty ^ this._dirtyFlag), (a || c) && s._updateColor(), r & n.transformDirty && this.transform(this.getParentRenderCmd(), !0), r & n.contentDirty && this._notifyRegionStatus && this._notifyRegionStatus(cc.Node.CanvasRenderCmd.RegionStatus.Dirty), this._dirtyFlag = 0;
    }
  };
})();
cc.ProgressTo = cc.ActionInterval.extend({
  _to: 0,
  _from: 0,
  ctor: function(t, e) {
    cc.ActionInterval.prototype.ctor.call(this), this._to = 0, this._from = 0, e !== void 0 && this.initWithDuration(t, e);
  },
  initWithDuration: function(t, e) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._to = e, !0) : !1;
  },
  clone: function() {
    var t = new cc.ProgressTo();
    return t.initWithDuration(this._duration, this._to), t;
  },
  reverse: function() {
    return cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported."), null;
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._from = t.percentage;
  },
  update: function(t) {
    this.target instanceof cc.ProgressTimer && (this.target.percentage = (this || window)._from + (this._to - this._from) * t);
  }
});
cc.progressTo = function(t, e) {
  return new cc.ProgressTo(t, e);
};
cc.ProgressTo.create = cc.progressTo;
cc.ProgressFromTo = cc.ActionInterval.extend({
  _to: 0,
  _from: 0,
  ctor: function(t, e, n) {
    cc.ActionInterval.prototype.ctor.call(this), this._to = 0, this._from = 0, n !== void 0 && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._to = n, this._from = e, !0) : !1;
  },
  clone: function() {
    var t = new cc.ProgressFromTo();
    return t.initWithDuration(this._duration, this._from, this._to), t;
  },
  reverse: function() {
    return cc.progressFromTo(this._duration, this._to, this._from);
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t);
  },
  update: function(t) {
    this.target instanceof cc.ProgressTimer && (this.target.percentage = (this || window)._from + (this._to - this._from) * t);
  }
});
cc.progressFromTo = function(t, e, n) {
  return new cc.ProgressFromTo(t, e, n);
};
cc.ProgressFromTo.create = cc.progressFromTo;
(function() {
  var t = 8;
  cc.ProgressTimer.WebGLRenderCmd = function(n) {
    cc.Node.WebGLRenderCmd.call(this, n), this._needDraw = !0, this._progressDirty = !0, this._bl = cc.p(), this._tr = cc.p(), this.initCmd();
  };
  var e = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  e.constructor = cc.ProgressTimer.WebGLRenderCmd, e.transform = function(n, r) {
    this.originTransform(n, r);
    var s = (this || window)._node._sprite;
    s._renderCmd.transform(this, r);
    var o = s._offsetPosition.x, a = o + s._rect.width, c = s._offsetPosition.y, l = c + s._rect.height, h = (this || window)._worldTransform;
    this._bl.x = o * h.a + c * h.c + h.tx, this._bl.y = o * h.b + c * h.d + h.ty, this._tr.x = a * h.a + l * h.c + h.tx, this._tr.y = a * h.b + l * h.d + h.ty, this._updateProgressData();
  }, e.rendering = function(n) {
    var r = (this || window)._node, s = n || cc._renderContext;
    if (!(this._vertexDataCount === 0 || !r._sprite)) {
      this._shaderProgram.use(), this._shaderProgram._updateProjectionUniform();
      var o = r._sprite._blendFunc;
      cc.glBlendFunc(o.src, o.dst), cc.glBindTexture2D(r._sprite.texture), s.bindBuffer(s.ARRAY_BUFFER, this._vertexWebGLBuffer), s.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), s.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), s.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), this._vertexDataDirty && (s.bufferSubData(s.ARRAY_BUFFER, 0, this._float32View), this._vertexDataDirty = !1);
      var a = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
      s.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, s.FLOAT, !1, a, 0), s.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, s.UNSIGNED_BYTE, !0, a, 12), s.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, s.FLOAT, !1, a, 16), r._type === cc.ProgressTimer.TYPE_RADIAL ? s.drawArrays(s.TRIANGLE_FAN, 0, this._vertexDataCount) : r._type === cc.ProgressTimer.TYPE_BAR && (r._reverseDirection ? (s.drawArrays(s.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), s.drawArrays(s.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : s.drawArrays(s.TRIANGLE_STRIP, 0, this._vertexDataCount)), cc.g_NumberOfDraws++;
    }
  }, e._syncStatus = function(n) {
    var r = (this || window)._node;
    if (r._sprite) {
      var s = cc.Node._dirtyFlags, o = (this || window)._dirtyFlag, a = n ? n._node : null;
      a && a._cascadeColorEnabled && n._dirtyFlag & s.colorDirty && (o |= s.colorDirty), a && a._cascadeOpacityEnabled && n._dirtyFlag & s.opacityDirty && (o |= s.opacityDirty), n && n._dirtyFlag & s.transformDirty && (o |= s.transformDirty), this._dirtyFlag = o;
      var c = r._sprite._renderCmd, l = c._dirtyFlag, h = (o | l) & s.colorDirty, u = (o | l) & s.opacityDirty;
      h && (c._syncDisplayColor(), c._dirtyFlag = c._dirtyFlag & s.colorDirty ^ c._dirtyFlag, this._dirtyFlag = (this || window)._dirtyFlag & s.colorDirty ^ this._dirtyFlag), u && (c._syncDisplayOpacity(), c._dirtyFlag = c._dirtyFlag & s.opacityDirty ^ c._dirtyFlag, this._dirtyFlag = (this || window)._dirtyFlag & s.opacityDirty ^ this._dirtyFlag), (h || u) && this._updateColor(), o & s.transformDirty && this.transform(n), o & s.textureDirty && (this._updateProgressData(), this._dirtyFlag = (this || window)._dirtyFlag & s.textureDirty ^ this._dirtyFlag), c._dirtyFlag = 0;
    }
  }, e.updateStatus = function() {
    var n = (this || window)._node;
    if (n._sprite) {
      var r = cc.Node._dirtyFlags, s = (this || window)._dirtyFlag, o = n._sprite._renderCmd, a = o._dirtyFlag, c = (s | a) & r.colorDirty, l = (s | a) & r.opacityDirty;
      c && (o._updateDisplayColor(), o._dirtyFlag = o._dirtyFlag & r.colorDirty ^ o._dirtyFlag, this._dirtyFlag = (this || window)._dirtyFlag & r.colorDirty ^ this._dirtyFlag), l && (o._updateDisplayOpacity(), o._dirtyFlag = o._dirtyFlag & r.opacityDirty ^ o._dirtyFlag, this._dirtyFlag = (this || window)._dirtyFlag & r.opacityDirty ^ this._dirtyFlag), (c || l) && this._updateColor(), s & r.transformDirty && this.transform(this.getParentRenderCmd(), !0), s & r.orderDirty && (this._dirtyFlag = (this || window)._dirtyFlag & r.orderDirty ^ this._dirtyFlag), s & r.textureDirty && (this._updateProgressData(), this._dirtyFlag = (this || window)._dirtyFlag & r.textureDirty ^ this._dirtyFlag);
    }
  }, e.releaseData = function() {
    if (this._vertexData) {
      var n = (this || window)._vertexWebGLBuffer;
      setTimeout(function() {
        cc._renderContext.deleteBuffer(n);
      }, 0.1), this._vertexWebGLBuffer = null, this._vertexData = null, this._float32View = null, this._vertexArrayBuffer = null, this._vertexDataCount = 0;
    }
  }, e.initCmd = function() {
    if (!this._vertexData) {
      this._vertexWebGLBuffer = cc._renderContext.createBuffer();
      var n = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
      this._vertexArrayBuffer = new ArrayBuffer(t * n), this._float32View = new Float32Array(this._vertexArrayBuffer), this._vertexData = [];
      for (var r = 0; r < t; r++)
        this._vertexData[r] = new cc.V3F_C4B_T2F(null, null, null, this._vertexArrayBuffer, r * n);
      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexWebGLBuffer), gl.bufferData(gl.ARRAY_BUFFER, this._float32View, gl.DYNAMIC_DRAW), this._vertexDataCount = 0, this._vertexDataDirty = !0, this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLOR);
    }
  }, e.resetVertexData = function() {
    this._vertexDataCount = 0;
  }, e._updateProgressData = function() {
    var n = (this || window)._node, r = n._type;
    r === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : r === cc.ProgressTimer.TYPE_BAR && this._updateBar(), this._vertexDataDirty = !0;
  }, e._updateProgress = function() {
    this.setDirtyFlag(cc.Node._dirtyFlags.textureDirty);
  }, e._updateBar = function() {
    var n = (this || window)._node;
    if (n._sprite) {
      var r = n._percentage / 100, s = n._barChangeRate, o = cc.pMult(cc.p(
        1 - s.x + r * s.x,
        1 - s.y + r * s.y
      ), 0.5), a = cc.pSub(n._midPoint, o), c = cc.pAdd(n._midPoint, o);
      a.x < 0 && (c.x += -a.x, a.x = 0), c.x > 1 && (a.x -= c.x - 1, c.x = 1), a.y < 0 && (c.y += -a.y, a.y = 0), c.y > 1 && (a.y -= c.y - 1, c.y = 1);
      var l;
      this._reverseDirection ? (l = (this || window)._vertexData, this._vertexDataCount || (this._vertexDataCount = 8, this._textureCoordFromAlphaPoint(l[0].texCoords, 0, 1), this._vertexFromAlphaPoint(l[0].vertices, 0, 1), this._textureCoordFromAlphaPoint(l[1].texCoords, 0, 0), this._vertexFromAlphaPoint(l[1].vertices, 0, 0), this._textureCoordFromAlphaPoint(l[6].texCoords, 1, 1), this._vertexFromAlphaPoint(l[6].vertices, 1, 1), this._textureCoordFromAlphaPoint(l[7].texCoords, 1, 0), this._vertexFromAlphaPoint(l[7].vertices, 1, 0)), this._textureCoordFromAlphaPoint(l[2].texCoords, a.x, c.y), this._vertexFromAlphaPoint(l[2].vertices, a.x, c.y), this._textureCoordFromAlphaPoint(l[3].texCoords, a.x, a.y), this._vertexFromAlphaPoint(l[3].vertices, a.x, a.y), this._textureCoordFromAlphaPoint(l[4].texCoords, c.x, c.y), this._vertexFromAlphaPoint(l[4].vertices, c.x, c.y), this._textureCoordFromAlphaPoint(l[5].texCoords, c.x, a.y), this._vertexFromAlphaPoint(l[5].vertices, c.x, a.y)) : (this._vertexDataCount || (this._vertexDataCount = 4), l = (this || window)._vertexData, this._textureCoordFromAlphaPoint(l[0].texCoords, a.x, c.y), this._vertexFromAlphaPoint(l[0].vertices, a.x, c.y), this._textureCoordFromAlphaPoint(l[1].texCoords, a.x, a.y), this._vertexFromAlphaPoint(l[1].vertices, a.x, a.y), this._textureCoordFromAlphaPoint(l[2].texCoords, c.x, c.y), this._vertexFromAlphaPoint(l[2].vertices, c.x, c.y), this._textureCoordFromAlphaPoint(l[3].texCoords, c.x, a.y), this._vertexFromAlphaPoint(l[3].vertices, c.x, a.y)), this._updateColor();
    }
  }, e._updateRadial = function() {
    var n = (this || window)._node;
    if (n._sprite) {
      var r, s = n._midPoint, o = n._percentage / 100, a = 2 * cc.PI * (n._reverseDirection ? o : 1 - o), c = cc.p(s.x, 1), l = cc.pRotateByAngle(c, s, a), h = 0, u;
      if (o === 0)
        u = c, h = 0;
      else if (o === 1)
        u = c, h = 4;
      else {
        var _ = cc.FLT_MAX, d = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
        for (r = 0; r <= d; ++r) {
          var f = (r + (d - 1)) % d, C = (this || window)._boundaryTexCoord(r % d), m = (this || window)._boundaryTexCoord(f);
          r === 0 ? m = cc.pLerp(C, m, 1 - s.x) : r === 4 && (C = cc.pLerp(C, m, 1 - s.x));
          var g = cc.p(0, 0);
          if (cc.pLineIntersect(C, m, s, l, g)) {
            if ((r === 0 || r === 4) && !(0 <= g.x && g.x <= 1))
              continue;
            g.y >= 0 && g.y < _ && (_ = g.y, h = r);
          }
        }
        u = cc.pAdd(s, cc.pMult(cc.pSub(l, s), _));
      }
      var y = !0;
      this._vertexDataCount !== h + 3 && (y = !1, this._vertexDataCount = h + 3), this._updateColor();
      var A = (this || window)._vertexData;
      if (!y)
        for (this._textureCoordFromAlphaPoint(A[0].texCoords, s.x, s.y), this._vertexFromAlphaPoint(A[0].vertices, s.x, s.y), this._textureCoordFromAlphaPoint(A[1].texCoords, c.x, c.y), this._vertexFromAlphaPoint(A[1].vertices, c.x, c.y), r = 0; r < h; r++) {
          var D = (this || window)._boundaryTexCoord(r);
          this._textureCoordFromAlphaPoint(A[r + 2].texCoords, D.x, D.y), this._vertexFromAlphaPoint(A[r + 2].vertices, D.x, D.y);
        }
      this._textureCoordFromAlphaPoint(A[this._vertexDataCount - 1].texCoords, u.x, u.y), this._vertexFromAlphaPoint(A[this._vertexDataCount - 1].vertices, u.x, u.y);
    }
  }, e._boundaryTexCoord = function(n) {
    if (n < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
      var r = cc.ProgressTimer.TEXTURE_COORDS;
      return this._node._reverseDirection ? cc.p(r >> 7 - (n << 1) & 1, r >> 7 - ((n << 1) + 1) & 1) : cc.p(r >> (n << 1) + 1 & 1, r >> (n << 1) & 1);
    }
    return cc.p(0, 0);
  }, e._textureCoordFromAlphaPoint = function(n, r, s) {
    var o = (this || window)._node._sprite;
    if (!o) {
      n.u = 0, n.v = 0;
      return;
    }
    var a = o._renderCmd._vertices, c = a[1], l = a[2], h = cc.p(c.u, c.v), u = cc.p(l.u, l.v);
    if (o.textureRectRotated) {
      var _ = r;
      r = s, s = _;
    }
    n.u = h.x * (1 - r) + u.x * r, n.v = h.y * (1 - s) + u.y * s;
  }, e._vertexFromAlphaPoint = function(n, r, s) {
    n.x = (this || window)._bl.x * (1 - r) + this._tr.x * r, n.y = (this || window)._bl.y * (1 - s) + this._tr.y * s, n.z = (this || window)._node._vertexZ;
  }, e._updateColor = function() {
    var n = (this || window)._node._sprite;
    if (!(!this._vertexDataCount || !n)) {
      var r = (this || window)._displayedColor, s = n._renderCmd._displayedColor, o = s.r, a = s.g, c = s.b, l = n._renderCmd._displayedOpacity / 255;
      n._opacityModifyRGB && (o *= l, a *= l, c *= l), r.r = o, r.g = a, r.b = c, r.a = n._renderCmd._displayedOpacity;
      for (var h = (this || window)._vertexData, u = 0, _ = (this || window)._vertexDataCount; u < _; ++u)
        h[u].colors = r;
      this._vertexDataDirty = !0;
    }
  };
})();
cc.SCENE_FADE = 4208917214;
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({
  _inScene: null,
  _outScene: null,
  _duration: null,
  _isInSceneOnTop: !1,
  _isSendCleanupToScene: !1,
  _className: "TransitionScene",
  ctor: function(t, e) {
    cc.Scene.prototype.ctor.call(this), t !== void 0 && e !== void 0 && this.initWithDuration(t, e);
  },
  _setNewScene: function(t) {
    this.unschedule(this._setNewScene);
    var e = cc.director;
    this._isSendCleanupToScene = e.isSendCleanupToScene(), e.runScene(this._inScene), cc.eventManager.setEnabled(!0), this._outScene.visible = !0;
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = !0;
  },
  visit: function() {
    this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit()), cc.Node.prototype.visit.call(this);
  },
  onEnter: function() {
    cc.Node.prototype.onEnter.call(this), cc.eventManager.setEnabled(!1), this._outScene.onExitTransitionDidStart(), this._inScene.onEnter();
  },
  onExit: function() {
    cc.Node.prototype.onExit.call(this), cc.eventManager.setEnabled(!0), this._outScene.onExit(), this._inScene.onEnterTransitionDidFinish();
  },
  cleanup: function() {
    cc.Node.prototype.cleanup.call(this), this._isSendCleanupToScene && this._outScene.cleanup();
  },
  initWithDuration: function(t, e) {
    if (!e)
      throw new Error("cc.TransitionScene.initWithDuration(): Argument scene must be non-nil");
    if (this.init()) {
      if (this._duration = t, this.attr({
        x: 0,
        y: 0,
        anchorX: 0,
        anchorY: 0
      }), this._inScene = e, this._outScene = cc.director.getRunningScene(), this._outScene || (this._outScene = new cc.Scene(), this._outScene.init()), this._inScene === (this || window)._outScene)
        throw new Error("cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene");
      return this._sceneOrder(), !0;
    } else
      return !1;
  },
  finish: function() {
    this._inScene.attr({
      visible: !0,
      x: 0,
      y: 0,
      scale: 1,
      rotation: 0
    }), this._outScene.attr({
      visible: !1,
      x: 0,
      y: 0,
      scale: 1,
      rotation: 0
    }), this.schedule(this._setNewScene, 0);
  },
  hideOutShowIn: function() {
    this._inScene.visible = !0, this._outScene.visible = !1;
  }
});
cc.TransitionScene.create = function(t, e) {
  return new cc.TransitionScene(t, e);
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({
  _orientation: 0,
  ctor: function(t, e, n) {
    cc.TransitionScene.prototype.ctor.call(this), n != null && this.initWithDuration(t, e, n);
  },
  initWithDuration: function(t, e, n) {
    return cc.TransitionScene.prototype.initWithDuration.call(this, t, e) && (this._orientation = n), !0;
  }
});
cc.TransitionSceneOriented.create = function(t, e, n) {
  return new cc.TransitionSceneOriented(t, e, n);
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this), this._inScene.attr({
      scale: 1e-3,
      anchorX: 0.5,
      anchorY: 0.5
    }), this._outScene.attr({
      scale: 1,
      anchorX: 0.5,
      anchorY: 0.5
    });
    var t = cc.sequence(
      cc.spawn(
        cc.scaleBy(this._duration / 2, 1e-3),
        cc.rotateBy(this._duration / 2, 360 * 2)
      ),
      cc.delayTime(this._duration / 2)
    );
    this._outScene.runAction(t), this._inScene.runAction(
      cc.sequence(
        t.reverse(),
        cc.callFunc(this.finish, this)
      )
    );
  }
});
cc.TransitionRotoZoom.create = function(t, e) {
  return new cc.TransitionRotoZoom(t, e);
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this);
    var t = cc.director.getWinSize();
    this._inScene.attr({
      scale: 0.5,
      x: t.width,
      y: 0,
      anchorX: 0.5,
      anchorY: 0.5
    }), this._outScene.anchorX = 0.5, this._outScene.anchorY = 0.5;
    var e = cc.jumpBy(this._duration / 4, cc.p(-t.width, 0), t.width / 4, 2), n = cc.scaleTo(this._duration / 4, 1), r = cc.scaleTo(this._duration / 4, 0.5), s = cc.sequence(r, e), o = cc.sequence(e, n), a = cc.delayTime(this._duration / 2);
    this._outScene.runAction(s), this._inScene.runAction(cc.sequence(a, o, cc.callFunc(this.finish, this)));
  }
});
cc.TransitionJumpZoom.create = function(t, e) {
  return new cc.TransitionJumpZoom(t, e);
};
cc.TransitionMoveInL = cc.TransitionScene.extend({
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this), this.initScenes();
    var t = (this || window).action();
    this._inScene.runAction(
      cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this))
    );
  },
  initScenes: function() {
    this._inScene.setPosition(-cc.director.getWinSize().width, 0);
  },
  action: function() {
    return cc.moveTo(this._duration, cc.p(0, 0));
  },
  easeActionWithAction: function(t) {
    return new cc.EaseOut(t, 2);
  }
});
cc.TransitionMoveInL.create = function(t, e) {
  return new cc.TransitionMoveInL(t, e);
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
  ctor: function(t, e) {
    cc.TransitionMoveInL.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  initScenes: function() {
    this._inScene.setPosition(cc.director.getWinSize().width, 0);
  }
});
cc.TransitionMoveInR.create = function(t, e) {
  return new cc.TransitionMoveInR(t, e);
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
  ctor: function(t, e) {
    cc.TransitionMoveInL.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  initScenes: function() {
    this._inScene.setPosition(0, cc.director.getWinSize().height);
  }
});
cc.TransitionMoveInT.create = function(t, e) {
  return new cc.TransitionMoveInT(t, e);
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
  ctor: function(t, e) {
    cc.TransitionMoveInL.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  initScenes: function() {
    this._inScene.setPosition(0, -cc.director.getWinSize().height);
  }
});
cc.TransitionMoveInB.create = function(t, e) {
  return new cc.TransitionMoveInB(t, e);
};
cc.ADJUST_FACTOR = 0.5;
cc.TransitionSlideInL = cc.TransitionScene.extend({
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = !1;
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this), this.initScenes();
    var t = (this || window).action(), e = (this || window).action(), n = cc.sequence(this.easeActionWithAction(t), cc.callFunc(this.finish, this)), r = (this || window).easeActionWithAction(e);
    this._inScene.runAction(n), this._outScene.runAction(r);
  },
  initScenes: function() {
    this._inScene.setPosition(-cc.director.getWinSize().width + cc.ADJUST_FACTOR, 0);
  },
  action: function() {
    return cc.moveBy(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0));
  },
  easeActionWithAction: function(t) {
    return new cc.EaseInOut(t, 2);
  }
});
cc.TransitionSlideInL.create = function(t, e) {
  return new cc.TransitionSlideInL(t, e);
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
  ctor: function(t, e) {
    cc.TransitionSlideInL.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = !0;
  },
  initScenes: function() {
    this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0);
  },
  action: function() {
    return cc.moveBy(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0));
  }
});
cc.TransitionSlideInR.create = function(t, e) {
  return new cc.TransitionSlideInR(t, e);
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
  ctor: function(t, e) {
    cc.TransitionSlideInL.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = !1;
  },
  initScenes: function() {
    this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR));
  },
  action: function() {
    return cc.moveBy(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR));
  }
});
cc.TransitionSlideInB.create = function(t, e) {
  return new cc.TransitionSlideInB(t, e);
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
  ctor: function(t, e) {
    cc.TransitionSlideInL.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = !0;
  },
  initScenes: function() {
    this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR);
  },
  action: function() {
    return cc.moveBy(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)));
  }
});
cc.TransitionSlideInT.create = function(t, e) {
  return new cc.TransitionSlideInT(t, e);
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this), this._inScene.attr({
      scale: 1e-3,
      anchorX: 2 / 3,
      anchorY: 0.5
    }), this._outScene.attr({
      scale: 1,
      anchorX: 1 / 3,
      anchorY: 0.5
    });
    var t = cc.scaleTo(this._duration, 0.01), e = cc.scaleTo(this._duration, 1);
    this._inScene.runAction(cc.sequence(this.easeActionWithAction(e), cc.callFunc(this.finish, this))), this._outScene.runAction(this.easeActionWithAction(t));
  },
  easeActionWithAction: function(t) {
    return new cc.EaseOut(t, 2);
  }
});
cc.TransitionShrinkGrow.create = function(t, e) {
  return new cc.TransitionShrinkGrow(t, e);
};
cc.TransitionFade = cc.TransitionScene.extend({
  _color: null,
  ctor: function(t, e, n) {
    cc.TransitionScene.prototype.ctor.call(this), this._color = cc.color(), e && this.initWithDuration(t, e, n);
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this);
    var t = new cc.LayerColor(this._color);
    this._inScene.visible = !1, this.addChild(t, 2, cc.SCENE_FADE);
    var e = (this || window).getChildByTag(cc.SCENE_FADE), n = cc.sequence(
      cc.fadeIn(this._duration / 2),
      cc.callFunc(this.hideOutShowIn, this),
      cc.fadeOut(this._duration / 2),
      cc.callFunc(this.finish, this)
    );
    e.runAction(n);
  },
  onExit: function() {
    cc.TransitionScene.prototype.onExit.call(this), this.removeChildByTag(cc.SCENE_FADE, !1);
  },
  initWithDuration: function(t, e, n) {
    return n = n || cc.color.BLACK, cc.TransitionScene.prototype.initWithDuration.call(this, t, e) && (this._color.r = n.r, this._color.g = n.g, this._color.b = n.b, this._color.a = 0), !0;
  }
});
cc.TransitionFade.create = function(t, e, n) {
  return new cc.TransitionFade(t, e, n);
};
cc.TransitionCrossFade = cc.TransitionScene.extend({
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this);
    var t = cc.color(0, 0, 0, 0), e = cc.director.getWinSize(), n = new cc.LayerColor(t), r = new cc.RenderTexture(e.width, e.height);
    r.sprite.anchorX = 0.5, r.sprite.anchorY = 0.5, r.attr({
      x: e.width / 2,
      y: e.height / 2,
      anchorX: 0.5,
      anchorY: 0.5
    }), r.begin(), this._inScene.visit(), r.end();
    var s = new cc.RenderTexture(e.width, e.height);
    s.setPosition(e.width / 2, e.height / 2), s.sprite.anchorX = s.anchorX = 0.5, s.sprite.anchorY = s.anchorY = 0.5, s.begin(), this._outScene.visit(), s.end(), r.sprite.setBlendFunc(cc.ONE, cc.ONE), s.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA), n.addChild(r), n.addChild(s), r.sprite.opacity = 255, s.sprite.opacity = 255;
    var o = cc.sequence(
      cc.fadeTo(this._duration, 0),
      cc.callFunc(this.hideOutShowIn, this),
      cc.callFunc(this.finish, this)
    );
    s.sprite.runAction(o), this.addChild(n, 2, cc.SCENE_FADE);
  },
  onExit: function() {
    this.removeChildByTag(cc.SCENE_FADE, !1), cc.TransitionScene.prototype.onExit.call(this);
  },
  visit: function() {
    cc.Node.prototype.visit.call(this);
  },
  draw: function() {
  }
});
cc.TransitionCrossFade.create = function(t, e) {
  return new cc.TransitionCrossFade(t, e);
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
  _gridProxy: null,
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), this._gridProxy = new cc.NodeGrid(), e && this.initWithDuration(t, e);
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = !1;
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this), this._gridProxy.setTarget(this._outScene), this._gridProxy.onEnter();
    var t = cc.director.getWinSize(), e = t.width / t.height, n = 0 | 12 * e, r = 12, s = cc.turnOffTiles(this._duration, cc.size(n, r)), o = (this || window).easeActionWithAction(s);
    this._gridProxy.runAction(cc.sequence(o, cc.callFunc(this.finish, this), cc.stopGrid()));
  },
  visit: function() {
    this._inScene.visit(), this._gridProxy.visit();
  },
  easeActionWithAction: function(t) {
    return t;
  }
});
cc.TransitionTurnOffTiles.create = function(t, e) {
  return new cc.TransitionTurnOffTiles(t, e);
};
cc.TransitionSplitCols = cc.TransitionScene.extend({
  _gridProxy: null,
  _switchTargetToInscene: function() {
    this._gridProxy.setTarget(this._inScene);
  },
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), this._gridProxy = new cc.NodeGrid(), e && this.initWithDuration(t, e);
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this), this._gridProxy.setTarget(this._outScene), this._gridProxy.onEnter();
    var t = (this || window).action(), e = cc.sequence(
      t,
      cc.callFunc(this._switchTargetToInscene, this),
      t.reverse()
    );
    this._gridProxy.runAction(
      cc.sequence(this.easeActionWithAction(e), cc.callFunc(this.finish, this), cc.stopGrid())
    );
  },
  onExit: function() {
    this._gridProxy.setTarget(null), this._gridProxy.onExit(), cc.TransitionScene.prototype.onExit.call(this);
  },
  visit: function() {
    this._gridProxy.visit();
  },
  easeActionWithAction: function(t) {
    return new cc.EaseInOut(t, 3);
  },
  action: function() {
    return cc.splitCols(this._duration / 2, 3);
  }
});
cc.TransitionSplitCols.create = function(t, e) {
  return new cc.TransitionSplitCols(t, e);
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
  ctor: function(t, e) {
    cc.TransitionSplitCols.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  action: function() {
    return cc.splitRows(this._duration / 2, 3);
  }
});
cc.TransitionSplitRows.create = function(t, e) {
  return new cc.TransitionSplitRows(t, e);
};
cc.TransitionFadeTR = cc.TransitionScene.extend({
  _gridProxy: null,
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), this._gridProxy = new cc.NodeGrid(), e && this.initWithDuration(t, e);
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = !1;
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this), this._gridProxy.setTarget(this._outScene), this._gridProxy.onEnter();
    var t = cc.director.getWinSize(), e = t.width / t.height, n = 0 | 12 * e, r = 12, s = (this || window).actionWithSize(cc.size(n, r));
    this._gridProxy.runAction(
      cc.sequence(this.easeActionWithAction(s), cc.callFunc(this.finish, this), cc.stopGrid())
    );
  },
  visit: function() {
    this._inScene.visit(), this._gridProxy.visit();
  },
  easeActionWithAction: function(t) {
    return t;
  },
  actionWithSize: function(t) {
    return cc.fadeOutTRTiles(this._duration, t);
  }
});
cc.TransitionFadeTR.create = function(t, e) {
  return new cc.TransitionFadeTR(t, e);
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
  ctor: function(t, e) {
    cc.TransitionFadeTR.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  actionWithSize: function(t) {
    return cc.fadeOutBLTiles(this._duration, t);
  }
});
cc.TransitionFadeBL.create = function(t, e) {
  return new cc.TransitionFadeBL(t, e);
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
  ctor: function(t, e) {
    cc.TransitionFadeTR.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  actionWithSize: function(t) {
    return new cc.FadeOutUpTiles(this._duration, t);
  }
});
cc.TransitionFadeUp.create = function(t, e) {
  return new cc.TransitionFadeUp(t, e);
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
  ctor: function(t, e) {
    cc.TransitionFadeTR.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  actionWithSize: function(t) {
    return cc.fadeOutDownTiles(this._duration, t);
  }
});
cc.TransitionFadeDown.create = function(t, e) {
  return new cc.TransitionFadeDown(t, e);
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({
  _to: 0,
  _from: 0,
  _sceneToBeModified: null,
  _className: "TransitionProgress",
  ctor: function(t, e) {
    cc.TransitionScene.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _setAttrs: function(t, e, n) {
    t.attr({
      x: e,
      y: n,
      anchorX: 0.5,
      anchorY: 0.5
    });
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this), this._setupTransition();
    var t = cc.director.getWinSize(), e = new cc.RenderTexture(t.width, t.height);
    e.sprite.anchorX = 0.5, e.sprite.anchorY = 0.5, this._setAttrs(e, t.width / 2, t.height / 2), e.clear(0, 0, 0, 1), e.begin(), this._sceneToBeModified.visit(), e.end(), this._sceneToBeModified === (this || window)._outScene && this.hideOutShowIn();
    var n = (this || window)._progressTimerNodeWithRenderTexture(e), r = cc.sequence(
      cc.progressFromTo(this._duration, this._from, this._to),
      cc.callFunc(this.finish, this)
    );
    n.runAction(r), this.addChild(n, 2, cc.SCENE_RADIAL);
  },
  onExit: function() {
    this.removeChildByTag(cc.SCENE_RADIAL, !0), cc.TransitionScene.prototype.onExit.call(this);
  },
  _setupTransition: function() {
    this._sceneToBeModified = (this || window)._outScene, this._from = 100, this._to = 0;
  },
  _progressTimerNodeWithRenderTexture: function(t) {
    return cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass"), null;
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = !1;
  }
});
cc.TransitionProgress.create = function(t, e) {
  return new cc.TransitionProgress(t, e);
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
  ctor: function(t, e) {
    cc.TransitionProgress.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _progressTimerNodeWithRenderTexture: function(t) {
    var e = cc.director.getWinSize(), n = new cc.ProgressTimer(t.sprite);
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL && (n.sprite.flippedY = !0), n.type = cc.ProgressTimer.TYPE_RADIAL, n.reverseDir = !1, n.percentage = 100, this._setAttrs(n, e.width / 2, e.height / 2), n;
  }
});
cc.TransitionProgressRadialCCW.create = function(t, e) {
  return new cc.TransitionProgressRadialCCW(t, e);
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
  ctor: function(t, e) {
    cc.TransitionProgress.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _progressTimerNodeWithRenderTexture: function(t) {
    var e = cc.director.getWinSize(), n = new cc.ProgressTimer(t.sprite);
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL && (n.sprite.flippedY = !0), n.type = cc.ProgressTimer.TYPE_RADIAL, n.reverseDir = !0, n.percentage = 100, this._setAttrs(n, e.width / 2, e.height / 2), n;
  }
});
cc.TransitionProgressRadialCW.create = function(t, e) {
  var n = new cc.TransitionProgressRadialCW();
  return n !== null && n.initWithDuration(t, e) ? n : new cc.TransitionProgressRadialCW(t, e);
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
  ctor: function(t, e) {
    cc.TransitionProgress.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _progressTimerNodeWithRenderTexture: function(t) {
    var e = cc.director.getWinSize(), n = new cc.ProgressTimer(t.sprite);
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL && (n.sprite.flippedY = !0), n.type = cc.ProgressTimer.TYPE_BAR, n.midPoint = cc.p(1, 0), n.barChangeRate = cc.p(1, 0), n.percentage = 100, this._setAttrs(n, e.width / 2, e.height / 2), n;
  }
});
cc.TransitionProgressHorizontal.create = function(t, e) {
  return new cc.TransitionProgressHorizontal(t, e);
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
  ctor: function(t, e) {
    cc.TransitionProgress.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _progressTimerNodeWithRenderTexture: function(t) {
    var e = cc.director.getWinSize(), n = new cc.ProgressTimer(t.sprite);
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL && (n.sprite.flippedY = !0), n.type = cc.ProgressTimer.TYPE_BAR, n.midPoint = cc.p(0, 0), n.barChangeRate = cc.p(0, 1), n.percentage = 100, this._setAttrs(n, e.width / 2, e.height / 2), n;
  }
});
cc.TransitionProgressVertical.create = function(t, e) {
  return new cc.TransitionProgressVertical(t, e);
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
  ctor: function(t, e) {
    cc.TransitionProgress.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _progressTimerNodeWithRenderTexture: function(t) {
    var e = cc.director.getWinSize(), n = new cc.ProgressTimer(t.sprite);
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL && (n.sprite.flippedY = !0), n.type = cc.ProgressTimer.TYPE_BAR, n.midPoint = cc.p(0.5, 0.5), n.barChangeRate = cc.p(1, 1), n.percentage = 0, this._setAttrs(n, e.width / 2, e.height / 2), n;
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = !1;
  },
  _setupTransition: function() {
    this._sceneToBeModified = (this || window)._inScene, this._from = 0, this._to = 100;
  }
});
cc.TransitionProgressInOut.create = function(t, e) {
  return new cc.TransitionProgressInOut(t, e);
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
  ctor: function(t, e) {
    cc.TransitionProgress.prototype.ctor.call(this), e && this.initWithDuration(t, e);
  },
  _progressTimerNodeWithRenderTexture: function(t) {
    var e = cc.director.getWinSize(), n = new cc.ProgressTimer(t.sprite);
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL && (n.sprite.flippedY = !0), n.type = cc.ProgressTimer.TYPE_BAR, n.midPoint = cc.p(0.5, 0.5), n.barChangeRate = cc.p(1, 1), n.percentage = 100, this._setAttrs(n, e.width / 2, e.height / 2), n;
  }
});
cc.TransitionProgressOutIn.create = function(t, e) {
  return new cc.TransitionProgressOutIn(t, e);
};
cc.TransitionPageTurn = cc.TransitionScene.extend({
  ctor: function(t, e, n) {
    cc.TransitionScene.prototype.ctor.call(this), this._gridProxy = new cc.NodeGrid(), this.initWithDuration(t, e, n);
  },
  _back: !0,
  _gridProxy: null,
  _className: "TransitionPageTurn",
  initWithDuration: function(t, e, n) {
    return this._back = n, cc.TransitionScene.prototype.initWithDuration.call(this, t, e), !0;
  },
  actionWithSize: function(t) {
    return this._back ? cc.reverseTime(cc.pageTurn3D(this._duration, t)) : cc.pageTurn3D(this._duration, t);
  },
  onEnter: function() {
    cc.TransitionScene.prototype.onEnter.call(this);
    var t = cc.director.getWinSize(), e, n;
    t.width > t.height ? (e = 16, n = 12) : (e = 12, n = 16);
    var r = (this || window).actionWithSize(cc.size(e, n)), s = (this || window)._gridProxy;
    this._back ? (s.setTarget(this._inScene), s.onEnter(), this._inScene.visible = !1, s.runAction(
      cc.sequence(r, cc.callFunc(this.finish, this), cc.stopGrid())
    ), this._inScene.runAction(cc.show())) : (s.setTarget(this._outScene), s.onEnter(), s.runAction(cc.sequence(r, cc.callFunc(this.finish, this), cc.stopGrid())));
  },
  visit: function() {
    this._back ? this._outScene.visit() : this._inScene.visit(), this._gridProxy.visit();
  },
  _sceneOrder: function() {
    this._isInSceneOnTop = (this || window)._back;
  }
});
cc.TransitionPageTurn.create = function(t, e, n) {
  return new cc.TransitionPageTurn(t, e, n);
};
cc.Codec = { name: "Jacob__Codec" };
cc.unzip = function() {
  return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments);
};
cc.unzipBase64 = function() {
  var t = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
  return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [t]);
};
cc.unzipBase64AsArray = function(t, e) {
  e = e || 1;
  var n = (this || window).unzipBase64(t), r = [], s, o, a;
  for (s = 0, a = n.length / e; s < a; s++)
    for (r[s] = 0, o = e - 1; o >= 0; --o)
      r[s] += n.charCodeAt(s * e + o) << o * 8;
  return r;
};
cc.unzipAsArray = function(t, e) {
  e = e || 1;
  var n = (this || window).unzip(t), r = [], s, o, a;
  for (s = 0, a = n.length / e; s < a; s++)
    for (r[s] = 0, o = e - 1; o >= 0; --o)
      r[s] += n.charCodeAt(s * e + o) << o * 8;
  return r;
};
cc.StringToArray = function(t) {
  var e = t.split(","), n = [], r;
  for (r = 0; r < e.length; r++)
    n.push(parseInt(e[r]));
  return n;
};
cc.Codec.Base64 = { name: "Jacob__Codec__Base64" };
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
cc.Codec.Base64.decode = /* @__PURE__ */ H(function(e) {
  var n = [], r, s, o, a, c, l, h, u = 0;
  for (e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""); u < e.length; )
    a = (this || window)._keyStr.indexOf(e.charAt(u++)), c = (this || window)._keyStr.indexOf(e.charAt(u++)), l = (this || window)._keyStr.indexOf(e.charAt(u++)), h = (this || window)._keyStr.indexOf(e.charAt(u++)), r = a << 2 | c >> 4, s = (c & 15) << 4 | l >> 2, o = (l & 3) << 6 | h, n.push(String.fromCharCode(r)), l !== 64 && n.push(String.fromCharCode(s)), h !== 64 && n.push(String.fromCharCode(o));
  return n = n.join(""), n;
}, "Jacob__Codec__Base64__decode");
cc.Codec.Base64.decodeAsArray = /* @__PURE__ */ H(function(e, n) {
  var r = (this || window).decode(e), s = [], o, a, c;
  for (o = 0, c = r.length / n; o < c; o++)
    for (s[o] = 0, a = n - 1; a >= 0; --a)
      s[o] += r.charCodeAt(o * n + a) << a * 8;
  return s;
}, "Jacob__Codec__Base64___decodeAsArray");
cc.uint8ArrayToUint32Array = function(t) {
  if (t.length % 4 !== 0)
    return null;
  for (var e = t.length / 4, n = window.Uint32Array ? new Uint32Array(e) : [], r = 0; r < e; r++) {
    var s = r * 4;
    n[r] = t[s] + t[s + 1] * 256 + t[s + 2] * 65536 + t[s + 3] * (1 << 24);
  }
  return n;
};
cc.Codec.GZip = /* @__PURE__ */ H(function(e) {
  this.data = e, this.debug = !1, this.gpflags = void 0, this.files = 0, this.unzipped = [], this.buf32k = new Array(32768), this.bIdx = 0, this.modeZIP = !1, this.bytepos = 0, this.bb = 1, this.bits = 0, this.nameBuf = [], this.fileout = void 0, this.literalTree = new Array(cc.Codec.GZip.LITERALS), this.distanceTree = new Array(32), this.treepos = 0, this.Places = null, this.len = 0, this.fpos = new Array(17), this.fpos[0] = 0, this.flens = void 0, this.fmax = void 0;
}, "Jacob__GZip");
cc.Codec.GZip.gunzip = function(t) {
  t.constructor === Array || t.constructor;
  var e = new cc.Codec.GZip(t);
  return e.gunzip()[0][0];
};
cc.Codec.GZip.HufNode = function() {
  this.b0 = 0, this.b1 = 0, this.jump = null, this.jumppos = -1;
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [
  0,
  128,
  64,
  192,
  32,
  160,
  96,
  224,
  16,
  144,
  80,
  208,
  48,
  176,
  112,
  240,
  8,
  136,
  72,
  200,
  40,
  168,
  104,
  232,
  24,
  152,
  88,
  216,
  56,
  184,
  120,
  248,
  4,
  132,
  68,
  196,
  36,
  164,
  100,
  228,
  20,
  148,
  84,
  212,
  52,
  180,
  116,
  244,
  12,
  140,
  76,
  204,
  44,
  172,
  108,
  236,
  28,
  156,
  92,
  220,
  60,
  188,
  124,
  252,
  2,
  130,
  66,
  194,
  34,
  162,
  98,
  226,
  18,
  146,
  82,
  210,
  50,
  178,
  114,
  242,
  10,
  138,
  74,
  202,
  42,
  170,
  106,
  234,
  26,
  154,
  90,
  218,
  58,
  186,
  122,
  250,
  6,
  134,
  70,
  198,
  38,
  166,
  102,
  230,
  22,
  150,
  86,
  214,
  54,
  182,
  118,
  246,
  14,
  142,
  78,
  206,
  46,
  174,
  110,
  238,
  30,
  158,
  94,
  222,
  62,
  190,
  126,
  254,
  1,
  129,
  65,
  193,
  33,
  161,
  97,
  225,
  17,
  145,
  81,
  209,
  49,
  177,
  113,
  241,
  9,
  137,
  73,
  201,
  41,
  169,
  105,
  233,
  25,
  153,
  89,
  217,
  57,
  185,
  121,
  249,
  5,
  133,
  69,
  197,
  37,
  165,
  101,
  229,
  21,
  149,
  85,
  213,
  53,
  181,
  117,
  245,
  13,
  141,
  77,
  205,
  45,
  173,
  109,
  237,
  29,
  157,
  93,
  221,
  61,
  189,
  125,
  253,
  3,
  131,
  67,
  195,
  35,
  163,
  99,
  227,
  19,
  147,
  83,
  211,
  51,
  179,
  115,
  243,
  11,
  139,
  75,
  203,
  43,
  171,
  107,
  235,
  27,
  155,
  91,
  219,
  59,
  187,
  123,
  251,
  7,
  135,
  71,
  199,
  39,
  167,
  103,
  231,
  23,
  151,
  87,
  215,
  55,
  183,
  119,
  247,
  15,
  143,
  79,
  207,
  47,
  175,
  111,
  239,
  31,
  159,
  95,
  223,
  63,
  191,
  127,
  255
];
cc.Codec.GZip.cplens = [
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
cc.Codec.GZip.cplext = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  99,
  99
];
cc.Codec.GZip.cpdist = [
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
];
cc.Codec.GZip.cpdext = [
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function() {
  return this.outputArr = [], this.nextFile(), this.unzipped;
};
cc.Codec.GZip.prototype.readByte = function() {
  return this.bits += 8, this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1;
};
cc.Codec.GZip.prototype.byteAlign = function() {
  this.bb = 1;
};
cc.Codec.GZip.prototype.readBit = function() {
  var t;
  return this.bits++, t = (this || window).bb & 1, this.bb >>= 1, this.bb === 0 && (this.bb = (this || window).readByte(), t = (this || window).bb & 1, this.bb = (this || window).bb >> 1 | 128), t;
};
cc.Codec.GZip.prototype.readBits = function(t) {
  for (var e = 0, n = t; n--; )
    e = e << 1 | this.readBit();
  return t && (e = cc.Codec.GZip.bitReverse[e] >> 8 - t), e;
};
cc.Codec.GZip.prototype.flushBuffer = function() {
  this.bIdx = 0;
};
cc.Codec.GZip.prototype.addBuffer = function(t) {
  this.buf32k[this.bIdx++] = t, this.outputArr.push(String.fromCharCode(t)), this.bIdx === 32768 && (this.bIdx = 0);
};
cc.Codec.GZip.prototype.IsPat = function() {
  for (; ; ) {
    if (this.fpos[this.len] >= (this || window).fmax)
      return -1;
    if (this.flens[this.fpos[this.len]] === (this || window).len)
      return this.fpos[this.len]++;
    this.fpos[this.len]++;
  }
};
cc.Codec.GZip.prototype.Rec = function() {
  var t = (this || window).Places[this.treepos], e;
  if (this.len === 17)
    return -1;
  if (this.treepos++, this.len++, e = (this || window).IsPat(), e >= 0)
    t.b0 = e;
  else if (t.b0 = 32768, this.Rec())
    return -1;
  if (e = (this || window).IsPat(), e >= 0)
    t.b1 = e, t.jump = null;
  else if (t.b1 = 32768, t.jump = (this || window).Places[this.treepos], t.jumppos = (this || window).treepos, this.Rec())
    return -1;
  return this.len--, 0;
};
cc.Codec.GZip.prototype.CreateTree = function(t, e, n, r) {
  var s;
  for (this.Places = t, this.treepos = 0, this.flens = n, this.fmax = e, s = 0; s < 17; s++)
    this.fpos[s] = 0;
  return this.len = 0, this.Rec() ? -1 : 0;
};
cc.Codec.GZip.prototype.DecodeValue = function(t) {
  for (var e, n, r = 0, s = t[r], o; ; )
    if (o = (this || window).readBit(), o) {
      if (!(s.b1 & 32768))
        return s.b1;
      for (s = s.jump, e = t.length, n = 0; n < e; n++)
        if (t[n] === s) {
          r = n;
          break;
        }
    } else {
      if (!(s.b0 & 32768))
        return s.b0;
      r++, s = t[r];
    }
  return -1;
};
cc.Codec.GZip.prototype.DeflateLoop = function() {
  var t, e, n, r, s;
  do
    if (t = (this || window).readBit(), n = (this || window).readBits(2), n === 0) {
      var o, a;
      for (this.byteAlign(), o = (this || window).readByte(), o |= (this || window).readByte() << 8, a = (this || window).readByte(), a |= (this || window).readByte() << 8, (o ^ ~a) & 65535 && document.write(`BlockLen checksum mismatch
`); o--; )
        e = (this || window).readByte(), this.addBuffer(e);
    } else if (n === 1)
      for (var c; ; )
        if (c = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, c > 23 ? (c = c << 1 | this.readBit(), c > 199 ? (c -= 128, c = c << 1 | this.readBit()) : (c -= 48, c > 143 && (c = c + 136))) : c += 256, c < 256)
          this.addBuffer(c);
        else {
          if (c === 256)
            break;
          var s, l;
          for (c -= 256 + 1, s = (this || window).readBits(cc.Codec.GZip.cplext[c]) + cc.Codec.GZip.cplens[c], c = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3, cc.Codec.GZip.cpdext[c] > 8 ? (l = (this || window).readBits(8), l |= (this || window).readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : l = (this || window).readBits(cc.Codec.GZip.cpdext[c]), l += cc.Codec.GZip.cpdist[c], c = 0; c < s; c++) {
            var e = (this || window).buf32k[this.bIdx - l & 32767];
            this.addBuffer(e);
          }
        }
    else if (n === 2) {
      var c, h, u, _, d, f = new Array(320);
      for (u = 257 + this.readBits(5), _ = 1 + this.readBits(5), d = 4 + this.readBits(4), c = 0; c < 19; c++)
        f[c] = 0;
      for (c = 0; c < d; c++)
        f[cc.Codec.GZip.border[c]] = (this || window).readBits(3);
      for (s = (this || window).distanceTree.length, r = 0; r < s; r++)
        this.distanceTree[r] = new cc.Codec.GZip.HufNode();
      if (this.CreateTree(this.distanceTree, 19, f, 0))
        return this.flushBuffer(), 1;
      for (h = u + _, r = 0; r < h; )
        if (c = (this || window).DecodeValue(this.distanceTree), c < 16)
          f[r++] = c;
        else if (c === 16) {
          var C;
          if (c = 3 + this.readBits(2), r + c > h)
            return this.flushBuffer(), 1;
          for (C = r ? f[r - 1] : 0; c--; )
            f[r++] = C;
        } else {
          if (c === 17 ? c = 3 + this.readBits(3) : c = 11 + this.readBits(7), r + c > h)
            return this.flushBuffer(), 1;
          for (; c--; )
            f[r++] = 0;
        }
      for (s = (this || window).literalTree.length, r = 0; r < s; r++)
        this.literalTree[r] = new cc.Codec.GZip.HufNode();
      if (this.CreateTree(this.literalTree, u, f, 0))
        return this.flushBuffer(), 1;
      for (s = (this || window).literalTree.length, r = 0; r < s; r++)
        this.distanceTree[r] = new cc.Codec.GZip.HufNode();
      var m = new Array();
      for (r = u; r < f.length; r++)
        m[r - u] = f[r];
      if (this.CreateTree(this.distanceTree, _, m, 0))
        return this.flushBuffer(), 1;
      for (; ; )
        if (c = (this || window).DecodeValue(this.literalTree), c >= 256) {
          var s, l;
          if (c -= 256, c === 0)
            break;
          for (c--, s = (this || window).readBits(cc.Codec.GZip.cplext[c]) + cc.Codec.GZip.cplens[c], c = (this || window).DecodeValue(this.distanceTree), cc.Codec.GZip.cpdext[c] > 8 ? (l = (this || window).readBits(8), l |= (this || window).readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : l = (this || window).readBits(cc.Codec.GZip.cpdext[c]), l += cc.Codec.GZip.cpdist[c]; s--; ) {
            var e = (this || window).buf32k[this.bIdx - l & 32767];
            this.addBuffer(e);
          }
        } else
          this.addBuffer(c);
    }
  while (!t);
  return this.flushBuffer(), this.byteAlign(), 0;
};
cc.Codec.GZip.prototype.unzipFile = function(t) {
  var e;
  for (this.gunzip(), e = 0; e < this.unzipped.length; e++)
    if (this.unzipped[e][1] === t)
      return this.unzipped[e][0];
};
cc.Codec.GZip.prototype.nextFile = function() {
  this.outputArr = [], this.modeZIP = !1;
  var t = [];
  if (t[0] = (this || window).readByte(), t[1] = (this || window).readByte(), t[0] === 120 && t[1] === 218 && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++), t[0] === 31 && t[1] === 139 && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++), t[0] === 80 && t[1] === 75 && (this.modeZIP = !0, t[2] = (this || window).readByte(), t[3] = (this || window).readByte(), t[2] === 3 && t[3] === 4)) {
    t[0] = (this || window).readByte(), t[1] = (this || window).readByte(), this.gpflags = (this || window).readByte(), this.gpflags |= (this || window).readByte() << 8;
    var e = (this || window).readByte();
    e |= (this || window).readByte() << 8, this.readByte(), this.readByte(), this.readByte(), this.readByte();
    var n = (this || window).readByte();
    n |= (this || window).readByte() << 8, n |= (this || window).readByte() << 16, n |= (this || window).readByte() << 24;
    var r = (this || window).readByte();
    r |= (this || window).readByte() << 8, r |= (this || window).readByte() << 16, r |= (this || window).readByte() << 24;
    var s = (this || window).readByte();
    s |= (this || window).readByte() << 8;
    var o = (this || window).readByte();
    for (o |= (this || window).readByte() << 8, c = 0, this.nameBuf = []; s--; ) {
      var a = (this || window).readByte();
      a === "/" | a === ":" ? c = 0 : c < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[c++] = String.fromCharCode(a));
    }
    this.fileout || (this.fileout = (this || window).nameBuf);
    for (var c = 0; c < o; )
      a = (this || window).readByte(), c++;
    e === 8 && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++), this.skipdir();
  }
};
cc.Codec.GZip.prototype.skipdir = function() {
  var t = [], e, n, r, s;
  if (this.gpflags & 8 && (t[0] = (this || window).readByte(), t[1] = (this || window).readByte(), t[2] = (this || window).readByte(), t[3] = (this || window).readByte(), e = (this || window).readByte(), e |= (this || window).readByte() << 8, e |= (this || window).readByte() << 16, e |= (this || window).readByte() << 24, n = (this || window).readByte(), n |= (this || window).readByte() << 8, n |= (this || window).readByte() << 16, n |= (this || window).readByte() << 24), this.modeZIP && this.nextFile(), t[0] = (this || window).readByte(), t[0] !== 8)
    return 0;
  if (this.gpflags = (this || window).readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.gpflags & 4)
    for (t[0] = (this || window).readByte(), t[2] = (this || window).readByte(), this.len = t[0] + 256 * t[1], r = 0; r < this.len; r++)
      this.readByte();
  if (this.gpflags & 8)
    for (r = 0, this.nameBuf = []; s = (this || window).readByte(); )
      (s === "7" || s === ":") && (r = 0), r < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[r++] = s);
  if (this.gpflags & 16)
    for (; s = (this || window).readByte(); )
      ;
  this.gpflags & 2 && (this.readByte(), this.readByte()), this.DeflateLoop(), n = (this || window).readByte(), n |= (this || window).readByte() << 8, n |= (this || window).readByte() << 16, n |= (this || window).readByte() << 24, this.modeZIP && this.nextFile();
};
(function() {
  function t(at) {
    throw at;
  }
  H(t, "i");
  var e = void 0, n = !0, r = (this || window);
  function s(at, ot) {
    var _t = at.split("."), mt = r;
    !(_t[0] in mt) && mt.execScript && mt.execScript("var " + _t[0]);
    for (var Ct; _t.length && (Ct = _t.shift()); )
      !_t.length && ot !== e ? mt[Ct] = ot : mt = mt[Ct] ? mt[Ct] : mt[Ct] = {};
  }
  H(s, "y");
  var o = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Uint32Array != "undefined";
  function a(at) {
    if (typeof at == "string") {
      var ot = at.split(""), _t, mt;
      for (_t = 0, mt = ot.length; _t < mt; _t++)
        ot[_t] = (ot[_t].charCodeAt(0) & 255) >>> 0;
      at = ot;
    }
    for (var Ct = 1, yt = 0, At = at.length, Pt, kt = 0; 0 < At; ) {
      Pt = 1024 < At ? 1024 : At, At -= Pt;
      do
        Ct += at[kt++], yt += Ct;
      while (--Pt);
      Ct %= 65521, yt %= 65521;
    }
    return (yt << 16 | Ct) >>> 0;
  }
  H(a, "ba");
  function c(at, ot) {
    this.index = typeof ot == "number" ? ot : 0, this.i = 0, this.buffer = at instanceof (o ? Uint8Array : Array) ? at : new (o ? Uint8Array : Array)(32768), 2 * this.buffer.length <= (this || window).index && t(Error("invalid index")), this.buffer.length <= (this || window).index && this.f();
  }
  H(c, "J"), c.prototype.f = function() {
    var at = (this || window).buffer, ot, _t = at.length, mt = new (o ? Uint8Array : Array)(_t << 1);
    if (o)
      mt.set(at);
    else
      for (ot = 0; ot < _t; ++ot)
        mt[ot] = at[ot];
    return this.buffer = mt;
  }, c.prototype.d = function(at, ot, _t) {
    var mt = (this || window).buffer, Ct = (this || window).index, yt = (this || window).i, At = mt[Ct], Pt;
    if (_t && 1 < ot && (at = 8 < ot ? (f[at & 255] << 24 | f[at >>> 8 & 255] << 16 | f[at >>> 16 & 255] << 8 | f[at >>> 24 & 255]) >> 32 - ot : f[at] >> 8 - ot), 8 > ot + yt)
      At = At << ot | at, yt += ot;
    else
      for (Pt = 0; Pt < ot; ++Pt)
        At = At << 1 | at >> ot - Pt - 1 & 1, ++yt === 8 && (yt = 0, mt[Ct++] = f[At], At = 0, Ct === mt.length && (mt = (this || window).f()));
    mt[Ct] = At, this.buffer = mt, this.i = yt, this.index = Ct;
  }, c.prototype.finish = function() {
    var at = (this || window).buffer, ot = (this || window).index, _t;
    return 0 < this.i && (at[ot] <<= 8 - this.i, at[ot] = f[at[ot]], ot++), o ? _t = at.subarray(0, ot) : (at.length = ot, _t = at), _t;
  };
  var l = new (o ? Uint8Array : Array)(256), h;
  for (h = 0; 256 > h; ++h) {
    for (var d = h, u = d, _ = 7, d = d >>> 1; d; d >>>= 1)
      u <<= 1, u |= d & 1, --_;
    l[h] = (u << _ & 255) >>> 0;
  }
  var f = l;
  function C(at) {
    this.buffer = new (o ? Uint16Array : Array)(2 * at), this.length = 0;
  }
  H(C, "la"), C.prototype.getParent = function(at) {
    return 2 * ((at - 2) / 4 | 0);
  }, C.prototype.push = function(at, ot) {
    var _t, mt, Ct = (this || window).buffer, yt;
    for (_t = (this || window).length, Ct[this.length++] = ot, Ct[this.length++] = at; 0 < _t && (mt = (this || window).getParent(_t), Ct[_t] > Ct[mt]); )
      yt = Ct[_t], Ct[_t] = Ct[mt], Ct[mt] = yt, yt = Ct[_t + 1], Ct[_t + 1] = Ct[mt + 1], Ct[mt + 1] = yt, _t = mt;
    return this.length;
  }, C.prototype.pop = function() {
    var at, ot, _t = (this || window).buffer, mt, Ct, yt;
    for (ot = _t[0], at = _t[1], this.length -= 2, _t[0] = _t[this.length], _t[1] = _t[this.length + 1], yt = 0; Ct = 2 * yt + 2, !(Ct >= (this || window).length); ) {
      if (Ct + 2 < this.length && _t[Ct + 2] > _t[Ct] && (Ct += 2), _t[Ct] > _t[yt])
        mt = _t[yt], _t[yt] = _t[Ct], _t[Ct] = mt, mt = _t[yt + 1], _t[yt + 1] = _t[Ct + 1], _t[Ct + 1] = mt;
      else
        break;
      yt = Ct;
    }
    return { index: at, value: ot, length: this.length };
  };
  function m(at) {
    var ot = at.length, _t = 0, mt = Number.POSITIVE_INFINITY, Ct, yt, At, Pt, kt, Ot, Xt, Vt, Lt;
    for (Vt = 0; Vt < ot; ++Vt)
      at[Vt] > _t && (_t = at[Vt]), at[Vt] < mt && (mt = at[Vt]);
    for (Ct = 1 << _t, yt = new (o ? Uint32Array : Array)(Ct), At = 1, Pt = 0, kt = 2; At <= _t; ) {
      for (Vt = 0; Vt < ot; ++Vt)
        if (at[Vt] === At) {
          for (Ot = 0, Xt = Pt, Lt = 0; Lt < At; ++Lt)
            Ot = Ot << 1 | Xt & 1, Xt >>= 1;
          for (Lt = Ot; Lt < Ct; Lt += kt)
            yt[Lt] = At << 16 | Vt;
          ++Pt;
        }
      ++At, Pt <<= 1, kt <<= 1;
    }
    return [yt, _t, mt];
  }
  H(m, "S");
  function g(at, ot) {
    this.h = y, this.w = 0, this.input = at, this.b = 0, ot && (ot.lazy && (this.w = ot.lazy), typeof ot.compressionType == "number" && (this.h = ot.compressionType), ot.outputBuffer && (this.a = o && ot.outputBuffer instanceof Array ? new Uint8Array(ot.outputBuffer) : ot.outputBuffer), typeof ot.outputIndex == "number" && (this.b = ot.outputIndex)), this.a || (this.a = new (o ? Uint8Array : Array)(32768));
  }
  H(g, "ma");
  var y = 2, A = { NONE: 0, r: 1, j: y, N: 3 }, D = [], N;
  for (N = 0; 288 > N; N++)
    switch (n) {
      case 143 >= N:
        D.push([N + 48, 8]);
        break;
      case 255 >= N:
        D.push([N - 144 + 400, 9]);
        break;
      case 279 >= N:
        D.push([N - 256 + 0, 7]);
        break;
      case 287 >= N:
        D.push([N - 280 + 192, 8]);
        break;
      default:
        t("invalid literal: " + N);
    }
  g.prototype.n = function() {
    var at, ot, _t, mt, Ct = (this || window).input;
    switch (this.h) {
      case 0:
        for (_t = 0, mt = Ct.length; _t < mt; ) {
          ot = o ? Ct.subarray(_t, _t + 65535) : Ct.slice(_t, _t + 65535), _t += ot.length;
          var yt = ot, At = _t === mt, Pt = e, kt = e, Ot = e, Xt = e, Vt = e, Lt = (this || window).a, Nt = (this || window).b;
          if (o) {
            for (Lt = new Uint8Array(this.a.buffer); Lt.length <= Nt + yt.length + 5; )
              Lt = new Uint8Array(Lt.length << 1);
            Lt.set(this.a);
          }
          if (Pt = At ? 1 : 0, Lt[Nt++] = Pt | 0, kt = yt.length, Ot = ~kt + 65536 & 65535, Lt[Nt++] = kt & 255, Lt[Nt++] = kt >>> 8 & 255, Lt[Nt++] = Ot & 255, Lt[Nt++] = Ot >>> 8 & 255, o)
            Lt.set(yt, Nt), Nt += yt.length, Lt = Lt.subarray(0, Nt);
          else {
            for (Xt = 0, Vt = yt.length; Xt < Vt; ++Xt)
              Lt[Nt++] = yt[Xt];
            Lt.length = Nt;
          }
          this.b = Nt, this.a = Lt;
        }
        break;
      case 1:
        var Jt = new c(new Uint8Array(this.a.buffer), this.b);
        Jt.d(1, 1, n), Jt.d(1, 2, n);
        var Ht = rt(this, Ct), Kt, ee, Zt;
        for (Kt = 0, ee = Ht.length; Kt < ee; Kt++)
          if (Zt = Ht[Kt], c.prototype.d.apply(Jt, D[Zt]), 256 < Zt)
            Jt.d(Ht[++Kt], Ht[++Kt], n), Jt.d(Ht[++Kt], 5), Jt.d(Ht[++Kt], Ht[++Kt], n);
          else if (Zt === 256)
            break;
        this.a = Jt.finish(), this.b = (this || window).a.length;
        break;
      case y:
        var $t = new c(new Uint8Array(this.a), this.b), ie, Ft, zt, Qt, le, _e = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], he, Se, xe, Bt, ce, pe = Array(19), de, jt, ve, re, Oe;
        for (ie = y, $t.d(
          1,
          1,
          n
        ), $t.d(ie, 2, n), Ft = rt(this, Ct), he = w(this.L, 15), Se = L(he), xe = w(this.K, 7), Bt = L(xe), zt = 286; 257 < zt && he[zt - 1] === 0; zt--)
          ;
        for (Qt = 30; 1 < Qt && xe[Qt - 1] === 0; Qt--)
          ;
        var Yt = zt, Ce = Qt, me = new (o ? Uint32Array : Array)(Yt + Ce), se, Pe, oe, Ge, Ee = new (o ? Uint32Array : Array)(316), ge, fe, Ae = new (o ? Uint8Array : Array)(19);
        for (se = Pe = 0; se < Yt; se++)
          me[Pe++] = he[se];
        for (se = 0; se < Ce; se++)
          me[Pe++] = xe[se];
        if (!o)
          for (se = 0, Ge = Ae.length; se < Ge; ++se)
            Ae[se] = 0;
        for (se = ge = 0, Ge = me.length; se < Ge; se += Pe) {
          for (Pe = 1; se + Pe < Ge && me[se + Pe] === me[se]; ++Pe)
            ;
          if (oe = Pe, me[se] === 0)
            if (3 > oe)
              for (; 0 < oe--; )
                Ee[ge++] = 0, Ae[0]++;
            else
              for (; 0 < oe; )
                fe = 138 > oe ? oe : 138, fe > oe - 3 && fe < oe && (fe = oe - 3), 10 >= fe ? (Ee[ge++] = 17, Ee[ge++] = fe - 3, Ae[17]++) : (Ee[ge++] = 18, Ee[ge++] = fe - 11, Ae[18]++), oe -= fe;
          else if (Ee[ge++] = me[se], Ae[me[se]]++, oe--, 3 > oe)
            for (; 0 < oe--; )
              Ee[ge++] = me[se], Ae[me[se]]++;
          else
            for (; 0 < oe; )
              fe = 6 > oe ? oe : 6, fe > oe - 3 && fe < oe && (fe = oe - 3), Ee[ge++] = 16, Ee[ge++] = fe - 3, Ae[16]++, oe -= fe;
        }
        for (at = o ? Ee.subarray(0, ge) : Ee.slice(0, ge), ce = w(Ae, 7), re = 0; 19 > re; re++)
          pe[re] = ce[_e[re]];
        for (le = 19; 4 < le && pe[le - 1] === 0; le--)
          ;
        for (de = L(ce), $t.d(zt - 257, 5, n), $t.d(Qt - 1, 5, n), $t.d(le - 4, 4, n), re = 0; re < le; re++)
          $t.d(pe[re], 3, n);
        for (re = 0, Oe = at.length; re < Oe; re++)
          if (jt = at[re], $t.d(
            de[jt],
            ce[jt],
            n
          ), 16 <= jt) {
            switch (re++, jt) {
              case 16:
                ve = 2;
                break;
              case 17:
                ve = 3;
                break;
              case 18:
                ve = 7;
                break;
              default:
                t("invalid code: " + jt);
            }
            $t.d(at[re], ve, n);
          }
        var ye = [Se, he], Ue = [Bt, xe], be, Be, Fe, ke, Le, te, Ne, Me;
        for (Le = ye[0], te = ye[1], Ne = Ue[0], Me = Ue[1], be = 0, Be = Ft.length; be < Be; ++be)
          if (Fe = Ft[be], $t.d(Le[Fe], te[Fe], n), 256 < Fe)
            $t.d(Ft[++be], Ft[++be], n), ke = Ft[++be], $t.d(Ne[ke], Me[ke], n), $t.d(Ft[++be], Ft[++be], n);
          else if (Fe === 256)
            break;
        this.a = $t.finish(), this.b = (this || window).a.length;
        break;
      default:
        t("invalid compression type");
    }
    return this.a;
  };
  function z(at, ot) {
    this.length = at, this.G = ot;
  }
  H(z, "wa");
  function M() {
    var at = U;
    switch (n) {
      case at === 3:
        return [257, at - 3, 0];
      case at === 4:
        return [258, at - 4, 0];
      case at === 5:
        return [259, at - 5, 0];
      case at === 6:
        return [260, at - 6, 0];
      case at === 7:
        return [261, at - 7, 0];
      case at === 8:
        return [262, at - 8, 0];
      case at === 9:
        return [263, at - 9, 0];
      case at === 10:
        return [264, at - 10, 0];
      case 12 >= at:
        return [265, at - 11, 1];
      case 14 >= at:
        return [266, at - 13, 1];
      case 16 >= at:
        return [267, at - 15, 1];
      case 18 >= at:
        return [268, at - 17, 1];
      case 22 >= at:
        return [269, at - 19, 2];
      case 26 >= at:
        return [270, at - 23, 2];
      case 30 >= at:
        return [271, at - 27, 2];
      case 34 >= at:
        return [272, at - 31, 2];
      case 42 >= at:
        return [273, at - 35, 3];
      case 50 >= at:
        return [274, at - 43, 3];
      case 58 >= at:
        return [275, at - 51, 3];
      case 66 >= at:
        return [276, at - 59, 3];
      case 82 >= at:
        return [277, at - 67, 4];
      case 98 >= at:
        return [278, at - 83, 4];
      case 114 >= at:
        return [279, at - 99, 4];
      case 130 >= at:
        return [280, at - 115, 4];
      case 162 >= at:
        return [281, at - 131, 5];
      case 194 >= at:
        return [282, at - 163, 5];
      case 226 >= at:
        return [283, at - 195, 5];
      case 257 >= at:
        return [284, at - 227, 5];
      case at === 258:
        return [285, at - 258, 0];
      default:
        t("invalid length: " + at);
    }
  }
  H(M, "xa");
  var Z = [], U, Q;
  for (U = 3; 258 >= U; U++)
    Q = M(), Z[U] = Q[2] << 24 | Q[1] << 16 | Q[0];
  var et = o ? new Uint32Array(Z) : Z;
  function rt(at, ot) {
    function _t(Se, xe) {
      var Bt = Se.G, ce = [], pe = 0, de;
      de = et[Se.length], ce[pe++] = de & 65535, ce[pe++] = de >> 16 & 255, ce[pe++] = de >> 24;
      var jt;
      switch (n) {
        case Bt === 1:
          jt = [0, Bt - 1, 0];
          break;
        case Bt === 2:
          jt = [1, Bt - 2, 0];
          break;
        case Bt === 3:
          jt = [2, Bt - 3, 0];
          break;
        case Bt === 4:
          jt = [3, Bt - 4, 0];
          break;
        case 6 >= Bt:
          jt = [4, Bt - 5, 1];
          break;
        case 8 >= Bt:
          jt = [5, Bt - 7, 1];
          break;
        case 12 >= Bt:
          jt = [6, Bt - 9, 2];
          break;
        case 16 >= Bt:
          jt = [7, Bt - 13, 2];
          break;
        case 24 >= Bt:
          jt = [8, Bt - 17, 3];
          break;
        case 32 >= Bt:
          jt = [9, Bt - 25, 3];
          break;
        case 48 >= Bt:
          jt = [10, Bt - 33, 4];
          break;
        case 64 >= Bt:
          jt = [11, Bt - 49, 4];
          break;
        case 96 >= Bt:
          jt = [12, Bt - 65, 5];
          break;
        case 128 >= Bt:
          jt = [13, Bt - 97, 5];
          break;
        case 192 >= Bt:
          jt = [14, Bt - 129, 6];
          break;
        case 256 >= Bt:
          jt = [15, Bt - 193, 6];
          break;
        case 384 >= Bt:
          jt = [16, Bt - 257, 7];
          break;
        case 512 >= Bt:
          jt = [17, Bt - 385, 7];
          break;
        case 768 >= Bt:
          jt = [18, Bt - 513, 8];
          break;
        case 1024 >= Bt:
          jt = [19, Bt - 769, 8];
          break;
        case 1536 >= Bt:
          jt = [20, Bt - 1025, 9];
          break;
        case 2048 >= Bt:
          jt = [21, Bt - 1537, 9];
          break;
        case 3072 >= Bt:
          jt = [22, Bt - 2049, 10];
          break;
        case 4096 >= Bt:
          jt = [23, Bt - 3073, 10];
          break;
        case 6144 >= Bt:
          jt = [24, Bt - 4097, 11];
          break;
        case 8192 >= Bt:
          jt = [25, Bt - 6145, 11];
          break;
        case 12288 >= Bt:
          jt = [26, Bt - 8193, 12];
          break;
        case 16384 >= Bt:
          jt = [27, Bt - 12289, 12];
          break;
        case 24576 >= Bt:
          jt = [28, Bt - 16385, 13];
          break;
        case 32768 >= Bt:
          jt = [29, Bt - 24577, 13];
          break;
        default:
          t("invalid distance");
      }
      de = jt, ce[pe++] = de[0], ce[pe++] = de[1], ce[pe++] = de[2];
      var ve, re;
      for (ve = 0, re = ce.length; ve < re; ++ve)
        Lt[Nt++] = ce[ve];
      Ht[ce[0]]++, Kt[ce[3]]++, Jt = Se.length + xe - 1, Vt = null;
    }
    H(_t, "b");
    var mt, Ct, yt, At, Pt, kt = {}, Ot, Xt, Vt, Lt = o ? new Uint16Array(2 * ot.length) : [], Nt = 0, Jt = 0, Ht = new (o ? Uint32Array : Array)(286), Kt = new (o ? Uint32Array : Array)(30), ee = at.w, Zt;
    if (!o) {
      for (yt = 0; 285 >= yt; )
        Ht[yt++] = 0;
      for (yt = 0; 29 >= yt; )
        Kt[yt++] = 0;
    }
    for (Ht[256] = 1, mt = 0, Ct = ot.length; mt < Ct; ++mt) {
      for (yt = Pt = 0, At = 3; yt < At && mt + yt !== Ct; ++yt)
        Pt = Pt << 8 | ot[mt + yt];
      if (kt[Pt] === e && (kt[Pt] = []), Ot = kt[Pt], !(0 < Jt--)) {
        for (; 0 < Ot.length && 32768 < mt - Ot[0]; )
          Ot.shift();
        if (mt + 3 >= Ct) {
          for (Vt && _t(Vt, -1), yt = 0, At = Ct - mt; yt < At; ++yt)
            Zt = ot[mt + yt], Lt[Nt++] = Zt, ++Ht[Zt];
          break;
        }
        if (0 < Ot.length) {
          var $t = e, ie = e, Ft = 0, zt = e, _e = e, Qt = e, he = e, le = ot.length, _e = 0, he = Ot.length;
          t:
            for (; _e < he; _e++) {
              if ($t = Ot[he - _e - 1], zt = 3, 3 < Ft) {
                for (Qt = Ft; 3 < Qt; Qt--)
                  if (ot[$t + Qt - 1] !== ot[mt + Qt - 1])
                    continue t;
                zt = Ft;
              }
              for (; 258 > zt && mt + zt < le && ot[$t + zt] === ot[mt + zt]; )
                ++zt;
              if (zt > Ft && (ie = $t, Ft = zt), zt === 258)
                break;
            }
          Xt = new z(Ft, mt - ie), Vt ? Vt.length < Xt.length ? (Zt = ot[mt - 1], Lt[Nt++] = Zt, ++Ht[Zt], _t(
            Xt,
            0
          )) : _t(Vt, -1) : Xt.length < ee ? Vt = Xt : _t(Xt, 0);
        } else
          Vt ? _t(Vt, -1) : (Zt = ot[mt], Lt[Nt++] = Zt, ++Ht[Zt]);
      }
      Ot.push(mt);
    }
    return Lt[Nt++] = 256, Ht[256]++, at.L = Ht, at.K = Kt, o ? Lt.subarray(0, Nt) : Lt;
  }
  H(rt, "sa");
  function w(at, ot) {
    function _t(_e) {
      var he = Kt[_e][ee[_e]];
      he === Vt ? (_t(_e + 1), _t(_e + 1)) : --Jt[he], ++ee[_e];
    }
    H(_t, "b");
    var mt = at.length, Ct = new C(572), yt = new (o ? Uint8Array : Array)(mt), At, Pt, kt, Ot, Xt;
    if (!o)
      for (Ot = 0; Ot < mt; Ot++)
        yt[Ot] = 0;
    for (Ot = 0; Ot < mt; ++Ot)
      0 < at[Ot] && Ct.push(Ot, at[Ot]);
    if (At = Array(Ct.length / 2), Pt = new (o ? Uint32Array : Array)(Ct.length / 2), At.length === 1)
      return yt[Ct.pop().index] = 1, yt;
    for (Ot = 0, Xt = Ct.length / 2; Ot < Xt; ++Ot)
      At[Ot] = Ct.pop(), Pt[Ot] = At[Ot].value;
    var Vt = Pt.length, Lt = new (o ? Uint16Array : Array)(ot), Nt = new (o ? Uint8Array : Array)(ot), Jt = new (o ? Uint8Array : Array)(Vt), Ht = Array(ot), Kt = Array(ot), ee = Array(ot), Zt = (1 << ot) - Vt, $t = 1 << ot - 1, ie, Ft, zt, Qt, le;
    for (Lt[ot - 1] = Vt, Ft = 0; Ft < ot; ++Ft)
      Zt < $t ? Nt[Ft] = 0 : (Nt[Ft] = 1, Zt -= $t), Zt <<= 1, Lt[ot - 2 - Ft] = (Lt[ot - 1 - Ft] / 2 | 0) + Vt;
    for (Lt[0] = Nt[0], Ht[0] = Array(Lt[0]), Kt[0] = Array(Lt[0]), Ft = 1; Ft < ot; ++Ft)
      Lt[Ft] > 2 * Lt[Ft - 1] + Nt[Ft] && (Lt[Ft] = 2 * Lt[Ft - 1] + Nt[Ft]), Ht[Ft] = Array(Lt[Ft]), Kt[Ft] = Array(Lt[Ft]);
    for (ie = 0; ie < Vt; ++ie)
      Jt[ie] = ot;
    for (zt = 0; zt < Lt[ot - 1]; ++zt)
      Ht[ot - 1][zt] = Pt[zt], Kt[ot - 1][zt] = zt;
    for (ie = 0; ie < ot; ++ie)
      ee[ie] = 0;
    for (Nt[ot - 1] === 1 && (--Jt[0], ++ee[ot - 1]), Ft = ot - 2; 0 <= Ft; --Ft) {
      for (Qt = ie = 0, le = ee[Ft + 1], zt = 0; zt < Lt[Ft]; zt++)
        Qt = Ht[Ft + 1][le] + Ht[Ft + 1][le + 1], Qt > Pt[ie] ? (Ht[Ft][zt] = Qt, Kt[Ft][zt] = Vt, le += 2) : (Ht[Ft][zt] = Pt[ie], Kt[Ft][zt] = ie, ++ie);
      ee[Ft] = 0, Nt[Ft] === 1 && _t(Ft);
    }
    for (kt = Jt, Ot = 0, Xt = At.length; Ot < Xt; ++Ot)
      yt[At[Ot].index] = kt[Ot];
    return yt;
  }
  H(w, "ta");
  function L(at) {
    var ot = new (o ? Uint16Array : Array)(at.length), _t = [], mt = [], Ct = 0, yt, At, Pt, kt;
    for (yt = 0, At = at.length; yt < At; yt++)
      _t[at[yt]] = (_t[at[yt]] | 0) + 1;
    for (yt = 1, At = 16; yt <= At; yt++)
      mt[yt] = Ct, Ct += _t[yt] | 0, Ct > 1 << yt && t("overcommitted"), Ct <<= 1;
    for (65536 > Ct && t("undercommitted"), yt = 0, At = at.length; yt < At; yt++)
      for (Ct = mt[at[yt]], mt[at[yt]] += 1, Pt = ot[yt] = 0, kt = at[yt]; Pt < kt; Pt++)
        ot[yt] = ot[yt] << 1 | Ct & 1, Ct >>>= 1;
    return ot;
  }
  H(L, "ua");
  function G(at, ot) {
    this.input = at, this.a = new (o ? Uint8Array : Array)(32768), this.h = I.j;
    var _t = {}, mt;
    (ot || !(ot = {})) && typeof ot.compressionType == "number" && (this.h = ot.compressionType);
    for (mt in ot)
      _t[mt] = ot[mt];
    _t.outputBuffer = (this || window).a, this.z = new g(this.input, _t);
  }
  H(G, "Da");
  var I = A;
  G.prototype.n = function() {
    var at, ot, _t, mt, Ct, yt, At, Pt = 0;
    switch (At = (this || window).a, at = Gt, at) {
      case Gt:
        ot = Math.LOG2E * Math.log(32768) - 8;
        break;
      default:
        t(Error("invalid compression method"));
    }
    switch (_t = ot << 4 | at, At[Pt++] = _t, at) {
      case Gt:
        switch (this.h) {
          case I.NONE:
            Ct = 0;
            break;
          case I.r:
            Ct = 1;
            break;
          case I.j:
            Ct = 2;
            break;
          default:
            t(Error("unsupported compression type"));
        }
        break;
      default:
        t(Error("invalid compression method"));
    }
    return mt = Ct << 6 | 0, At[Pt++] = mt | 31 - (256 * _t + mt) % 31, yt = a(this.input), this.z.b = Pt, At = (this || window).z.n(), Pt = At.length, o && (At = new Uint8Array(At.buffer), At.length <= Pt + 4 && (this.a = new Uint8Array(At.length + 4), this.a.set(At), At = (this || window).a), At = At.subarray(0, Pt + 4)), At[Pt++] = yt >> 24 & 255, At[Pt++] = yt >> 16 & 255, At[Pt++] = yt >> 8 & 255, At[Pt++] = yt & 255, At;
  }, s("Zlib.Deflate", G), s("Zlib.Deflate.compress", function(at, ot) {
    return new G(at, ot).n();
  }), s("Zlib.Deflate.CompressionType", I), s("Zlib.Deflate.CompressionType.NONE", I.NONE), s("Zlib.Deflate.CompressionType.FIXED", I.r), s("Zlib.Deflate.CompressionType.DYNAMIC", I.j);
  function O(at, ot) {
    switch (this.k = [], this.l = 32768, this.e = (this || window).g = (this || window).c = (this || window).q = 0, this.input = o ? new Uint8Array(at) : at, this.s = !1, this.m = $, this.B = !1, (ot || !(ot = {})) && (ot.index && (this.c = ot.index), ot.bufferSize && (this.l = ot.bufferSize), ot.bufferType && (this.m = ot.bufferType), ot.resize && (this.B = ot.resize)), this.m) {
      case K:
        this.b = 32768, this.a = new (o ? Uint8Array : Array)(32768 + this.l + 258);
        break;
      case $:
        this.b = 0, this.a = new (o ? Uint8Array : Array)(this.l), this.f = (this || window).J, this.t = (this || window).H, this.o = (this || window).I;
        break;
      default:
        t(Error("invalid inflate mode"));
    }
  }
  H(O, "V");
  var K = 0, $ = 1, S = { D: K, C: $ };
  O.prototype.p = function() {
    for (; !this.s; ) {
      var at = gt(this, 3);
      switch (at & 1 && (this.s = n), at >>>= 1, at) {
        case 0:
          var ot = (this || window).input, _t = (this || window).c, mt = (this || window).a, Ct = (this || window).b, yt = e, At = e, Pt = e, kt = mt.length, Ot = e;
          switch (this.e = (this || window).g = 0, yt = ot[_t++], yt === e && t(Error("invalid uncompressed block header: LEN (first byte)")), At = yt, yt = ot[_t++], yt === e && t(Error("invalid uncompressed block header: LEN (second byte)")), At |= yt << 8, yt = ot[_t++], yt === e && t(Error("invalid uncompressed block header: NLEN (first byte)")), Pt = yt, yt = ot[_t++], yt === e && t(Error("invalid uncompressed block header: NLEN (second byte)")), Pt |= yt << 8, At === ~Pt && t(Error("invalid uncompressed block header: length verify")), _t + At > ot.length && t(Error("input buffer is broken")), this.m) {
            case K:
              for (; Ct + At > mt.length; ) {
                if (Ot = kt - Ct, At -= Ot, o)
                  mt.set(ot.subarray(_t, _t + Ot), Ct), Ct += Ot, _t += Ot;
                else
                  for (; Ot--; )
                    mt[Ct++] = ot[_t++];
                this.b = Ct, mt = (this || window).f(), Ct = (this || window).b;
              }
              break;
            case $:
              for (; Ct + At > mt.length; )
                mt = (this || window).f({ v: 2 });
              break;
            default:
              t(Error("invalid inflate mode"));
          }
          if (o)
            mt.set(ot.subarray(_t, _t + At), Ct), Ct += At, _t += At;
          else
            for (; At--; )
              mt[Ct++] = ot[_t++];
          this.c = _t, this.b = Ct, this.a = mt;
          break;
        case 1:
          this.o(lt, pt);
          break;
        case 2:
          ht(this);
          break;
        default:
          t(Error("unknown BTYPE: " + at));
      }
    }
    return this.t();
  };
  var b = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], W = o ? new Uint16Array(b) : b, x = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258], E = o ? new Uint16Array(x) : x, R = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0], F = o ? new Uint8Array(R) : R, k = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], X = o ? new Uint16Array(k) : k, j = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
  ], V = o ? new Uint8Array(j) : j, Y = new (o ? Uint8Array : Array)(288), tt, it;
  for (tt = 0, it = Y.length; tt < it; ++tt)
    Y[tt] = 143 >= tt ? 8 : 255 >= tt ? 9 : 279 >= tt ? 7 : 8;
  var lt = m(Y), ut = new (o ? Uint8Array : Array)(30), ft, vt;
  for (ft = 0, vt = ut.length; ft < vt; ++ft)
    ut[ft] = 5;
  var pt = m(ut);
  function gt(at, ot) {
    for (var _t = at.g, mt = at.e, Ct = at.input, yt = at.c, At; mt < ot; )
      At = Ct[yt++], At === e && t(Error("input buffer is broken")), _t |= At << mt, mt += 8;
    return At = _t & (1 << ot) - 1, at.g = _t >>> ot, at.e = mt - ot, at.c = yt, At;
  }
  H(gt, "X");
  function St(at, ot) {
    for (var _t = at.g, mt = at.e, Ct = at.input, yt = at.c, At = ot[0], Pt = ot[1], kt, Ot, Xt; mt < Pt; )
      kt = Ct[yt++], kt === e && t(Error("input buffer is broken")), _t |= kt << mt, mt += 8;
    return Ot = At[_t & (1 << Pt) - 1], Xt = Ot >>> 16, at.g = _t >> Xt, at.e = mt - Xt, at.c = yt, Ot & 65535;
  }
  H(St, "mb");
  function ht(at) {
    function ot(Xt, Vt, Lt) {
      var Nt, Jt, Ht, Kt;
      for (Kt = 0; Kt < Xt; )
        switch (Nt = St(this, Vt), Nt) {
          case 16:
            for (Ht = 3 + gt(this, 2); Ht--; )
              Lt[Kt++] = Jt;
            break;
          case 17:
            for (Ht = 3 + gt(this, 3); Ht--; )
              Lt[Kt++] = 0;
            Jt = 0;
            break;
          case 18:
            for (Ht = 11 + gt(this, 7); Ht--; )
              Lt[Kt++] = 0;
            Jt = 0;
            break;
          default:
            Jt = Lt[Kt++] = Nt;
        }
      return Lt;
    }
    H(ot, "c");
    var _t = gt(at, 5) + 257, mt = gt(at, 5) + 1, Ct = gt(at, 4) + 4, yt = new (o ? Uint8Array : Array)(W.length), At, Pt, kt, Ot;
    for (Ot = 0; Ot < Ct; ++Ot)
      yt[W[Ot]] = gt(at, 3);
    At = m(yt), Pt = new (o ? Uint8Array : Array)(_t), kt = new (o ? Uint8Array : Array)(mt), at.o(m(ot.call(at, _t, At, Pt)), m(ot.call(at, mt, At, kt)));
  }
  H(ht, "Ka"), O.prototype.o = function(at, ot) {
    var _t = (this || window).a, mt = (this || window).b;
    this.u = at;
    for (var Ct = _t.length - 258, yt, At, Pt, kt; (yt = St(this, at)) !== 256; )
      if (256 > yt)
        mt >= Ct && (this.b = mt, _t = (this || window).f(), mt = (this || window).b), _t[mt++] = yt;
      else
        for (At = yt - 257, kt = E[At], 0 < F[At] && (kt += gt(this, F[At])), yt = St(this, ot), Pt = X[yt], 0 < V[yt] && (Pt += gt(this, V[yt])), mt >= Ct && (this.b = mt, _t = (this || window).f(), mt = (this || window).b); kt--; )
          _t[mt] = _t[mt++ - Pt];
    for (; 8 <= (this || window).e; )
      this.e -= 8, this.c--;
    this.b = mt;
  }, O.prototype.I = function(at, ot) {
    var _t = (this || window).a, mt = (this || window).b;
    this.u = at;
    for (var Ct = _t.length, yt, At, Pt, kt; (yt = St(this, at)) !== 256; )
      if (256 > yt)
        mt >= Ct && (_t = (this || window).f(), Ct = _t.length), _t[mt++] = yt;
      else
        for (At = yt - 257, kt = E[At], 0 < F[At] && (kt += gt(this, F[At])), yt = St(this, ot), Pt = X[yt], 0 < V[yt] && (Pt += gt(this, V[yt])), mt + kt > Ct && (_t = (this || window).f(), Ct = _t.length); kt--; )
          _t[mt] = _t[mt++ - Pt];
    for (; 8 <= (this || window).e; )
      this.e -= 8, this.c--;
    this.b = mt;
  }, O.prototype.f = function() {
    var at = new (o ? Uint8Array : Array)(this.b - 32768), ot = (this || window).b - 32768, _t, mt, Ct = (this || window).a;
    if (o)
      at.set(Ct.subarray(32768, at.length));
    else
      for (_t = 0, mt = at.length; _t < mt; ++_t)
        at[_t] = Ct[_t + 32768];
    if (this.k.push(at), this.q += at.length, o)
      Ct.set(Ct.subarray(ot, ot + 32768));
    else
      for (_t = 0; 32768 > _t; ++_t)
        Ct[_t] = Ct[ot + _t];
    return this.b = 32768, Ct;
  }, O.prototype.J = function(at) {
    var ot, _t = (this || window).input.length / this.c + 1 | 0, mt, Ct, yt, At = (this || window).input, Pt = (this || window).a;
    return at && (typeof at.v == "number" && (_t = at.v), typeof at.F == "number" && (_t += at.F)), 2 > _t ? (mt = (At.length - this.c) / this.u[2], yt = 258 * (mt / 2) | 0, Ct = yt < Pt.length ? Pt.length + yt : Pt.length << 1) : Ct = Pt.length * _t, o ? (ot = new Uint8Array(Ct), ot.set(Pt)) : ot = Pt, this.a = ot;
  }, O.prototype.t = function() {
    var at = 0, ot = (this || window).a, _t = (this || window).k, mt, Ct = new (o ? Uint8Array : Array)(this.q + (this.b - 32768)), yt, At, Pt, kt;
    if (_t.length === 0)
      return o ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
    for (yt = 0, At = _t.length; yt < At; ++yt)
      for (mt = _t[yt], Pt = 0, kt = mt.length; Pt < kt; ++Pt)
        Ct[at++] = mt[Pt];
    for (yt = 32768, At = (this || window).b; yt < At; ++yt)
      Ct[at++] = ot[yt];
    return this.k = [], this.buffer = Ct;
  }, O.prototype.H = function() {
    var at, ot = (this || window).b;
    return o ? this.B ? (at = new Uint8Array(ot), at.set(this.a.subarray(0, ot))) : at = (this || window).a.subarray(0, ot) : (this.a.length > ot && (this.a.length = ot), at = (this || window).a), this.buffer = at;
  };
  function ct(at, ot) {
    var _t, mt;
    switch (this.input = at, this.c = 0, (ot || !(ot = {})) && (ot.index && (this.c = ot.index), ot.verify && (this.M = ot.verify)), _t = at[this.c++], mt = at[this.c++], _t & 15) {
      case Gt:
        this.method = Gt;
        break;
      default:
        t(Error("unsupported compression method"));
    }
    ((_t << 8) + mt) % 31 !== 0 && t(Error("invalid fcheck flag:" + ((_t << 8) + mt) % 31)), mt & 32 && t(Error("fdict flag is not supported")), this.A = new O(at, { index: this.c, bufferSize: ot.bufferSize, bufferType: ot.bufferType, resize: ot.resize });
  }
  H(ct, "nb"), ct.prototype.p = function() {
    var at = (this || window).input, ot, _t;
    return ot = (this || window).A.p(), this.c = (this || window).A.c, this.M && (_t = (at[this.c++] << 24 | at[this.c++] << 16 | at[this.c++] << 8 | at[this.c++]) >>> 0, _t !== a(ot) && t(Error("invalid adler-32 checksum"))), ot;
  }, s("Zlib.Inflate", ct), s("Zlib.Inflate.BufferType", S), S.ADAPTIVE = S.C, S.BLOCK = S.D, s("Zlib.Inflate.prototype.decompress", ct.prototype.p);
  var bt = new (o ? Uint8Array : Array)(288), Et, wt;
  for (Et = 0, wt = bt.length; Et < wt; ++Et)
    bt[Et] = 143 >= Et ? 8 : 255 >= Et ? 9 : 279 >= Et ? 7 : 8;
  m(bt);
  var It = new (o ? Uint8Array : Array)(30), Dt, Ut;
  for (Dt = 0, Ut = It.length; Dt < Ut; ++Dt)
    It[Dt] = 5;
  m(It);
  var Gt = 8;
}).call(globalThis);
var _p = window;
_p = _p.Zlib = _p.Zlib;
_p.Deflate = _p.Deflate;
_p.Deflate.compress = _p.Deflate.compress;
_p.Inflate = _p.Inflate;
_p.Inflate.BufferType = _p.Inflate.BufferType;
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
cc.PNGReader = cc.Class.extend({
  ctor: function(t) {
    var e, n, r, s, o, a, c, l, h, u, _, d, f;
    for (this.data = t, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o = null; ; ) {
      switch (e = (this || window).readUInt32(), l = function() {
        var C, m;
        for (m = [], C = 0; C < 4; ++C)
          m.push(String.fromCharCode(this.data[this.pos++]));
        return m;
      }.call(this).join(""), l) {
        case "IHDR":
          this.width = (this || window).readUInt32(), this.height = (this || window).readUInt32(), this.bits = (this || window).data[this.pos++], this.colorType = (this || window).data[this.pos++], this.compressionMethod = (this || window).data[this.pos++], this.filterMethod = (this || window).data[this.pos++], this.interlaceMethod = (this || window).data[this.pos++];
          break;
        case "acTL":
          this.animation = {
            numFrames: this.readUInt32(),
            numPlays: this.readUInt32() || 1 / 0,
            frames: []
          };
          break;
        case "PLTE":
          this.palette = (this || window).read(e);
          break;
        case "fcTL":
          o && this.animation.frames.push(o), this.pos += 4, o = {
            width: this.readUInt32(),
            height: this.readUInt32(),
            xOffset: this.readUInt32(),
            yOffset: this.readUInt32()
          }, s = (this || window).readUInt16(), r = (this || window).readUInt16() || 100, o.delay = 1e3 * s / r, o.disposeOp = (this || window).data[this.pos++], o.blendOp = (this || window).data[this.pos++], o.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (l === "fdAT" && (this.pos += 4, e -= 4), t = (o != null ? o.data : void 0) || this.imgData, _ = 0; 0 <= e ? _ < e : _ > e; 0 <= e ? ++_ : --_)
            t.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (this.transparency.indexed = (this || window).read(e), h = 255 - this.transparency.indexed.length, h > 0)
                for (d = 0; 0 <= h ? d < h : d > h; 0 <= h ? ++d : --d)
                  this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = (this || window).read(e)[0];
              break;
            case 2:
              this.transparency.rgb = (this || window).read(e);
          }
          break;
        case "tEXt":
          u = (this || window).read(e), a = u.indexOf(0), c = String.fromCharCode.apply(String, u.slice(0, a)), this.text[c] = String.fromCharCode.apply(String, u.slice(a + 1));
          break;
        case "IEND":
          o && this.animation.frames.push(o), this.colors = function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }.call(this), this.hasAlphaChannel = (f = (this || window).colorType) === 4 || f === 6, n = (this || window).colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = (this || window).bits * n, this.colorSpace = function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }.call(this), Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
          return;
        default:
          this.pos += e;
      }
      if (this.pos += 4, this.pos > this.data.length)
        throw new Error("Incomplete or corrupt PNG file");
    }
  },
  read: function(t) {
    var e, n;
    for (n = [], e = 0; 0 <= t ? e < t : e > t; 0 <= t ? ++e : --e)
      n.push(this.data[this.pos++]);
    return n;
  },
  readUInt32: function() {
    var t, e, n, r;
    return t = (this || window).data[this.pos++] << 24, e = (this || window).data[this.pos++] << 16, n = (this || window).data[this.pos++] << 8, r = (this || window).data[this.pos++], t | e | n | r;
  },
  readUInt16: function() {
    var t, e;
    return t = (this || window).data[this.pos++] << 8, e = (this || window).data[this.pos++], t | e;
  },
  decodePixels: function(t) {
    var e, n, r, s, o, a, c, l, h, u, _, d, f, C, m, g, y, A, D, N, z, M, Z;
    if (t == null && (t = (this || window).imgData), t.length === 0)
      return new Uint8Array(0);
    var U = new Zlib.Inflate(t, { index: 0, verify: !1 });
    for (t = U.decompress(), d = (this || window).pixelBitlength / 8, g = d * this.width, f = new Uint8Array(g * this.height), a = t.length, m = 0, C = 0, n = 0; C < a; ) {
      switch (t[C++]) {
        case 0:
          for (s = D = 0; D < g; s = D += 1)
            f[n++] = t[C++];
          break;
        case 1:
          for (s = N = 0; N < g; s = N += 1)
            e = t[C++], o = s < d ? 0 : f[n - d], f[n++] = (e + o) % 256;
          break;
        case 2:
          for (s = z = 0; z < g; s = z += 1)
            e = t[C++], r = (s - s % d) / d, y = m && f[(m - 1) * g + r * d + s % d], f[n++] = (y + e) % 256;
          break;
        case 3:
          for (s = M = 0; M < g; s = M += 1)
            e = t[C++], r = (s - s % d) / d, o = s < d ? 0 : f[n - d], y = m && f[(m - 1) * g + r * d + s % d], f[n++] = (e + Math.floor((o + y) / 2)) % 256;
          break;
        case 4:
          for (s = Z = 0; Z < g; s = Z += 1)
            e = t[C++], r = (s - s % d) / d, o = s < d ? 0 : f[n - d], m === 0 ? y = A = 0 : (y = f[(m - 1) * g + r * d + s % d], A = r && f[(m - 1) * g + (r - 1) * d + s % d]), c = o + y - A, l = Math.abs(c - o), u = Math.abs(c - y), _ = Math.abs(c - A), l <= u && l <= _ ? h = o : u <= _ ? h = y : h = A, f[n++] = (e + h) % 256;
          break;
        default:
          throw new Error("Invalid filter algorithm: " + t[C - 1]);
      }
      m++;
    }
    return f;
  },
  copyToImageData: function(t, e) {
    var n, r, s, o, a, c, l, h, u, _, d;
    if (r = (this || window).colors, u = null, n = (this || window).hasAlphaChannel, this.palette.length && (u = (d = (this || window)._decodedPalette) != null ? d : this._decodedPalette = (this || window).decodePalette(), r = 4, n = !0), s = t.data || t, h = s.length, a = u || e, o = c = 0, r === 1)
      for (; o < h; )
        l = u ? e[o / 4] * 4 : c, _ = a[l++], s[o++] = _, s[o++] = _, s[o++] = _, s[o++] = n ? a[l++] : 255, c = l;
    else
      for (; o < h; )
        l = u ? e[o / 4] * 4 : c, s[o++] = a[l++], s[o++] = a[l++], s[o++] = a[l++], s[o++] = n ? a[l++] : 255, c = l;
  },
  decodePalette: function() {
    var t, e, n, r, s, o, a, c, l;
    for (n = (this || window).palette, o = (this || window).transparency.indexed || [], s = new Uint8Array((o.length || 0) + n.length), r = 0, t = 0, e = a = 0, c = n.length; a < c; e = a += 3)
      s[r++] = n[e], s[r++] = n[e + 1], s[r++] = n[e + 2], s[r++] = (l = o[t++]) != null ? l : 255;
    return s;
  },
  render: function(t) {
    var e, n;
    return t.width = (this || window).width, t.height = (this || window).height, e = t.getContext("2d"), n = e.createImageData(this.width, this.height), this.copyToImageData(n, this.decodePixels()), e.putImageData(n, 0, 0);
  }
});
cc.tiffReader = {
  _littleEndian: !1,
  _tiffData: null,
  _fileDirectories: [],
  getUint8: function(t) {
    return this._tiffData[t];
  },
  getUint16: function(t) {
    return this._littleEndian ? this._tiffData[t + 1] << 8 | this._tiffData[t] : this._tiffData[t] << 8 | this._tiffData[t + 1];
  },
  getUint32: function(t) {
    var e = (this || window)._tiffData;
    return this._littleEndian ? e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t] : e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3];
  },
  checkLittleEndian: function() {
    var t = (this || window).getUint16(0);
    if (t === 18761)
      this.littleEndian = !0;
    else if (t === 19789)
      this.littleEndian = !1;
    else
      throw console.log(t), TypeError("Invalid byte order value.");
    return this.littleEndian;
  },
  hasTowel: function() {
    if (this.getUint16(2) !== 42)
      throw RangeError("You forgot your towel!");
    return !0;
  },
  getFieldTypeName: function(t) {
    var e = (this || window).fieldTypeNames;
    return t in e ? e[t] : null;
  },
  getFieldTagName: function(t) {
    var e = (this || window).fieldTagNames;
    return t in e ? e[t] : (console.log("Unknown Field Tag:", t), "Tag" + t);
  },
  getFieldTypeLength: function(t) {
    return ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(t) !== -1 ? 1 : ["SHORT", "SSHORT"].indexOf(t) !== -1 ? 2 : ["LONG", "SLONG", "FLOAT"].indexOf(t) !== -1 ? 4 : ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(t) !== -1 ? 8 : null;
  },
  getFieldValues: function(t, e, n, r) {
    var s = [], o = (this || window).getFieldTypeLength(e), a = o * n;
    if (a <= 4)
      this.littleEndian === !1 ? s.push(r >>> (4 - o) * 8) : s.push(r);
    else
      for (var c = 0; c < n; c++) {
        var l = o * c;
        o >= 8 ? ["RATIONAL", "SRATIONAL"].indexOf(e) !== -1 ? (s.push(this.getUint32(r + l)), s.push(this.getUint32(r + l + 4))) : cc.log("Can't handle this field type or size") : s.push(this.getBytes(o, r + l));
      }
    return e === "ASCII" && s.forEach(function(h, u, _) {
      _[u] = String.fromCharCode(h);
    }), s;
  },
  getBytes: function(t, e) {
    if (t <= 0)
      cc.log("No bytes requested");
    else {
      if (t <= 1)
        return this.getUint8(e);
      if (t <= 2)
        return this.getUint16(e);
      if (t <= 3)
        return this.getUint32(e) >>> 8;
      if (t <= 4)
        return this.getUint32(e);
      cc.log("Too many bytes requested");
    }
  },
  getBits: function(t, e, n) {
    n = n || 0;
    var r = Math.floor(n / 8), s = e + r, o = n + t, a = 32 - t, c, l;
    return o <= 0 ? console.log("No bits requested") : o <= 8 ? (c = 24 + n, l = (this || window).getUint8(s)) : o <= 16 ? (c = 16 + n, l = (this || window).getUint16(s)) : o <= 32 ? (c = n, l = (this || window).getUint32(s)) : console.log("Too many bits requested"), {
      bits: l << c >>> a,
      byteOffset: s + Math.floor(o / 8),
      bitOffset: o % 8
    };
  },
  parseFileDirectory: function(t) {
    for (var e = (this || window).getUint16(t), n = [], r = t + 2, s = 0; s < e; r += 12, s++) {
      var o = (this || window).getUint16(r), a = (this || window).getUint16(r + 2), c = (this || window).getUint32(r + 4), l = (this || window).getUint32(r + 8), h = (this || window).getFieldTagName(o), u = (this || window).getFieldTypeName(a), _ = (this || window).getFieldValues(h, u, c, l);
      n[h] = { type: u, values: _ };
    }
    this._fileDirectories.push(n);
    var d = (this || window).getUint32(r);
    d !== 0 && this.parseFileDirectory(d);
  },
  clampColorSample: function(t, e) {
    var n = Math.pow(2, 8 - e);
    return Math.floor(t * n + (n - 1));
  },
  parseTIFF: function(t, e) {
    if (e = e || document.createElement("canvas"), this._tiffData = t, this.canvas = e, this.checkLittleEndian(), !!this.hasTowel()) {
      var n = (this || window).getUint32(4);
      this._fileDirectories.length = 0, this.parseFileDirectory(n);
      var r = (this || window)._fileDirectories[0], s = r.ImageWidth.values[0], o = r.ImageLength.values[0];
      this.canvas.width = s, this.canvas.height = o;
      var a = [], c = r.Compression ? r.Compression.values[0] : 1, l = r.SamplesPerPixel.values[0], h = [], u = 0, _ = !1;
      if (r.BitsPerSample.values.forEach(function(Et, wt, It) {
        h[wt] = {
          bitsPerSample: Et,
          hasBytesPerSample: !1,
          bytesPerSample: void 0
        }, Et % 8 === 0 && (h[wt].hasBytesPerSample = !0, h[wt].bytesPerSample = Et / 8), u += Et;
      }, this), u % 8 === 0) {
        _ = !0;
        var d = u / 8;
      }
      var f = r.StripOffsets.values, C = f.length;
      if (r.StripByteCounts)
        var m = r.StripByteCounts.values;
      else if (cc.log("Missing StripByteCounts!"), C === 1)
        var m = [Math.ceil(s * o * u / 8)];
      else
        throw Error("Cannot recover from missing StripByteCounts");
      for (var g = 0; g < C; g++) {
        var y = f[g];
        a[g] = [];
        for (var A = m[g], D = 0, N = 0, z = 1, M = !0, Z = [], U = 0, Q = 0, et = 0; D < A; D += z)
          switch (c) {
            case 1:
              for (var rt = 0, Z = []; rt < l; rt++)
                if (h[rt].hasBytesPerSample) {
                  var w = h[rt].bytesPerSample * rt;
                  Z.push(this.getBytes(h[rt].bytesPerSample, y + D + w));
                } else {
                  var L = (this || window).getBits(h[rt].bitsPerSample, y + D, N);
                  throw Z.push(L.bits), D = L.byteOffset - y, N = L.bitOffset, RangeError("Cannot handle sub-byte bits per sample");
                }
              if (a[g].push(Z), _)
                z = d;
              else
                throw z = 0, RangeError("Cannot handle sub-byte bits per pixel");
              break;
            case 2:
              break;
            case 3:
              break;
            case 4:
              break;
            case 5:
              break;
            case 6:
              break;
            case 7:
              break;
            case 32773:
              if (M) {
                M = !1;
                var G = 1, I = 1, O = (this || window).getInt8(y + D);
                O >= 0 && O <= 127 ? G = O + 1 : O >= -127 && O <= -1 ? I = -O + 1 : M = !0;
              } else {
                for (var K = (this || window).getUint8(y + D), rt = 0; rt < I; rt++) {
                  if (h[Q].hasBytesPerSample)
                    et = et << 8 * U | K, U++, U === h[Q].bytesPerSample && (Z.push(et), et = U = 0, Q++);
                  else
                    throw RangeError("Cannot handle sub-byte bits per sample");
                  Q === l && (a[g].push(Z), Z = [], Q = 0);
                }
                G--, G === 0 && (M = !0);
              }
              z = 1;
              break;
          }
      }
      if (e.getContext) {
        var $ = (this || window).canvas.getContext("2d");
        $.fillStyle = "rgba(255, 255, 255, 0)";
        var S = r.RowsPerStrip ? r.RowsPerStrip.values[0] : o, b = a.length, W = o % S, x = W === 0 ? S : W, E = S, R = 0, F = r.PhotometricInterpretation.values[0], k = [], X = 0;
        if (r.ExtraSamples && (k = r.ExtraSamples.values, X = k.length), r.ColorMap)
          var j = r.ColorMap.values, V = Math.pow(2, h[0].bitsPerSample);
        for (var g = 0; g < b; g++) {
          g + 1 === b && (E = x);
          for (var Y = a[g].length, tt = R * g, it = 0, lt = 0; lt < Y; it++)
            for (var ut = 0; ut < s; ut++, lt++) {
              var ft = a[g][lt], vt = 0, pt = 0, gt = 0, St = 1;
              if (X > 0) {
                for (var ht = 0; ht < X; ht++)
                  if (k[ht] === 1 || k[ht] === 2) {
                    St = ft[3 + ht] / 256;
                    break;
                  }
              }
              switch (F) {
                case 0:
                  if (h[0].hasBytesPerSample)
                    var ct = Math.pow(16, h[0].bytesPerSample * 2);
                  ft.forEach(function(wt, It, Dt) {
                    Dt[It] = ct - wt;
                  });
                case 1:
                  vt = pt = gt = (this || window).clampColorSample(ft[0], h[0].bitsPerSample);
                  break;
                case 2:
                  vt = (this || window).clampColorSample(ft[0], h[0].bitsPerSample), pt = (this || window).clampColorSample(ft[1], h[1].bitsPerSample), gt = (this || window).clampColorSample(ft[2], h[2].bitsPerSample);
                  break;
                case 3:
                  if (j === void 0)
                    throw Error("Palette image missing color map");
                  var bt = ft[0];
                  vt = (this || window).clampColorSample(j[bt], 16), pt = (this || window).clampColorSample(j[V + bt], 16), gt = (this || window).clampColorSample(j[2 * V + bt], 16);
                  break;
                default:
                  throw RangeError("Unknown Photometric Interpretation:", F);
              }
              $.fillStyle = "rgba(" + vt + ", " + pt + ", " + gt + ", " + St + ")", $.fillRect(ut, tt + it, 1, 1);
            }
          R = E;
        }
      }
      return this.canvas;
    }
  },
  fieldTagNames: {
    315: "Artist",
    258: "BitsPerSample",
    265: "CellLength",
    264: "CellWidth",
    320: "ColorMap",
    259: "Compression",
    33432: "Copyright",
    306: "DateTime",
    338: "ExtraSamples",
    266: "FillOrder",
    289: "FreeByteCounts",
    288: "FreeOffsets",
    291: "GrayResponseCurve",
    290: "GrayResponseUnit",
    316: "HostComputer",
    270: "ImageDescription",
    257: "ImageLength",
    256: "ImageWidth",
    271: "Make",
    281: "MaxSampleValue",
    280: "MinSampleValue",
    272: "Model",
    254: "NewSubfileType",
    274: "Orientation",
    262: "PhotometricInterpretation",
    284: "PlanarConfiguration",
    296: "ResolutionUnit",
    278: "RowsPerStrip",
    277: "SamplesPerPixel",
    305: "Software",
    279: "StripByteCounts",
    273: "StripOffsets",
    255: "SubfileType",
    263: "Threshholding",
    282: "XResolution",
    283: "YResolution",
    326: "BadFaxLines",
    327: "CleanFaxData",
    343: "ClipPath",
    328: "ConsecutiveBadFaxLines",
    433: "Decode",
    434: "DefaultImageColor",
    269: "DocumentName",
    336: "DotRange",
    321: "HalftoneHints",
    346: "Indexed",
    347: "JPEGTables",
    285: "PageName",
    297: "PageNumber",
    317: "Predictor",
    319: "PrimaryChromaticities",
    532: "ReferenceBlackWhite",
    339: "SampleFormat",
    559: "StripRowCounts",
    330: "SubIFDs",
    292: "T4Options",
    293: "T6Options",
    325: "TileByteCounts",
    323: "TileLength",
    324: "TileOffsets",
    322: "TileWidth",
    301: "TransferFunction",
    318: "WhitePoint",
    344: "XClipPathUnits",
    286: "XPosition",
    529: "YCbCrCoefficients",
    531: "YCbCrPositioning",
    530: "YCbCrSubSampling",
    345: "YClipPathUnits",
    287: "YPosition",
    37378: "ApertureValue",
    40961: "ColorSpace",
    36868: "DateTimeDigitized",
    36867: "DateTimeOriginal",
    34665: "Exif IFD",
    36864: "ExifVersion",
    33434: "ExposureTime",
    41728: "FileSource",
    37385: "Flash",
    40960: "FlashpixVersion",
    33437: "FNumber",
    42016: "ImageUniqueID",
    37384: "LightSource",
    37500: "MakerNote",
    37377: "ShutterSpeedValue",
    37510: "UserComment",
    33723: "IPTC",
    34675: "ICC Profile",
    700: "XMP",
    42112: "GDAL_METADATA",
    42113: "GDAL_NODATA",
    34377: "Photoshop"
  },
  fieldTypeNames: {
    1: "BYTE",
    2: "ASCII",
    3: "SHORT",
    4: "LONG",
    5: "RATIONAL",
    6: "SBYTE",
    7: "UNDEFINED",
    8: "SSHORT",
    9: "SLONG",
    10: "SRATIONAL",
    11: "FLOAT",
    12: "DOUBLE"
  }
};
cc.Particle = function(t, e, n, r, s, o, a, c, l, h, u, _) {
  this.pos = t || cc.p(0, 0), this.startPos = e || cc.p(0, 0), this.color = n || { r: 0, g: 0, b: 0, a: 255 }, this.deltaColor = r || { r: 0, g: 0, b: 0, a: 255 }, this.size = s || 0, this.deltaSize = o || 0, this.rotation = a || 0, this.deltaRotation = c || 0, this.timeToLive = l || 0, this.atlasIndex = h || 0, this.modeA = u || new cc.Particle.ModeA(), this.modeB = _ || new cc.Particle.ModeB(), this.isChangeColor = !1, this.drawPos = cc.p(0, 0);
};
cc.Particle.ModeA = function(t, e, n) {
  this.dir = t || cc.p(0, 0), this.radialAccel = e || 0, this.tangentialAccel = n || 0;
};
cc.Particle.ModeB = function(t, e, n, r) {
  this.angle = t || 0, this.degreesPerSecond = e || 0, this.radius = n || 0, this.deltaRadius = r || 0;
};
cc.Particle.TemporaryPoints = [
  cc.p(),
  cc.p(),
  cc.p(),
  cc.p()
];
cc.ParticleSystem = cc.Node.extend({
  _className: "ParticleSystem",
  _plistFile: "",
  _elapsed: 0,
  _dontTint: !1,
  modeA: null,
  modeB: null,
  _pointZeroForParticle: cc.p(0, 0),
  _particles: null,
  _emitCounter: 0,
  _particleIdx: 0,
  _batchNode: null,
  atlasIndex: 0,
  _transformSystemDirty: !1,
  _allocatedParticles: 0,
  _isActive: !1,
  particleCount: 0,
  duration: 0,
  _sourcePosition: null,
  _posVar: null,
  life: 0,
  lifeVar: 0,
  angle: 0,
  angleVar: 0,
  startSize: 0,
  startSizeVar: 0,
  endSize: 0,
  endSizeVar: 0,
  _startColor: null,
  _startColorVar: null,
  _endColor: null,
  _endColorVar: null,
  startSpin: 0,
  startSpinVar: 0,
  endSpin: 0,
  endSpinVar: 0,
  emissionRate: 0,
  _totalParticles: 0,
  _texture: null,
  _blendFunc: null,
  _opacityModifyRGB: !1,
  positionType: null,
  autoRemoveOnFinish: !1,
  emitterMode: 0,
  _textureLoaded: null,
  ctor: function(t) {
    if (cc.Node.prototype.ctor.call(this), this.emitterMode = cc.ParticleSystem.MODE_GRAVITY, this.modeA = new cc.ParticleSystem.ModeA(), this.modeB = new cc.ParticleSystem.ModeB(), this._blendFunc = { src: cc.BLEND_SRC, dst: cc.BLEND_DST }, this._particles = [], this._sourcePosition = cc.p(0, 0), this._posVar = cc.p(0, 0), this._startColor = cc.color(255, 255, 255, 255), this._startColorVar = cc.color(255, 255, 255, 255), this._endColor = cc.color(255, 255, 255, 255), this._endColorVar = cc.color(255, 255, 255, 255), this._plistFile = "", this._elapsed = 0, this._dontTint = !1, this._pointZeroForParticle = cc.p(0, 0), this._emitCounter = 0, this._particleIdx = 0, this._batchNode = null, this.atlasIndex = 0, this._transformSystemDirty = !1, this._allocatedParticles = 0, this._isActive = !1, this.particleCount = 0, this.duration = 0, this.life = 0, this.lifeVar = 0, this.angle = 0, this.angleVar = 0, this.startSize = 0, this.startSizeVar = 0, this.endSize = 0, this.endSizeVar = 0, this.startSpin = 0, this.startSpinVar = 0, this.endSpin = 0, this.endSpinVar = 0, this.emissionRate = 0, this._totalParticles = 0, this._texture = null, this._opacityModifyRGB = !1, this.positionType = cc.ParticleSystem.TYPE_FREE, this.autoRemoveOnFinish = !1, this._textureLoaded = !0, !t || cc.isNumber(t)) {
      var e = t || 100;
      this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE), this.initWithTotalParticles(e);
    } else
      cc.isString(t) ? this.initWithFile(t) : cc.isObject(t) && this.initWithDictionary(t, "");
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParticleSystem.CanvasRenderCmd(this) : new cc.ParticleSystem.WebGLRenderCmd(this);
  },
  ignoreColor: function(t) {
    this._dontTint = t;
  },
  initTexCoordsWithRect: function(t) {
    this._renderCmd.initTexCoordsWithRect(t);
  },
  getBatchNode: function() {
    return this._batchNode;
  },
  setBatchNode: function(t) {
    this._renderCmd.setBatchNode(t);
  },
  getAtlasIndex: function() {
    return this.atlasIndex;
  },
  setAtlasIndex: function(t) {
    this.atlasIndex = t;
  },
  getDrawMode: function() {
    return this._renderCmd.getDrawMode();
  },
  setDrawMode: function(t) {
    this._renderCmd.setDrawMode(t);
  },
  getShapeType: function() {
    return this._renderCmd.getShapeType();
  },
  setShapeType: function(t) {
    this._renderCmd.setShapeType(t);
  },
  isActive: function() {
    return this._isActive;
  },
  getParticleCount: function() {
    return this.particleCount;
  },
  setParticleCount: function(t) {
    this.particleCount = t;
  },
  getDuration: function() {
    return this.duration;
  },
  setDuration: function(t) {
    this.duration = t;
  },
  getSourcePosition: function() {
    return { x: this._sourcePosition.x, y: this._sourcePosition.y };
  },
  setSourcePosition: function(t) {
    this._sourcePosition = t;
  },
  getPosVar: function() {
    return { x: this._posVar.x, y: this._posVar.y };
  },
  setPosVar: function(t) {
    this._posVar = t;
  },
  getLife: function() {
    return this.life;
  },
  setLife: function(t) {
    this.life = t;
  },
  getLifeVar: function() {
    return this.lifeVar;
  },
  setLifeVar: function(t) {
    this.lifeVar = t;
  },
  getAngle: function() {
    return this.angle;
  },
  setAngle: function(t) {
    this.angle = t;
  },
  getAngleVar: function() {
    return this.angleVar;
  },
  setAngleVar: function(t) {
    this.angleVar = t;
  },
  getGravity: function() {
    this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
    var t = (this || window).modeA.gravity;
    return cc.p(t.x, t.y);
  },
  setGravity: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity"), this.modeA.gravity = t;
  },
  getSpeed: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity"), this.modeA.speed;
  },
  setSpeed: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity"), this.modeA.speed = t;
  },
  getSpeedVar: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity"), this.modeA.speedVar;
  },
  setSpeedVar: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity"), this.modeA.speedVar = t;
  },
  getTangentialAccel: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity"), this.modeA.tangentialAccel;
  },
  setTangentialAccel: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity"), this.modeA.tangentialAccel = t;
  },
  getTangentialAccelVar: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity"), this.modeA.tangentialAccelVar;
  },
  setTangentialAccelVar: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity"), this.modeA.tangentialAccelVar = t;
  },
  getRadialAccel: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity"), this.modeA.radialAccel;
  },
  setRadialAccel: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity"), this.modeA.radialAccel = t;
  },
  getRadialAccelVar: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity"), this.modeA.radialAccelVar;
  },
  setRadialAccelVar: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity"), this.modeA.radialAccelVar = t;
  },
  getRotationIsDir: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity"), this.modeA.rotationIsDir;
  },
  setRotationIsDir: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity"), this.modeA.rotationIsDir = t;
  },
  getStartRadius: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius"), this.modeB.startRadius;
  },
  setStartRadius: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius"), this.modeB.startRadius = t;
  },
  getStartRadiusVar: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius"), this.modeB.startRadiusVar;
  },
  setStartRadiusVar: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius"), this.modeB.startRadiusVar = t;
  },
  getEndRadius: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius"), this.modeB.endRadius;
  },
  setEndRadius: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius"), this.modeB.endRadius = t;
  },
  getEndRadiusVar: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius"), this.modeB.endRadiusVar;
  },
  setEndRadiusVar: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius"), this.modeB.endRadiusVar = t;
  },
  getRotatePerSecond: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius"), this.modeB.rotatePerSecond;
  },
  setRotatePerSecond: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius"), this.modeB.rotatePerSecond = t;
  },
  getRotatePerSecondVar: function() {
    return this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius"), this.modeB.rotatePerSecondVar;
  },
  setRotatePerSecondVar: function(t) {
    this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius"), this.modeB.rotatePerSecondVar = t;
  },
  setScale: function(t, e) {
    this._transformSystemDirty = !0, cc.Node.prototype.setScale.call(this, t, e);
  },
  setRotation: function(t) {
    this._transformSystemDirty = !0, cc.Node.prototype.setRotation.call(this, t);
  },
  setScaleX: function(t) {
    this._transformSystemDirty = !0, cc.Node.prototype.setScaleX.call(this, t);
  },
  setScaleY: function(t) {
    this._transformSystemDirty = !0, cc.Node.prototype.setScaleY.call(this, t);
  },
  getStartSize: function() {
    return this.startSize;
  },
  setStartSize: function(t) {
    this.startSize = t;
  },
  getStartSizeVar: function() {
    return this.startSizeVar;
  },
  setStartSizeVar: function(t) {
    this.startSizeVar = t;
  },
  getEndSize: function() {
    return this.endSize;
  },
  setEndSize: function(t) {
    this.endSize = t;
  },
  getEndSizeVar: function() {
    return this.endSizeVar;
  },
  setEndSizeVar: function(t) {
    this.endSizeVar = t;
  },
  getStartColor: function() {
    return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a);
  },
  setStartColor: function(t) {
    this._startColor = cc.color(t);
  },
  getStartColorVar: function() {
    return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a);
  },
  setStartColorVar: function(t) {
    this._startColorVar = cc.color(t);
  },
  getEndColor: function() {
    return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a);
  },
  setEndColor: function(t) {
    this._endColor = cc.color(t);
  },
  getEndColorVar: function() {
    return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a);
  },
  setEndColorVar: function(t) {
    this._endColorVar = cc.color(t);
  },
  getStartSpin: function() {
    return this.startSpin;
  },
  setStartSpin: function(t) {
    this.startSpin = t;
  },
  getStartSpinVar: function() {
    return this.startSpinVar;
  },
  setStartSpinVar: function(t) {
    this.startSpinVar = t;
  },
  getEndSpin: function() {
    return this.endSpin;
  },
  setEndSpin: function(t) {
    this.endSpin = t;
  },
  getEndSpinVar: function() {
    return this.endSpinVar;
  },
  setEndSpinVar: function(t) {
    this.endSpinVar = t;
  },
  getEmissionRate: function() {
    return this.emissionRate;
  },
  setEmissionRate: function(t) {
    this.emissionRate = t;
  },
  getTotalParticles: function() {
    return this._totalParticles;
  },
  setTotalParticles: function(t) {
    this._renderCmd.setTotalParticles(t);
  },
  getTexture: function() {
    return this._texture;
  },
  setTexture: function(t) {
    t && (t.isLoaded() ? this.setTextureWithRect(t, cc.rect(0, 0, t.width, t.height)) : (this._textureLoaded = !1, t.addEventListener("load", function(e) {
      this._textureLoaded = !0, this.setTextureWithRect(e, cc.rect(0, 0, e.width, e.height));
    }, this)));
  },
  getBlendFunc: function() {
    return this._blendFunc;
  },
  setBlendFunc: function(t, e) {
    e === void 0 ? this._blendFunc !== t && (this._blendFunc = t, this._updateBlendFunc()) : (this._blendFunc.src !== t || this._blendFunc.dst !== e) && (this._blendFunc = { src: t, dst: e }, this._updateBlendFunc());
  },
  isOpacityModifyRGB: function() {
    return this._opacityModifyRGB;
  },
  setOpacityModifyRGB: function(t) {
    this._opacityModifyRGB = t;
  },
  isBlendAdditive: function() {
    return this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE || this._blendFunc.src === cc.ONE && this._blendFunc.dst === cc.ONE;
  },
  setBlendAdditive: function(t) {
    var e = (this || window)._blendFunc;
    t ? (e.src = cc.SRC_ALPHA, e.dst = cc.ONE) : this._renderCmd._setBlendAdditive();
  },
  getPositionType: function() {
    return this.positionType;
  },
  setPositionType: function(t) {
    this.positionType = t;
  },
  isAutoRemoveOnFinish: function() {
    return this.autoRemoveOnFinish;
  },
  setAutoRemoveOnFinish: function(t) {
    this.autoRemoveOnFinish = t;
  },
  getEmitterMode: function() {
    return this.emitterMode;
  },
  setEmitterMode: function(t) {
    this.emitterMode = t;
  },
  init: function() {
    return this.initWithTotalParticles(150);
  },
  initWithFile: function(t) {
    this._plistFile = t;
    var e = cc.loader.getRes(t);
    return e ? this.initWithDictionary(e, "") : (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1);
  },
  getBoundingBoxToWorld: function() {
    return cc.rect(0, 0, cc._canvas.width, cc._canvas.height);
  },
  initWithDictionary: function(t, e) {
    var n = !1, r = null, s = (this || window)._valueForKey, o = parseInt(s("maxParticles", t));
    if (this.initWithTotalParticles(o)) {
      this.angle = parseFloat(s("angle", t)), this.angleVar = parseFloat(s("angleVariance", t)), this.duration = parseFloat(s("duration", t)), this._blendFunc.src = parseInt(s("blendFuncSource", t)), this._blendFunc.dst = parseInt(s("blendFuncDestination", t));
      var a = (this || window)._startColor;
      a.r = parseFloat(s("startColorRed", t)) * 255, a.g = parseFloat(s("startColorGreen", t)) * 255, a.b = parseFloat(s("startColorBlue", t)) * 255, a.a = parseFloat(s("startColorAlpha", t)) * 255;
      var c = (this || window)._startColorVar;
      c.r = parseFloat(s("startColorVarianceRed", t)) * 255, c.g = parseFloat(s("startColorVarianceGreen", t)) * 255, c.b = parseFloat(s("startColorVarianceBlue", t)) * 255, c.a = parseFloat(s("startColorVarianceAlpha", t)) * 255;
      var l = (this || window)._endColor;
      l.r = parseFloat(s("finishColorRed", t)) * 255, l.g = parseFloat(s("finishColorGreen", t)) * 255, l.b = parseFloat(s("finishColorBlue", t)) * 255, l.a = parseFloat(s("finishColorAlpha", t)) * 255;
      var h = (this || window)._endColorVar;
      if (h.r = parseFloat(s("finishColorVarianceRed", t)) * 255, h.g = parseFloat(s("finishColorVarianceGreen", t)) * 255, h.b = parseFloat(s("finishColorVarianceBlue", t)) * 255, h.a = parseFloat(s("finishColorVarianceAlpha", t)) * 255, this.startSize = parseFloat(s("startParticleSize", t)), this.startSizeVar = parseFloat(s("startParticleSizeVariance", t)), this.endSize = parseFloat(s("finishParticleSize", t)), this.endSizeVar = parseFloat(s("finishParticleSizeVariance", t)), this.setPosition(
        parseFloat(s("sourcePositionx", t)),
        parseFloat(s("sourcePositiony", t))
      ), this._posVar.x = parseFloat(s("sourcePositionVariancex", t)), this._posVar.y = parseFloat(s("sourcePositionVariancey", t)), this.startSpin = parseFloat(s("rotationStart", t)), this.startSpinVar = parseFloat(s("rotationStartVariance", t)), this.endSpin = parseFloat(s("rotationEnd", t)), this.endSpinVar = parseFloat(s("rotationEndVariance", t)), this.emitterMode = parseInt(s("emitterType", t)), this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) {
        var u = (this || window).modeA;
        u.gravity.x = parseFloat(s("gravityx", t)), u.gravity.y = parseFloat(s("gravityy", t)), u.speed = parseFloat(s("speed", t)), u.speedVar = parseFloat(s("speedVariance", t));
        var _ = s("radialAcceleration", t);
        u.radialAccel = _ ? parseFloat(_) : 0, _ = s("radialAccelVariance", t), u.radialAccelVar = _ ? parseFloat(_) : 0, _ = s("tangentialAcceleration", t), u.tangentialAccel = _ ? parseFloat(_) : 0, _ = s("tangentialAccelVariance", t), u.tangentialAccelVar = _ ? parseFloat(_) : 0;
        var d = s("rotationIsDir", t).toLowerCase();
        u.rotationIsDir = d != null && (d === "true" || d === "1");
      } else if (this.emitterMode === cc.ParticleSystem.MODE_RADIUS) {
        var f = (this || window).modeB;
        f.startRadius = parseFloat(s("maxRadius", t)), f.startRadiusVar = parseFloat(s("maxRadiusVariance", t)), f.endRadius = parseFloat(s("minRadius", t)), f.endRadiusVar = 0, f.rotatePerSecond = parseFloat(s("rotatePerSecond", t)), f.rotatePerSecondVar = parseFloat(s("rotatePerSecondVariance", t));
      } else
        return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
      if (this.life = parseFloat(s("particleLifespan", t)), this.lifeVar = parseFloat(s("particleLifespanVariance", t)), this.emissionRate = (this || window)._totalParticles / this.life, !this._batchNode) {
        this._opacityModifyRGB = !1;
        var C = s("textureFileName", t), m = cc.path.changeBasename(this._plistFile, C), g = cc.textureCache.getTextureForKey(m);
        if (g)
          this.setTexture(g);
        else {
          var y = s("textureImageData", t);
          if (!y || y.length === 0) {
            if (g = cc.textureCache.addImage(m), !g)
              return !1;
            this.setTexture(g);
          } else {
            if (r = cc.unzipBase64AsArray(y, 1), !r)
              return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
            var A = cc.getImageFormatByData(r);
            if (A !== cc.FMT_TIFF && A !== cc.FMT_PNG)
              return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
            var D = document.createElement("canvas");
            if (A === cc.FMT_PNG) {
              var N = new cc.PNGReader(r);
              N.render(D);
            } else {
              var z = cc.tiffReader;
              z.parseTIFF(r, D);
            }
            cc.textureCache.cacheImage(m, D);
            var M = cc.textureCache.getTextureForKey(m);
            M || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture"), this.setTexture(M);
          }
        }
      }
      n = !0;
    }
    return n;
  },
  initWithTotalParticles: function(t) {
    this._totalParticles = t;
    var e, n = (this || window)._particles;
    for (n.length = 0, e = 0; e < t; e++)
      n[e] = new cc.Particle();
    if (!n)
      return cc.log("Particle system: not enough memory"), !1;
    if (this._allocatedParticles = t, this._batchNode)
      for (e = 0; e < this._totalParticles; e++)
        n[e].atlasIndex = e;
    return this._isActive = !0, this._blendFunc.src = cc.BLEND_SRC, this._blendFunc.dst = cc.BLEND_DST, this.positionType = cc.ParticleSystem.TYPE_FREE, this.emitterMode = cc.ParticleSystem.MODE_GRAVITY, this.autoRemoveOnFinish = !1, this._transformSystemDirty = !1, this.scheduleUpdateWithPriority(1), this._renderCmd._initWithTotalParticles(t), !0;
  },
  destroyParticleSystem: function() {
    this.unscheduleUpdate();
  },
  addParticle: function() {
    if (this.isFull())
      return !1;
    var t = (this || window)._renderCmd.addParticle();
    return this.initParticle(t), ++this.particleCount, !0;
  },
  initParticle: function(t) {
    var e = cc.randomMinus1To1;
    t.timeToLive = (this || window).life + this.lifeVar * e(), t.timeToLive = Math.max(0, t.timeToLive), t.pos.x = (this || window)._sourcePosition.x + this._posVar.x * e(), t.pos.y = (this || window)._sourcePosition.y + this._posVar.y * e();
    var n, r, s = (this || window)._startColor, o = (this || window)._startColorVar, a = (this || window)._endColor, c = (this || window)._endColorVar;
    n = {
      r: cc.clampf(s.r + o.r * e(), 0, 255),
      g: cc.clampf(s.g + o.g * e(), 0, 255),
      b: cc.clampf(s.b + o.b * e(), 0, 255),
      a: cc.clampf(s.a + o.a * e(), 0, 255)
    }, r = {
      r: cc.clampf(a.r + c.r * e(), 0, 255),
      g: cc.clampf(a.g + c.g * e(), 0, 255),
      b: cc.clampf(a.b + c.b * e(), 0, 255),
      a: cc.clampf(a.a + c.a * e(), 0, 255)
    }, t.color = n;
    var l = t.deltaColor, h = t.timeToLive;
    l.r = (r.r - n.r) / h, l.g = (r.g - n.g) / h, l.b = (r.b - n.b) / h, l.a = (r.a - n.a) / h;
    var u = (this || window).startSize + this.startSizeVar * e();
    if (u = Math.max(0, u), t.size = u, this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE)
      t.deltaSize = 0;
    else {
      var _ = (this || window).endSize + this.endSizeVar * e();
      _ = Math.max(0, _), t.deltaSize = (_ - u) / h;
    }
    var d = (this || window).startSpin + this.startSpinVar * e(), f = (this || window).endSpin + this.endSpinVar * e();
    t.rotation = d, t.deltaRotation = (f - d) / h, this.positionType === cc.ParticleSystem.TYPE_FREE ? t.startPos = (this || window).convertToWorldSpace(this._pointZeroForParticle) : this.positionType === cc.ParticleSystem.TYPE_RELATIVE && (t.startPos.x = (this || window)._position.x, t.startPos.y = (this || window)._position.y);
    var C = cc.degreesToRadians(this.angle + this.angleVar * e());
    if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) {
      var m = (this || window).modeA, g = t.modeA, y = m.speed + m.speedVar * e();
      g.dir.x = Math.cos(C), g.dir.y = Math.sin(C), cc.pMultIn(g.dir, y), g.radialAccel = m.radialAccel + m.radialAccelVar * e(), g.tangentialAccel = m.tangentialAccel + m.tangentialAccelVar * e(), m.rotationIsDir && (t.rotation = -cc.radiansToDegrees(cc.pToAngle(g.dir)));
    } else {
      var A = (this || window).modeB, D = t.modeB, N = A.startRadius + A.startRadiusVar * e(), z = A.endRadius + A.endRadiusVar * e();
      D.radius = N, D.deltaRadius = A.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (z - N) / h, D.angle = C, D.degreesPerSecond = cc.degreesToRadians(A.rotatePerSecond + A.rotatePerSecondVar * e());
    }
  },
  stopSystem: function() {
    this._isActive = !1, this._elapsed = (this || window).duration, this._emitCounter = 0;
  },
  resetSystem: function() {
    this._isActive = !0, this._elapsed = 0;
    var t = (this || window)._particles;
    for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx)
      t[this._particleIdx].timeToLive = 0;
  },
  isFull: function() {
    return this.particleCount >= (this || window)._totalParticles;
  },
  updateQuadWithParticle: function(t, e) {
    this._renderCmd.updateQuadWithParticle(t, e);
  },
  postStep: function() {
    this._renderCmd.postStep();
  },
  update: function(t) {
    if (this._isActive && this.emissionRate) {
      var e = 1 / this.emissionRate;
      for (this.particleCount < this._totalParticles && (this._emitCounter += t); this.particleCount < this._totalParticles && this._emitCounter > e; )
        this.addParticle(), this._emitCounter -= e;
      this._elapsed += t, this.duration !== -1 && this.duration < this._elapsed && this.stopSystem();
    }
    this._particleIdx = 0;
    var n = cc.Particle.TemporaryPoints[0];
    if (this.positionType === cc.ParticleSystem.TYPE_FREE ? cc.pIn(n, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType === cc.ParticleSystem.TYPE_RELATIVE && (n.x = (this || window)._position.x, n.y = (this || window)._position.y), this._visible) {
      for (var r = cc.Particle.TemporaryPoints[1], s = cc.Particle.TemporaryPoints[2], o = cc.Particle.TemporaryPoints[3], a = (this || window)._particles; this._particleIdx < this.particleCount; ) {
        cc.pZeroIn(r), cc.pZeroIn(s), cc.pZeroIn(o);
        var c = a[this._particleIdx];
        if (c.timeToLive -= t, c.timeToLive > 0) {
          if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) {
            var l = o, h = r, u = s;
            c.pos.x || c.pos.y ? (cc.pIn(h, c.pos), cc.pNormalizeIn(h)) : cc.pZeroIn(h), cc.pIn(u, h), cc.pMultIn(h, c.modeA.radialAccel);
            var _ = u.x;
            u.x = -u.y, u.y = _, cc.pMultIn(u, c.modeA.tangentialAccel), cc.pIn(l, h), cc.pAddIn(l, u), cc.pAddIn(l, this.modeA.gravity), cc.pMultIn(l, t), cc.pAddIn(c.modeA.dir, l), cc.pIn(l, c.modeA.dir), cc.pMultIn(l, t), cc.pAddIn(c.pos, l);
          } else {
            var d = c.modeB;
            d.angle += d.degreesPerSecond * t, d.radius += d.deltaRadius * t, c.pos.x = -Math.cos(d.angle) * d.radius, c.pos.y = -Math.sin(d.angle) * d.radius;
          }
          this._renderCmd._updateDeltaColor(c, t), c.size += c.deltaSize * t, c.size = Math.max(0, c.size), c.rotation += c.deltaRotation * t;
          var f = r;
          if (this.positionType === cc.ParticleSystem.TYPE_FREE || this.positionType === cc.ParticleSystem.TYPE_RELATIVE) {
            var C = s;
            cc.pIn(C, n), cc.pSubIn(C, c.startPos), cc.pIn(f, c.pos), cc.pSubIn(f, C);
          } else
            cc.pIn(f, c.pos);
          this._batchNode && (f.x += (this || window)._position.x, f.y += (this || window)._position.y), this._renderCmd.updateParticlePosition(c, f), ++this._particleIdx;
        } else {
          var m = c.atlasIndex;
          if (this._particleIdx !== (this || window).particleCount - 1) {
            var g = a[this._particleIdx];
            a[this._particleIdx] = a[this.particleCount - 1], a[this.particleCount - 1] = g;
          }
          if (this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + m), a[this.particleCount - 1].atlasIndex = m), --this.particleCount, this.particleCount === 0 && this.autoRemoveOnFinish) {
            this.unscheduleUpdate(), this._parent.removeChild(this, !0);
            return;
          }
        }
      }
      this._transformSystemDirty = !1;
    }
    this._batchNode || this.postStep();
  },
  updateWithNoTime: function() {
    this.update(0);
  },
  _valueForKey: function(t, e) {
    if (e) {
      var n = e[t];
      return n != null ? n : "";
    }
    return "";
  },
  _updateBlendFunc: function() {
    if (this._batchNode) {
      cc.log("Can't change blending functions when the particle is being batched");
      return;
    }
    var t = (this || window)._texture;
    if (t && t instanceof cc.Texture2D) {
      this._opacityModifyRGB = !1;
      var e = (this || window)._blendFunc;
      e.src === cc.BLEND_SRC && e.dst === cc.BLEND_DST && (t.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (e.src = cc.SRC_ALPHA, e.dst = cc.ONE_MINUS_SRC_ALPHA));
    }
  },
  clone: function() {
    var t = new cc.ParticleSystem();
    if (t.initWithTotalParticles(this.getTotalParticles())) {
      t.setAngle(this.getAngle()), t.setAngleVar(this.getAngleVar()), t.setDuration(this.getDuration());
      var e = (this || window).getBlendFunc();
      if (t.setBlendFunc(e.src, e.dst), t.setStartColor(this.getStartColor()), t.setStartColorVar(this.getStartColorVar()), t.setEndColor(this.getEndColor()), t.setEndColorVar(this.getEndColorVar()), t.setStartSize(this.getStartSize()), t.setStartSizeVar(this.getStartSizeVar()), t.setEndSize(this.getEndSize()), t.setEndSizeVar(this.getEndSizeVar()), t.setPosition(cc.p(this.x, this.y)), t.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y)), t.setPositionType(this.getPositionType()), t.setStartSpin(this.getStartSpin() || 0), t.setStartSpinVar(this.getStartSpinVar() || 0), t.setEndSpin(this.getEndSpin() || 0), t.setEndSpinVar(this.getEndSpinVar() || 0), t.setEmitterMode(this.getEmitterMode()), this.getEmitterMode() === cc.ParticleSystem.MODE_GRAVITY) {
        var n = (this || window).getGravity();
        t.setGravity(cc.p(n.x, n.y)), t.setSpeed(this.getSpeed()), t.setSpeedVar(this.getSpeedVar()), t.setRadialAccel(this.getRadialAccel()), t.setRadialAccelVar(this.getRadialAccelVar()), t.setTangentialAccel(this.getTangentialAccel()), t.setTangentialAccelVar(this.getTangentialAccelVar());
      } else
        this.getEmitterMode() === cc.ParticleSystem.MODE_RADIUS && (t.setStartRadius(this.getStartRadius()), t.setStartRadiusVar(this.getStartRadiusVar()), t.setEndRadius(this.getEndRadius()), t.setEndRadiusVar(this.getEndRadiusVar()), t.setRotatePerSecond(this.getRotatePerSecond()), t.setRotatePerSecondVar(this.getRotatePerSecondVar()));
      if (t.setLife(this.getLife()), t.setLifeVar(this.getLifeVar()), t.setEmissionRate(this.getEmissionRate()), !this.getBatchNode()) {
        t.setOpacityModifyRGB(this.isOpacityModifyRGB());
        var r = (this || window).getTexture();
        if (r) {
          var s = r.getContentSize();
          t.setTextureWithRect(r, cc.rect(0, 0, s.width, s.height));
        }
      }
    }
    return t;
  },
  setDisplayFrame: function(t) {
    if (t) {
      var e = t.getOffsetInPixels();
      (e.x !== 0 || e.y !== 0) && cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
      var n = t.getTexture(), r = (this || window)._texture;
      r !== n && this.setTexture(n);
    }
  },
  setTextureWithRect: function(t, e) {
    var n = (this || window)._texture;
    n !== t && (this._texture = t, this._updateBlendFunc()), this.initTexCoordsWithRect(e);
  },
  listenBackToForeground: function(t) {
  }
});
var _p = cc.ParticleSystem.prototype;
_p.opacityModifyRGB;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
_p.batchNode;
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
_p.drawMode;
cc.defineGetterSetter(_p, "drawMode", _p.getDrawMode, _p.setDrawMode);
_p.shapeType;
cc.defineGetterSetter(_p, "shapeType", _p.getShapeType, _p.setShapeType);
_p.active;
cc.defineGetterSetter(_p, "active", _p.isActive);
_p.sourcePos;
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
_p.posVar;
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
_p.gravity;
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
_p.speed;
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
_p.speedVar;
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
_p.tangentialAccel;
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
_p.tangentialAccelVar;
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
_p.radialAccel;
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
_p.radialAccelVar;
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
_p.rotationIsDir;
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
_p.startRadius;
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
_p.startRadiusVar;
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
_p.endRadius;
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
_p.endRadiusVar;
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
_p.rotatePerS;
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
_p.rotatePerSVar;
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
_p.startColor;
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
_p.startColorVar;
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
_p.endColor;
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
_p.endColorVar;
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
_p.totalParticles;
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
_p.texture;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleSystem.create = function(t) {
  return new cc.ParticleSystem(t);
};
cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create;
cc.ParticleSystem.ModeA = function(t, e, n, r, s, o, a, c) {
  this.gravity = t || cc.p(0, 0), this.speed = e || 0, this.speedVar = n || 0, this.tangentialAccel = r || 0, this.tangentialAccelVar = s || 0, this.radialAccel = o || 0, this.radialAccelVar = a || 0, this.rotationIsDir = c || !1;
};
cc.ParticleSystem.ModeB = function(t, e, n, r, s, o) {
  this.startRadius = t || 0, this.startRadiusVar = e || 0, this.endRadius = n || 0, this.endRadiusVar = r || 0, this.rotatePerSecond = s || 0, this.rotatePerSecondVar = o || 0;
};
cc.ParticleSystem.SHAPE_MODE = 0;
cc.ParticleSystem.TEXTURE_MODE = 1;
cc.ParticleSystem.STAR_SHAPE = 0;
cc.ParticleSystem.BALL_SHAPE = 1;
cc.ParticleSystem.DURATION_INFINITY = -1;
cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.ParticleSystem.MODE_GRAVITY = 0;
cc.ParticleSystem.MODE_RADIUS = 1;
cc.ParticleSystem.TYPE_FREE = 0;
cc.ParticleSystem.TYPE_RELATIVE = 1;
cc.ParticleSystem.TYPE_GROUPED = 2;
(function() {
  cc.ParticleSystem.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !0, this._drawMode = cc.ParticleSystem.TEXTURE_MODE, this._shapeType = cc.ParticleSystem.BALL_SHAPE, this._pointRect = cc.rect(0, 0, 0, 0), this._tintCache = document.createElement("canvas");
  };
  var t = cc.ParticleSystem.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.ParticleSystem.CanvasRenderCmd, t.getDrawMode = function() {
    return this._drawMode;
  }, t.setDrawMode = function(e) {
    this._drawMode = e;
  }, t.getShapeType = function() {
    return this._shapeType;
  }, t.setShapeType = function(e) {
    this._shapeType = e;
  }, t.setBatchNode = function(e) {
    this._batchNode !== e && (this._node._batchNode = e);
  }, t.updateQuadWithParticle = function(e, n) {
  }, t.updateParticlePosition = function(e, n) {
    cc.pIn(e.drawPos, n);
  }, t.rendering = function(e, n, r) {
    var s = e || cc._renderContext, o = s.getContext(), a = (this || window)._node, c = (this || window)._pointRect;
    s.setTransform(this._worldTransform, n, r), s.save(), a.isBlendAdditive() ? o.globalCompositeOperation = "lighter" : o.globalCompositeOperation = "source-over";
    var l, h, u, _, d = (this || window)._node.particleCount, f = (this || window)._node._particles;
    if (a.drawMode !== cc.ParticleSystem.SHAPE_MODE && a._texture) {
      if (!a._texture._textureLoaded) {
        s.restore();
        return;
      }
      var C = a._texture.getHtmlElementObj();
      if (!C.width || !C.height) {
        s.restore();
        return;
      }
      var m = C;
      for (l = 0; l < d; l++)
        if (h = f[l], u = 0 | h.size * 0.5, _ = h.color.a / 255, _ !== 0) {
          o.globalAlpha = _, o.save(), o.translate(0 | h.drawPos.x, -(0 | h.drawPos.y));
          var g = Math.floor(h.size / 4) * 4, y = c.width, A = c.height;
          o.scale(Math.max(1 / y * g, 1e-6), Math.max(1 / A * g, 1e-6)), h.rotation && o.rotate(cc.degreesToRadians(h.rotation)), m = h.isChangeColor ? this._changeTextureColor(a._texture, h.color, this._pointRect) : C, o.drawImage(m, -(0 | y / 2), -(0 | A / 2)), o.restore();
        }
    } else {
      var D = cc._drawingUtil;
      for (l = 0; l < d; l++)
        h = f[l], u = 0 | h.size * 0.5, _ = h.color.a / 255, _ !== 0 && (o.globalAlpha = _, o.save(), o.translate(0 | h.drawPos.x, -(0 | h.drawPos.y)), a.shapeType === cc.ParticleSystem.STAR_SHAPE ? (h.rotation && o.rotate(cc.degreesToRadians(h.rotation)), D.drawStar(s, u, h.color)) : D.drawColorBall(s, u, h.color), o.restore());
    }
    s.restore(), cc.g_NumberOfDraws++;
  }, t._changeTextureColor = function(e, n, r) {
    var s = (this || window)._tintCache, o = e.getContentSize();
    return s.width = o.width, s.height = o.height, e._generateColorTexture(n.r, n.g, n.b, r, s);
  }, t.initTexCoordsWithRect = function(e) {
    this._pointRect = e;
  }, t.setTotalParticles = function(e) {
    this._node._totalParticles = e < 200 ? e : 200;
  }, t.addParticle = function() {
    var e = (this || window)._node, n = e._particles, r;
    return e.particleCount < n.length ? r = n[e.particleCount] : (r = new cc.Particle(), n.push(r)), r;
  }, t._setupVBO = function() {
  }, t._allocMemory = function() {
    return !0;
  }, t.postStep = function() {
  }, t._setBlendAdditive = function() {
    var e = (this || window)._node._blendFunc;
    e.src = cc.BLEND_SRC, e.dst = cc.BLEND_DST;
  }, t._initWithTotalParticles = function(e) {
  }, t._updateDeltaColor = function(e, n) {
    this._node._dontTint || (e.color.r += e.deltaColor.r * n, e.color.g += e.deltaColor.g * n, e.color.b += e.deltaColor.b * n, e.color.a += e.deltaColor.a * n, e.isChangeColor = !0);
  };
})();
cc.ParticleFire = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 300 : 150);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(0.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0;
    }
    return !1;
  }
});
cc.ParticleFire.create = function() {
  return new cc.ParticleFire();
};
cc.ParticleFireworks = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1500 : 150);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, e.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0;
    }
    return !1;
  }
});
cc.ParticleFireworks.create = function() {
  return new cc.ParticleFireworks();
};
cc.ParticleSun = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 350 : 150);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setBlendAdditive(!0), this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5), this.setAngle(90), this.setAngleVar(360);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, e.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(0.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0;
    }
    return !1;
  }
});
cc.ParticleSun.create = function() {
  return new cc.ParticleSun();
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, e.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0;
    }
    return !1;
  }
});
cc.ParticleGalaxy.create = function() {
  return new cc.ParticleGalaxy();
};
cc.ParticleFlower = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 250 : 100);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, e.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0;
    }
    return !1;
  }
});
cc.ParticleFlower.create = function() {
  return new cc.ParticleFlower();
};
cc.ParticleMeteor = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 150 : 100);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, e.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0;
    }
    return !1;
  }
});
cc.ParticleMeteor.create = function() {
  return new cc.ParticleMeteor();
};
cc.ParticleSpiral = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 500 : 100);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, e.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0;
    }
    return !1;
  }
});
cc.ParticleSpiral.create = function() {
  return new cc.ParticleSpiral();
};
cc.ParticleExplosion = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 300);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(0.1), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, e.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0;
    }
    return !1;
  }
});
cc.ParticleExplosion.create = function() {
  return new cc.ParticleExplosion();
};
cc.ParticleSmoke = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90), this.setAngleVar(5);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0;
    }
    return !1;
  }
});
cc.ParticleSmoke.create = function() {
  return new cc.ParticleSmoke();
};
cc.ParticleSnow = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 250);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, e.height + 10), this.setPosVar(cc.p(e.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0;
    }
    return !1;
  }
});
cc.ParticleSnow.create = function() {
  return new cc.ParticleSnow();
};
cc.ParticleRain = cc.ParticleSystem.extend({
  ctor: function() {
    cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1e3 : 300);
  },
  initWithTotalParticles: function(t) {
    if (cc.ParticleSystem.prototype.initWithTotalParticles.call(this, t)) {
      this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1), this.setSpeed(130), this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5);
      var e = cc.director.getWinSize();
      return this.setPosition(e.width / 2, e.height), this.setPosVar(cc.p(e.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0;
    }
    return !1;
  }
});
cc.ParticleRain.create = function() {
  return new cc.ParticleRain();
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({
  textureAtlas: null,
  _blendFunc: null,
  _className: "ParticleBatchNode",
  ctor: function(t, e) {
    cc.Node.prototype.ctor.call(this), this._blendFunc = { src: cc.BLEND_SRC, dst: cc.BLEND_DST }, cc.isString(t) ? this.init(t, e) : t instanceof cc.Texture2D && this.initWithTexture(t, e);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParticleBatchNode.CanvasRenderCmd(this) : new cc.ParticleBatchNode.WebGLRenderCmd(this);
  },
  initWithTexture: function(t, e) {
    return this.textureAtlas = new cc.TextureAtlas(), this.textureAtlas.initWithTexture(t, e), this._children.length = 0, this._renderCmd._initWithTexture(), !0;
  },
  initWithFile: function(t, e) {
    var n = cc.textureCache.addImage(t);
    return this.initWithTexture(n, e);
  },
  init: function(t, e) {
    var n = cc.textureCache.addImage(t);
    return this.initWithTexture(n, e);
  },
  addChild: function(t, e, n) {
    if (!t)
      throw new Error("cc.ParticleBatchNode.addChild() : child should be non-null");
    if (!(t instanceof cc.ParticleSystem))
      throw new Error("cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children");
    if (e = e == null ? t.zIndex : e, n = n == null ? t.tag : n, t.getTexture() !== (this || window).textureAtlas.texture)
      throw new Error("cc.ParticleSystem.addChild() : the child is not using the same texture id");
    var r = t.getBlendFunc();
    if (this._children.length === 0)
      this.setBlendFunc(r);
    else if (r.src !== (this || window)._blendFunc.src || r.dst !== (this || window)._blendFunc.dst) {
      cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
      return;
    }
    var s = (this || window)._addChildHelper(t, e, n), o = 0;
    if (s !== 0) {
      var a = (this || window)._children[s - 1];
      o = a.getAtlasIndex() + a.getTotalParticles();
    } else
      o = 0;
    this.insertChild(t, o), t.setBatchNode(this);
  },
  insertChild: function(t, e) {
    var n = t.getTotalParticles(), r = (this || window).textureAtlas, s = r.totalQuads;
    t.setAtlasIndex(e), s + n > r.getCapacity() && (this._increaseAtlasCapacityTo(s + n), r.fillWithEmptyQuadsFromIndex(r.getCapacity() - n, n)), t.getAtlasIndex() + n !== s && r.moveQuadsFromIndex(e, e + n), r.increaseTotalQuadsWith(n), this._updateAllAtlasIndexes();
  },
  removeChild: function(t, e) {
    if (t != null) {
      if (!(t instanceof cc.ParticleSystem))
        throw new Error("cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children");
      if (this._children.indexOf(t) === -1) {
        cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
        return;
      }
      cc.Node.prototype.removeChild.call(this, t, e);
      var n = (this || window).textureAtlas;
      n.removeQuadsAtIndex(t.getAtlasIndex(), t.getTotalParticles()), n.fillWithEmptyQuadsFromIndex(n.totalQuads, t.getTotalParticles()), t.setBatchNode(null), this._updateAllAtlasIndexes();
    }
  },
  reorderChild: function(t, e) {
    if (!t)
      throw new Error("cc.ParticleBatchNode.reorderChild(): child should be non-null");
    if (!(t instanceof cc.ParticleSystem))
      throw new Error("cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children");
    if (this._children.indexOf(t) === -1) {
      cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
      return;
    }
    if (e !== t.zIndex) {
      if (this._children.length > 1) {
        var n = (this || window)._getCurrentIndex(t, e);
        if (n.oldIndex !== n.newIndex) {
          this._children.splice(n.oldIndex, 1), this._children.splice(n.newIndex, 0, t);
          var r = t.getAtlasIndex();
          this._updateAllAtlasIndexes();
          for (var s = 0, o = (this || window)._children, a = 0; a < o.length; a++) {
            var c = o[a];
            if (c === t) {
              s = t.getAtlasIndex();
              break;
            }
          }
          this.textureAtlas.moveQuadsFromIndex(r, t.getTotalParticles(), s), t.updateWithNoTime();
        }
      }
      t._setLocalZOrder(e);
    }
  },
  removeChildAtIndex: function(t, e) {
    this.removeChild(this._children[i], e);
  },
  removeAllChildren: function(t) {
    for (var e = (this || window)._children, n = 0; n < e.length; n++)
      e[n].setBatchNode(null);
    cc.Node.prototype.removeAllChildren.call(this, t), this.textureAtlas.removeAllQuads();
  },
  disableParticle: function(t) {
    var e = (this || window).textureAtlas.quads[t];
    e.br.vertices.x = e.br.vertices.y = e.tr.vertices.x = e.tr.vertices.y = e.tl.vertices.x = e.tl.vertices.y = e.bl.vertices.x = e.bl.vertices.y = 0, this.textureAtlas._setDirty(!0);
  },
  getTexture: function() {
    return this.textureAtlas.texture;
  },
  setTexture: function(t) {
    this.textureAtlas.texture = t;
    var e = (this || window)._blendFunc;
    t && !t.hasPremultipliedAlpha() && e.src === cc.BLEND_SRC && e.dst === cc.BLEND_DST && (e.src = cc.SRC_ALPHA, e.dst = cc.ONE_MINUS_SRC_ALPHA);
  },
  setBlendFunc: function(t, e) {
    e === void 0 ? (this._blendFunc.src = t.src, this._blendFunc.dst = t.dst) : (this._blendFunc.src = t, this._blendFunc.src = e);
  },
  getBlendFunc: function() {
    return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
  },
  _updateAllAtlasIndexes: function() {
    for (var t = 0, e = (this || window)._children, n = 0; n < e.length; n++) {
      var r = e[n];
      r.setAtlasIndex(t), t += r.getTotalParticles();
    }
  },
  _increaseAtlasCapacityTo: function(t) {
    cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + t + "]."), this.textureAtlas.resizeCapacity(t) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas");
  },
  _searchNewPositionInChildrenForZ: function(t) {
    for (var e = (this || window)._children, n = e.length, r = 0; r < n; r++)
      if (e[r].zIndex > t)
        return r;
    return n;
  },
  _getCurrentIndex: function(t, e) {
    for (var n = !1, r = !1, s = 0, o = 0, a = 0, c = (this || window)._children, l = c.length, h = 0; h < l; h++) {
      var u = c[h];
      if (u.zIndex > e && !r && (s = h, r = !0, n && r) || t === u && (o = h, n = !0, r || (a = -1), n && r))
        break;
    }
    return r || (s = l), s += a, { newIndex: s, oldIndex: o };
  },
  _addChildHelper: function(t, e, n) {
    if (!t)
      throw new Error("cc.ParticleBatchNode._addChildHelper(): child should be non-null");
    if (t.parent)
      return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"), null;
    this._children || (this._children = []);
    var r = (this || window)._searchNewPositionInChildrenForZ(e);
    return this._children.splice(r, 0, t), t.tag = n, t._setLocalZOrder(e), t.parent = (this || window), this._running && (t.onEnter(), t.onEnterTransitionDidFinish()), r;
  },
  _updateBlendFunc: function() {
    this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA);
  },
  getTextureAtlas: function() {
    return this.textureAtlas;
  },
  setTextureAtlas: function(t) {
    this.textureAtlas = t;
  }
});
var _p = cc.ParticleBatchNode.prototype;
_p.texture;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleBatchNode.create = function(t, e) {
  return new cc.ParticleBatchNode(t, e);
};
(function() {
  cc.ParticleBatchNode.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !1;
  };
  var t = cc.ParticleBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.ParticleBatchNode.CanvasRenderCmd, t._initWithTexture = function() {
  };
})();
(function() {
  cc.ParticleBatchNode.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._matrix = new cc.math.Matrix4(), this._matrix.identity();
  };
  var t = cc.ParticleBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.ParticleBatchNode.WebGLRenderCmd, t.rendering = function(e) {
    var n = (this || window)._node;
    if (n.textureAtlas.totalQuads !== 0) {
      var r = (this || window)._worldTransform;
      this._matrix.mat[0] = r.a, this._matrix.mat[4] = r.c, this._matrix.mat[12] = r.tx, this._matrix.mat[1] = r.b, this._matrix.mat[5] = r.d, this._matrix.mat[13] = r.ty, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix), cc.glBlendFuncForParticle(n._blendFunc.src, n._blendFunc.dst), n.textureAtlas.drawQuads();
    }
  }, t._initWithTexture = function() {
    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
  }, t.visit = function(e) {
    var n = (this || window)._node;
    n._visible && (e = e || this.getParentRenderCmd(), e && (this._curLevel = e._curLevel + 1), this._syncStatus(e), cc.renderer.pushRenderCommand(this), this._dirtyFlag = 0);
  };
})();
(function() {
  cc.ParticleSystem.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._matrix = new cc.math.Matrix4(), this._matrix.identity(), this._buffersVBO = [0, 0], this._quads = [], this._indices = [], this._quadsArrayBuffer = null;
  };
  var t = cc.ParticleSystem.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.ParticleSystem.WebGLRenderCmd, t.getDrawMode = function() {
  }, t.setDrawMode = function(e) {
  }, t.getShapeType = function() {
  }, t.setShapeType = function(e) {
  }, t.setBatchNode = function(e) {
    var n = (this || window)._node;
    if (n._batchNode !== e) {
      var r = n._batchNode;
      if (n._batchNode = e, e)
        for (var s = n._particles, o = 0; o < n._totalParticles; o++)
          s[o].atlasIndex = o;
      e ? r || (n._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, n.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(n._totalParticles), n.setTexture(r.getTexture()), this._setupVBO());
    }
  }, t.initIndices = function(e) {
    for (var n = (this || window)._indices, r = 0, s = e; r < s; ++r) {
      var o = r * 6, a = r * 4;
      n[o + 0] = a + 0, n[o + 1] = a + 1, n[o + 2] = a + 2, n[o + 5] = a + 1, n[o + 4] = a + 2, n[o + 3] = a + 3;
    }
  }, t.isDifferentTexture = function(e, n) {
    return e === n;
  }, t.updateParticlePosition = function(e, n) {
    this.updateQuadWithParticle(e, n);
  }, t.updateQuadWithParticle = function(e, n) {
    var r = null, s = (this || window)._node;
    if (s._batchNode) {
      var o = s._batchNode.textureAtlas.quads;
      r = o[s.atlasIndex + e.atlasIndex], s._batchNode.textureAtlas.dirty = !0;
    } else
      r = (this || window)._quads[s._particleIdx];
    var a, c, l, h;
    s._opacityModifyRGB ? (a = 0 | e.color.r * e.color.a / 255, c = 0 | e.color.g * e.color.a / 255, l = 0 | e.color.b * e.color.a / 255) : (a = 0 | e.color.r, c = 0 | e.color.g, l = 0 | e.color.b), h = 0 | e.color.a;
    var u = r.bl.colors, _ = r.br.colors, d = r.tl.colors, f = r.tr.colors;
    u.r = _.r = d.r = f.r = a, u.g = _.g = d.g = f.g = c, u.b = _.b = d.b = f.b = l, u.a = _.a = d.a = f.a = h;
    var C = e.size / 2;
    if (e.rotation) {
      var m = -C, g = -C, y = C, A = C, D = n.x, N = n.y, z = -cc.degreesToRadians(e.rotation), M = Math.cos(z), Z = Math.sin(z), U = m * M - g * Z + D, Q = m * Z + g * M + N, et = y * M - g * Z + D, rt = y * Z + g * M + N, w = y * M - A * Z + D, L = y * Z + A * M + N, G = m * M - A * Z + D, I = m * Z + A * M + N;
      r.bl.vertices.x = U, r.bl.vertices.y = Q, r.br.vertices.x = et, r.br.vertices.y = rt, r.tl.vertices.x = G, r.tl.vertices.y = I, r.tr.vertices.x = w, r.tr.vertices.y = L;
    } else
      r.bl.vertices.x = n.x - C, r.bl.vertices.y = n.y - C, r.br.vertices.x = n.x + C, r.br.vertices.y = n.y - C, r.tl.vertices.x = n.x - C, r.tl.vertices.y = n.y + C, r.tr.vertices.x = n.x + C, r.tr.vertices.y = n.y + C;
  }, t.rendering = function(e) {
    var n = (this || window)._node;
    if (n._texture) {
      var r = e || cc._renderContext, s = (this || window)._worldTransform;
      this._matrix.mat[0] = s.a, this._matrix.mat[4] = s.c, this._matrix.mat[12] = s.tx, this._matrix.mat[1] = s.b, this._matrix.mat[5] = s.d, this._matrix.mat[13] = s.ty, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix), cc.glBindTexture2D(n._texture), cc.glBlendFuncForParticle(n._blendFunc.src, n._blendFunc.dst), r.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), r.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), r.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), r.bindBuffer(r.ARRAY_BUFFER, this._buffersVBO[0]), r.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, r.FLOAT, !1, 24, 0), r.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, r.UNSIGNED_BYTE, !0, 24, 12), r.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, r.FLOAT, !1, 24, 16), r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), r.drawElements(r.TRIANGLES, n._particleIdx * 6, r.UNSIGNED_SHORT, 0);
    }
  }, t.initTexCoordsWithRect = function(e) {
    var n = (this || window)._node, r = n.texture, s = cc.contentScaleFactor(), o = cc.rect(
      e.x * s,
      e.y * s,
      e.width * s,
      e.height * s
    ), a = e.width, c = e.height;
    r && (a = r.pixelsWidth, c = r.pixelsHeight);
    var l, h, u, _;
    cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (l = (o.x * 2 + 1) / (a * 2), h = (o.y * 2 + 1) / (c * 2), u = l + (o.width * 2 - 2) / (a * 2), _ = h + (o.height * 2 - 2) / (c * 2)) : (l = o.x / a, h = o.y / c, u = l + o.width / a, _ = h + o.height / c);
    var d = _;
    _ = h, h = d;
    var f, C = 0, m = 0;
    n._batchNode ? (f = n._batchNode.textureAtlas.quads, C = n.atlasIndex, m = n.atlasIndex + n._totalParticles) : (f = (this || window)._quads, C = 0, m = n._totalParticles);
    for (var g = C; g < m; g++) {
      f[g] || (f[g] = cc.V3F_C4B_T2F_QuadZero());
      var y = f[g];
      y.bl.texCoords.u = l, y.bl.texCoords.v = h, y.br.texCoords.u = u, y.br.texCoords.v = h, y.tl.texCoords.u = l, y.tl.texCoords.v = _, y.tr.texCoords.u = u, y.tr.texCoords.v = _;
    }
  }, t.setTotalParticles = function(e) {
    var n = (this || window)._node;
    if (e > n._allocatedParticles) {
      var r = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
      this._indices = new Uint16Array(e * 6);
      var s = new ArrayBuffer(e * r), o = n._particles;
      o.length = 0;
      var a = (this || window)._quads;
      a.length = 0;
      for (var c = 0; c < e; c++)
        o[c] = new cc.Particle(), a[c] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, s, c * r);
      if (n._allocatedParticles = e, n._totalParticles = e, n._batchNode)
        for (var l = 0; l < e; l++)
          o[l].atlasIndex = l;
      this._quadsArrayBuffer = s, this.initIndices(e), this._setupVBO(), n._texture && this.initTexCoordsWithRect(cc.rect(0, 0, n._texture.width, n._texture.height));
    } else
      n._totalParticles = e;
    n.resetSystem();
  }, t.addParticle = function() {
    var e = (this || window)._node, n = e._particles;
    return n[e.particleCount];
  }, t._setupVBO = function() {
    var e = cc._renderContext;
    this._buffersVBO[0] = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._buffersVBO[0]), e.bufferData(e.ARRAY_BUFFER, this._quadsArrayBuffer, e.DYNAMIC_DRAW), this._buffersVBO[1] = e.createBuffer(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this._indices, e.STATIC_DRAW);
  }, t._allocMemory = function() {
    var e = (this || window)._node;
    if (e._batchNode)
      return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
    var n = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, r = e._totalParticles, s = (this || window)._quads;
    s.length = 0, this._indices = new Uint16Array(r * 6);
    for (var o = new ArrayBuffer(n * r), a = 0; a < r; a++)
      s[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, o, a * n);
    return !s || !this._indices ? (cc.log("cocos2d: Particle system: not enough memory"), !1) : (this._quadsArrayBuffer = o, !0);
  }, t.postStep = function() {
    var e = cc._renderContext;
    e.bindBuffer(e.ARRAY_BUFFER, this._buffersVBO[0]), e.bufferSubData(e.ARRAY_BUFFER, 0, this._quadsArrayBuffer);
  }, t._setBlendAdditive = function() {
    var e = (this || window)._node._blendFunc;
    this._texture && !this._texture.hasPremultipliedAlpha() ? (e.src = cc.SRC_ALPHA, e.dst = cc.ONE_MINUS_SRC_ALPHA) : (e.src = cc.BLEND_SRC, e.dst = cc.BLEND_DST);
  }, t._initWithTotalParticles = function(e) {
    if (!this._allocMemory())
      return !1;
    this.initIndices(e), this._setupVBO(), this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
  }, t._updateDeltaColor = function(e, n) {
    e.color.r += e.deltaColor.r * n, e.color.g += e.deltaColor.g * n, e.color.b += e.deltaColor.b * n, e.color.a += e.deltaColor.a * n, e.isChangeColor = !0;
  };
})();
cc.IMEKeyboardNotificationInfo = function(t, e, n) {
  this.begin = t || cc.rect(0, 0, 0, 0), this.end = e || cc.rect(0, 0, 0, 0), this.duration = n || 0;
};
cc.IMEDelegate = cc.Class.extend({
  ctor: function() {
    cc.imeDispatcher.addDelegate(this);
  },
  removeDelegate: function() {
    cc.imeDispatcher.removeDelegate(this);
  },
  attachWithIME: function() {
    return cc.imeDispatcher.attachDelegateWithIME(this);
  },
  detachWithIME: function() {
    return cc.imeDispatcher.detachDelegateWithIME(this);
  },
  canAttachWithIME: function() {
    return !1;
  },
  didAttachWithIME: function() {
  },
  canDetachWithIME: function() {
    return !1;
  },
  didDetachWithIME: function() {
  },
  insertText: function(t, e) {
  },
  deleteBackward: function() {
  },
  getContentText: function() {
    return "";
  },
  keyboardWillShow: function(t) {
  },
  keyboardDidShow: function(t) {
  },
  keyboardWillHide: function(t) {
  },
  keyboardDidHide: function(t) {
  }
});
cc.IMEDispatcher = cc.Class.extend({
  _domInputControl: null,
  impl: null,
  _currentInputString: "",
  _lastClickPosition: null,
  ctor: function() {
    this.impl = new cc.IMEDispatcher.Impl(), this._lastClickPosition = cc.p(0, 0);
  },
  init: function() {
    if (!cc.sys.isMobile) {
      this._domInputControl = cc.$("#imeDispatcherInput"), this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0, 0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
      var t = (this || window);
      this._domInputControl.addEventListener("input", function() {
        t._processDomInputString(t._domInputControl.value);
      }, !1), this._domInputControl.addEventListener("keydown", function(e) {
        e.keyCode === cc.KEY.tab ? (e.stopPropagation(), e.preventDefault()) : e.keyCode === cc.KEY.enter && (t.dispatchInsertText(`
`, 1), e.stopPropagation(), e.preventDefault());
      }, !1), /msie/i.test(navigator.userAgent) && this._domInputControl.addEventListener("keyup", function(e) {
        e.keyCode === cc.KEY.backspace && t._processDomInputString(t._domInputControl.value);
      }, !1), window.addEventListener("mousedown", function(e) {
        var n = e.pageX || 0, r = e.pageY || 0;
        t._lastClickPosition.x = n, t._lastClickPosition.y = r;
      }, !1);
    }
  },
  _processDomInputString: function(t) {
    var e, n, r = (this || window)._currentInputString.length < t.length ? this._currentInputString.length : t.length;
    for (n = 0; n < r && t[n] === (this || window)._currentInputString[n]; n++)
      ;
    var s = (this || window)._currentInputString.length - n, o = t.length - n;
    for (e = 0; e < s; e++)
      this.dispatchDeleteBackward();
    for (e = 0; e < o; e++)
      this.dispatchInsertText(t[n + e], 1);
    this._currentInputString = t;
  },
  dispatchInsertText: function(t, e) {
    !this.impl || !t || e <= 0 || this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(t, e);
  },
  dispatchDeleteBackward: function() {
    this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward();
  },
  getContentText: function() {
    if (this.impl && this.impl._delegateWithIme) {
      var t = (this || window).impl._delegateWithIme.getContentText();
      return t || "";
    }
    return "";
  },
  dispatchKeyboardWillShow: function(t) {
    if (this.impl)
      for (var e = 0; e < this.impl._delegateList.length; e++) {
        var n = (this || window).impl._delegateList[e];
        n && n.keyboardWillShow(t);
      }
  },
  dispatchKeyboardDidShow: function(t) {
    if (this.impl)
      for (var e = 0; e < this.impl._delegateList.length; e++) {
        var n = (this || window).impl._delegateList[e];
        n && n.keyboardDidShow(t);
      }
  },
  dispatchKeyboardWillHide: function(t) {
    if (this.impl)
      for (var e = 0; e < this.impl._delegateList.length; e++) {
        var n = (this || window).impl._delegateList[e];
        n && n.keyboardWillHide(t);
      }
  },
  dispatchKeyboardDidHide: function(t) {
    if (this.impl)
      for (var e = 0; e < this.impl._delegateList.length; e++) {
        var n = (this || window).impl._delegateList[e];
        n && n.keyboardDidHide(t);
      }
  },
  addDelegate: function(t) {
    !t || !this.impl || this.impl._delegateList.indexOf(t) > -1 || this.impl._delegateList.splice(0, 0, t);
  },
  attachDelegateWithIME: function(t) {
    if (!this.impl || !t || this.impl._delegateList.indexOf(t) === -1)
      return !1;
    if (this.impl._delegateWithIme) {
      if (!this.impl._delegateWithIme.canDetachWithIME() || !t.canAttachWithIME())
        return !1;
      var e = (this || window).impl._delegateWithIme;
      return this.impl._delegateWithIme = null, e.didDetachWithIME(), this._focusDomInput(t), !0;
    }
    return t.canAttachWithIME() ? (this._focusDomInput(t), !0) : !1;
  },
  _focusDomInput: function(t) {
    if (cc.sys.isMobile) {
      this.impl._delegateWithIme = t, t.didAttachWithIME(), this._currentInputString = t.string || "";
      var e = t.getTipMessage ? t.getTipMessage() : "please enter your word:", n, r = window.Window;
      r && r.prototype.prompt && r.prototype.prompt != prompt ? n = r.prototype.prompt.call(window, e, this._currentInputString) : n = prompt(e, this._currentInputString), n != null && this._processDomInputString(n), this.dispatchInsertText(`
`, 1);
    } else
      this.impl._delegateWithIme = t, this._currentInputString = t.string || "", t.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = (this || window)._currentInputString, this._domInputControlTranslate();
  },
  _domInputControlTranslate: function() {
    /msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = (this || window)._lastClickPosition.x + "px", this._domInputControl.style.top = (this || window)._lastClickPosition.y + "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y);
  },
  detachDelegateWithIME: function(t) {
    return !this.impl || !t || this.impl._delegateWithIme !== t || !t.canDetachWithIME() ? !1 : (this.impl._delegateWithIme = null, t.didDetachWithIME(), cc._canvas.focus(), !0);
  },
  removeDelegate: function(t) {
    !this.impl || !t || this.impl._delegateList.indexOf(t) !== -1 && (this.impl._delegateWithIme && t === (this || window).impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList, t));
  },
  processKeycode: function(t) {
    t < 32 ? t === cc.KEY.backspace ? this.dispatchDeleteBackward() : t === cc.KEY.enter ? this.dispatchInsertText(`
`, 1) : t === cc.KEY.tab || cc.KEY.escape : t < 255 && this.dispatchInsertText(String.fromCharCode(t), 1);
  }
});
cc.IMEDispatcher.Impl = cc.Class.extend({
  _delegateWithIme: null,
  _delegateList: null,
  ctor: function() {
    this._delegateList = [];
  },
  findDelegate: function(t) {
    for (var e = 0; e < this._delegateList.length; e++)
      if (this._delegateList[e] === t)
        return e;
    return null;
  }
});
cc.imeDispatcher = new cc.IMEDispatcher();
document.body ? cc.imeDispatcher.init() : window.addEventListener("load", function() {
  cc.imeDispatcher.init();
}, !1);
cc.TextFieldDelegate = cc.Class.extend({
  onTextFieldAttachWithIME: function(t) {
    return !1;
  },
  onTextFieldDetachWithIME: function(t) {
    return !1;
  },
  onTextFieldInsertText: function(t, e, n) {
    return !1;
  },
  onTextFieldDeleteBackward: function(t, e, n) {
    return !1;
  },
  onDraw: function(t) {
    return !1;
  }
});
cc.TextFieldTTF = cc.LabelTTF.extend({
  delegate: null,
  colorSpaceHolder: null,
  _colorText: null,
  _lens: null,
  _inputText: "",
  _placeHolder: "",
  _charCount: 0,
  _className: "TextFieldTTF",
  ctor: function(t, e, n, r, s) {
    this.colorSpaceHolder = cc.color(127, 127, 127), this._colorText = cc.color(255, 255, 255, 255), cc.LabelTTF.prototype.ctor.call(this), s !== void 0 ? (this.initWithPlaceHolder("", e, n, r, s), t && this.setPlaceHolder(t)) : r === void 0 && n !== void 0 && (this.initWithString("", arguments[1], arguments[2]), t && this.setPlaceHolder(t));
  },
  onEnter: function() {
    cc.LabelTTF.prototype.onEnter.call(this), cc.imeDispatcher.addDelegate(this);
  },
  onExit: function() {
    cc.LabelTTF.prototype.onExit.call(this), cc.imeDispatcher.removeDelegate(this);
  },
  getDelegate: function() {
    return this.delegate;
  },
  setDelegate: function(t) {
    this.delegate = t;
  },
  getCharCount: function() {
    return this._charCount;
  },
  getColorSpaceHolder: function() {
    return cc.color(this.colorSpaceHolder);
  },
  setColorSpaceHolder: function(t) {
    this.colorSpaceHolder.r = t.r, this.colorSpaceHolder.g = t.g, this.colorSpaceHolder.b = t.b, this.colorSpaceHolder.a = cc.isUndefined(t.a) ? 255 : t.a, this._inputText.length || this.setColor(this.colorSpaceHolder);
  },
  setTextColor: function(t) {
    this._colorText.r = t.r, this._colorText.g = t.g, this._colorText.b = t.b, this._colorText.a = cc.isUndefined(t.a) ? 255 : t.a, this._inputText.length && this.setColor(this._colorText);
  },
  initWithPlaceHolder: function(t, e, n, r, s) {
    switch (arguments.length) {
      case 5:
        return t && this.setPlaceHolder(t), this.initWithString(this._placeHolder, r, s, e, n);
      case 3:
        return t && this.setPlaceHolder(t), this.initWithString(this._placeHolder, arguments[1], arguments[2]);
      default:
        throw new Error("Argument must be non-nil ");
    }
  },
  setString: function(t) {
    t = String(t), this._inputText = t || "", this._inputText.length ? (cc.LabelTTF.prototype.setString.call(this, this._inputText), this.setColor(this._colorText)) : (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder)), cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._renderCmd._updateTexture(), this._charCount = (this || window)._inputText.length;
  },
  getString: function() {
    return this._inputText;
  },
  setPlaceHolder: function(t) {
    this._placeHolder = t || "", this._inputText.length || (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder));
  },
  getPlaceHolder: function() {
    return this._placeHolder;
  },
  draw: function(t) {
    var e = t || cc._renderContext;
    this.delegate && this.delegate.onDraw(this) || cc.LabelTTF.prototype.draw.call(this, e);
  },
  visit: function(t) {
    this._super(t);
  },
  attachWithIME: function() {
    return cc.imeDispatcher.attachDelegateWithIME(this);
  },
  detachWithIME: function() {
    return cc.imeDispatcher.detachDelegateWithIME(this);
  },
  canAttachWithIME: function() {
    return this.delegate ? !this.delegate.onTextFieldAttachWithIME(this) : !0;
  },
  didAttachWithIME: function() {
  },
  canDetachWithIME: function() {
    return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0;
  },
  didDetachWithIME: function() {
  },
  deleteBackward: function() {
    var t = (this || window)._inputText.length;
    if (t !== 0) {
      var e = 1;
      if (!(this.delegate && this.delegate.onTextFieldDeleteBackward(this, this._inputText[t - e], e))) {
        if (t <= e) {
          this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder);
          return;
        }
        this.string = (this || window)._inputText.substring(0, t - e);
      }
    }
  },
  removeDelegate: function() {
    cc.imeDispatcher.removeDelegate(this);
  },
  _tipMessage: "please enter your word:",
  setTipMessage: function(t) {
    t != null && (this._tipMessage = t);
  },
  getTipMessage: function() {
    return this._tipMessage;
  },
  insertText: function(t, e) {
    var n = t, r = n.indexOf(`
`);
    if (r > -1 && (n = n.substring(0, r)), n.length > 0) {
      if (this.delegate && this.delegate.onTextFieldInsertText(this, n, n.length))
        return;
      var s = (this || window)._inputText + n;
      this._charCount = s.length, this.string = s;
    }
    r !== -1 && (this.delegate && this.delegate.onTextFieldInsertText(this, `
`, 1) || this.detachWithIME());
  },
  getContentText: function() {
    return this._inputText;
  },
  keyboardWillShow: function(t) {
  },
  keyboardDidShow: function(t) {
  },
  keyboardWillHide: function(t) {
  },
  keyboardDidHide: function(t) {
  }
});
var _p = cc.TextFieldTTF.prototype;
_p.charCount;
cc.defineGetterSetter(_p, "charCount", _p.getCharCount);
_p.placeHolder;
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.TextFieldTTF.create = function(t, e, n, r, s) {
  return new cc.TextFieldTTF(t, e, n, r, s);
};
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function(t, e, n, r, s, o, a) {
  this.status = t || 0, this.type = e || 0, this.pixelDepth = n || 0, this.width = r || 0, this.height = s || 0, this.imageData = o || [], this.flipped = a || 0;
};
cc.tgaLoadHeader = function(t, e, n) {
  var r = 2;
  if (r + 1 > e)
    return !1;
  var s = new cc.BinaryStreamReader(t);
  if (s.setOffset(r), n.type = s.readByte(), r += 10, r + 4 + 1 > e || (s.setOffset(r), n.width = s.readUnsignedShort(), n.height = s.readUnsignedInteger(), n.pixelDepth = s.readByte(), r += 5, r + 1 > e))
    return !1;
  var o = s.readByte();
  return n.flipped = 0, o & 32 && (n.flipped = 1), !0;
};
cc.tgaLoadImageData = function(t, e, n) {
  var r, s, o, a, c = 18;
  if (r = 0 | n.pixelDepth / 2, s = n.height * n.width * r, c + s > e)
    return !1;
  if (n.imageData = cc.__getSubArray(t, c, c + s), r >= 3)
    for (o = 0; o < s; o += r)
      a = n.imageData[o], n.imageData[o] = n.imageData[o + 2], n.imageData[o + 2] = a;
  return !0;
};
cc.tgaRGBtogreyscale = function(t) {
  var e, n;
  if (t.pixelDepth !== 8) {
    var r = t.pixelDepth / 8, s = new Uint8Array(t.height * t.width);
    if (s !== null) {
      for (e = 0, n = 0; n < t.width * t.height; e += r, n++)
        s[n] = 0.3 * t.imageData[e] + 0.59 * t.imageData[e + 1] + 0.11 * t.imageData[e + 2];
      t.pixelDepth = 8, t.type = 3, t.imageData = s;
    }
  }
};
cc.tgaDestroy = function(t) {
  t && (t.imageData = null, t = null);
};
cc.tgaLoadRLEImageData = function(t, e, n) {
  var r, s, o, a = 0, c = 0, l = 0, h = [], u = 0, _ = 18;
  for (r = n.pixelDepth / 8, s = n.height * n.width, o = 0; o < s; o++) {
    if (u !== 0)
      u--, c = l !== 0;
    else {
      if (_ + 1 > e)
        break;
      u = t[_], _ += 1, l = u & 128, l && (u -= 128), c = 0;
    }
    if (!c) {
      if (_ + r > e)
        break;
      if (h = cc.__getSubArray(t, _, _ + r), _ += r, r >= 3) {
        var d = h[0];
        h[0] = h[2], h[2] = d;
      }
    }
    for (var f = 0; f < r; f++)
      n.imageData[a + f] = h[f];
    a += r;
  }
  return !0;
};
cc.tgaFlipImage = function(t) {
  for (var e = t.pixelDepth / 8, n = t.width * e, r = 0; r < t.height / 2; r++) {
    var s = cc.__getSubArray(t.imageData, r * n, r * n + n);
    cc.__setDataToArray(cc.__getSubArray(t.imageData, (t.height - (r + 1)) * n, n), t.imageData, r * n), cc.__setDataToArray(s, t.imageData, (t.height - (r + 1)) * n);
  }
  t.flipped = 0;
};
cc.__getSubArray = function(t, e, n) {
  return t instanceof Array ? t.slice(e, n) : t.subarray(e, n);
};
cc.__setDataToArray = function(t, e, n) {
  for (var r = 0; r < t.length; r++)
    e[n + r] = t[r];
};
cc.BinaryStreamReader = cc.Class.extend({
  _binaryData: null,
  _offset: 0,
  ctor: function(t) {
    this._binaryData = t;
  },
  setBinaryData: function(t) {
    this._binaryData = t, this._offset = 0;
  },
  getBinaryData: function() {
    return this._binaryData;
  },
  _checkSize: function(t) {
    if (!(this._offset + Math.ceil(t / 8) < this._data.length))
      throw new Error("Index out of bound");
  },
  _decodeFloat: function(t, e) {
    var n = t + e + 1, r = n >> 3;
    this._checkSize(n);
    var s = Math.pow(2, e - 1) - 1, o = (this || window)._readBits(t + e, 1, r), a = (this || window)._readBits(t, e, r), c = 0, l = 2, h = 0;
    do
      for (var u = (this || window)._readByte(++h, r), _ = t % 8 || 8, d = 1 << _; d >>= 1; )
        u & d && (c += 1 / l), l *= 2;
    while (t -= _);
    return this._offset += r, a === (s << 1) + 1 ? c ? NaN : o ? -1 / 0 : 1 / 0 : (1 + o * -2) * (a || c ? a ? Math.pow(2, a - s) * (1 + c) : Math.pow(2, -s + 1) * c : 0);
  },
  _readByte: function(t, e) {
    return this._data[this._offset + e - t - 1];
  },
  _decodeInt: function(t, e) {
    var n = (this || window)._readBits(0, t, t / 8), r = Math.pow(2, t), s = e && n >= r / 2 ? n - r : n;
    return this._offset += t / 8, s;
  },
  _shl: function(t, e) {
    for (++e; --e; t = ((t %= 2147483647 + 1) & 1073741824) === 1073741824 ? t * 2 : (t - 1073741824) * 2 + 2147483647 + 1)
      ;
    return t;
  },
  _readBits: function(t, e, n) {
    var r = (t + e) % 8, s = t % 8, o = n - (t >> 3) - 1, a = n + (-(t + e) >> 3), c = o - a, l = (this || window)._readByte(o, n) >> s & (1 << (c ? 8 - s : e)) - 1;
    for (c && r && (l += (this._readByte(a++, n) & (1 << r) - 1) << (c-- << 3) - s); c; )
      l += (this || window)._shl(this._readByte(a++, n), (c-- << 3) - s);
    return l;
  },
  readInteger: function() {
    return this._decodeInt(32, !0);
  },
  readUnsignedInteger: function() {
    return this._decodeInt(32, !1);
  },
  readSingle: function() {
    return this._decodeFloat(23, 8);
  },
  readShort: function() {
    return this._decodeInt(16, !0);
  },
  readUnsignedShort: function() {
    return this._decodeInt(16, !1);
  },
  readByte: function() {
    var t = (this || window)._data[this._offset];
    return this._offset += 1, t;
  },
  readData: function(t, e) {
    return this._binaryData instanceof Array ? this._binaryData.slice(t, e) : this._binaryData.subarray(t, e);
  },
  setOffset: function(t) {
    this._offset = t;
  },
  getOffset: function() {
    return this._offset;
  }
});
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.Node.extend({
  properties: null,
  mapOrientation: null,
  objectGroups: null,
  _mapSize: null,
  _tileSize: null,
  _tileProperties: null,
  _className: "TMXTiledMap",
  ctor: function(t, e) {
    cc.Node.prototype.ctor.call(this), this._mapSize = cc.size(0, 0), this._tileSize = cc.size(0, 0), e !== void 0 ? this.initWithXML(t, e) : t !== void 0 && this.initWithTMXFile(t);
  },
  getMapSize: function() {
    return cc.size(this._mapSize.width, this._mapSize.height);
  },
  setMapSize: function(t) {
    this._mapSize.width = t.width, this._mapSize.height = t.height;
  },
  _getMapWidth: function() {
    return this._mapSize.width;
  },
  _setMapWidth: function(t) {
    this._mapSize.width = t;
  },
  _getMapHeight: function() {
    return this._mapSize.height;
  },
  _setMapHeight: function(t) {
    this._mapSize.height = t;
  },
  getTileSize: function() {
    return cc.size(this._tileSize.width, this._tileSize.height);
  },
  setTileSize: function(t) {
    this._tileSize.width = t.width, this._tileSize.height = t.height;
  },
  _getTileWidth: function() {
    return this._tileSize.width;
  },
  _setTileWidth: function(t) {
    this._tileSize.width = t;
  },
  _getTileHeight: function() {
    return this._tileSize.height;
  },
  _setTileHeight: function(t) {
    this._tileSize.height = t;
  },
  getMapOrientation: function() {
    return this.mapOrientation;
  },
  setMapOrientation: function(t) {
    this.mapOrientation = t;
  },
  getObjectGroups: function() {
    return this.objectGroups;
  },
  setObjectGroups: function(t) {
    this.objectGroups = t;
  },
  getProperties: function() {
    return this.properties;
  },
  setProperties: function(t) {
    this.properties = t;
  },
  initWithTMXFile: function(t) {
    if (!t || t.length === 0)
      throw new Error("cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.");
    this.width = 0, this.height = 0;
    var e = new cc.TMXMapInfo(t);
    if (!e)
      return !1;
    var n = e.getTilesets();
    return (!n || n.length === 0) && cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename."), this._buildWithMapInfo(e), !0;
  },
  initWithXML: function(t, e) {
    this.width = 0, this.height = 0;
    var n = new cc.TMXMapInfo(t, e), r = n.getTilesets();
    return (!r || r.length === 0) && cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename."), this._buildWithMapInfo(n), !0;
  },
  _buildWithMapInfo: function(t) {
    this._mapSize = t.getMapSize(), this._tileSize = t.getTileSize(), this.mapOrientation = t.orientation, this.objectGroups = t.getObjectGroups(), this.properties = t.properties, this._tileProperties = t.getTileProperties();
    var e = 0, n = t.getLayers();
    if (n) {
      for (var r = null, s = 0, o = n.length; s < o; s++)
        if (r = n[s], r && r.visible) {
          var a = (this || window)._parseLayer(r, t);
          this.addChild(a, e, e), this.width = Math.max(this.width, a.width), this.height = Math.max(this.height, a.height), e++;
        }
    }
  },
  allLayers: function() {
    for (var t = [], e = (this || window)._children, n = 0, r = e.length; n < r; n++) {
      var s = e[n];
      s && s instanceof cc.TMXLayer && t.push(s);
    }
    return t;
  },
  getLayer: function(t) {
    if (!t || t.length === 0)
      throw new Error("cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.");
    for (var e = (this || window)._children, n = 0; n < e.length; n++) {
      var r = e[n];
      if (r && r.layerName === t)
        return r;
    }
    return null;
  },
  getObjectGroup: function(t) {
    if (!t || t.length === 0)
      throw new Error("cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.");
    if (this.objectGroups)
      for (var e = 0; e < this.objectGroups.length; e++) {
        var n = (this || window).objectGroups[e];
        if (n && n.groupName === t)
          return n;
      }
    return null;
  },
  getProperty: function(t) {
    return this.properties[t.toString()];
  },
  propertiesForGID: function(t) {
    return cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead."), this.getPropertiesForGID[t];
  },
  getPropertiesForGID: function(t) {
    return this._tileProperties[t];
  },
  _parseLayer: function(t, e) {
    var n = (this || window)._tilesetForLayer(t, e), r = new cc.TMXLayer(n, t, e);
    return t.ownTiles = !1, r;
  },
  _tilesetForLayer: function(t, e) {
    var n = t._layerSize, r = e.getTilesets();
    if (r)
      for (var s = r.length - 1; s >= 0; s--) {
        var o = r[s];
        if (o)
          for (var a = 0; a < n.height; a++)
            for (var c = 0; c < n.width; c++) {
              var l = c + n.width * a, h = t._tiles[l];
              if (h !== 0 && (h & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= o.firstGid)
                return o;
            }
      }
    return cc.log("cocos2d: Warning: TMX Layer " + t.name + " has no tiles"), null;
  }
});
var _p = cc.TMXTiledMap.prototype;
_p.mapWidth;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
_p.mapHeight;
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
_p.tileWidth;
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
_p.tileHeight;
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXTiledMap.create = function(t, e) {
  return new cc.TMXTiledMap(t, e);
};
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({
  properties: null,
  name: "",
  _layerSize: null,
  _tiles: null,
  visible: null,
  _opacity: null,
  ownTiles: !0,
  _minGID: 1e5,
  _maxGID: 0,
  offset: null,
  ctor: function() {
    this.properties = [], this.name = "", this._layerSize = null, this._tiles = null, this.visible = !0, this._opacity = 0, this.ownTiles = !0, this._minGID = 1e5, this._maxGID = 0, this.offset = cc.p(0, 0);
  },
  getProperties: function() {
    return this.properties;
  },
  setProperties: function(t) {
    this.properties = t;
  }
});
cc.TMXTilesetInfo = cc.Class.extend({
  name: "",
  firstGid: 0,
  _tileSize: null,
  spacing: 0,
  margin: 0,
  sourceImage: "",
  imageSize: null,
  ctor: function() {
    this._tileSize = cc.size(0, 0), this.imageSize = cc.size(0, 0);
  },
  rectForGID: function(t, e) {
    var n = e || cc.rect(0, 0, 0, 0);
    n.width = (this || window)._tileSize.width, n.height = (this || window)._tileSize.height, t &= cc.TMX_TILE_FLIPPED_MASK, t = t - parseInt(this.firstGid, 10);
    var r = parseInt((this.imageSize.width - this.margin * 2 + this.spacing) / (this._tileSize.width + this.spacing), 10);
    return n.x = parseInt(t % r * (this._tileSize.width + this.spacing) + this.margin, 10), n.y = parseInt(parseInt(t / r, 10) * (this._tileSize.height + this.spacing) + this.margin, 10), n;
  }
});
cc.TMXMapInfo = cc.SAXParser.extend({
  properties: null,
  orientation: null,
  parentElement: null,
  parentGID: null,
  layerAttrs: 0,
  storingCharacters: !1,
  tmxFileName: null,
  currentString: null,
  _objectGroups: null,
  _mapSize: null,
  _tileSize: null,
  _layers: null,
  _tilesets: null,
  _tileProperties: null,
  _resources: "",
  _currentFirstGID: 0,
  ctor: function(t, e) {
    cc.SAXParser.prototype.ctor.apply(this), this._mapSize = cc.size(0, 0), this._tileSize = cc.size(0, 0), this._layers = [], this._tilesets = [], this._objectGroups = [], this.properties = [], this._tileProperties = {}, this._currentFirstGID = 0, e !== void 0 ? this.initWithXML(t, e) : t !== void 0 && this.initWithTMXFile(t);
  },
  getOrientation: function() {
    return this.orientation;
  },
  setOrientation: function(t) {
    this.orientation = t;
  },
  getMapSize: function() {
    return cc.size(this._mapSize.width, this._mapSize.height);
  },
  setMapSize: function(t) {
    this._mapSize.width = t.width, this._mapSize.height = t.height;
  },
  _getMapWidth: function() {
    return this._mapSize.width;
  },
  _setMapWidth: function(t) {
    this._mapSize.width = t;
  },
  _getMapHeight: function() {
    return this._mapSize.height;
  },
  _setMapHeight: function(t) {
    this._mapSize.height = t;
  },
  getTileSize: function() {
    return cc.size(this._tileSize.width, this._tileSize.height);
  },
  setTileSize: function(t) {
    this._tileSize.width = t.width, this._tileSize.height = t.height;
  },
  _getTileWidth: function() {
    return this._tileSize.width;
  },
  _setTileWidth: function(t) {
    this._tileSize.width = t;
  },
  _getTileHeight: function() {
    return this._tileSize.height;
  },
  _setTileHeight: function(t) {
    this._tileSize.height = t;
  },
  getLayers: function() {
    return this._layers;
  },
  setLayers: function(t) {
    this._layers.push(t);
  },
  getTilesets: function() {
    return this._tilesets;
  },
  setTilesets: function(t) {
    this._tilesets.push(t);
  },
  getObjectGroups: function() {
    return this._objectGroups;
  },
  setObjectGroups: function(t) {
    this._objectGroups.push(t);
  },
  getParentElement: function() {
    return this.parentElement;
  },
  setParentElement: function(t) {
    this.parentElement = t;
  },
  getParentGID: function() {
    return this.parentGID;
  },
  setParentGID: function(t) {
    this.parentGID = t;
  },
  getLayerAttribs: function() {
    return this.layerAttrs;
  },
  setLayerAttribs: function(t) {
    this.layerAttrs = t;
  },
  getStoringCharacters: function() {
    return this.storingCharacters;
  },
  setStoringCharacters: function(t) {
    this.storingCharacters = t;
  },
  getProperties: function() {
    return this.properties;
  },
  setProperties: function(t) {
    this.properties = t;
  },
  initWithTMXFile: function(t) {
    return this._internalInit(t, null), this.parseXMLFile(t);
  },
  initWithXML: function(t, e) {
    return this._internalInit(null, e), this.parseXMLString(t);
  },
  parseXMLFile: function(t, e) {
    e = e || !1;
    var n = e ? t : cc.loader.getRes(t);
    if (!n)
      throw new Error("Please load the resource first : " + t);
    var r = (this || window)._parseXML(n), s, o, a = r.documentElement, c = a.getAttribute("version"), l = a.getAttribute("orientation");
    if (a.nodeName === "map") {
      c !== "1.0" && c !== null && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + c), l === "orthogonal" ? this.orientation = cc.TMX_ORIENTATION_ORTHO : l === "isometric" ? this.orientation = cc.TMX_ORIENTATION_ISO : l === "hexagonal" ? this.orientation = cc.TMX_ORIENTATION_HEX : l !== null && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + l);
      var h = cc.size(0, 0);
      h.width = parseFloat(a.getAttribute("width")), h.height = parseFloat(a.getAttribute("height")), this.setMapSize(h), h = cc.size(0, 0), h.width = parseFloat(a.getAttribute("tilewidth")), h.height = parseFloat(a.getAttribute("tileheight")), this.setTileSize(h);
      var u = a.querySelectorAll("map > properties >  property");
      if (u) {
        var _ = {};
        for (s = 0; s < u.length; s++)
          _[u[s].getAttribute("name")] = u[s].getAttribute("value");
        this.properties = _;
      }
    }
    var d = a.getElementsByTagName("tileset");
    for (a.nodeName !== "map" && (d = [], d.push(a)), s = 0; s < d.length; s++) {
      var f = d[s], C = f.getAttribute("source");
      if (C) {
        var m = e ? cc.path.join(this._resources, C) : cc.path.changeBasename(t, C);
        this.parseXMLFile(m);
      } else {
        var g = new cc.TMXTilesetInfo();
        g.name = f.getAttribute("name") || "", g.firstGid = parseInt(f.getAttribute("firstgid")) || 0, g.spacing = parseInt(f.getAttribute("spacing")) || 0, g.margin = parseInt(f.getAttribute("margin")) || 0;
        var y = cc.size(0, 0);
        y.width = parseFloat(f.getAttribute("tilewidth")), y.height = parseFloat(f.getAttribute("tileheight")), g._tileSize = y;
        var A = f.getElementsByTagName("image")[0], D = A.getAttribute("source"), N = -1;
        if (this.tmxFileName && (N = (this || window).tmxFileName.lastIndexOf("/")), N !== -1) {
          var z = (this || window).tmxFileName.substr(0, N + 1);
          g.sourceImage = z + D;
        } else
          g.sourceImage = (this || window)._resources + (this._resources ? "/" : "") + D;
        this.setTilesets(g);
        var M = f.getElementsByTagName("tile");
        if (M)
          for (var Z = 0; Z < M.length; Z++) {
            var U = M[Z];
            this.parentGID = parseInt(g.firstGid) + parseInt(U.getAttribute("id") || 0);
            var Q = U.querySelectorAll("properties > property");
            if (Q) {
              var et = {};
              for (o = 0; o < Q.length; o++) {
                var rt = Q[o].getAttribute("name");
                et[rt] = Q[o].getAttribute("value");
              }
              this._tileProperties[this.parentGID] = et;
            }
          }
      }
    }
    var w = a.getElementsByTagName("layer");
    if (w)
      for (s = 0; s < w.length; s++) {
        var L = w[s], G = L.getElementsByTagName("data")[0], I = new cc.TMXLayerInfo();
        I.name = L.getAttribute("name");
        var O = cc.size(0, 0);
        O.width = parseFloat(L.getAttribute("width")), O.height = parseFloat(L.getAttribute("height")), I._layerSize = O;
        var K = L.getAttribute("visible");
        I.visible = K != "0";
        var $ = L.getAttribute("opacity") || 1;
        $ ? I._opacity = parseInt(255 * parseFloat($)) : I._opacity = 255, I.offset = cc.p(parseFloat(L.getAttribute("x")) || 0, parseFloat(L.getAttribute("y")) || 0);
        var S = "";
        for (o = 0; o < G.childNodes.length; o++)
          S += G.childNodes[o].nodeValue;
        S = S.trim();
        var b = G.getAttribute("compression"), W = G.getAttribute("encoding");
        if (b && b !== "gzip" && b !== "zlib")
          return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
        var M;
        switch (b) {
          case "gzip":
            M = cc.unzipBase64AsArray(S, 4);
            break;
          case "zlib":
            var x = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(S, 1));
            M = cc.uint8ArrayToUint32Array(x.decompress());
            break;
          case null:
          case "":
            if (W === "base64")
              M = cc.Codec.Base64.decodeAsArray(S, 4);
            else if (W === "csv") {
              M = [];
              for (var E = S.split(","), R = 0; R < E.length; R++)
                M.push(parseInt(E[R]));
            } else {
              var F = G.getElementsByTagName("tile");
              M = [];
              for (var k = 0; k < F.length; k++)
                M.push(parseInt(F[k].getAttribute("gid")));
            }
            break;
          default:
            this.layerAttrs === cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported");
            break;
        }
        M && (I._tiles = new Uint32Array(M));
        var X = L.querySelectorAll("properties > property");
        if (X) {
          var j = {};
          for (o = 0; o < X.length; o++)
            j[X[o].getAttribute("name")] = X[o].getAttribute("value");
          I.properties = j;
        }
        this.setLayers(I);
      }
    var V = a.getElementsByTagName("objectgroup");
    if (V)
      for (s = 0; s < V.length; s++) {
        var Y = V[s], tt = new cc.TMXObjectGroup();
        tt.groupName = Y.getAttribute("name"), tt.setPositionOffset(cc.p(
          parseFloat(Y.getAttribute("x")) * this.getTileSize().width || 0,
          parseFloat(Y.getAttribute("y")) * this.getTileSize().height || 0
        ));
        var it = Y.querySelectorAll("objectgroup > properties > property");
        if (it)
          for (o = 0; o < it.length; o++) {
            var lt = {};
            lt[it[o].getAttribute("name")] = it[o].getAttribute("value"), tt.properties = lt;
          }
        var ut = Y.querySelectorAll("object"), ft = cc.director.getContentScaleFactor();
        if (ut)
          for (o = 0; o < ut.length; o++) {
            var vt = ut[o], pt = {};
            pt.name = vt.getAttribute("name") || "", pt.type = vt.getAttribute("type") || "", pt.width = parseInt(vt.getAttribute("width")) || 0, pt.height = parseInt(vt.getAttribute("height")) || 0, pt.x = (((vt.getAttribute("x") || 0) | 0) + tt.getPositionOffset().x) / ft;
            var gt = ((vt.getAttribute("y") || 0) | 0) + tt.getPositionOffset().y / ft;
            pt.y = (parseInt(this.getMapSize().height * this.getTileSize().height) - gt - pt.height) / cc.director.getContentScaleFactor(), pt.rotation = parseInt(vt.getAttribute("rotation")) || 0;
            var St = vt.querySelectorAll("properties > property");
            if (St)
              for (var ht = 0; ht < St.length; ht++)
                pt[St[ht].getAttribute("name")] = St[ht].getAttribute("value");
            var ct = vt.querySelectorAll("polygon");
            if (ct && ct.length > 0) {
              var bt = ct[0].getAttribute("points");
              bt && (pt.points = (this || window)._parsePointsString(bt));
            }
            var Et = vt.querySelectorAll("polyline");
            if (Et && Et.length > 0) {
              var wt = Et[0].getAttribute("points");
              wt && (pt.polylinePoints = (this || window)._parsePointsString(wt));
            }
            tt.setObjects(pt);
          }
        this.setObjectGroups(tt);
      }
    return a;
  },
  _parsePointsString: function(t) {
    if (!t)
      return null;
    for (var e = [], n = t.split(" "), r = 0; r < n.length; r++) {
      var s = n[r].split(",");
      e.push({ x: s[0], y: s[1] });
    }
    return e;
  },
  parseXMLString: function(t) {
    return this.parseXMLFile(t, !0);
  },
  getTileProperties: function() {
    return this._tileProperties;
  },
  setTileProperties: function(t) {
    this._tileProperties.push(t);
  },
  getCurrentString: function() {
    return this.currentString;
  },
  setCurrentString: function(t) {
    this.currentString = t;
  },
  getTMXFileName: function() {
    return this.tmxFileName;
  },
  setTMXFileName: function(t) {
    this.tmxFileName = t;
  },
  _internalInit: function(t, e) {
    this._tilesets.length = 0, this._layers.length = 0, this.tmxFileName = t, e && (this._resources = e), this._objectGroups.length = 0, this.properties.length = 0, this._tileProperties.length = 0, this.currentString = "", this.storingCharacters = !1, this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE, this.parentElement = cc.TMX_PROPERTY_NONE, this._currentFirstGID = 0;
  }
});
var _p = cc.TMXMapInfo.prototype;
_p.mapWidth;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
_p.mapHeight;
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
_p.tileWidth;
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
_p.tileHeight;
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXMapInfo.create = function(t, e) {
  return new cc.TMXMapInfo(t, e);
};
cc.loader.register(["tmx", "tsx"], cc._txtLoader);
cc.TMXLayerInfo.ATTRIB_NONE = 1;
cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
cc.TMXLayerInfo.ATTRIB_GZIP = 4;
cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
cc.TMXObjectGroup = cc.Class.extend({
  properties: null,
  groupName: "",
  _positionOffset: null,
  _objects: null,
  ctor: function() {
    this.groupName = "", this._positionOffset = cc.p(0, 0), this.properties = [], this._objects = [];
  },
  getPositionOffset: function() {
    return cc.p(this._positionOffset);
  },
  setPositionOffset: function(t) {
    this._positionOffset.x = t.x, this._positionOffset.y = t.y;
  },
  getProperties: function() {
    return this.properties;
  },
  setProperties: function(t) {
    this.properties.push(t);
  },
  getGroupName: function() {
    return this.groupName.toString();
  },
  setGroupName: function(t) {
    this.groupName = t;
  },
  propertyNamed: function(t) {
    return this.properties[t];
  },
  objectNamed: function(t) {
    return this.getObject(t);
  },
  getObject: function(t) {
    if (this._objects && this._objects.length > 0)
      for (var e = (this || window)._objects, n = 0, r = e.length; n < r; n++) {
        var s = e[n].name;
        if (s && s === t)
          return e[n];
      }
    return null;
  },
  getObjects: function() {
    return this._objects;
  },
  setObjects: function(t) {
    this._objects.push(t);
  }
});
cc.TMXLayer = cc.SpriteBatchNode.extend({
  tiles: null,
  tileset: null,
  layerOrientation: null,
  properties: null,
  layerName: "",
  _textures: null,
  _texGrids: null,
  _spriteTiles: null,
  _layerSize: null,
  _mapTileSize: null,
  _opacity: 255,
  _minGID: null,
  _maxGID: null,
  _vertexZvalue: null,
  _useAutomaticVertexZ: null,
  _reusedTile: null,
  _atlasIndexArray: null,
  _contentScaleFactor: null,
  _className: "TMXLayer",
  ctor: function(t, e, n) {
    cc.SpriteBatchNode.prototype.ctor.call(this), this._descendants = [], this._layerSize = cc.size(0, 0), this._mapTileSize = cc.size(0, 0), this._spriteTiles = {}, n !== void 0 && this.initWithTilesetInfo(t, e, n);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.TMXLayer.CanvasRenderCmd(this) : new cc.TMXLayer.WebGLRenderCmd(this);
  },
  _fillTextureGrids: function(t, e) {
    var n = (this || window)._textures[e];
    if (!n.isLoaded()) {
      n.addEventListener("load", function() {
        this._fillTextureGrids(t, e);
      }, this);
      return;
    }
    (!t.imageSize.width || !t.imageSize.height) && (t.imageSize.width = n.width, t.imageSize.height = n.height);
    for (var r = t._tileSize.width, s = t._tileSize.height, o = n._contentSize.width, a = n._contentSize.height, c = t.spacing, l = t.margin, h = Math.floor((o - l * 2 + c) / (r + c)), u = Math.floor((a - l * 2 + c) / (s + c)), _ = u * h, d = t.firstGid, f = t.firstGid + _, C = (this || window)._texGrids, m = null, g = !!C[d]; d < f && (g && !C[d] && (g = !1), !(!g && C[d])); ++d)
      m = {
        texId: e,
        x: 0,
        y: 0,
        width: r,
        height: s,
        t: 0,
        l: 0,
        r: 0,
        b: 0
      }, t.rectForGID(d, m), m.t = m.y / a, m.l = m.x / o, m.r = (m.x + m.width) / o, m.b = (m.y + m.height) / a, C[d] = m;
  },
  initWithTilesetInfo: function(t, e, n) {
    var r = e._layerSize;
    parseInt(r.width * r.height), this.layerName = e.name, this.tiles = e._tiles, this.properties = e.properties, this._layerSize = r, this._minGID = e._minGID, this._maxGID = e._maxGID, this._opacity = e._opacity, this.tileset = t, this.layerOrientation = n.orientation, this._mapTileSize = n.getTileSize();
    var s = n._tilesets;
    if (s) {
      this._textures = [], this._texGrids = [];
      var o, a = s.length, c, l;
      for (o = 0; o < a; ++o)
        c = s[o], l = cc.textureCache.addImage(c.sourceImage), this._textures.push(l), this._fillTextureGrids(c, o), c === t && (this._texture = l);
    }
    var h = (this || window)._calculateLayerOffset(e.offset);
    return this.setPosition(cc.pointPixelsToPoints(h)), this._parseInternalProperties(), this.setContentSize(cc.sizePixelsToPoints(cc.size(
      this._layerSize.width * this._mapTileSize.width,
      this._layerSize.height * this._mapTileSize.height
    ))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0;
  },
  getLayerSize: function() {
    return cc.size(this._layerSize.width, this._layerSize.height);
  },
  setLayerSize: function(t) {
    this._layerSize.width = t.width, this._layerSize.height = t.height;
  },
  _getLayerWidth: function() {
    return this._layerSize.width;
  },
  _setLayerWidth: function(t) {
    this._layerSize.width = t;
  },
  _getLayerHeight: function() {
    return this._layerSize.height;
  },
  _setLayerHeight: function(t) {
    this._layerSize.height = t;
  },
  getMapTileSize: function() {
    return cc.size(this._mapTileSize.width, this._mapTileSize.height);
  },
  setMapTileSize: function(t) {
    this._mapTileSize.width = t.width, this._mapTileSize.height = t.height;
  },
  _getTileWidth: function() {
    return this._mapTileSize.width;
  },
  _setTileWidth: function(t) {
    this._mapTileSize.width = t;
  },
  _getTileHeight: function() {
    return this._mapTileSize.height;
  },
  _setTileHeight: function(t) {
    this._mapTileSize.height = t;
  },
  getTiles: function() {
    return this.tiles;
  },
  setTiles: function(t) {
    this.tiles = t;
  },
  getTileset: function() {
    return this.tileset;
  },
  setTileset: function(t) {
    this.tileset = t;
  },
  getLayerOrientation: function() {
    return this.layerOrientation;
  },
  setLayerOrientation: function(t) {
    this.layerOrientation = t;
  },
  getProperties: function() {
    return this.properties;
  },
  setProperties: function(t) {
    this.properties = t;
  },
  getProperty: function(t) {
    return this.properties[t];
  },
  getLayerName: function() {
    return this.layerName;
  },
  setLayerName: function(t) {
    this.layerName = t;
  },
  releaseMap: function() {
    this._spriteTiles = {};
  },
  getTileAt: function(t, e) {
    if (t === void 0)
      throw new Error("cc.TMXLayer.getTileAt(): pos should be non-null");
    var n = t;
    if (e === void 0 && (n = t.x, e = t.y), n >= (this || window)._layerSize.width || e >= (this || window)._layerSize.height || n < 0 || e < 0)
      throw new Error("cc.TMXLayer.getTileAt(): invalid position");
    if (!this.tiles)
      return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
    var r = null, s = (this || window).getTileGIDAt(n, e);
    if (s === 0)
      return r;
    var o = 0 | n + e * this._layerSize.width;
    if (r = (this || window)._spriteTiles[o], !r) {
      var a = (this || window)._texGrids[s], c = (this || window)._textures[a.texId];
      a = cc.rectPixelsToPoints(a), r = new cc.Sprite(c, a), r.setPosition(this.getPositionAt(n, e));
      var l = (this || window)._vertexZForPos(n, e);
      r.setVertexZ(l), r.setAnchorPoint(0, 0), r.setOpacity(this._opacity), this.addChild(r, l, o);
    }
    return r;
  },
  getTileGIDAt: function(t, e) {
    if (t === void 0)
      throw new Error("cc.TMXLayer.getTileGIDAt(): pos should be non-null");
    var n = t;
    if (e === void 0 && (n = t.x, e = t.y), n >= (this || window)._layerSize.width || e >= (this || window)._layerSize.height || n < 0 || e < 0)
      throw new Error("cc.TMXLayer.getTileGIDAt(): invalid position");
    if (!this.tiles)
      return cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null;
    var r = 0 | n + e * this._layerSize.width, s = (this || window).tiles[r];
    return (s & cc.TMX_TILE_FLIPPED_MASK) >>> 0;
  },
  setTileGID: function(t, e, n, r) {
    if (e === void 0)
      throw new Error("cc.TMXLayer.setTileGID(): pos should be non-null");
    var s;
    if (r !== void 0 ? s = cc.p(e, n) : (s = e, r = n), s.x >= (this || window)._layerSize.width || s.y >= (this || window)._layerSize.height || s.x < 0 || s.y < 0)
      throw new Error("cc.TMXLayer.setTileGID(): invalid position");
    if (!this.tiles) {
      cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released");
      return;
    }
    if (t !== 0 && t < this.tileset.firstGid) {
      cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + t);
      return;
    }
    r = r || 0;
    var o = (this || window).getTileFlagsAt(s), a = (this || window).getTileGIDAt(s);
    if (a !== t || o !== r) {
      var c = (t | r) >>> 0;
      if (t === 0)
        this.removeTileAt(s);
      else if (a === 0)
        this._updateTileForGID(c, s);
      else {
        var l = s.x + s.y * this._layerSize.width, h = (this || window).getChildByTag(l);
        if (h) {
          var u = (this || window)._texGrids[t], _ = (this || window)._textures[u.texId];
          u = cc.rectPixelsToPoints(u), h.setTexture(_), h.setTextureRect(u, !1), r != null && this._setupTileSprite(h, s, c), this.tiles[l] = c;
        } else
          this._updateTileForGID(c, s);
      }
    }
  },
  addChild: function(t, e, n) {
    cc.Node.prototype.addChild.call(this, t, e, n), n !== void 0 && (this._spriteTiles[n] = t, t._vertexZ = (this || window)._vertexZ + cc.renderer.assignedZStep * n / this.tiles.length);
  },
  removeChild: function(t, e) {
    this._spriteTiles[t.tag] && (this._spriteTiles[t.tag] = null), cc.Node.prototype.removeChild.call(this, t, e);
  },
  getTileFlagsAt: function(t, e) {
    if (!t)
      throw new Error("cc.TMXLayer.getTileFlagsAt(): pos should be non-null");
    if (e !== void 0 && (t = cc.p(t, e)), t.x >= (this || window)._layerSize.width || t.y >= (this || window)._layerSize.height || t.x < 0 || t.y < 0)
      throw new Error("cc.TMXLayer.getTileFlagsAt(): invalid position");
    if (!this.tiles)
      return cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"), null;
    var n = 0 | t.x + t.y * this._layerSize.width, r = (this || window).tiles[n];
    return (r & cc.TMX_TILE_FLIPPED_ALL) >>> 0;
  },
  removeTileAt: function(t, e) {
    if (!t)
      throw new Error("cc.TMXLayer.removeTileAt(): pos should be non-null");
    if (e !== void 0 && (t = cc.p(t, e)), t.x >= (this || window)._layerSize.width || t.y >= (this || window)._layerSize.height || t.x < 0 || t.y < 0)
      throw new Error("cc.TMXLayer.removeTileAt(): invalid position");
    if (!this.tiles) {
      cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released");
      return;
    }
    var n = (this || window).getTileGIDAt(t);
    if (n !== 0) {
      var r = 0 | t.x + t.y * this._layerSize.width;
      this.tiles[r] = 0;
      var s = (this || window)._spriteTiles[r];
      s && this.removeChild(s, !0);
    }
  },
  getPositionAt: function(t, e) {
    e !== void 0 && (t = cc.p(t, e));
    var n = cc.p(0, 0);
    switch (this.layerOrientation) {
      case cc.TMX_ORIENTATION_ORTHO:
        n = (this || window)._positionForOrthoAt(t);
        break;
      case cc.TMX_ORIENTATION_ISO:
        n = (this || window)._positionForIsoAt(t);
        break;
      case cc.TMX_ORIENTATION_HEX:
        n = (this || window)._positionForHexAt(t);
        break;
    }
    return cc.pointPixelsToPoints(n);
  },
  _positionForIsoAt: function(t) {
    return cc.p(
      this._mapTileSize.width / 2 * (this._layerSize.width + t.x - t.y - 1),
      this._mapTileSize.height / 2 * (this._layerSize.height * 2 - t.x - t.y - 2)
    );
  },
  _positionForOrthoAt: function(t) {
    return cc.p(
      t.x * this._mapTileSize.width,
      (this._layerSize.height - t.y - 1) * this._mapTileSize.height
    );
  },
  _positionForHexAt: function(t) {
    var e = t.x % 2 === 1 ? -this._mapTileSize.height / 2 : 0;
    return cc.p(
      t.x * this._mapTileSize.width * 3 / 4,
      (this._layerSize.height - t.y - 1) * this._mapTileSize.height + e
    );
  },
  _calculateLayerOffset: function(t) {
    var e = cc.p(0, 0);
    switch (this.layerOrientation) {
      case cc.TMX_ORIENTATION_ORTHO:
        e = cc.p(t.x * this._mapTileSize.width, -t.y * this._mapTileSize.height);
        break;
      case cc.TMX_ORIENTATION_ISO:
        e = cc.p(
          this._mapTileSize.width / 2 * (t.x - t.y),
          this._mapTileSize.height / 2 * (-t.x - t.y)
        );
        break;
      case cc.TMX_ORIENTATION_HEX:
        (t.x !== 0 || t.y !== 0) && cc.log("offset for hexagonal map not implemented yet");
        break;
    }
    return e;
  },
  _updateTileForGID: function(t, e) {
    if (this._texGrids[t]) {
      var n = 0 | e.x + e.y * this._layerSize.width;
      n < this.tiles.length && (this.tiles[n] = t);
    }
  },
  _parseInternalProperties: function() {
    var t = (this || window).getProperty("cc_vertexz");
    if (t)
      if (t === "automatic") {
        this._useAutomaticVertexZ = !0;
        var e = (this || window).getProperty("cc_alpha_func"), n = 0;
        e && (n = parseFloat(e)), cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST), this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(cc.UNIFORM_ALPHA_TEST_VALUE_S, n));
      } else
        this._vertexZvalue = parseInt(t, 10);
  },
  _setupTileSprite: function(t, e, n) {
    e.x + e.y * this._layerSize.width;
    var r = (this || window).getPositionAt(e);
    if (t.setPosition(r), t.setVertexZ(this._vertexZForPos(e)), t.setAnchorPoint(0, 0), t.setOpacity(this._opacity), t.setFlippedX(!1), t.setFlippedY(!1), t.setRotation(0), (n & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0) {
      t.setAnchorPoint(0.5, 0.5), t.setPosition(r.x + t.width / 2, r.y + t.height / 2);
      var s = (n & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0;
      s === cc.TMX_TILE_HORIZONTAL_FLAG ? t.setRotation(90) : s === cc.TMX_TILE_VERTICAL_FLAG ? t.setRotation(270) : s === (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? (t.setRotation(90), t.setFlippedX(!0)) : (t.setRotation(270), t.setFlippedX(!0));
    } else
      (n & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && t.setFlippedX(!0), (n & cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && t.setFlippedY(!0);
  },
  _vertexZForPos: function(t, e) {
    e === void 0 && (e = t.y, t = t.x);
    var n = 0, r = 0;
    if (this._useAutomaticVertexZ)
      switch (this.layerOrientation) {
        case cc.TMX_ORIENTATION_ISO:
          r = (this || window)._layerSize.width + this._layerSize.height, n = -(r - (t + e));
          break;
        case cc.TMX_ORIENTATION_ORTHO:
          n = -(this._layerSize.height - e);
          break;
        case cc.TMX_ORIENTATION_HEX:
          cc.log("TMX Hexa zOrder not supported");
          break;
        default:
          cc.log("TMX invalid value");
          break;
      }
    else
      n = (this || window)._vertexZvalue;
    return n;
  }
});
var _p = cc.TMXLayer.prototype;
_p.layerWidth;
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
_p.layerHeight;
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
_p.tileWidth;
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
_p.tileHeight;
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXLayer.create = function(t, e, n) {
  return new cc.TMXLayer(t, e, n);
};
(function() {
  cc.TMXLayer.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !0;
  };
  var t = cc.TMXLayer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.TMXLayer.CanvasRenderCmd, t.visit = function(e) {
    var n = (this || window)._node, r = cc.renderer;
    if (e = e || this.getParentRenderCmd(), e && (this._curLevel = e._curLevel + 1), !!n._visible) {
      isNaN(n._customZ) && (n._vertexZ = r.assignedZ, r.assignedZ += r.assignedZStep), this._syncStatus(e);
      var s = n._children, o, a = n._spriteTiles, c, l = s.length;
      if (l > 0) {
        for (n.sortAllChildren(), c = 0; c < l && (o = s[c], o._localZOrder < 0); c++)
          o._renderCmd.visit(this);
        for (r.pushRenderCommand(this); c < l; c++) {
          if (o = s[c], o._localZOrder === 0 && a[o.tag]) {
            isNaN(o._customZ) && (o._vertexZ = r.assignedZ, r.assignedZ += r.assignedZStep), o._renderCmd.updateStatus();
            continue;
          }
          o._renderCmd.visit(this);
        }
      } else
        r.pushRenderCommand(this);
      this._dirtyFlag = 0;
    }
  }, t.rendering = function(e, n, r) {
    var s = (this || window)._node, o = s._rotationX || s._rotationY, a = s.layerOrientation, c = s.tiles, l = s._opacity / 255;
    if (!(!c || l <= 0)) {
      var h = s._mapTileSize.width, u = s._mapTileSize.height, _ = s.tileset._tileSize.width / cc.director._contentScaleFactor, d = s.tileset._tileSize.height / cc.director._contentScaleFactor, f = _ - h, C = d - u, m = cc.winSize.width, g = cc.winSize.height, y = s._layerSize.height, A = s._layerSize.width, D = s._texGrids, N = s._spriteTiles, z = (this || window)._worldTransform, M = -s._contentSize.width * s._anchorPoint.x, Z = -s._contentSize.height * s._anchorPoint.y, U = z.a, Q = z.b, et = z.c, rt = z.d, w = M * U + Z * et + z.tx, L = M * Q + Z * rt + z.ty, G = e || cc._renderContext, I = G.getContext(), O = 0, K = 0, $ = A, S = y;
      !o && a === cc.TMX_ORIENTATION_ORTHO && (O = Math.floor(-(w - f * U) / (h * U)), K = Math.floor((L - C * rt + u * y * rt - g) / (u * rt)), $ = Math.ceil((m - w + f * U) / (h * U)), S = y - Math.floor(-(L + C * rt) / (u * rt)), O < 0 && (O = 0), K < 0 && (K = 0), $ > A && ($ = A), S > y && (S = y));
      var b, W, x, E = K * A, R, F, k, X, j, V = cc.TMX_TILE_FLIPPED_MASK, Y, tt, it, lt, ut = _, ft = d, vt = _ * U, pt = d * rt, gt, St, ht, ct, bt = !1, Et = !1;
      R = E + O;
      for (b in N)
        if (b < R && N[b])
          j = N[b]._renderCmd, N[b]._localZOrder === 0 && j.rendering && j.rendering(e, n, r);
        else if (b >= R)
          break;
      for (G.setTransform(z, n, r), G.setGlobalAlpha(l), W = K; W < S; ++W) {
        for (x = O; x < $; ++x) {
          if (R = E + x, N[R]) {
            j = N[R]._renderCmd, N[R]._localZOrder === 0 && j.rendering && (j.rendering(e, n, r), G.setTransform(z, n, r), G.setGlobalAlpha(l));
            continue;
          }
          if (F = s.tiles[R], k = D[(F & V) >>> 0], !!k && (X = s._textures[k.texId], !(!X || !X._htmlElementObj))) {
            switch (a) {
              case cc.TMX_ORIENTATION_ORTHO:
                tt = x * h, it = -(y - W - 1) * u;
                break;
              case cc.TMX_ORIENTATION_ISO:
                tt = h / 2 * (A + x - W - 1), it = -u / 2 * (y * 2 - x - W - 2);
                break;
              case cc.TMX_ORIENTATION_HEX:
                tt = x * h * 3 / 4, it = -(y - W - 1) * u + (x % 2 === 1 ? -u / 2 : 0);
                break;
            }
            if (lt = tt + _, Y = it - d, !o && a === cc.TMX_ORIENTATION_ISO) {
              if (ht = -L + it * rt, ht < -g - pt) {
                x += Math.floor((-g - ht) * 2 / pt) - 1;
                continue;
              }
              if (ct = w + lt * U, ct < -vt) {
                x += Math.floor(-ct * 2 / vt) - 1;
                continue;
              }
              if (St = w + tt * U, gt = -L + Y * rt, St > m || gt > 0) {
                x = $;
                continue;
              }
            }
            F > cc.TMX_TILE_DIAGONAL_FLAG && (bt = (F & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0, Et = (F & cc.TMX_TILE_VERTICAL_FLAG) >>> 0), bt && (tt = -lt, I.scale(-1, 1)), Et && (Y = -it, I.scale(1, -1)), I.drawImage(
              X._htmlElementObj,
              k.x,
              k.y,
              k.width,
              k.height,
              tt,
              Y,
              ut,
              ft
            ), bt && I.scale(-1, 1), Et && I.scale(1, -1), cc.g_NumberOfDraws++;
          }
        }
        E += A;
      }
      for (b in N)
        b > R && N[b] && (j = N[b]._renderCmd, N[b]._localZOrder === 0 && j.rendering && j.rendering(e, n, r));
    }
  };
})();
(function() {
  cc.TMXLayer.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._vertices = [
      { x: 0, y: 0 },
      { x: 0, y: 0 },
      { x: 0, y: 0 },
      { x: 0, y: 0 }
    ], this._color = new Uint32Array(1), this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST);
    var n = Math.PI * 90 / 180;
    this._sin90 = Math.sin(n), this._cos90 = Math.cos(n), n = n * 3, this._sin270 = Math.sin(n), this._cos270 = Math.cos(n);
  };
  var t = cc.TMXLayer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = cc.TMXLayer.WebGLRenderCmd, t.uploadData = function(e, n, r) {
    var s = (this || window)._node, o = s._rotationX || s._rotationY, a = s.layerOrientation, c = s.tiles;
    if (!c)
      return 0;
    cc.view._scaleX, cc.view._scaleY;
    var l = s._mapTileSize.width, h = s._mapTileSize.height, u = s.tileset._tileSize.width / cc.director._contentScaleFactor, _ = s.tileset._tileSize.height / cc.director._contentScaleFactor, d = u - l, f = _ - h, C = cc.winSize.width, m = cc.winSize.height, g = s._layerSize.height, y = s._layerSize.width, A = s._texGrids, D = s._spriteTiles, N = (this || window)._worldTransform, z = N.a, M = N.b, Z = N.c, U = N.d, Q = N.tx, et = N.ty, rt = -s._contentSize.width * s._anchorPoint.x, w = -s._contentSize.height * s._anchorPoint.y, L = rt * z + w * Z + Q, G = rt * M + w * U + et, I = s._opacity, O = (this || window)._displayedColor.r, K = (this || window)._displayedColor.g, $ = (this || window)._displayedColor.b;
    if (s._opacityModifyRGB) {
      var S = I / 255;
      O *= S, K *= S, $ *= S;
    }
    this._color[0] = I << 24 | $ << 16 | K << 8 | O;
    var b = 0, W = 0, x = y, E = g;
    !o && a === cc.TMX_ORIENTATION_ORTHO && (b = Math.floor(-(L - d * z) / (l * z)), W = Math.floor((G - f * U + h * g * U - m) / (h * U)), x = Math.ceil((C - L + d * z) / (l * z)), E = g - Math.floor(-(G + f * U) / (h * U)), b < 0 && (b = 0), W < 0 && (W = 0), x > y && (x = y), E > g && (E = g));
    var R, F, k = r, X = W * y, j, V, Y, tt = cc.TMX_TILE_FLIPPED_MASK, it, lt, ut, ft, vt, pt = u * z, gt = _ * U, St, ht, ct, bt, Et = z, wt = M, It = Z, Dt = U, Ut = Q, Gt = et, at = !1, ot = !1, _t = !1, mt = (this || window)._vertices;
    for (R = W; R < E; ++R) {
      for (F = b; F < x; ++F)
        if (k + 24 > e.length && (cc.renderer._increaseBatchingSize((k - r) / 6), cc.renderer._batchRendering(), r = 0, k = 0), j = X + F, !D[j] && (V = s.tiles[j], Y = A[(V & tt) >>> 0], !!Y)) {
          switch (a) {
            case cc.TMX_ORIENTATION_ORTHO:
              ut = F * l, ft = (g - R - 1) * h, j = s._vertexZ + cc.renderer.assignedZStep * j / c.length;
              break;
            case cc.TMX_ORIENTATION_ISO:
              ut = l / 2 * (y + F - R - 1), ft = h / 2 * (g * 2 - F - R - 2), j = s._vertexZ + cc.renderer.assignedZStep * (s.height - ft) / s.height;
              break;
            case cc.TMX_ORIENTATION_HEX:
              ut = F * l * 3 / 4, ft = (g - R - 1) * h + (F % 2 === 1 ? -h / 2 : 0), j = s._vertexZ + cc.renderer.assignedZStep * (s.height - ft) / s.height;
              break;
          }
          if (vt = ut + u, lt = ft + _, !o && a === cc.TMX_ORIENTATION_ISO) {
            if (ct = G + ft * U, ct > m + gt) {
              F += Math.floor((ct - m) * 2 / gt) - 1;
              continue;
            }
            if (bt = L + vt * z, bt < -pt) {
              F += Math.floor(-bt * 2 / pt) - 1;
              continue;
            }
            if (ht = L + ut * z, St = G + lt * U, ht > C || St < 0) {
              F = x;
              continue;
            }
          }
          for (V > cc.TMX_TILE_DIAGONAL_FLAG && (at = !0, ot = (V & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0, _t = (V & cc.TMX_TILE_VERTICAL_FLAG) >>> 0), mt[0].x = ut * Et + lt * It + Ut, mt[0].y = ut * wt + lt * Dt + Gt, mt[1].x = ut * Et + ft * It + Ut, mt[1].y = ut * wt + ft * Dt + Gt, mt[2].x = vt * Et + lt * It + Ut, mt[2].y = vt * wt + lt * Dt + Gt, mt[3].x = vt * Et + ft * It + Ut, mt[3].y = vt * wt + ft * Dt + Gt, it = 0; it < 4; ++it) {
            switch (e[k] = mt[it].x, e[k + 1] = mt[it].y, e[k + 2] = j, n[k + 3] = (this || window)._color[0], it) {
              case 0:
                e[k + 4] = ot ? Y.r : Y.l, e[k + 5] = _t ? Y.b : Y.t;
                break;
              case 1:
                e[k + 4] = ot ? Y.r : Y.l, e[k + 5] = _t ? Y.t : Y.b;
                break;
              case 2:
                e[k + 4] = ot ? Y.l : Y.r, e[k + 5] = _t ? Y.b : Y.t;
                break;
              case 3:
                e[k + 4] = ot ? Y.l : Y.r, e[k + 5] = _t ? Y.t : Y.b;
                break;
            }
            k += 6;
          }
          at && (Et = z, wt = M, It = Z, Dt = U, Ut = Q, Gt = et, ot = !1, _t = !1, at = !1);
        }
      X += y;
    }
    return (k - r) / 6;
  };
})();
cc.PointObject = cc.Class.extend({
  _ratio: null,
  _offset: null,
  _child: null,
  ctor: function(t, e) {
    this.initWithCCPoint(t, e);
  },
  getRatio: function() {
    return this._ratio;
  },
  setRatio: function(t) {
    this._ratio = t;
  },
  getOffset: function() {
    return this._offset;
  },
  setOffset: function(t) {
    this._offset = t;
  },
  getChild: function() {
    return this._child;
  },
  setChild: function(t) {
    this._child = t;
  },
  initWithCCPoint: function(t, e) {
    return this._ratio = t, this._offset = e, this._child = null, !0;
  }
});
cc.PointObject.create = function(t, e) {
  return new cc.PointObject(t, e);
};
cc.ParallaxNode = cc.Node.extend({
  parallaxArray: null,
  _lastPosition: null,
  _className: "ParallaxNode",
  getParallaxArray: function() {
    return this.parallaxArray;
  },
  setParallaxArray: function(t) {
    this.parallaxArray = t;
  },
  ctor: function() {
    cc.Node.prototype.ctor.call(this), this.parallaxArray = [], this._lastPosition = cc.p(-100, -100);
  },
  addChild: function(t, e, n, r) {
    if (arguments.length === 3) {
      cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
      return;
    }
    if (!t)
      throw new Error("cc.ParallaxNode.addChild(): child should be non-null");
    var s = new cc.PointObject(n, r);
    s.setChild(t), this.parallaxArray.push(s), t.setPosition(this._position.x * n.x + r.x, this._position.y * n.y + r.y), cc.Node.prototype.addChild.call(this, t, e, t.tag);
  },
  removeChild: function(t, e) {
    for (var n = (this || window).parallaxArray, r = 0; r < n.length; r++) {
      var s = n[r];
      if (s.getChild() === t) {
        n.splice(r, 1);
        break;
      }
    }
    cc.Node.prototype.removeChild.call(this, t, e);
  },
  removeAllChildren: function(t) {
    this.parallaxArray.length = 0, cc.Node.prototype.removeAllChildren.call(this, t);
  },
  _updateParallaxPosition: function() {
    var t = (this || window)._absolutePosition();
    if (!cc.pointEqualToPoint(t, this._lastPosition)) {
      for (var e = (this || window).parallaxArray, n = 0, r = e.length; n < r; n++) {
        var s = e[n], o = s.getChild();
        o.setPosition(
          -t.x + t.x * s.getRatio().x + s.getOffset().x,
          -t.y + t.y * s.getRatio().y + s.getOffset().y
        );
      }
      this._lastPosition = t;
    }
  },
  _absolutePosition: function() {
    for (var t = (this || window)._position, e = (this || window); e.parent !== null; )
      e = e.parent, t = cc.pAdd(t, e.getPosition());
    return t;
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParallaxNode.CanvasRenderCmd(this) : new cc.ParallaxNode.WebGLRenderCmd(this);
  }
});
cc.ParallaxNode.create = function() {
  return new cc.ParallaxNode();
};
(function() {
  cc.ParallaxNode.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !1;
  };
  var t = cc.ParallaxNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.ParallaxNode.CanvasRenderCmd, t.updateStatus = function() {
    this._node._updateParallaxPosition(), cc.Node.CanvasRenderCmd.prototype.updateStatus.call(this);
  }, t._syncStatus = function(e) {
    this._node._updateParallaxPosition(), cc.Node.CanvasRenderCmd.prototype._syncStatus.call(this, e);
  };
})();
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
    cc.ParallaxNode.WebGLRenderCmd = function(e) {
      cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !1;
    };
    var t = cc.ParallaxNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = cc.ParallaxNode.WebGLRenderCmd, t.updateStatus = function() {
      this._node._updateParallaxPosition(), cc.Node.WebGLRenderCmd.prototype.updateStatus.call(this);
    }, t._syncStatus = function(e) {
      this._node._updateParallaxPosition(), cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this, e);
    };
  }
});
cc.CONTROL_EVENT_TOTAL_NUMBER = 9;
cc.CONTROL_EVENT_TOUCH_DOWN = 1;
cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE = 2;
cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE = 4;
cc.CONTROL_EVENT_TOUCH_DRAG_ENTER = 8;
cc.CONTROL_EVENT_TOUCH_DRAG_EXIT = 16;
cc.CONTROL_EVENT_TOUCH_UP_INSIDE = 32;
cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE = 64;
cc.CONTROL_EVENT_TOUCH_CANCEL = 128;
cc.CONTROL_EVENT_VALUECHANGED = 256;
cc.CONTROL_STATE_NORMAL = 1;
cc.CONTROL_STATE_HIGHLIGHTED = 2;
cc.CONTROL_STATE_DISABLED = 4;
cc.CONTROL_STATE_SELECTED = 8;
cc.CONTROL_STATE_INITIAL = 8;
cc.Control = cc.Layer.extend({
  _isOpacityModifyRGB: !1,
  _hasVisibleParents: !1,
  _touchListener: null,
  _className: "Control",
  isOpacityModifyRGB: function() {
    return this._isOpacityModifyRGB;
  },
  setOpacityModifyRGB: function(t) {
    this._isOpacityModifyRGB = t;
    for (var e = (this || window).getChildren(), n = 0, r = e.length; n < r; n++) {
      var s = e[n];
      s && s.setOpacityModifyRGB(t);
    }
  },
  _state: cc.CONTROL_STATE_NORMAL,
  getState: function() {
    return this._state;
  },
  _enabled: !1,
  _selected: !1,
  _highlighted: !1,
  _dispatchTable: null,
  setEnabled: function(t) {
    this._enabled = t, this._state = t ? cc.CONTROL_STATE_NORMAL : cc.CONTROL_STATE_DISABLED, this.needsLayout();
  },
  isEnabled: function() {
    return this._enabled;
  },
  setSelected: function(t) {
    this._selected = t, this.needsLayout();
  },
  isSelected: function() {
    return this._selected;
  },
  setHighlighted: function(t) {
    this._highlighted = t, this.needsLayout();
  },
  isHighlighted: function() {
    return this._highlighted;
  },
  hasVisibleParents: function() {
    for (var t = (this || window).getParent(), e = t; e != null; e = e.getParent())
      if (!e.isVisible())
        return !1;
    return !0;
  },
  ctor: function() {
    cc.Layer.prototype.ctor.call(this), this._dispatchTable = {}, this._color = cc.color.WHITE;
  },
  init: function() {
    if (cc.Layer.prototype.init.call(this)) {
      this._state = cc.CONTROL_STATE_NORMAL, this._enabled = !0, this._selected = !1, this._highlighted = !1;
      var t = cc.EventListener.create({
        event: cc.EventListener.TOUCH_ONE_BY_ONE,
        swallowTouches: !0
      });
      return this.onTouchBegan && (t.onTouchBegan = (this || window).onTouchBegan.bind(this)), this.onTouchMoved && (t.onTouchMoved = (this || window).onTouchMoved.bind(this)), this.onTouchEnded && (t.onTouchEnded = (this || window).onTouchEnded.bind(this)), this.onTouchCancelled && (t.onTouchCancelled = (this || window).onTouchCancelled.bind(this)), this._touchListener = t, !0;
    } else
      return !1;
  },
  onEnter: function() {
    var t = (this || window)._touchListener;
    t._isRegistered() || cc.eventManager.addListener(t, this), cc.Node.prototype.onEnter.call(this);
  },
  sendActionsForControlEvents: function(t) {
    for (var e = 0, n = cc.CONTROL_EVENT_TOTAL_NUMBER; e < n; e++)
      if (t & 1 << e)
        for (var r = (this || window)._dispatchListforControlEvent(1 << e), s = 0, o = r.length; s < o; s++)
          r[s].invoke(this);
  },
  addTargetWithActionForControlEvents: function(t, e, n) {
    for (var r = 0, s = cc.CONTROL_EVENT_TOTAL_NUMBER; r < s; r++)
      n & 1 << r && this._addTargetWithActionForControlEvent(t, e, 1 << r);
  },
  removeTargetWithActionForControlEvents: function(t, e, n) {
    for (var r = 0, s = cc.CONTROL_EVENT_TOTAL_NUMBER; r < s; r++)
      n & 1 << r && this._removeTargetWithActionForControlEvent(t, e, 1 << r);
  },
  getTouchLocation: function(t) {
    var e = t.getLocation();
    return this.convertToNodeSpace(e);
  },
  isTouchInside: function(t) {
    var e = t.getLocation();
    return e = (this || window).getParent().convertToNodeSpace(e), cc.rectContainsPoint(this.getBoundingBox(), e);
  },
  _invocationWithTargetAndActionForControlEvent: function(t, e, n) {
    return null;
  },
  _dispatchListforControlEvent: function(t) {
    return t = t.toString(), this._dispatchTable[t] || (this._dispatchTable[t] = []), this._dispatchTable[t];
  },
  _addTargetWithActionForControlEvent: function(t, e, n) {
    var r = new cc.Invocation(t, e, n), s = (this || window)._dispatchListforControlEvent(n);
    s.push(r);
  },
  _removeTargetWithActionForControlEvent: function(t, e, n) {
    var r = (this || window)._dispatchListforControlEvent(n);
    if (!t && !e)
      r.length = 0;
    else
      for (var s = 0; s < r.length; ) {
        var o = r[s], a = !0;
        t && (a = t === o.getTarget()), e && (a = a && e === o.getAction()), a ? cc.arrayRemoveObject(r, o) : s++;
      }
  },
  needsLayout: function() {
  }
});
var _p = cc.Control.prototype;
_p.state;
cc.defineGetterSetter(_p, "state", _p.getState);
_p.enabled;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
_p.selected;
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
_p.highlighted;
cc.defineGetterSetter(_p, "highlighted", _p.isHighlighted, _p.setHighlighted);
_p = null;
cc.Control.create = function() {
  var t = new cc.Control();
  return t && t.init() ? t : null;
};
cc.CONTROL_ZOOM_ACTION_TAG = 3435855873;
cc.ControlButton = cc.Control.extend({
  _doesAdjustBackgroundImage: !1,
  zoomOnTouchDown: !1,
  _preferredSize: null,
  _labelAnchorPoint: null,
  _currentTitle: null,
  _currentTitleColor: null,
  _titleLabel: null,
  _backgroundSprite: null,
  _opacity: 0,
  _isPushed: !1,
  _titleDispatchTable: null,
  _titleColorDispatchTable: null,
  _titleLabelDispatchTable: null,
  _backgroundSpriteDispatchTable: null,
  _parentInited: !1,
  _marginV: 0,
  _marginH: 0,
  _className: "ControlButton",
  ctor: function(t, e, n) {
    cc.Control.prototype.ctor.call(this), this._preferredSize = cc.size(0, 0), this._labelAnchorPoint = cc.p(0, 0), this._currentTitle = "", this._currentTitleColor = cc.color.WHITE, this._titleDispatchTable = {}, this._titleColorDispatchTable = {}, this._titleLabelDispatchTable = {}, this._backgroundSpriteDispatchTable = {}, n != null ? this.initWithTitleAndFontNameAndFontSize(t, e, n) : e != null ? this.initWithLabelAndBackgroundSprite(t, e) : t != null ? this.initWithBackgroundSprite(t) : this.init();
  },
  init: function() {
    return this.initWithLabelAndBackgroundSprite(new cc.LabelTTF("", "Arial", 12), new cc.Scale9Sprite());
  },
  needsLayout: function() {
    if (this._parentInited) {
      this._titleLabel && this._titleLabel.setVisible(!1), this._backgroundSprite && this._backgroundSprite.setVisible(!1), this.setLabelAnchorPoint(this._labelAnchorPoint);
      var t = (this || window)._state;
      this._currentTitle = (this || window).getTitleForState(t), this._currentTitleColor = (this || window).getTitleColorForState(t), this._titleLabel = (this || window).getTitleLabelForState(t);
      var e = (this || window)._titleLabel;
      e && e.setString && e.setString(this._currentTitle), e && e.setColor(this._currentTitleColor);
      var n = (this || window).getContentSize();
      e && e.setPosition(n.width / 2, n.height / 2), this._backgroundSprite = (this || window).getBackgroundSpriteForState(t);
      var r = (this || window)._backgroundSprite;
      r && r.setPosition(n.width / 2, n.height / 2);
      var s = cc.size(0, 0);
      if (e) {
        var o = e.getBoundingBox();
        s.width = o.width, s.height = o.height;
      }
      if (this._doesAdjustBackgroundImage)
        r && r.setContentSize(s.width + this._marginH * 2, s.height + this._marginV * 2);
      else if (r) {
        var a = r.getPreferredSize();
        a = cc.size(a.width, a.height), a.width <= 0 && (a.width = s.width), a.height <= 0 && (a.height = s.height), r.setContentSize(a);
      }
      var c = e ? e.getBoundingBox() : cc.rect(0, 0, 0, 0), l = r ? r.getBoundingBox() : cc.rect(0, 0, 0, 0), h = cc.rectUnion(c, l);
      this.setContentSize(h.width, h.height), n = (this || window).getContentSize(), e && (e.setPosition(n.width / 2, n.height / 2), e.setVisible(!0)), r && (r.setPosition(n.width / 2, n.height / 2), r.setVisible(!0));
    }
  },
  initWithLabelAndBackgroundSprite: function(t, e) {
    if (!t)
      throw new Error("cc.ControlButton.initWithLabelAndBackgroundSprite(): label should be non-null");
    if (!e)
      throw new Error("cc.ControlButton.initWithLabelAndBackgroundSprite(): backgroundSprite should be non-null");
    if (cc.Control.prototype.init.call(this, !0)) {
      this._parentInited = !0, this._titleDispatchTable = {}, this._titleColorDispatchTable = {}, this._titleLabelDispatchTable = {}, this._backgroundSpriteDispatchTable = {}, this._isPushed = !1, this.zoomOnTouchDown = !0, this._currentTitle = null, this.setAdjustBackgroundImage(!0), this.setPreferredSize(cc.size(0, 0)), this.zoomOnTouchDown = !0, this.ignoreAnchorPointForPosition(!1), this.setAnchorPoint(0.5, 0.5), this._titleLabel = t, this._backgroundSprite = e, this.setOpacity(255), this.setOpacityModifyRGB(!0);
      var n = t.getString();
      return this.setTitleForState(n, cc.CONTROL_STATE_NORMAL), this.setTitleColorForState(t.getColor(), cc.CONTROL_STATE_NORMAL), this.setTitleLabelForState(t, cc.CONTROL_STATE_NORMAL), this.setBackgroundSpriteForState(e, cc.CONTROL_STATE_NORMAL), this._state = cc.CONTROL_STATE_NORMAL, this._marginH = 24, this._marginV = 12, this._labelAnchorPoint = cc.p(0.5, 0.5), this.setPreferredSize(cc.size(0, 0)), this.needsLayout(), !0;
    } else
      return !1;
  },
  initWithTitleAndFontNameAndFontSize: function(t, e, n) {
    var r = new cc.LabelTTF(t, e, n);
    return this.initWithLabelAndBackgroundSprite(r, new cc.Scale9Sprite());
  },
  initWithBackgroundSprite: function(t) {
    var e = new cc.LabelTTF("", "Arial", 30);
    return this.initWithLabelAndBackgroundSprite(e, t);
  },
  doesAdjustBackgroundImage: function() {
    return this._doesAdjustBackgroundImage;
  },
  setAdjustBackgroundImage: function(t) {
    this._doesAdjustBackgroundImage = t, this.needsLayout();
  },
  getZoomOnTouchDown: function() {
    return this.zoomOnTouchDown;
  },
  setZoomOnTouchDown: function(t) {
    return this.zoomOnTouchDown = t;
  },
  getPreferredSize: function() {
    return this._preferredSize;
  },
  setPreferredSize: function(t) {
    if (t.width === 0 && t.height === 0)
      this._doesAdjustBackgroundImage = !0;
    else {
      this._doesAdjustBackgroundImage = !1;
      var e = (this || window)._backgroundSpriteDispatchTable;
      for (var n in e)
        e[n].setPreferredSize(t);
    }
    this._preferredSize = t, this.needsLayout();
  },
  getLabelAnchorPoint: function() {
    return this._labelAnchorPoint;
  },
  setLabelAnchorPoint: function(t) {
    this._labelAnchorPoint = t, this._titleLabel && this._titleLabel.setAnchorPoint(t);
  },
  _getCurrentTitle: function() {
    return this._currentTitle;
  },
  _getCurrentTitleColor: function() {
    return this._currentTitleColor;
  },
  getOpacity: function() {
    return this._opacity;
  },
  setOpacity: function(t) {
    cc.Control.prototype.setOpacity.call(this, t);
    var e = (this || window)._backgroundSpriteDispatchTable;
    for (var n in e)
      e[n].setOpacity(t);
  },
  setColor: function(t) {
    cc.Control.prototype.setColor.call(this, t);
    var e = (this || window)._backgroundSpriteDispatchTable;
    for (var n in e)
      e[n].setColor(t);
  },
  getColor: function() {
    var t = (this || window)._realColor;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  isPushed: function() {
    return this._isPushed;
  },
  _getVerticalMargin: function() {
    return this._marginV;
  },
  _getHorizontalOrigin: function() {
    return this._marginH;
  },
  setMargins: function(t, e) {
    this._marginV = e, this._marginH = t, this.needsLayout();
  },
  setEnabled: function(t) {
    cc.Control.prototype.setEnabled.call(this, t), this.needsLayout();
  },
  setSelected: function(t) {
    cc.Control.prototype.setSelected.call(this, t), this.needsLayout();
  },
  setHighlighted: function(t) {
    this._state = t ? cc.CONTROL_STATE_HIGHLIGHTED : cc.CONTROL_STATE_NORMAL, cc.Control.prototype.setHighlighted.call(this, t);
    var e = (this || window).getActionByTag(cc.CONTROL_ZOOM_ACTION_TAG);
    if (e && this.stopAction(e), this.zoomOnTouchDown) {
      var n = (this || window).isHighlighted() && this.isEnabled() && !this.isSelected() ? 1.1 : 1, r = cc.scaleTo(0.05, n);
      r.setTag(cc.CONTROL_ZOOM_ACTION_TAG), this.runAction(r);
    }
  },
  onTouchBegan: function(t, e) {
    return !this.isTouchInside(t) || !this.isEnabled() || !this.isVisible() || !this.hasVisibleParents() ? !1 : (this._isPushed = !0, this.setHighlighted(!0), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DOWN), !0);
  },
  onTouchMoved: function(t, e) {
    if (!this._enabled || !this._isPushed || this._selected) {
      this._highlighted && this.setHighlighted(!1);
      return;
    }
    var n = (this || window).isTouchInside(t);
    n && !this._highlighted ? (this.setHighlighted(!0), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_ENTER)) : n && this._highlighted ? this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_INSIDE) : !n && this._highlighted ? (this.setHighlighted(!1), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_EXIT)) : !n && !this._highlighted && this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_DRAG_OUTSIDE);
  },
  onTouchEnded: function(t, e) {
    this._isPushed = !1, this.setHighlighted(!1), this.isTouchInside(t) ? this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_INSIDE) : this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_UP_OUTSIDE);
  },
  onTouchCancelled: function(t, e) {
    this._isPushed = !1, this.setHighlighted(!1), this.sendActionsForControlEvents(cc.CONTROL_EVENT_TOUCH_CANCEL);
  },
  getTitleForState: function(t) {
    var e = (this || window)._titleDispatchTable;
    return e ? e[t] ? e[t] : e[cc.CONTROL_STATE_NORMAL] : "";
  },
  setTitleForState: function(t, e) {
    this._titleDispatchTable[e] = t || "", this.getState() === e && this.needsLayout();
  },
  getTitleColorForState: function(t) {
    var e = (this || window)._titleColorDispatchTable[t];
    return e || (e = (this || window)._titleColorDispatchTable[cc.CONTROL_STATE_NORMAL], e) ? e : cc.color.WHITE;
  },
  setTitleColorForState: function(t, e) {
    this._titleColorDispatchTable[e] = t, this.getState() === e && this.needsLayout();
  },
  getTitleLabelForState: function(t) {
    var e = (this || window)._titleLabelDispatchTable;
    return e[t] ? e[t] : e[cc.CONTROL_STATE_NORMAL];
  },
  setTitleLabelForState: function(t, e) {
    var n = (this || window)._titleLabelDispatchTable;
    if (n[e]) {
      var r = n[e];
      r && this.removeChild(r, !0);
    }
    n[e] = t, t.setVisible(!1), t.setAnchorPoint(0.5, 0.5), this.addChild(t, 1), this.getState() === e && this.needsLayout();
  },
  setTitleTTFForState: function(t, e) {
    var n = (this || window).getTitleForState(e);
    n || (n = ""), this.setTitleLabelForState(new cc.LabelTTF(n, t, 12), e);
  },
  getTitleTTFForState: function(t) {
    var e = (this || window).getTitleLabelForState(t);
    return e != null && e instanceof cc.LabelTTF ? e.getFontName() : "";
  },
  setTitleTTFSizeForState: function(t, e) {
    var n = (this || window).getTitleLabelForState(e);
    n != null && n instanceof cc.LabelTTF && n.setFontSize(t);
  },
  getTitleTTFSizeForState: function(t) {
    var e = (this || window).getTitleLabelForState(t);
    return e != null && e instanceof cc.LabelTTF ? e.getFontSize() : 0;
  },
  setTitleBMFontForState: function(t, e) {
    var n = (this || window).getTitleForState(e);
    n || (n = ""), this.setTitleLabelForState(new cc.LabelBMFont(n, t), e);
  },
  getTitleBMFontForState: function(t) {
    var e = (this || window).getTitleLabelForState(t);
    return e != null && e instanceof cc.LabelBMFont ? e.getFntFile() : "";
  },
  getBackgroundSpriteForState: function(t) {
    var e = (this || window)._backgroundSpriteDispatchTable;
    return e[t] ? e[t] : e[cc.CONTROL_STATE_NORMAL];
  },
  setBackgroundSpriteForState: function(t, e) {
    var n = (this || window)._backgroundSpriteDispatchTable;
    if (n[e]) {
      var r = n[e];
      r && this.removeChild(r, !0);
    }
    n[e] = t, t.setVisible(!1), t.setAnchorPoint(0.5, 0.5), this.addChild(t);
    var s = (this || window)._preferredSize;
    (s.width !== 0 || s.height !== 0) && t.setPreferredSize(s), this._state === e && this.needsLayout();
  },
  setBackgroundSpriteFrameForState: function(t, e) {
    var n = cc.Scale9Sprite.createWithSpriteFrame(t);
    this.setBackgroundSpriteForState(n, e);
  }
});
var _p = cc.ControlButton.prototype;
_p.adjustBackground;
cc.defineGetterSetter(_p, "adjustBackground", _p.getAdjustBackgroundImage, _p.setAdjustBackgroundImage);
_p.preferredSize;
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
_p.labelAnchor;
cc.defineGetterSetter(_p, "labelAnchor", _p.getLabelAnchorPoint, _p.setLabelAnchorPoint);
_p = null;
cc.ControlButton.create = function(t, e, n) {
  return new cc.ControlButton(t, e, n);
};
cc.RGBA = function(t, e, n, r) {
  this.r = t, this.g = e, this.b = n, this.a = r;
};
cc.HSV = function(t, e, n) {
  this.h = t, this.s = e, this.v = n;
};
cc.ControlUtils = {};
cc.ControlUtils.addSpriteToTargetWithPosAndAnchor = function(t, e, n, r) {
  var s = new cc.Sprite("#" + t);
  return s ? (s.setPosition(n), s.setAnchorPoint(r), e.addChild(s), s) : null;
};
cc.ControlUtils.HSVfromRGB = function(t) {
  var e = new cc.HSV(), n, r, s;
  if (n = t.r < t.g ? t.r : t.g, n = n < t.b ? n : t.b, r = t.r > t.g ? t.r : t.g, r = r > t.b ? r : t.b, e.v = r, s = r - n, r > 0)
    e.s = s / r;
  else
    return e.s = 0, e.h = -1, e;
  return t.r >= r ? e.h = (t.g - t.b) / s : t.g >= r ? e.h = 2 + (t.b - t.r) / s : e.h = 4 + (t.r - t.g) / s, e.h *= 60, e.h < 0 && (e.h += 360), e;
};
cc.ControlUtils.RGBfromHSV = function(t) {
  var e, n, r, s, o, a, c = new cc.RGBA();
  if (c.a = 1, t.s <= 0)
    return t.h ? (c.r = 0, c.g = 0, c.b = 0, c) : (c.r = t.v, c.g = t.v, c.b = t.v, c);
  switch (e = t.h, e >= 360 && (e = 0), e /= 60, a = 0 | e, o = e - a, n = t.v * (1 - t.s), r = t.v * (1 - t.s * o), s = t.v * (1 - t.s * (1 - o)), a) {
    case 0:
      c.r = t.v, c.g = s, c.b = n;
      break;
    case 1:
      c.r = r, c.g = t.v, c.b = n;
      break;
    case 2:
      c.r = n, c.g = t.v, c.b = s;
      break;
    case 3:
      c.r = n, c.g = r, c.b = t.v;
      break;
    case 4:
      c.r = s, c.g = n, c.b = t.v;
      break;
    default:
      c.r = t.v, c.g = n, c.b = r;
      break;
  }
  return c;
};
cc.ControlUtils.CCRectUnion = function(t, e) {
  return cc.rectUnion(t, e);
};
cc.Invocation = cc.Class.extend({
  _action: null,
  _target: null,
  _controlEvent: null,
  ctor: function(t, e, n) {
    this._target = t, this._action = e, this._controlEvent = n;
  },
  getAction: function() {
    return this._action;
  },
  getTarget: function() {
    return this._target;
  },
  getControlEvent: function() {
    return this._controlEvent;
  },
  invoke: function(t) {
    this._target && this._action && (cc.isString(this._action) ? this._target[this._action](t, this._controlEvent) : this._action.call(this._target, t, this._controlEvent));
  }
});
cc.Spacer = cc.Layer.extend({});
cc.Spacer.verticalSpacer = function(t) {
  var e = new cc.Spacer();
  return e.init(), e.setContentSize(0, t), e;
};
cc.Spacer.horizontalSpacer = function(t) {
  var e = new cc.Spacer();
  return e.init(), e.setContentSize(t, 0), e;
};
cc.MenuPassive = cc.Layer.extend({
  _color: null,
  _opacity: 0,
  _className: "MenuPassive",
  ctor: function() {
  },
  getColor: function() {
    var t = (this || window)._color;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  setColor: function(t) {
    var e = (this || window)._color;
    if (e.r = t.r, e.g = t.g, e.b = t.b, this._children && this._children.length > 0)
      for (var n = 0; n < this._children.length; n++)
        this._children[n] && this._children[n].setColor(t);
    t.a !== void 0 && !t.a_undefined && this.setOpacity(t.a);
  },
  getOpacity: function() {
    return this._opacity;
  },
  setOpacity: function(t) {
    if (this._opacity = t, this._children && this._children.length > 0)
      for (var e = 0; e < this._children.length; e++)
        this._children[e] && this._children[e].setOpacity(t);
    this._color.a = t;
  },
  initWithItems: function(t, e) {
    if (this.init()) {
      var n = cc.director.getWinSize();
      this.ignoreAnchorPointForPosition(!0), this.setAnchorPoint(0.5, 0.5), this.setContentSize(n), this.setPosition(n.width / 2, n.height / 2);
      var r = 0;
      if (t) {
        this.addChild(t, r);
        for (var s = 0; s < e.length; s++)
          e[s] && (r++, this.addChild(e[s], r));
      }
      return !0;
    }
    return !1;
  },
  alignItemsVertically: function() {
    this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING);
  },
  alignItemsVerticallyWithPadding: function(t) {
    var e = -t, n;
    if (this._children && this._children.length > 0)
      for (n = 0; n < this._children.length; n++)
        this._children[n] && (e += (this || window)._children[n].getContentSize().height * this._children[n].getScaleY() + t);
    var r = 0, s = e / 2;
    if (this._children && this._children.length > 0)
      for (n = 0; n < this._children.length; n++)
        this._children[n] && (r = Math.max(r, this._children[n].getContentSize().width), this._children[n].setPosition(0, s - this._children[n].getContentSize().height * this._children[n].getScaleY() / 2), s -= (this || window)._children[n].getContentSize().height * this._children[n].getScaleY() + t);
    this.setContentSize(r, e);
  },
  alignItemsHorizontally: function() {
    this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING);
  },
  alignItemsHorizontallyWithPadding: function(t) {
    var e = -t, n;
    if (this._children && this._children.length > 0)
      for (n = 0; n < this._children.length; n++)
        this._children[n] && (e += (this || window)._children[n].getContentSize().width * this._children[n].getScaleX() + t);
    var r = 0, s = -e / 2;
    if (this._children && this._children.length > 0)
      for (n = 0; n < this._children.length; n++)
        this._children[n] && (r = Math.max(r, this._children[n].getContentSize().height), this._children[n].setPosition(s + this._children[n].getContentSize().width * this._children[n].getScaleX() / 2, 0), s += (this || window)._children[n].getContentSize().width * this._children[n].getScaleX() + t);
    this.setContentSize(e, r);
  },
  alignItemsInColumns: function(t) {
    var e = [], n;
    for (n = 1; n < arguments.length; n++)
      e.push(arguments[n]);
    var r = -5, s = 0, o = 0, a = 0, c, l;
    if (this._children && this._children.length > 0) {
      for (n = 0; n < this._children.length; n++)
        if (this._children[n]) {
          if (s >= e.length) {
            cc.log("cc.MenuPassive.alignItemsInColumns(): invalid row index");
            continue;
          }
          if (c = e[s], !c) {
            cc.log("cc.MenuPassive.alignItemsInColumns(): can not have zero columns on a row");
            continue;
          }
          l = (this || window)._children[n].getContentSize().height, o = 0 | (o >= l || l == null ? o : l), ++a, a >= c && (r += o + 5, a = 0, o = 0, ++s);
        }
    }
    var h = cc.director.getWinSize();
    s = 0, o = 0, c = 0;
    var u = 0, _ = 0, d = r / 2;
    if (this._children && this._children.length > 0)
      for (n = 0; n < this._children.length; n++)
        this._children[n] && (c === 0 && (c = e[s], u = h.width / (1 + c), _ = u), l = (this || window)._children[n].getContentSize().height, o = 0 | (o >= l || l == null ? o : l), this._children[n].setPosition(
          _ - h.width / 2,
          d - this._children[n].getContentSize().height / 2
        ), _ += u, ++a, a >= c && (d -= o + 5, a = 0, c = 0, o = 0, ++s));
  },
  alignItemsInRows: function(t) {
    var e = [], n;
    for (n = 1; n < arguments.length; n++)
      e.push(arguments[n]);
    var r = [], s = [], o = -10, a = -5, c = 0, l = 0, h = 0, u, _;
    if (this._children && this._children.length > 0) {
      for (n = 0; n < this._children.length; n++)
        if (this._children[n]) {
          if (c >= e.length) {
            cc.log("cc.MenuPassive.alignItemsInRows(): invalid row index");
            continue;
          }
          if (u = e[c], !u) {
            cc.log("cc.MenuPassive.alignItemsInColumns(): can't have zero rows on a column");
            continue;
          }
          _ = (this || window)._children[n].getContentSize().width, l = 0 | (l >= _ || _ == null ? l : _), a += 0 | this._children[n].getContentSize().height + 5, ++h, h >= u && (r.push(l), s.push(a), o += l + 10, h = 0, l = 0, a = -5, ++c);
        }
    }
    var d = cc.director.getWinSize();
    c = 0, l = 0, u = null;
    var f = -o / 2, C = 0;
    if (this._children && this._children.length > 0)
      for (n = 0; n < this._children.length; n++)
        this._children[n] && (u == null && (u = e[c], C = s[c]), _ = (this || window)._children[n].getContentSize().width, l = 0 | (l >= _ || _ == null ? l : _), this._children[n].setPosition(f + r[c] / 2, C - d.height / 2), C -= (this || window)._children[n].getContentSize().height + 10, ++h, h >= u && (f += l + 5, h = 0, u = 0, l = 0, ++c));
  },
  setOpacityModifyRGB: function(t) {
  },
  isOpacityModifyRGB: function() {
    return !1;
  }
});
cc.MenuPassive.create = function(t) {
  t || (t = null);
  for (var e = [], n = 1; n < arguments.length; n++)
    e.push(arguments[n]);
  var r = new cc.MenuPassive();
  return r && r.initWithItems(t, e) ? r : null;
};
cc.MenuPassive.createWithItem = function(t) {
  return cc.MenuPassive.create(t, null);
};
cc.ControlSaturationBrightnessPicker = cc.Control.extend({
  _saturation: 0,
  _brightness: 0,
  _background: null,
  _overlay: null,
  _shadow: null,
  _slider: null,
  _startPos: null,
  _boxPos: 0,
  _boxSize: 0,
  _className: "ControlSaturationBrightnessPicker",
  ctor: function(t, e) {
    cc.Control.prototype.ctor.call(this), e && this.initWithTargetAndPos(t, e);
  },
  getSaturation: function() {
    return this._saturation;
  },
  getBrightness: function() {
    return this._brightness;
  },
  getBackground: function() {
    return this._background;
  },
  getOverlay: function() {
    return this._brightness;
  },
  getShadow: function() {
    return this._shadow;
  },
  getSlider: function() {
    return this._slider;
  },
  getStartPos: function() {
    return this._startPos;
  },
  initWithTargetAndPos: function(t, e) {
    return cc.Control.prototype.init.call(this) ? (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerBackground.png", t, e, cc.p(0, 0)), this._overlay = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerOverlay.png", t, e, cc.p(0, 0)), this._shadow = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPickerShadow.png", t, e, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", t, e, cc.p(0.5, 0.5)), this._startPos = e, this._boxPos = 35, this._boxSize = (this || window)._background.getContentSize().width / 2, !0) : !1;
  },
  setEnabled: function(t) {
    cc.Control.prototype.setEnabled.call(this, t), this._slider && this._slider.setOpacity(t ? 255 : 128);
  },
  updateWithHSV: function(t) {
    var e = new cc.HSV();
    e.s = 1, e.h = t.h, e.v = 1;
    var n = cc.ControlUtils.RGBfromHSV(e);
    this._background.setColor(cc.color(0 | n.r * 255, 0 | n.g * 255, 0 | n.b * 255));
  },
  updateDraggerWithHSV: function(t) {
    var e = cc.p(
      this._startPos.x + this._boxPos + this._boxSize * (1 - t.s),
      this._startPos.y + this._boxPos + this._boxSize * t.v
    );
    this._updateSliderPosition(e);
  },
  _updateSliderPosition: function(t) {
    var e = (this || window)._startPos.x + this._background.getBoundingBox().width * 0.5, n = (this || window)._startPos.y + this._background.getBoundingBox().height * 0.5, r = t.x - e, s = t.y - n, o = Math.sqrt(r * r + s * s), a = Math.atan2(s, r), c = (this || window)._background.getBoundingBox().width * 0.5;
    o > c && (t.x = e + c * Math.cos(a), t.y = n + c * Math.sin(a)), this._slider.setPosition(t), t.x < this._startPos.x + this._boxPos ? t.x = (this || window)._startPos.x + this._boxPos : t.x > this._startPos.x + this._boxPos + this._boxSize - 1 && (t.x = (this || window)._startPos.x + this._boxPos + this._boxSize - 1), t.y < this._startPos.y + this._boxPos ? t.y = (this || window)._startPos.y + this._boxPos : t.y > this._startPos.y + this._boxPos + this._boxSize && (t.y = (this || window)._startPos.y + this._boxPos + this._boxSize), this._saturation = 1 - Math.abs((this._startPos.x + this._boxPos - t.x) / this._boxSize), this._brightness = Math.abs((this._startPos.y + this._boxPos - t.y) / this._boxSize);
  },
  _checkSliderPosition: function(t) {
    var e = (this || window)._startPos.x + this._background.getBoundingBox().width * 0.5, n = (this || window)._startPos.y + this._background.getBoundingBox().height * 0.5, r = t.x - e, s = t.y - n, o = Math.sqrt(r * r + s * s);
    return o <= (this || window)._background.getBoundingBox().width * 0.5 ? (this._updateSliderPosition(t), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED), !0) : !1;
  },
  onTouchBegan: function(t, e) {
    if (!this.isEnabled() || !this.isVisible())
      return !1;
    var n = (this || window).getTouchLocation(t);
    return this._checkSliderPosition(n);
  },
  onTouchMoved: function(t, e) {
    var n = (this || window).getTouchLocation(t);
    this._checkSliderPosition(n);
  }
});
var _p = cc.ControlSaturationBrightnessPicker.prototype;
_p.saturation;
cc.defineGetterSetter(_p, "saturation", _p.getSaturation);
_p.brightness;
cc.defineGetterSetter(_p, "brightness", _p.getBrightness);
_p.background;
cc.defineGetterSetter(_p, "background", _p.getBackground);
_p.overlay;
cc.defineGetterSetter(_p, "overlay", _p.getOverlay);
_p.shadow;
cc.defineGetterSetter(_p, "shadow", _p.getShadow);
_p.slider;
cc.defineGetterSetter(_p, "slider", _p.getSlider);
_p.startPos;
cc.defineGetterSetter(_p, "startPos", _p.getStartPos);
_p = null;
cc.ControlSaturationBrightnessPicker.create = function(t, e) {
  return new cc.ControlSaturationBrightnessPicker(t, e);
};
cc.ControlHuePicker = cc.Control.extend({
  _hue: 0,
  _huePercentage: 0,
  _background: null,
  _slider: null,
  _startPos: null,
  _className: "ControlHuePicker",
  ctor: function(t, e) {
    cc.Control.prototype.ctor.call(this), e && this.initWithTargetAndPos(t, e);
  },
  getHue: function() {
    return this._hue;
  },
  setHue: function(t) {
    this._hue = t, this.setHuePercentage(this._hue / 360);
  },
  getHuePercentage: function() {
    return this._huePercentage;
  },
  setHuePercentage: function(t) {
    this._huePercentage = t, this._hue = (this || window)._huePercentage * 360;
    var e = (this || window)._background.getBoundingBox(), n = (this || window)._startPos.x + e.width * 0.5, r = (this || window)._startPos.y + e.height * 0.5, s = e.width * 0.5 - 15, o = (this || window)._huePercentage * 360 - 180, a = cc.degreesToRadians(o), c = n + s * Math.cos(a), l = r + s * Math.sin(a);
    this._slider.setPosition(c, l);
  },
  setEnabled: function(t) {
    cc.Control.prototype.setEnabled.call(this, t), this._slider && this._slider.setOpacity(t ? 255 : 128);
  },
  getBackground: function() {
    return this._background;
  },
  getSlider: function() {
    return this._slider;
  },
  getStartPos: function() {
    return this._startPos;
  },
  initWithTargetAndPos: function(t, e) {
    return cc.Control.prototype.init.call(this) ? (this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("huePickerBackground.png", t, e, cc.p(0, 0)), this._slider = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("colourPicker.png", t, e, cc.p(0.5, 0.5)), this._slider.setPosition(e.x, e.y + this._background.getBoundingBox().height * 0.5), this._startPos = e, this._hue = 0, this._huePercentage = 0, !0) : !1;
  },
  _updateSliderPosition: function(t) {
    var e = (this || window)._background.getBoundingBox(), n = (this || window)._startPos.x + e.width * 0.5, r = (this || window)._startPos.y + e.height * 0.5, s = t.x - n, o = t.y - r, a = Math.atan2(o, s), c = cc.radiansToDegrees(a) + 180;
    this.setHue(c), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
  },
  _checkSliderPosition: function(t) {
    var e = Math.sqrt(Math.pow(t.x + 10, 2) + Math.pow(t.y, 2));
    return 80 > e && e > 59 ? (this._updateSliderPosition(t), !0) : !1;
  },
  onTouchBegan: function(t, e) {
    if (!this.isEnabled() || !this.isVisible())
      return !1;
    var n = (this || window).getTouchLocation(t);
    return this._checkSliderPosition(n);
  },
  onTouchMoved: function(t, e) {
    var n = (this || window).getTouchLocation(t);
    this._checkSliderPosition(n);
  }
});
var _p = cc.ControlHuePicker.prototype;
_p.hue;
cc.defineGetterSetter(_p, "hue", _p.getHue, _p.setHue);
_p.huePercent;
cc.defineGetterSetter(_p, "huePercent", _p.getHuePercentage, _p.setHuePercentage);
_p.background;
cc.defineGetterSetter(_p, "background", _p.getBackground);
_p.slider;
cc.defineGetterSetter(_p, "slider", _p.getSlider);
_p.startPos;
cc.defineGetterSetter(_p, "startPos", _p.getStartPos);
_p = null;
cc.ControlHuePicker.create = function(t, e) {
  return new cc.ControlHuePicker(t, e);
};
cc.ControlColourPicker = cc.Control.extend({
  _hsv: null,
  _colourPicker: null,
  _huePicker: null,
  _background: null,
  _className: "ControlColourPicker",
  ctor: function() {
    cc.Control.prototype.ctor.call(this), this.init();
  },
  hueSliderValueChanged: function(t, e) {
    this._hsv.h = t.getHue();
    var n = cc.ControlUtils.RGBfromHSV(this._hsv);
    cc.Control.prototype.setColor.call(this, cc.color(0 | n.r * 255, 0 | n.g * 255, 0 | n.b * 255)), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED), this._updateControlPicker();
  },
  colourSliderValueChanged: function(t, e) {
    this._hsv.s = t.getSaturation(), this._hsv.v = t.getBrightness();
    var n = cc.ControlUtils.RGBfromHSV(this._hsv);
    cc.Control.prototype.setColor.call(this, cc.color(0 | n.r * 255, 0 | n.g * 255, 0 | n.b * 255)), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
  },
  setColor: function(t) {
    cc.Control.prototype.setColor.call(this, t);
    var e = new cc.RGBA();
    e.r = t.r / 255, e.g = t.g / 255, e.b = t.b / 255, e.a = 1, this._hsv = cc.ControlUtils.HSVfromRGB(e), this._updateHueAndControlPicker();
  },
  getBackground: function() {
    return this._background;
  },
  init: function() {
    if (cc.Control.prototype.init.call(this)) {
      cc.spriteFrameCache.addSpriteFrames(res.CCControlColourPickerSpriteSheet_plist);
      var t = new cc.SpriteBatchNode(res.CCControlColourPickerSpriteSheet_png);
      this.addChild(t), this._hsv = new cc.HSV(0, 0, 0), this._background = cc.ControlUtils.addSpriteToTargetWithPosAndAnchor("menuColourPanelBackground.png", t, cc.p(0, 0), cc.p(0.5, 0.5));
      var e = cc.pSub(
        this._background.getPosition(),
        cc.p(this._background.getContentSize().width / 2, this._background.getContentSize().height / 2)
      ), n = 8, r = 28;
      return this._huePicker = new cc.ControlHuePicker(t, cc.p(e.x + n, e.y + n)), this._colourPicker = new cc.ControlSaturationBrightnessPicker(t, cc.p(e.x + r, e.y + r)), this._huePicker.addTargetWithActionForControlEvents(this, this.hueSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED), this._colourPicker.addTargetWithActionForControlEvents(this, this.colourSliderValueChanged, cc.CONTROL_EVENT_VALUECHANGED), this._updateHueAndControlPicker(), this.addChild(this._huePicker), this.addChild(this._colourPicker), this.setContentSize(this._background.getContentSize()), !0;
    } else
      return !1;
  },
  _updateControlPicker: function() {
    this._huePicker.setHue(this._hsv.h), this._colourPicker.updateWithHSV(this._hsv);
  },
  _updateHueAndControlPicker: function() {
    this._huePicker.setHue(this._hsv.h), this._colourPicker.updateWithHSV(this._hsv), this._colourPicker.updateDraggerWithHSV(this._hsv);
  },
  setEnabled: function(t) {
    cc.Control.prototype.setEnabled.call(this, t), this._huePicker !== null && this._huePicker.setEnabled(t), this._colourPicker && this._colourPicker.setEnabled(t);
  },
  onTouchBegan: function() {
    return !1;
  }
});
var _p = cc.ControlColourPicker.prototype;
_p.background;
cc.defineGetterSetter(_p, "background", _p.getBackground);
_p = null;
cc.ControlColourPicker.create = function() {
  return new cc.ControlColourPicker();
};
var res = res || {};
res.CCControlColourPickerSpriteSheet_plist = res.CCControlColourPickerSpriteSheet_plist || "res/extensions/CCControlColourPickerSpriteSheet.plist";
res.CCControlColourPickerSpriteSheet_png = res.CCControlColourPickerSpriteSheet_png || "res/extensions/CCControlColourPickerSpriteSheet.png";
cc.SLIDER_MARGIN_H = 24;
cc.SLIDER_MARGIN_V = 8;
cc.ControlSlider = cc.Control.extend({
  _value: 0,
  _minimumValue: 0,
  _maximumValue: 0,
  _minimumAllowedValue: 0,
  _maximumAllowedValue: 0,
  _thumbSprite: null,
  _progressSprite: null,
  _backgroundSprite: null,
  _className: "ControlSlider",
  ctor: function(t, e, n) {
    if (cc.Control.prototype.ctor.call(this), n != null) {
      var r = new cc.Sprite(t), s = new cc.Sprite(e), o = new cc.Sprite(n);
      this.initWithSprites(r, s, o);
    }
  },
  getValue: function() {
    return this._value;
  },
  setValue: function(t) {
    t = Math.max(t, this._minimumValue), t = Math.min(t, this._maximumValue), this._value = t, this.needsLayout(), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
  },
  getMinimumValue: function() {
    return this._minimumValue;
  },
  setMinimumValue: function(t) {
    this._minimumValue = t, this._minimumAllowedValue = t, this._minimumValue >= (this || window)._maximumValue && (this._maximumValue = (this || window)._minimumValue + 1), this.setValue(this._value);
  },
  getMaximumValue: function() {
    return this._maximumValue;
  },
  setMaximumValue: function(t) {
    this._maximumValue = t, this._maximumAllowedValue = t, this._maximumValue <= (this || window)._minimumValue && (this._minimumValue = (this || window)._maximumValue - 1), this.setValue(this._value);
  },
  isTouchInside: function(t) {
    var e = t.getLocation();
    e = (this || window).getParent().convertToNodeSpace(e);
    var n = (this || window).getBoundingBox();
    return n.width += (this || window)._thumbSprite.getContentSize().width, n.x -= (this || window)._thumbSprite.getContentSize().width / 2, cc.rectContainsPoint(n, e);
  },
  locationFromTouch: function(t) {
    var e = t.getLocation();
    return e = (this || window).convertToNodeSpace(e), e.x < 0 ? e.x = 0 : e.x > this._backgroundSprite.getContentSize().width && (e.x = (this || window)._backgroundSprite.getContentSize().width), e;
  },
  getMinimumAllowedValue: function() {
    return this._minimumAllowedValue;
  },
  setMinimumAllowedValue: function(t) {
    this._minimumAllowedValue = t;
  },
  getMaximumAllowedValue: function() {
    return this._maximumAllowedValue;
  },
  setMaximumAllowedValue: function(t) {
    this._maximumAllowedValue = t;
  },
  getThumbSprite: function() {
    return this._thumbSprite;
  },
  getProgressSprite: function() {
    return this._progressSprite;
  },
  getBackgroundSprite: function() {
    return this._backgroundSprite;
  },
  initWithSprites: function(t, e, n) {
    if (cc.Control.prototype.init.call(this)) {
      this.ignoreAnchorPointForPosition(!1), this._backgroundSprite = t, this._progressSprite = e, this._thumbSprite = n;
      var r = cc.ControlUtils.CCRectUnion(t.getBoundingBox(), n.getBoundingBox());
      return this.setContentSize(r.width, r.height), this._backgroundSprite.setAnchorPoint(0.5, 0.5), this._backgroundSprite.setPosition(r.width / 2, r.height / 2), this.addChild(this._backgroundSprite), this._progressSprite.setAnchorPoint(0, 0.5), this._progressSprite.setPosition(0, r.height / 2), this.addChild(this._progressSprite), this._thumbSprite.setPosition(0, r.height / 2), this.addChild(this._thumbSprite), this._minimumValue = 0, this._maximumValue = 1, this.setValue(this._minimumValue), !0;
    } else
      return !1;
  },
  setEnabled: function(t) {
    cc.Control.prototype.setEnabled.call(this, t), this._thumbSprite && this._thumbSprite.setOpacity(t ? 255 : 128);
  },
  sliderBegan: function(t) {
    this.setSelected(!0), this._thumbSprite.setColor(cc.color.GRAY), this.setValue(this.valueForLocation(t));
  },
  sliderMoved: function(t) {
    this.setValue(this.valueForLocation(t));
  },
  sliderEnded: function(t) {
    this.isSelected() && this.setValue(this.valueForLocation(this._thumbSprite.getPosition())), this._thumbSprite.setColor(cc.color.WHITE), this.setSelected(!1);
  },
  getTouchLocationInControl: function(t) {
    var e = t.getLocation();
    return e = (this || window).convertToNodeSpace(e), e.x < 0 ? e.x = 0 : e.x > this._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H && (e.x = (this || window)._backgroundSprite.getContentSize().width + cc.SLIDER_MARGIN_H), e;
  },
  onTouchBegan: function(t, e) {
    if (!this.isTouchInside(t) || !this.isEnabled() || !this.isVisible())
      return !1;
    var n = (this || window).locationFromTouch(t);
    return this.sliderBegan(n), !0;
  },
  onTouchMoved: function(t, e) {
    var n = (this || window).locationFromTouch(t);
    this.sliderMoved(n);
  },
  onTouchEnded: function(t, e) {
    this.sliderEnded(cc.p(0, 0));
  },
  needsLayout: function() {
    var t = (this._value - this._minimumValue) / (this._maximumValue - this._minimumValue);
    this._thumbSprite.setPositionX(t * this._backgroundSprite.getContentSize().width);
    var e = (this || window)._progressSprite.getTextureRect();
    e = cc.rect(e.x, e.y, this._thumbSprite.getPositionX(), e.height), this._progressSprite.setTextureRect(e, this._progressSprite.isTextureRectRotated()), this._thumbSprite._renderCmd.transform(this._renderCmd);
  },
  valueForLocation: function(t) {
    var e = t.x / this._backgroundSprite.getContentSize().width;
    return Math.max(Math.min(this._minimumValue + e * (this._maximumValue - this._minimumValue), this._maximumAllowedValue), this._minimumAllowedValue);
  }
});
var _p = cc.ControlSlider.prototype;
_p.value;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
_p.minValue;
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
_p.maxValue;
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
_p.minAllowedValue;
cc.defineGetterSetter(_p, "minAllowedValue", _p.getMinimumAllowedValue, _p.setMinimumAllowedValue);
_p.maxAllowedValue;
cc.defineGetterSetter(_p, "maxAllowedValue", _p.getMaximumAllowedValue, _p.setMaximumAllowedValue);
_p.thumbSprite;
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite);
_p.progressSprite;
cc.defineGetterSetter(_p, "progressSprite", _p.getProgressSprite);
_p.backgroundSprite;
cc.defineGetterSetter(_p, "backgroundSprite", _p.getBackgroundSprite);
_p = null;
cc.ControlSlider.create = function(t, e, n) {
  return new cc.ControlSlider(t, e, n);
};
cc.ControlSwitch = cc.Control.extend({
  _switchSprite: null,
  _initialTouchXPosition: 0,
  _moved: !1,
  _on: !1,
  _className: "ControlSwitch",
  ctor: function(t, e, n, r, s, o) {
    cc.Control.prototype.ctor.call(this), o && this.initWithMaskSprite(t, e, n, r, s, o);
  },
  initWithMaskSprite: function(t, e, n, r, s, o) {
    if (!t)
      throw new Error("cc.ControlSwitch.initWithMaskSprite(): maskSprite should be non-null.");
    if (!e)
      throw new Error("cc.ControlSwitch.initWithMaskSprite(): onSprite should be non-null.");
    if (!n)
      throw new Error("cc.ControlSwitch.initWithMaskSprite(): offSprite should be non-null.");
    if (!r)
      throw new Error("cc.ControlSwitch.initWithMaskSprite(): thumbSprite should be non-null.");
    return this.init() ? (this._on = !0, this._switchSprite = new cc.ControlSwitchSprite(), this._switchSprite.initWithMaskSprite(t, e, n, r, s, o), this._switchSprite.setPosition(this._switchSprite.getContentSize().width / 2, this._switchSprite.getContentSize().height / 2), this.addChild(this._switchSprite), this.ignoreAnchorPointForPosition(!1), this.setAnchorPoint(0.5, 0.5), this.setContentSize(this._switchSprite.getContentSize()), !0) : !1;
  },
  setOn: function(t, e) {
    e = e || !1, this._on = t;
    var n = (this || window)._on ? this._switchSprite.getOnPosition() : this._switchSprite.getOffPosition();
    e ? this._switchSprite.runAction(new cc.ActionTween(0.2, "sliderXPosition", this._switchSprite.getSliderXPosition(), n)) : this._switchSprite.setSliderXPosition(n), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
  },
  isOn: function() {
    return this._on;
  },
  hasMoved: function() {
    return this._moved;
  },
  setEnabled: function(t) {
    this._enabled = t, this._switchSprite.setOpacity(t ? 255 : 128);
  },
  locationFromTouch: function(t) {
    var e = t.getLocation();
    return e = (this || window).convertToNodeSpace(e), e;
  },
  onTouchBegan: function(t, e) {
    if (!this.isTouchInside(t) || !this.isEnabled() || !this.isVisible())
      return !1;
    this._moved = !1;
    var n = (this || window).locationFromTouch(t);
    return this._initialTouchXPosition = n.x - this._switchSprite.getSliderXPosition(), this._switchSprite.getThumbSprite().setColor(cc.color.GRAY), this._switchSprite.needsLayout(), !0;
  },
  onTouchMoved: function(t, e) {
    var n = (this || window).locationFromTouch(t);
    n = cc.p(n.x - this._initialTouchXPosition, 0), this._moved = !0, this._switchSprite.setSliderXPosition(n.x);
  },
  onTouchEnded: function(t, e) {
    var n = (this || window).locationFromTouch(t);
    this._switchSprite.getThumbSprite().setColor(cc.color.WHITE), this.hasMoved() ? this.setOn(!(n.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0);
  },
  onTouchCancelled: function(t, e) {
    var n = (this || window).locationFromTouch(t);
    this._switchSprite.getThumbSprite().setColor(cc.color.WHITE), this.hasMoved() ? this.setOn(!(n.x < this._switchSprite.getContentSize().width / 2), !0) : this.setOn(!this._on, !0);
  }
});
cc.ControlSwitch.create = function(t, e, n, r, s, o) {
  return new cc.ControlSwitch(t, e, n, r, s, o);
};
cc.ControlSwitchSprite = cc.Sprite.extend({
  _sliderXPosition: 0,
  _onPosition: 0,
  _offPosition: 0,
  _textureLocation: 0,
  _maskLocation: 0,
  _maskSize: null,
  _onSprite: null,
  _offSprite: null,
  _thumbSprite: null,
  _onLabel: null,
  _offLabel: null,
  _clipper: null,
  _stencil: null,
  _backRT: null,
  ctor: function() {
    cc.Sprite.prototype.ctor.call(this), this._sliderXPosition = 0, this._onPosition = 0, this._offPosition = 0, this._maskLocation = 0, this._maskSize = cc.size(0, 0), this._onSprite = null, this._offSprite = null, this._thumbSprite = null, this._onLabel = null, this._offLabel = null;
  },
  initWithMaskSprite: function(t, e, n, r, s, o) {
    if (cc.Sprite.prototype.init.call(this)) {
      this.setSpriteFrame(t.displayFrame()), this._onPosition = 0, this._offPosition = -e.getContentSize().width + r.getContentSize().width / 2, this._sliderXPosition = (this || window)._onPosition, this.setOnSprite(e), this.setOffSprite(n), this.setThumbSprite(r), this.setOnLabel(s), this.setOffLabel(o), this._stencil = t;
      var a = (this || window)._maskSize = (this || window)._stencil.getContentSize();
      return this._stencil.setPosition(0, 0), this._clipper = new cc.ClippingNode(), this._clipper.setAnchorPoint(0.5, 0.5), this._clipper.setPosition(a.width / 2, a.height / 2), this._clipper.setStencil(this._stencil), this.addChild(this._clipper), this._clipper.addChild(e), this._clipper.addChild(n), this._clipper.addChild(s), this._clipper.addChild(o), this.addChild(this._thumbSprite), this.needsLayout(), !0;
    }
    return !1;
  },
  needsLayout: function() {
    var t = (this || window)._maskSize;
    this._onSprite.setPosition(
      this._onSprite.getContentSize().width / 2 + this._sliderXPosition - t.width / 2,
      this._onSprite.getContentSize().height / 2 - t.height / 2
    ), this._offSprite.setPosition(
      this._onSprite.getContentSize().width + this._offSprite.getContentSize().width / 2 + this._sliderXPosition - t.width / 2,
      this._offSprite.getContentSize().height / 2 - t.height / 2
    ), this._onLabel && this._onLabel.setPosition(
      this._onSprite.getPositionX() - this._thumbSprite.getContentSize().width / 6,
      this._onSprite.getContentSize().height / 2 - t.height / 2
    ), this._offLabel && this._offLabel.setPosition(
      this._offSprite.getPositionX() + this._thumbSprite.getContentSize().width / 6,
      this._offSprite.getContentSize().height / 2 - t.height / 2
    ), this._thumbSprite.setPosition(
      this._onSprite.getContentSize().width + this._sliderXPosition,
      this._maskSize.height / 2
    );
  },
  setSliderXPosition: function(t) {
    t <= (this || window)._offPosition ? t = (this || window)._offPosition : t >= (this || window)._onPosition && (t = (this || window)._onPosition), this._sliderXPosition = t, this.needsLayout();
  },
  getSliderXPosition: function() {
    return this._sliderXPosition;
  },
  _getOnSideWidth: function() {
    return this._onSprite.getContentSize().width;
  },
  _getOffSideWidth: function() {
    return this._offSprite.getContentSize().height;
  },
  updateTweenAction: function(t, e) {
    e === "sliderXPosition" && this.setSliderXPosition(t);
  },
  setOnPosition: function(t) {
    this._onPosition = t;
  },
  getOnPosition: function() {
    return this._onPosition;
  },
  setOffPosition: function(t) {
    this._offPosition = t;
  },
  getOffPosition: function() {
    return this._offPosition;
  },
  setMaskTexture: function(t) {
    this._stencil.setTexture(t);
  },
  getMaskTexture: function() {
    return this._stencil.getTexture();
  },
  setTextureLocation: function(t) {
    this._textureLocation = t;
  },
  getTextureLocation: function() {
    return this._textureLocation;
  },
  setMaskLocation: function(t) {
    this._maskLocation = t;
  },
  getMaskLocation: function() {
    return this._maskLocation;
  },
  setOnSprite: function(t) {
    this._onSprite = t;
  },
  getOnSprite: function() {
    return this._onSprite;
  },
  setOffSprite: function(t) {
    this._offSprite = t;
  },
  getOffSprite: function() {
    return this._offSprite;
  },
  setThumbSprite: function(t) {
    this._thumbSprite = t;
  },
  getThumbSprite: function() {
    return this._thumbSprite;
  },
  setOnLabel: function(t) {
    this._onLabel = t;
  },
  getOnLabel: function() {
    return this._onLabel;
  },
  setOffLabel: function(t) {
    this._offLabel = t;
  },
  getOffLabel: function() {
    return this._offLabel;
  }
});
var _p = cc.ControlSwitchSprite.prototype;
_p.sliderX;
cc.defineGetterSetter(_p, "sliderX", _p.getSliderXPosition, _p.setSliderXPosition);
_p.onPos;
cc.defineGetterSetter(_p, "onPos", _p.getOnPosition, _p.setOnPosition);
_p.offPos;
cc.defineGetterSetter(_p, "offPos", _p.getOffPosition, _p.setOffPosition);
_p.maskTexture;
cc.defineGetterSetter(_p, "maskTexture", _p.getMaskTexture, _p.setMaskTexture);
_p.maskPos;
cc.defineGetterSetter(_p, "maskPos", _p.getMaskLocation, _p.setMaskLocation);
_p.onSprite;
cc.defineGetterSetter(_p, "onSprite", _p.getOnSprite, _p.setOnSprite);
_p.offSprite;
cc.defineGetterSetter(_p, "offSprite", _p.getOffSprite, _p.setOffSprite);
_p.thumbSprite;
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite);
_p.onLabel;
cc.defineGetterSetter(_p, "onLabel", _p.getOnLabel, _p.setOnLabel);
_p.offLabel;
cc.defineGetterSetter(_p, "offLabel", _p.getOffLabel, _p.setOffLabel);
_p.onSideWidth;
cc.defineGetterSetter(_p, "onSideWidth", _p._getOnSideWidth);
_p.offSideWidth;
cc.defineGetterSetter(_p, "offSideWidth", _p._getOffSideWidth);
_p = null;
cc.CONTROL_STEPPER_PARTMINUS = 0;
cc.CONTROL_STEPPER_PARTPLUS = 1;
cc.CONTROL_STEPPER_PARTNONE = 2;
cc.CONTROL_STEPPER_LABELCOLOR_ENABLED = cc.color(55, 55, 55);
cc.CONTROL_STEPPER_LABELCOLOR_DISABLED = cc.color(147, 147, 147);
cc.CONTROL_STEPPER_LABELFONT = "CourierNewPSMT";
cc.AUTOREPEAT_DELTATIME = 0.15;
cc.AUTOREPEAT_INCREASETIME_INCREMENT = 12;
cc.ControlStepper = cc.Control.extend({
  _minusSprite: null,
  _plusSprite: null,
  _minusLabel: null,
  _plusLabel: null,
  _value: 0,
  _continuous: !1,
  _autorepeat: !1,
  _wraps: !1,
  _minimumValue: 0,
  _maximumValue: 0,
  _stepValue: 0,
  _touchInsideFlag: !1,
  _touchedPart: cc.CONTROL_STEPPER_PARTNONE,
  _autorepeatCount: 0,
  _className: "ControlStepper",
  ctor: function(t, e) {
    cc.Control.prototype.ctor.call(this), this._minusSprite = null, this._plusSprite = null, this._minusLabel = null, this._plusLabel = null, this._value = 0, this._continuous = !1, this._autorepeat = !1, this._wraps = !1, this._minimumValue = 0, this._maximumValue = 0, this._stepValue = 0, this._touchInsideFlag = !1, this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._autorepeatCount = 0, e && this.initWithMinusSpriteAndPlusSprite(t, e);
  },
  initWithMinusSpriteAndPlusSprite: function(t, e) {
    if (!t)
      throw new Error("cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Minus sprite should be non-null.");
    if (!e)
      throw new Error("cc.ControlStepper.initWithMinusSpriteAndPlusSprite(): Plus sprite should be non-null.");
    if (this.init()) {
      this._autorepeat = !0, this._continuous = !0, this._minimumValue = 0, this._maximumValue = 100, this._value = 0, this._stepValue = 1, this._wraps = !1, this.ignoreAnchorPointForPosition(!1), this.setMinusSprite(t), this._minusSprite.setPosition(t.getContentSize().width / 2, t.getContentSize().height / 2), this.addChild(this._minusSprite), this.setMinusLabel(new cc.LabelTTF("-", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER)), this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_DISABLED), this._minusLabel.setPosition(this._minusSprite.getContentSize().width / 2, this._minusSprite.getContentSize().height / 2), this._minusSprite.addChild(this._minusLabel), this.setPlusSprite(e), this._plusSprite.setPosition(
        t.getContentSize().width + e.getContentSize().width / 2,
        t.getContentSize().height / 2
      ), this.addChild(this._plusSprite), this.setPlusLabel(new cc.LabelTTF("+", cc.CONTROL_STEPPER_LABELFONT, 40, cc.size(40, 40), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER)), this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setPosition(this._plusSprite.getContentSize().width / 2, this._plusSprite.getContentSize().height / 2), this._plusSprite.addChild(this._plusLabel);
      var n = cc.ControlUtils.CCRectUnion(this._minusSprite.getBoundingBox(), this._plusSprite.getBoundingBox());
      return this.setContentSize(this._minusSprite.getContentSize().width + this._plusSprite.getContentSize().height, n.height), !0;
    }
    return !1;
  },
  setWraps: function(t) {
    this._wraps = t, this._wraps && (this._minusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(cc.CONTROL_STEPPER_LABELCOLOR_ENABLED)), this.setValue(this._value);
  },
  getWraps: function() {
    return this._wraps;
  },
  setMinimumValue: function(t) {
    if (t >= (this || window)._maximumValue)
      throw new Error("cc.ControlStepper.setMinimumValue(): minimumValue should be numerically less than maximumValue.");
    this._minimumValue = t, this.setValue(this._value);
  },
  getMinimumValue: function() {
    return this._minimumValue;
  },
  setMaximumValue: function(t) {
    if (t <= (this || window)._minimumValue)
      throw new Error("cc.ControlStepper.setMaximumValue(): maximumValue should be numerically less than maximumValue.");
    this._maximumValue = t, this.setValue(this._value);
  },
  getMaximumValue: function() {
    return this._maximumValue;
  },
  setValue: function(t) {
    this.setValueWithSendingEvent(t, !0);
  },
  getValue: function() {
    return this._value;
  },
  setStepValue: function(t) {
    if (t <= 0)
      throw new Error("cc.ControlStepper.setMaximumValue(): stepValue should be numerically greater than 0.");
    this._stepValue = t;
  },
  getStepValue: function() {
    return this._stepValue;
  },
  isContinuous: function() {
    return this._continuous;
  },
  setValueWithSendingEvent: function(t, e) {
    t < this._minimumValue ? t = (this || window)._wraps ? this._maximumValue : this._minimumValue : t > this._maximumValue && (t = (this || window)._wraps ? this._minimumValue : this._maximumValue), this._value = t, this._wraps || (this._minusLabel.setColor(t === (this || window)._minimumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED), this._plusLabel.setColor(t === (this || window)._maximumValue ? cc.CONTROL_STEPPER_LABELCOLOR_DISABLED : cc.CONTROL_STEPPER_LABELCOLOR_ENABLED)), e && this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
  },
  startAutorepeat: function() {
    this._autorepeatCount = -1, this.schedule(this.update, cc.AUTOREPEAT_DELTATIME, cc.REPEAT_FOREVER, cc.AUTOREPEAT_DELTATIME * 3);
  },
  stopAutorepeat: function() {
    this.unschedule(this.update);
  },
  update: function(t) {
    this._autorepeatCount++, !(this._autorepeatCount < cc.AUTOREPEAT_INCREASETIME_INCREMENT && this._autorepeatCount % 3 !== 0) && (this._touchedPart === cc.CONTROL_STEPPER_PARTMINUS ? this.setValueWithSendingEvent(this._value - this._stepValue, this._continuous) : this._touchedPart === cc.CONTROL_STEPPER_PARTPLUS && this.setValueWithSendingEvent(this._value + this._stepValue, this._continuous));
  },
  updateLayoutUsingTouchLocation: function(t) {
    t.x < this._minusSprite.getContentSize().width && this._value > this._minimumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTMINUS, this._minusSprite.setColor(cc.color.GRAY), this._plusSprite.setColor(cc.color.WHITE)) : t.x >= (this || window)._minusSprite.getContentSize().width && this._value < this._maximumValue ? (this._touchedPart = cc.CONTROL_STEPPER_PARTPLUS, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.GRAY)) : (this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE));
  },
  onTouchBegan: function(t, e) {
    if (!this.isTouchInside(t) || !this.isEnabled() || !this.isVisible())
      return !1;
    var n = (this || window).getTouchLocation(t);
    return this.updateLayoutUsingTouchLocation(n), this._touchInsideFlag = !0, this._autorepeat && this.startAutorepeat(), !0;
  },
  onTouchMoved: function(t, e) {
    if (this.isTouchInside(t)) {
      var n = (this || window).getTouchLocation(t);
      this.updateLayoutUsingTouchLocation(n), this._touchInsideFlag || (this._touchInsideFlag = !0, this._autorepeat && this.startAutorepeat());
    } else
      this._touchInsideFlag = !1, this._touchedPart = cc.CONTROL_STEPPER_PARTNONE, this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE), this._autorepeat && this.stopAutorepeat();
  },
  onTouchEnded: function(t, e) {
    if (this._minusSprite.setColor(cc.color.WHITE), this._plusSprite.setColor(cc.color.WHITE), this._autorepeat && this.stopAutorepeat(), this.isTouchInside(t)) {
      var n = (this || window).getTouchLocation(t);
      this.setValue(this._value + (n.x < this._minusSprite.getContentSize().width ? 0 - this._stepValue : this._stepValue));
    }
  },
  setMinusSprite: function(t) {
    this._minusSprite = t;
  },
  getMinusSprite: function() {
    return this._minusSprite;
  },
  setPlusSprite: function(t) {
    this._plusSprite = t;
  },
  getPlusSprite: function() {
    return this._plusSprite;
  },
  setMinusLabel: function(t) {
    this._minusLabel = t;
  },
  getMinusLabel: function() {
    return this._minusLabel;
  },
  setPlusLabel: function(t) {
    this._plusLabel = t;
  },
  getPlusLabel: function() {
    return this._plusLabel;
  }
});
var _p = cc.ControlStepper.prototype;
_p.wraps;
cc.defineGetterSetter(_p, "wraps", _p.getWraps, _p.setWraps);
_p.value;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
_p.minValue;
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
_p.maxValue;
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
_p.stepValue;
cc.defineGetterSetter(_p, "stepValue", _p.getStepValue, _p.setStepValue);
_p.continuous;
cc.defineGetterSetter(_p, "continuous", _p.isContinuous);
_p.minusSprite;
cc.defineGetterSetter(_p, "minusSprite", _p.getMinusSprite, _p.setMinusSprite);
_p.plusSprite;
cc.defineGetterSetter(_p, "plusSprite", _p.getPlusSprite, _p.setPlusSprite);
_p.minusLabel;
cc.defineGetterSetter(_p, "minusLabel", _p.getMinusLabel, _p.setMinusLabel);
_p.plusLabel;
cc.defineGetterSetter(_p, "plusLabel", _p.getPlusLabel, _p.setPlusLabel);
_p = null;
cc.ControlStepper.create = function(t, e) {
  return new cc.ControlStepper(t, e);
};
cc.ControlPotentiometer = cc.Control.extend({
  _thumbSprite: null,
  _progressTimer: null,
  _previousLocation: null,
  _value: 0,
  _minimumValue: 0,
  _maximumValue: 1,
  _className: "ControlPotentiometer",
  ctor: function(t, e, n) {
    if (cc.Control.prototype.ctor.call(this), n != null) {
      var r = new cc.Sprite(t), s = new cc.Sprite(n), o = new cc.ProgressTimer(new cc.Sprite(e));
      this.initWithTrackSprite_ProgressTimer_ThumbSprite(r, o, s);
    }
  },
  initWithTrackSprite_ProgressTimer_ThumbSprite: function(t, e, n) {
    return this.init() ? (this.setProgressTimer(e), this.setThumbSprite(n), this._thumbSprite.setPosition(e.getPosition()), this.addChild(n, 2), this.addChild(e, 1), this.addChild(t), this.setContentSize(t.getContentSize()), this._minimumValue = 0, this._maximumValue = 1, this.setValue(this._minimumValue), !0) : !1;
  },
  setEnabled: function(t) {
    this.setEnabled(t), this._thumbSprite !== null && this._thumbSprite.setOpacity(t ? 255 : 128);
  },
  setValue: function(t) {
    t < this._minimumValue && (t = (this || window)._minimumValue), t > this._maximumValue && (t = (this || window)._maximumValue), this._value = t;
    var e = (t - this._minimumValue) / (this._maximumValue - this._minimumValue);
    this._progressTimer.setPercentage(e * 100), this._thumbSprite.setRotation(e * 360), this.sendActionsForControlEvents(cc.CONTROL_EVENT_VALUECHANGED);
  },
  getValue: function() {
    return this._value;
  },
  setMinimumValue: function(t) {
    this._minimumValue = t, this._minimumValue >= (this || window)._maximumValue && (this._maximumValue = (this || window)._minimumValue + 1), this.setValue(this._maximumValue);
  },
  getMinimumValue: function() {
    return this._minimumValue;
  },
  setMaximumValue: function(t) {
    this._maximumValue = t, this._maximumValue <= (this || window)._minimumValue && (this._minimumValue = (this || window)._maximumValue - 1), this.setValue(this._minimumValue);
  },
  getMaximumValue: function() {
    return this._maximumValue;
  },
  isTouchInside: function(t) {
    var e = (this || window).getTouchLocation(t), n = (this || window).distanceBetweenPointAndPoint(this._progressTimer.getPosition(), e);
    return n < Math.min(this.getContentSize().width / 2, this.getContentSize().height / 2);
  },
  onTouchBegan: function(t, e) {
    return !this.isTouchInside(t) || !this.isEnabled() || !this.isVisible() ? !1 : (this._previousLocation = (this || window).getTouchLocation(t), this.potentiometerBegan(this._previousLocation), !0);
  },
  onTouchMoved: function(t, e) {
    var n = (this || window).getTouchLocation(t);
    this.potentiometerMoved(n);
  },
  onTouchEnded: function(t, e) {
    this.potentiometerEnded(cc.p(0, 0));
  },
  distanceBetweenPointAndPoint: function(t, e) {
    var n = t.x - e.x, r = t.y - e.y;
    return Math.sqrt(n * n + r * r);
  },
  angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint: function(t, e, n, r) {
    var s = e.x - t.x, o = e.y - t.y, a = r.x - n.x, c = r.y - n.y, l = Math.atan2(s, o), h = Math.atan2(a, c);
    return (l - h) * 180 / Math.PI;
  },
  potentiometerBegan: function(t) {
    this.setSelected(!0), this.getThumbSprite().setColor(cc.color.GRAY);
  },
  potentiometerMoved: function(t) {
    var e = (this || window).angleInDegreesBetweenLineFromPoint_toPoint_toLineFromPoint_toPoint(this._progressTimer.getPosition(), t, this._progressTimer.getPosition(), this._previousLocation);
    e > 180 ? e -= 360 : e < -180 && (e += 360), this.setValue(this._value + e / 360 * (this._maximumValue - this._minimumValue)), this._previousLocation = t;
  },
  potentiometerEnded: function(t) {
    this.getThumbSprite().setColor(cc.color.WHITE), this.setSelected(!1);
  },
  setThumbSprite: function(t) {
    this._thumbSprite = t;
  },
  getThumbSprite: function() {
    return this._thumbSprite;
  },
  setProgressTimer: function(t) {
    this._progressTimer = t;
  },
  getProgressTimer: function() {
    return this._progressTimer;
  },
  setPreviousLocation: function(t) {
    this._previousLocation = t;
  },
  getPreviousLocation: function() {
    return this._previousLocation;
  }
});
var _p = cc.ControlPotentiometer.prototype;
_p.value;
cc.defineGetterSetter(_p, "value", _p.getValue, _p.setValue);
_p.minValue;
cc.defineGetterSetter(_p, "minValue", _p.getMinimumValue, _p.setMinimumValue);
_p.maxValue;
cc.defineGetterSetter(_p, "maxValue", _p.getMaximumValue, _p.setMaximumValue);
_p.progressTimer;
cc.defineGetterSetter(_p, "progressTimer", _p.getProgressTimer, _p.setProgressTimer);
_p.thumbSprite;
cc.defineGetterSetter(_p, "thumbSprite", _p.getThumbSprite, _p.setThumbSprite);
_p.prevLocation;
cc.defineGetterSetter(_p, "prevLocation", _p.getPreviousLocation, _p.setPreviousLocation);
_p = null;
cc.ControlPotentiometer.create = function(t, e, n) {
  return new cc.ControlPotentiometer(t, e, n);
};
cc.SCROLLVIEW_DIRECTION_NONE = -1;
cc.SCROLLVIEW_DIRECTION_HORIZONTAL = 0;
cc.SCROLLVIEW_DIRECTION_VERTICAL = 1;
cc.SCROLLVIEW_DIRECTION_BOTH = 2;
var SCROLL_DEACCEL_RATE = 0.95, SCROLL_DEACCEL_DIST = 1, BOUNCE_DURATION = 0.15, INSET_RATIO = 0.2, MOVE_INCH = 7 / 160, BOUNCE_BACK_FACTOR = 0.35;
cc.convertDistanceFromPointToInch = function(t) {
  var e = cc.view, n = (e.getScaleX() + e.getScaleY()) / 2;
  return t * n / 160;
};
cc.ScrollViewDelegate = cc.Class.extend({
  scrollViewDidScroll: function(t) {
  },
  scrollViewDidZoom: function(t) {
  }
});
cc.ScrollView = cc.Layer.extend({
  _zoomScale: 0,
  _minZoomScale: 0,
  _maxZoomScale: 0,
  _delegate: null,
  _direction: cc.SCROLLVIEW_DIRECTION_BOTH,
  _dragging: !1,
  _contentOffset: null,
  _container: null,
  _touchMoved: !1,
  _maxInset: null,
  _minInset: null,
  _bounceable: !1,
  _clippingToBounds: !1,
  _scrollDistance: null,
  _touchPoint: null,
  _touchLength: 0,
  _touches: null,
  _viewSize: null,
  _minScale: 0,
  _maxScale: 0,
  _parentScissorRect: null,
  _scissorRestored: !1,
  _tmpViewRect: null,
  _touchListener: null,
  _className: "ScrollView",
  ctor: function(t, e) {
    cc.Layer.prototype.ctor.call(this), this._contentOffset = cc.p(0, 0), this._maxInset = cc.p(0, 0), this._minInset = cc.p(0, 0), this._scrollDistance = cc.p(0, 0), this._touchPoint = cc.p(0, 0), this._touches = [], this._viewSize = cc.size(0, 0), this._parentScissorRect = new cc.Rect(0, 0, 0, 0), this._tmpViewRect = new cc.Rect(0, 0, 0, 0), e != null ? this.initWithViewSize(t, e) : this.initWithViewSize(cc.size(200, 200), null);
  },
  init: function() {
    return this.initWithViewSize(cc.size(200, 200), null);
  },
  initWithViewSize: function(t, e) {
    var n = cc.p(0, 0);
    return cc.Layer.prototype.init.call(this) ? (!e && !this._container && (e = new cc.Layer()), e && this.setContainer(e), this.setViewSize(t), this.setTouchEnabled(!0), this._touches.length = 0, this._delegate = null, this._bounceable = !0, this._clippingToBounds = !0, this._direction = cc.SCROLLVIEW_DIRECTION_BOTH, this._container.setPosition(n), this._touchLength = 0, this._minScale = (this || window)._maxScale = 1, !0) : !1;
  },
  setContentOffset: function(t, e) {
    if (e) {
      this.setContentOffsetInDuration(t, BOUNCE_DURATION);
      return;
    }
    if (!this._bounceable) {
      var n = (this || window).minContainerOffset(), r = (this || window).maxContainerOffset();
      t.x = Math.max(n.x, Math.min(r.x, t.x)), t.y = Math.max(n.y, Math.min(r.y, t.y));
    }
    this._container.setPosition(t);
    var s = (this || window)._delegate;
    s != null && s.scrollViewDidScroll && s.scrollViewDidScroll(this);
  },
  getContentOffset: function() {
    var t = (this || window)._container.getPosition();
    return cc.p(t.x, t.y);
  },
  setContentOffsetInDuration: function(t, e) {
    var n = cc.moveTo(e, t), r = cc.callFunc(this._stoppedAnimatedScroll, this);
    this._container.runAction(cc.sequence(n, r)), this.schedule(this._performedAnimatedScroll);
  },
  setZoomScale: function(t, e) {
    if (e) {
      this.setZoomScaleInDuration(t, BOUNCE_DURATION);
      return;
    }
    var n = (this || window)._container;
    if (n.getScale() !== t) {
      var r, s, o;
      if (this._touchLength === 0) {
        var a = (this || window)._viewSize;
        o = cc.p(a.width * 0.5, a.height * 0.5), o = (this || window).convertToWorldSpace(o);
      } else
        o = (this || window)._touchPoint;
      r = n.convertToNodeSpace(o), n.setScale(Math.max(this._minScale, Math.min(this._maxScale, t))), s = n.convertToWorldSpace(r);
      var c = cc.pSub(o, s);
      this._delegate && this._delegate.scrollViewDidZoom && this._delegate.scrollViewDidZoom(this), this.setContentOffset(cc.pAdd(n.getPosition(), c));
    }
  },
  getZoomScale: function() {
    return this._container.getScale();
  },
  setZoomScaleInDuration: function(t, e) {
    if (e > 0) {
      var n = (this || window)._container.getScale();
      if (n !== t) {
        var r = cc.actionTween(e, "zoomScale", n, t);
        this.runAction(r);
      }
    } else
      this.setZoomScale(t);
  },
  minContainerOffset: function() {
    var t = (this || window)._container, e = t.getContentSize(), n = (this || window)._viewSize;
    return cc.p(
      n.width - e.width * t.getScaleX(),
      n.height - e.height * t.getScaleY()
    );
  },
  maxContainerOffset: function() {
    return cc.p(0, 0);
  },
  isNodeVisible: function(t) {
    var e = (this || window).getContentOffset(), n = (this || window).getViewSize(), r = (this || window).getZoomScale(), s = cc.rect(-e.x / r, -e.y / r, n.width / r, n.height / r);
    return cc.rectIntersectsRect(s, t.getBoundingBox());
  },
  pause: function(t) {
    this._container.pause();
    for (var e = (this || window)._container.getChildren(), n = 0; n < e.length; n++)
      e[n].pause();
    this._super();
  },
  resume: function(t) {
    for (var e = (this || window)._container.getChildren(), n = 0, r = e.length; n < r; n++)
      e[n].resume();
    this._container.resume(), this._super();
  },
  isDragging: function() {
    return this._dragging;
  },
  isTouchMoved: function() {
    return this._touchMoved;
  },
  isBounceable: function() {
    return this._bounceable;
  },
  setBounceable: function(t) {
    this._bounceable = t;
  },
  getViewSize: function() {
    return this._viewSize;
  },
  setViewSize: function(t) {
    this._viewSize = t, cc.Node.prototype.setContentSize.call(this, t);
  },
  getContainer: function() {
    return this._container;
  },
  setContainer: function(t) {
    t && (this.removeAllChildren(!0), this._container = t, t.ignoreAnchorPointForPosition(!1), t.setAnchorPoint(0, 0), this.addChild(t), this.setViewSize(this._viewSize));
  },
  getDirection: function() {
    return this._direction;
  },
  setDirection: function(t) {
    this._direction = t;
  },
  getDelegate: function() {
    return this._delegate;
  },
  setDelegate: function(t) {
    this._delegate = t;
  },
  onTouchBegan: function(t, e) {
    for (var n = (this || window); n != null; n = n.parent)
      if (!n.isVisible())
        return !1;
    var r = (this || window)._getViewRect(), s = (this || window)._container, o = s.convertToWorldSpace(s.convertTouchToNodeSpace(t)), a = (this || window)._touches;
    return a.length > 2 || this._touchMoved || !cc.rectContainsPoint(r, o) ? !1 : (a.push(t), a.length === 1 ? (this._touchPoint = (this || window).convertTouchToNodeSpace(t), this._touchMoved = !1, this._dragging = !0, this._scrollDistance.x = 0, this._scrollDistance.y = 0, this._touchLength = 0) : a.length === 2 && (this._touchPoint = cc.pMidpoint(
      this.convertTouchToNodeSpace(a[0]),
      this.convertTouchToNodeSpace(a[1])
    ), this._touchLength = cc.pDistance(
      s.convertTouchToNodeSpace(a[0]),
      s.convertTouchToNodeSpace(a[1])
    ), this._dragging = !1), !0);
  },
  onTouchMoved: function(t, e) {
    if (this.isVisible()) {
      if (this.setNodeDirty(), this._touches.length === 1 && this._dragging) {
        this._touchMoved = !0, this._getViewRect();
        var n = (this || window).convertTouchToNodeSpace(t), r = cc.pSub(n, this._touchPoint), s = 0, o = (this || window)._direction, a;
        if (o === cc.SCROLLVIEW_DIRECTION_VERTICAL)
          s = r.y, a = (this || window)._container.getPositionY(), this.minContainerOffset().y <= a && a <= (this || window).maxContainerOffset().y || (r.y *= BOUNCE_BACK_FACTOR);
        else if (o === cc.SCROLLVIEW_DIRECTION_HORIZONTAL)
          s = r.x, a = (this || window)._container.getPositionX(), this.minContainerOffset().x <= a && a <= (this || window).maxContainerOffset().x || (r.x *= BOUNCE_BACK_FACTOR);
        else {
          s = Math.sqrt(r.x * r.x + r.y * r.y), a = (this || window)._container.getPositionY();
          var c = (this || window).minContainerOffset(), l = (this || window).maxContainerOffset();
          c.y <= a && a <= l.y || (r.y *= BOUNCE_BACK_FACTOR), a = (this || window)._container.getPositionX(), c.x <= a && a <= l.x || (r.x *= BOUNCE_BACK_FACTOR);
        }
        if (!this._touchMoved && Math.abs(cc.convertDistanceFromPointToInch(s)) < MOVE_INCH)
          return;
        if (this._touchMoved || (r.x = 0, r.y = 0), this._touchPoint = n, this._touchMoved = !0, this._dragging) {
          switch (o) {
            case cc.SCROLLVIEW_DIRECTION_VERTICAL:
              r.x = 0;
              break;
            case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
              r.y = 0;
              break;
          }
          var h = (this || window)._container.getPosition(), u = h.x + r.x, _ = h.y + r.y;
          this._scrollDistance = r, this.setContentOffset(cc.p(u, _));
        }
      } else if (this._touches.length === 2 && !this._dragging) {
        var d = cc.pDistance(
          this._container.convertTouchToNodeSpace(this._touches[0]),
          this._container.convertTouchToNodeSpace(this._touches[1])
        );
        this.setZoomScale(this.getZoomScale() * d / this._touchLength);
      }
    }
  },
  onTouchEnded: function(t, e) {
    this.isVisible() && (this._touches.length === 1 && this._touchMoved && this.schedule(this._deaccelerateScrolling), this._touches.length = 0, this._dragging = !1, this._touchMoved = !1);
  },
  onTouchCancelled: function(t, e) {
    this.isVisible() && (this._touches.length = 0, this._dragging = !1, this._touchMoved = !1);
  },
  setContentSize: function(t, e) {
    this.getContainer() !== null && (e === void 0 ? this.getContainer().setContentSize(t) : this.getContainer().setContentSize(t, e), this.updateInset());
  },
  _setWidth: function(t) {
    var e = (this || window).getContainer();
    e !== null && (e._setWidth(t), this.updateInset());
  },
  _setHeight: function(t) {
    var e = (this || window).getContainer();
    e !== null && (e._setHeight(t), this.updateInset());
  },
  getContentSize: function() {
    return this._container.getContentSize();
  },
  updateInset: function() {
    if (this.getContainer() !== null) {
      var t = (this || window)._viewSize, e = (this || window).maxContainerOffset();
      this._maxInset.x = e.x + t.width * INSET_RATIO, this._maxInset.y = e.y + t.height * INSET_RATIO, e = (this || window).minContainerOffset(), this._minInset.x = e.x - t.width * INSET_RATIO, this._minInset.y = e.y - t.height * INSET_RATIO;
    }
  },
  isClippingToBounds: function() {
    return this._clippingToBounds;
  },
  setClippingToBounds: function(t) {
    this._clippingToBounds = t;
  },
  addChild: function(t, e, n) {
    if (!t)
      throw new Error("child must not nil!");
    e = e || t.getLocalZOrder(), n = n || t.getTag(), this._container !== t ? this._container.addChild(t, e, n) : cc.Layer.prototype.addChild.call(this, t, e, n);
  },
  isTouchEnabled: function() {
    return this._touchListener !== null;
  },
  setTouchEnabled: function(t) {
    if (this._touchListener && cc.eventManager.removeListener(this._touchListener), this._touchListener = null, !t)
      this._dragging = !1, this._touchMoved = !1, this._touches.length = 0;
    else {
      var e = cc.EventListener.create({
        event: cc.EventListener.TOUCH_ONE_BY_ONE
      });
      this.onTouchBegan && (e.onTouchBegan = (this || window).onTouchBegan.bind(this)), this.onTouchMoved && (e.onTouchMoved = (this || window).onTouchMoved.bind(this)), this.onTouchEnded && (e.onTouchEnded = (this || window).onTouchEnded.bind(this)), this.onTouchCancelled && (e.onTouchCancelled = (this || window).onTouchCancelled.bind(this)), this._touchListener = e, cc.eventManager.addListener(e, this);
    }
  },
  _initWithViewSize: function(t) {
    return null;
  },
  _relocateContainer: function(t) {
    var e = (this || window).minContainerOffset(), n = (this || window).maxContainerOffset(), r = (this || window)._direction, s = (this || window)._container.getPosition(), o = s.x, a = s.y;
    (r === cc.SCROLLVIEW_DIRECTION_BOTH || r === cc.SCROLLVIEW_DIRECTION_HORIZONTAL) && (o = Math.max(o, e.x), o = Math.min(o, n.x)), (r === cc.SCROLLVIEW_DIRECTION_BOTH || r === cc.SCROLLVIEW_DIRECTION_VERTICAL) && (a = Math.min(a, n.y), a = Math.max(a, e.y)), (a !== s.y || o !== s.x) && this.setContentOffset(cc.p(o, a), t);
  },
  _deaccelerateScrolling: function(t) {
    if (this._dragging) {
      this.unschedule(this._deaccelerateScrolling);
      return;
    }
    var e, n, r = (this || window)._container.getPosition(), s = (this || window)._scrollDistance;
    this._container.setPosition(r.x + s.x, r.y + s.y), this._bounceable ? (e = (this || window)._maxInset, n = (this || window)._minInset) : (e = (this || window).maxContainerOffset(), n = (this || window).minContainerOffset());
    var o = (this || window)._container.getPositionX(), a = (this || window)._container.getPositionY();
    s.x = s.x * SCROLL_DEACCEL_RATE, s.y = s.y * SCROLL_DEACCEL_RATE, this.setContentOffset(cc.p(o, a)), (Math.abs(s.x) <= SCROLL_DEACCEL_DIST && Math.abs(s.y) <= SCROLL_DEACCEL_DIST || a > e.y || a < n.y || o > e.x || o < n.x || o === e.x || o === n.x || a === e.y || a === n.y) && (this.unschedule(this._deaccelerateScrolling), this._relocateContainer(!0));
  },
  _performedAnimatedScroll: function(t) {
    if (this._dragging) {
      this.unschedule(this._performedAnimatedScroll);
      return;
    }
    this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this);
  },
  _stoppedAnimatedScroll: function(t) {
    this.unschedule(this._performedAnimatedScroll), this._delegate && this._delegate.scrollViewDidScroll && this._delegate.scrollViewDidScroll(this);
  },
  _handleZoom: function() {
  },
  _getViewRect: function() {
    for (var t = (this || window).convertToWorldSpace(cc.p(0, 0)), e = (this || window)._viewSize, n = (this || window).getScaleX(), r = (this || window).getScaleY(), s = (this || window)._parent; s != null; s = s.getParent())
      n *= s.getScaleX(), r *= s.getScaleY();
    n < 0 && (t.x += e.width * n, n = -n), r < 0 && (t.y += e.height * r, r = -r);
    var o = (this || window)._tmpViewRect;
    return o.x = t.x, o.y = t.y, o.width = e.width * n, o.height = e.height * r, o;
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ScrollView.CanvasRenderCmd(this) : new cc.ScrollView.WebGLRenderCmd(this);
  }
});
var _p = cc.ScrollView.prototype;
_p.minOffset;
cc.defineGetterSetter(_p, "minOffset", _p.minContainerOffset);
_p.maxOffset;
cc.defineGetterSetter(_p, "maxOffset", _p.maxContainerOffset);
_p.bounceable;
cc.defineGetterSetter(_p, "bounceable", _p.isBounceable, _p.setBounceable);
_p.viewSize;
cc.defineGetterSetter(_p, "viewSize", _p.getViewSize, _p.setViewSize);
_p.container;
cc.defineGetterSetter(_p, "container", _p.getContainer, _p.setContainer);
_p.direction;
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
_p.delegate;
cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate);
_p.clippingToBounds;
cc.defineGetterSetter(_p, "clippingToBounds", _p.isClippingToBounds, _p.setClippingToBounds);
_p = null;
cc.ScrollView.create = function(t, e) {
  return new cc.ScrollView(t, e);
};
(function() {
  cc.ScrollView.CanvasRenderCmd = function(e) {
    cc.Layer.CanvasRenderCmd.call(this, e), this._needDraw = !1, this.startCmd = new cc.CustomRenderCmd(this, this._startCmd), this.startCmd._canUseDirtyRegion = !0, this.endCmd = new cc.CustomRenderCmd(this, this._endCmd), this.endCmd._canUseDirtyRegion = !0;
  };
  var t = cc.ScrollView.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
  t.constructor = cc.ScrollView.CanvasRenderCmd, t._startCmd = function(e, n, r) {
    var s = (this || window)._node, o = e || cc._renderContext, a = o.getContext();
    if (o.save(), s._clippingToBounds) {
      this._scissorRestored = !1, o.setTransform(this._worldTransform, n, r);
      var c = s.getScaleX(), l = s.getScaleY(), h = s._viewSize.width * c, u = s._viewSize.height * l;
      a.beginPath(), a.rect(0, 0, h, -u), a.closePath(), a.clip();
    }
  }, t._endCmd = function(e) {
    e = e || cc._renderContext, e.restore();
  }, t.visit = function(e) {
    var n = (this || window)._node;
    if (n._visible) {
      var r, s = n._children, o;
      if (this._syncStatus(e), cc.renderer.pushRenderCommand(this.startCmd), s && s.length > 0)
        for (o = s.length, n.sortAllChildren(), r = 0; r < o; r++)
          s[r]._renderCmd.visit(this);
      cc.renderer.pushRenderCommand(this.endCmd), this._dirtyFlag = 0;
    }
  };
})();
cc.SortableObject = cc.Class.extend({
  setObjectID: function(t) {
  },
  getObjectID: function() {
    return 0;
  }
});
cc.SortedObject = cc.SortableObject.extend({
  _objectID: 0,
  ctor: function() {
    this._objectID = 0;
  },
  setObjectID: function(t) {
    this._objectID = t;
  },
  getObjectID: function() {
    return this._objectID;
  }
});
var _compareObject = /* @__PURE__ */ H(function(t, e) {
  return t.getObjectID() - e.getObjectID();
}, "_compareObject");
cc.ArrayForObjectSorting = cc.Class.extend({
  _saveObjectArr: null,
  ctor: function() {
    this._saveObjectArr = [];
  },
  insertSortedObject: function(t) {
    if (!t)
      throw new Error("cc.ArrayForObjectSorting.insertSortedObject(): addObject should be non-null.");
    var e = (this || window).indexOfSortedObject(t);
    this.insertObject(t, e);
  },
  removeSortedObject: function(t) {
    if (this.count() !== 0) {
      var e = (this || window).indexOfSortedObject(t);
      if (e < this.count() && e !== cc.INVALID_INDEX) {
        var n = (this || window).objectAtIndex(e);
        n.getObjectID() === t.getObjectID() && this.removeObjectAtIndex(e);
      }
    }
  },
  setObjectID_ofSortedObject: function(t, e) {
    var n = (this || window).indexOfSortedObject(e);
    if (n < this.count() && n !== cc.INVALID_INDEX) {
      var r = (this || window).objectAtIndex(n);
      r.getObjectID() === e.getObjectID() && (this.removeObjectAtIndex(n), r.setObjectID(t), this.insertSortedObject(r));
    }
  },
  objectWithObjectID: function(t) {
    if (this.count() === 0)
      return null;
    var e = new cc.SortedObject();
    e.setObjectID(t);
    var n = (this || window).indexOfSortedObject(e);
    return n < this.count() && n !== cc.INVALID_INDEX && (e = (this || window).objectAtIndex(n), e.getObjectID() !== t && (e = null)), e;
  },
  getObjectWithObjectID: function(t) {
    return null;
  },
  indexOfSortedObject: function(t) {
    var e = 0;
    if (t)
      for (var n = 0, r = t.getObjectID(), s = (this || window)._saveObjectArr, o = 0; o < s.length; o++) {
        var a = s[o], c = a.getObjectID();
        if (r === c || r >= n && r < c)
          break;
        n = c, e++;
      }
    else
      e = cc.INVALID_INDEX;
    return e;
  },
  count: function() {
    return this._saveObjectArr.length;
  },
  lastObject: function() {
    var t = (this || window)._saveObjectArr;
    return t.length === 0 ? null : t[t.length - 1];
  },
  objectAtIndex: function(t) {
    return this._saveObjectArr[t];
  },
  addObject: function(t) {
    this._saveObjectArr.push(t), this._saveObjectArr.sort(_compareObject);
  },
  removeObjectAtIndex: function(t) {
    this._saveObjectArr.splice(t, 1), this._saveObjectArr.sort(_compareObject);
  },
  insertObject: function(t, e) {
    this._saveObjectArr.splice(e, 0, t), this._saveObjectArr.sort(_compareObject);
  }
});
cc.TABLEVIEW_FILL_TOPDOWN = 0;
cc.TABLEVIEW_FILL_BOTTOMUP = 1;
cc.TableViewCell = cc.Node.extend({
  _idx: 0,
  _className: "TableViewCell",
  getIdx: function() {
    return this._idx;
  },
  setIdx: function(t) {
    this._idx = t;
  },
  reset: function() {
    this._idx = cc.INVALID_INDEX;
  },
  setObjectID: function(t) {
    this._idx = t;
  },
  getObjectID: function() {
    return this._idx;
  }
});
var _p = cc.TableViewCell.prototype;
_p.objectId;
cc.defineGetterSetter(_p, "objectId", _p.getObjectID, _p.setObjectID);
_p = null;
cc.TableViewDelegate = cc.ScrollViewDelegate.extend({
  tableCellTouched: function(t, e) {
  },
  tableCellHighlight: function(t, e) {
  },
  tableCellUnhighlight: function(t, e) {
  },
  tableCellWillRecycle: function(t, e) {
  }
});
cc.TableViewDataSource = cc.Class.extend({
  tableCellSizeForIndex: function(t, e) {
    return this.cellSizeForTable(t);
  },
  cellSizeForTable: function(t) {
    return cc.size(0, 0);
  },
  tableCellAtIndex: function(t, e) {
    return null;
  },
  numberOfCellsInTableView: function(t) {
    return 0;
  }
});
cc.TableView = cc.ScrollView.extend({
  _vOrdering: null,
  _indices: null,
  _cellsFreed: null,
  _dataSource: null,
  _tableViewDelegate: null,
  _oldDirection: null,
  _cellsPositions: null,
  _touchedCell: null,
  ctor: function(t, e, n) {
    cc.ScrollView.prototype.ctor.call(this), this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE, this._cellsPositions = [], this.initWithViewSize(e, n), this.setDataSource(t), this._updateCellPositions(), this._updateContentSize();
  },
  __indexFromOffset: function(t) {
    var e = 0, n = (this || window)._dataSource.numberOfCellsInTableView(this) - 1, r;
    switch (this.getDirection()) {
      case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
        r = t.x;
        break;
      default:
        r = t.y;
        break;
    }
    for (var s = (this || window)._cellsPositions; n >= e; ) {
      var o = 0 | e + (n - e) / 2, a = s[o], c = s[o + 1];
      if (r >= a && r <= c)
        return o;
      r < a ? n = o - 1 : e = o + 1;
    }
    return e <= 0 ? 0 : -1;
  },
  _indexFromOffset: function(t) {
    var e = { x: t.x, y: t.y }, n = (this || window)._dataSource, r = n.numberOfCellsInTableView(this) - 1;
    this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (e.y = (this || window).getContainer().getContentSize().height - e.y);
    var s = (this || window).__indexFromOffset(e);
    return s !== -1 && (s = Math.max(0, s), s > r && (s = cc.INVALID_INDEX)), s;
  },
  __offsetFromIndex: function(t) {
    var e;
    switch (this.getDirection()) {
      case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
        e = cc.p(this._cellsPositions[t], 0);
        break;
      default:
        e = cc.p(0, this._cellsPositions[t]);
        break;
    }
    return e;
  },
  _offsetFromIndex: function(t) {
    var e = (this || window).__offsetFromIndex(t), n = (this || window)._dataSource.tableCellSizeForIndex(this, t);
    return this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (e.y = (this || window).getContainer().getContentSize().height - e.y - n.height), e;
  },
  _updateCellPositions: function() {
    var t = (this || window)._dataSource.numberOfCellsInTableView(this), e = (this || window)._cellsPositions;
    if (t > 0) {
      for (var n = 0, r, s = (this || window)._dataSource, o = 0; o < t; o++)
        switch (e[o] = n, r = s.tableCellSizeForIndex(this, o), this.getDirection()) {
          case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
            n += r.width;
            break;
          default:
            n += r.height;
            break;
        }
      this._cellsPositions[t] = n;
    }
  },
  _updateContentSize: function() {
    var t = cc.size(0, 0), e = (this || window)._dataSource.numberOfCellsInTableView(this);
    if (e > 0) {
      var n = (this || window)._cellsPositions[e];
      switch (this.getDirection()) {
        case cc.SCROLLVIEW_DIRECTION_HORIZONTAL:
          t = cc.size(n, this._viewSize.height);
          break;
        default:
          t = cc.size(this._viewSize.width, n);
          break;
      }
    }
    this.setContentSize(t), this._oldDirection !== (this || window)._direction && (this._direction === cc.SCROLLVIEW_DIRECTION_HORIZONTAL ? this.setContentOffset(cc.p(0, 0)) : this.setContentOffset(cc.p(0, this.minContainerOffset().y)), this._oldDirection = (this || window)._direction);
  },
  _moveCellOutOfSight: function(t) {
    this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, t), this._cellsFreed.addObject(t), this._cellsUsed.removeSortedObject(t), cc.arrayRemoveObject(this._indices, t.getIdx()), t.reset(), t.getParent() === (this || window).getContainer() && this.getContainer().removeChild(t, !0);
  },
  _setIndexForCell: function(t, e) {
    e.setAnchorPoint(0, 0), e.setPosition(this._offsetFromIndex(t)), e.setIdx(t);
  },
  _addCellIfNecessary: function(t) {
    t.getParent() !== (this || window).getContainer() && this.getContainer().addChild(t), this._cellsUsed.insertSortedObject(t);
    var e = (this || window)._indices, n = t.getIdx();
    e.indexOf(n) === -1 && (e.push(n), e.sort(function(r, s) {
      return r - s;
    }));
  },
  getDataSource: function() {
    return this._dataSource;
  },
  setDataSource: function(t) {
    this._dataSource = t;
  },
  getDelegate: function() {
    return this._tableViewDelegate;
  },
  setDelegate: function(t) {
    this._tableViewDelegate = t;
  },
  setVerticalFillOrder: function(t) {
    this._vOrdering !== t && (this._vOrdering = t, this._cellsUsed.count() > 0 && this.reloadData());
  },
  getVerticalFillOrder: function() {
    return this._vOrdering;
  },
  initWithViewSize: function(t, e) {
    return cc.ScrollView.prototype.initWithViewSize.call(this, t, e) ? (this._cellsUsed = new cc.ArrayForObjectSorting(), this._cellsFreed = new cc.ArrayForObjectSorting(), this._indices = [], this._tableViewDelegate = null, this._vOrdering = cc.TABLEVIEW_FILL_BOTTOMUP, this.setDirection(cc.SCROLLVIEW_DIRECTION_VERTICAL), cc.ScrollView.prototype.setDelegate.call(this, this), !0) : !1;
  },
  updateCellAtIndex: function(t) {
    if (!(t === cc.INVALID_INDEX || t > this._dataSource.numberOfCellsInTableView(this) - 1)) {
      var e = (this || window).cellAtIndex(t);
      e && this._moveCellOutOfSight(e), e = (this || window)._dataSource.tableCellAtIndex(this, t), this._setIndexForCell(t, e), this._addCellIfNecessary(e);
    }
  },
  insertCellAtIndex: function(t) {
    if (!(t === cc.INVALID_INDEX || t > this._dataSource.numberOfCellsInTableView(this) - 1)) {
      var e, n = (this || window)._cellsUsed, r = n.objectWithObjectID(t);
      if (r) {
        e = n.indexOfSortedObject(r);
        for (var s = e; s < n.count(); s++)
          r = n.objectAtIndex(s), this._setIndexForCell(r.getIdx() + 1, r);
      }
      r = (this || window)._dataSource.tableCellAtIndex(this, t), this._setIndexForCell(t, r), this._addCellIfNecessary(r), this._updateCellPositions(), this._updateContentSize();
    }
  },
  removeCellAtIndex: function(t) {
    if (!(t === cc.INVALID_INDEX || t > this._dataSource.numberOfCellsInTableView(this) - 1)) {
      var e = (this || window).cellAtIndex(t);
      if (e) {
        var n = (this || window)._cellsUsed, r = n.indexOfSortedObject(e);
        this._moveCellOutOfSight(e), cc.arrayRemoveObject(this._indices, t), this._updateCellPositions();
        for (var s = n.count() - 1; s > r; s--)
          e = n.objectAtIndex(s), this._setIndexForCell(e.getIdx() - 1, e);
      }
    }
  },
  reloadData: function() {
    this._oldDirection = cc.SCROLLVIEW_DIRECTION_NONE;
    for (var t = (this || window)._cellsUsed, e = (this || window)._cellsFreed, n = (this || window).getContainer(), r = 0, s = t.count(); r < s; r++) {
      var o = t.objectAtIndex(r);
      this._tableViewDelegate && this._tableViewDelegate.tableCellWillRecycle && this._tableViewDelegate.tableCellWillRecycle(this, o), e.addObject(o), o.reset(), o.getParent() === n && n.removeChild(o, !0);
    }
    this._indices = [], this._cellsUsed = new cc.ArrayForObjectSorting(), this._updateCellPositions(), this._updateContentSize(), this._dataSource.numberOfCellsInTableView(this) > 0 && this.scrollViewDidScroll(this), this.setNodeDirty();
  },
  dequeueCell: function() {
    if (this._cellsFreed.count() === 0)
      return null;
    var t = (this || window)._cellsFreed.objectAtIndex(0);
    return this._cellsFreed.removeObjectAtIndex(0), t;
  },
  cellAtIndex: function(t) {
    var e = (this || window)._indices.indexOf(t);
    return e === -1 ? null : this._cellsUsed.objectWithObjectID(t);
  },
  scrollViewDidScroll: function(t) {
    var e = (this || window)._dataSource, n = e.numberOfCellsInTableView(this);
    if (n !== 0) {
      this._tableViewDelegate !== null && this._tableViewDelegate.scrollViewDidScroll && this._tableViewDelegate.scrollViewDidScroll(this);
      var r = 0, s = (this || window)._viewSize, o = (this || window).getContainer(), a = (this || window).getContentOffset();
      a.x *= -1, a.y *= -1;
      var c = Math.max(n - 1, 0);
      this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN && (a.y = a.y + s.height / o.getScaleY());
      var l = (this || window)._indexFromOffset(a);
      l === cc.INVALID_INDEX && (l = n - 1), this._vOrdering === cc.TABLEVIEW_FILL_TOPDOWN ? a.y -= s.height / o.getScaleY() : a.y += s.height / o.getScaleY(), a.x += s.width / o.getScaleX();
      var h = (this || window)._indexFromOffset(a);
      h === cc.INVALID_INDEX && (h = n - 1);
      var u, _ = (this || window)._cellsUsed;
      if (_.count() > 0)
        for (u = _.objectAtIndex(0), r = u.getIdx(); r < l && (this._moveCellOutOfSight(u), _.count() > 0); )
          u = _.objectAtIndex(0), r = u.getIdx();
      if (_.count() > 0)
        for (u = _.lastObject(), r = u.getIdx(); r <= c && r > h && (this._moveCellOutOfSight(u), _.count() > 0); )
          u = _.lastObject(), r = u.getIdx();
      for (var d = (this || window)._indices, f = l; f <= h; f++)
        d.indexOf(f) === -1 && this.updateCellAtIndex(f);
    }
  },
  scrollViewDidZoom: function(t) {
  },
  onTouchEnded: function(t, e) {
    if (this.isVisible()) {
      if (this._touchedCell) {
        var n = (this || window).getBoundingBox(), r = cc.p(n.x, n.y);
        r = (this || window)._parent.convertToWorldSpace(r), n.x = r.x, n.y = r.y;
        var s = (this || window)._tableViewDelegate;
        cc.rectContainsPoint(n, t.getLocation()) && s !== null && (s.tableCellUnhighlight && s.tableCellUnhighlight(this, this._touchedCell), s.tableCellTouched && s.tableCellTouched(this, this._touchedCell)), this._touchedCell = null;
      }
      cc.ScrollView.prototype.onTouchEnded.call(this, t, e);
    }
  },
  onTouchBegan: function(t, e) {
    for (var n = (this || window); n != null; n = n.parent)
      if (!n.isVisible())
        return !1;
    var r = cc.ScrollView.prototype.onTouchBegan.call(this, t, e);
    if (this._touches.length === 1) {
      var s, o;
      o = (this || window).getContainer().convertTouchToNodeSpace(t), s = (this || window)._indexFromOffset(o), s === cc.INVALID_INDEX ? this._touchedCell = null : this._touchedCell = (this || window).cellAtIndex(s), this._touchedCell && this._tableViewDelegate !== null && this._tableViewDelegate.tableCellHighlight && this._tableViewDelegate.tableCellHighlight(this, this._touchedCell);
    } else
      this._touchedCell && (this._tableViewDelegate !== null && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null);
    return r;
  },
  onTouchMoved: function(t, e) {
    cc.ScrollView.prototype.onTouchMoved.call(this, t, e), this._touchedCell && this.isTouchMoved() && (this._tableViewDelegate !== null && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null);
  },
  onTouchCancelled: function(t, e) {
    cc.ScrollView.prototype.onTouchCancelled.call(this, t, e), this._touchedCell && (this._tableViewDelegate !== null && this._tableViewDelegate.tableCellUnhighlight && this._tableViewDelegate.tableCellUnhighlight(this, this._touchedCell), this._touchedCell = null);
  }
});
var _p = cc.TableView.prototype;
_p.dataSource;
cc.defineGetterSetter(_p, "dataSource", _p.getDataSource, _p.setDataSource);
_p.delegate;
cc.defineGetterSetter(_p, "delegate", _p.getDelegate, _p.setDelegate);
_p.verticalFillOrder;
cc.defineGetterSetter(_p, "verticalFillOrder", _p.getVerticalFillOrder, _p.setVerticalFillOrder);
_p = null;
cc.TableView.create = function(t, e, n) {
  return new cc.TableView(t, e, n);
};
(function() {
  cc.ScrollView.WebGLRenderCmd = function(e) {
    cc.Layer.WebGLRenderCmd.call(this, e), this._needDraw = !1, this.startCmd = new cc.CustomRenderCmd(this, this._startCmd), this.endCmd = new cc.CustomRenderCmd(this, this._endCmd);
  };
  var t = cc.ScrollView.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
  t.constructor = cc.ScrollView.WebGLRenderCmd, t._startCmd = function() {
    var e = (this || window)._node, n = cc.view, r = e._getViewRect();
    if (n.isScissorEnabled()) {
      if (e._scissorRestored = !0, e._parentScissorRect = n.getScissorRect(), cc.rectIntersection(r, e._parentScissorRect)) {
        var s = e._parentScissorRect, o = Math.max(r.x, s.x), a = Math.max(r.y, s.y), c = Math.min(r.x + r.width, s.x + s.width), l = Math.min(r.y + r.height, s.y + s.height);
        n.setScissorInPoints(o, a, c - o, l - a);
      }
    } else {
      var h = cc._renderContext;
      h.enable(h.SCISSOR_TEST), n.setScissorInPoints(r.x, r.y, r.width, r.height);
    }
  }, t._endCmd = function() {
    var e = (this || window)._node;
    if (e._scissorRestored) {
      var n = e._parentScissorRect;
      cc.view.setScissorInPoints(n.x, n.y, n.width, n.height);
    } else {
      var r = cc._renderContext;
      r.disable(r.SCISSOR_TEST);
    }
  }, t.visit = function(e) {
    var n = (this || window)._node;
    if (n._visible) {
      var r, s = n._children, o, a;
      if (this._syncStatus(e), n._clippingToBounds && cc.renderer.pushRenderCommand(this.startCmd), s && s.length > 0) {
        for (a = s.length, r = 0; r < a && (o = s[r], o && o._localZOrder < 0); r++)
          o._renderCmd.visit();
        for (; r < a; r++)
          s[r]._renderCmd.visit();
      }
      n._clippingToBounds && cc.renderer.pushRenderCommand(this.endCmd), this._dirtyFlag = 0;
    }
  };
})();
var PROPERTY_POSITION = "position", PROPERTY_CONTENTSIZE = "contentSize", PROPERTY_SKEW = "skew", PROPERTY_ANCHORPOINT = "anchorPoint", PROPERTY_SCALE = "scale", PROPERTY_ROTATION = "rotation", PROPERTY_TAG = "tag", PROPERTY_IGNOREANCHORPOINTFORPOSITION = "ignoreAnchorPointForPosition", PROPERTY_VISIBLE = "visible", ASSERT_FAIL_UNEXPECTED_PROPERTY = /* @__PURE__ */ H(function(t) {
  cc.log("Unexpected property: '" + t + "'!");
}, "ASSERT_FAIL_UNEXPECTED_PROPERTY"), ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE = /* @__PURE__ */ H(function(t) {
  cc.log("Unexpected property type: '" + t + "'!");
}, "ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE");
function BlockData(t, e) {
  this.selMenuHander = t, this.target = e;
}
H(BlockData, "BlockData");
function BlockCCControlData(t, e, n) {
  this.selCCControlHandler = t, this.target = e, this.controlEvents = n;
}
H(BlockCCControlData, "BlockCCControlData");
cc.NodeLoader = cc.Class.extend({
  _customProperties: null,
  ctor: function() {
    this._customProperties = new cc._Dictionary();
  },
  loadCCNode: function(t, e) {
    return this._createCCNode(t, e);
  },
  parseProperties: function(t, e, n) {
    for (var r = n.readInt(!1), s = n.readInt(!1), o = r + s, a = 0; a < o; a++) {
      var c = a >= r, l = n.readInt(!1), h = n.readCachedString(), u = !1, _ = n.readByte();
      if ((_ === CCB_PLATFORM_ALL || _ === CCB_PLATFORM_IOS || _ === CCB_PLATFORM_MAC) && (u = !0), t instanceof cc.BuilderFile) {
        if (t.getCCBFileNode() && c) {
          t = t.getCCBFileNode();
          var d = t.userObject;
          u = d.indexOf(h) !== -1;
        }
      } else if (c && t === n.getAnimationManager().getRootNode()) {
        var f = t.userObject;
        f || (f = [], t.userObject = f), f.push(h);
      }
      switch (l) {
        case CCB_PROPTYPE_POSITION: {
          var C = (this || window).parsePropTypePosition(t, e, n, h);
          u && this.onHandlePropTypePosition(t, e, h, C, n);
          break;
        }
        case CCB_PROPTYPE_POINT: {
          var m = (this || window).parsePropTypePoint(t, e, n);
          u && this.onHandlePropTypePoint(t, e, h, m, n);
          break;
        }
        case CCB_PROPTYPE_POINTLOCK: {
          var g = (this || window).parsePropTypePointLock(t, e, n);
          u && this.onHandlePropTypePointLock(t, e, h, g, n);
          break;
        }
        case CCB_PROPTYPE_SIZE: {
          var y = (this || window).parsePropTypeSize(t, e, n);
          u && this.onHandlePropTypeSize(t, e, h, y, n);
          break;
        }
        case CCB_PROPTYPE_SCALELOCK: {
          var A = (this || window).parsePropTypeScaleLock(t, e, n, h);
          u && this.onHandlePropTypeScaleLock(t, e, h, A, n);
          break;
        }
        case CCB_PROPTYPE_FLOATXY: {
          var D = (this || window).parsePropTypeFloatXY(t, e, n);
          u && this.onHandlePropTypeFloatXY(t, e, h, D, n);
          break;
        }
        case CCB_PROPTYPE_FLOAT: {
          var N = (this || window).parsePropTypeFloat(t, e, n);
          u && this.onHandlePropTypeFloat(t, e, h, N, n);
          break;
        }
        case CCB_PROPTYPE_DEGREES: {
          var z = (this || window).parsePropTypeDegrees(t, e, n, h);
          u && this.onHandlePropTypeDegrees(t, e, h, z, n);
          break;
        }
        case CCB_PROPTYPE_FLOATSCALE: {
          var M = (this || window).parsePropTypeFloatScale(t, e, n);
          u && this.onHandlePropTypeFloatScale(t, e, h, M, n);
          break;
        }
        case CCB_PROPTYPE_INTEGER: {
          var Z = (this || window).parsePropTypeInteger(t, e, n);
          u && this.onHandlePropTypeInteger(t, e, h, Z, n);
          break;
        }
        case CCB_PROPTYPE_INTEGERLABELED: {
          var U = (this || window).parsePropTypeIntegerLabeled(t, e, n);
          u && this.onHandlePropTypeIntegerLabeled(t, e, h, U, n);
          break;
        }
        case CCB_PROPTYPE_FLOATVAR: {
          var Q = (this || window).parsePropTypeFloatVar(t, e, n);
          u && this.onHandlePropTypeFloatVar(t, e, h, Q, n);
          break;
        }
        case CCB_PROPTYPE_CHECK: {
          var et = (this || window).parsePropTypeCheck(t, e, n, h);
          u && this.onHandlePropTypeCheck(t, e, h, et, n);
          break;
        }
        case CCB_PROPTYPE_SPRITEFRAME: {
          var rt = (this || window).parsePropTypeSpriteFrame(t, e, n, h);
          u && this.onHandlePropTypeSpriteFrame(t, e, h, rt, n);
          break;
        }
        case CCB_PROPTYPE_ANIMATION: {
          var w = (this || window).parsePropTypeAnimation(t, e, n);
          u && this.onHandlePropTypeAnimation(t, e, h, w, n);
          break;
        }
        case CCB_PROPTYPE_TEXTURE: {
          var L = (this || window).parsePropTypeTexture(t, e, n);
          u && this.onHandlePropTypeTexture(t, e, h, L, n);
          break;
        }
        case CCB_PROPTYPE_BYTE: {
          var G = (this || window).parsePropTypeByte(t, e, n, h);
          u && this.onHandlePropTypeByte(t, e, h, G, n);
          break;
        }
        case CCB_PROPTYPE_COLOR3: {
          var I = (this || window).parsePropTypeColor3(t, e, n, h);
          u && this.onHandlePropTypeColor3(t, e, h, I, n);
          break;
        }
        case CCB_PROPTYPE_COLOR4VAR: {
          var O = (this || window).parsePropTypeColor4FVar(t, e, n);
          u && this.onHandlePropTypeColor4FVar(t, e, h, O, n);
          break;
        }
        case CCB_PROPTYPE_FLIP: {
          var K = (this || window).parsePropTypeFlip(t, e, n);
          u && this.onHandlePropTypeFlip(t, e, h, K, n);
          break;
        }
        case CCB_PROPTYPE_BLENDMODE: {
          var $ = (this || window).parsePropTypeBlendFunc(t, e, n);
          u && this.onHandlePropTypeBlendFunc(t, e, h, $, n);
          break;
        }
        case CCB_PROPTYPE_FNTFILE: {
          var S = n.getCCBRootPath() + this.parsePropTypeFntFile(t, e, n);
          u && this.onHandlePropTypeFntFile(t, e, h, S, n);
          break;
        }
        case CCB_PROPTYPE_FONTTTF: {
          var b = (this || window).parsePropTypeFontTTF(t, e, n);
          u && this.onHandlePropTypeFontTTF(t, e, h, b, n);
          break;
        }
        case CCB_PROPTYPE_STRING: {
          var W = (this || window).parsePropTypeString(t, e, n);
          u && this.onHandlePropTypeString(t, e, h, W, n);
          break;
        }
        case CCB_PROPTYPE_TEXT: {
          var x = (this || window).parsePropTypeText(t, e, n);
          u && this.onHandlePropTypeText(t, e, h, x, n);
          break;
        }
        case CCB_PROPTYPE_BLOCK: {
          var E = (this || window).parsePropTypeBlock(t, e, n);
          u && this.onHandlePropTypeBlock(t, e, h, E, n);
          break;
        }
        case CCB_PROPTYPE_BLOCKCCCONTROL: {
          var R = (this || window).parsePropTypeBlockCCControl(t, e, n);
          u && R != null && this.onHandlePropTypeBlockCCControl(t, e, h, R, n);
          break;
        }
        case CCB_PROPTYPE_CCBFILE: {
          var F = (this || window).parsePropTypeCCBFile(t, e, n);
          u && this.onHandlePropTypeCCBFile(t, e, h, F, n);
          break;
        }
        default:
          ASSERT_FAIL_UNEXPECTED_PROPERTYTYPE(l);
          break;
      }
    }
  },
  getCustomProperties: function() {
    return this._customProperties;
  },
  _createCCNode: function(t, e) {
    return new cc.Node();
  },
  parsePropTypePosition: function(t, e, n, r) {
    var s = n.readFloat(), o = n.readFloat(), a = n.readInt(!1), c = n.getAnimationManager().getContainerSize(e), l = cc._getAbsolutePosition(s, o, a, c, r);
    if (t.setPosition(cc.getAbsolutePosition(l, a, c, r)), n.getAnimatedProperties().indexOf(r) > -1) {
      var h = [s, o, a];
      n.getAnimationManager().setBaseValue(h, t, r);
    }
    return l;
  },
  parsePropTypePoint: function(t, e, n) {
    var r = n.readFloat(), s = n.readFloat();
    return cc.p(r, s);
  },
  parsePropTypePointLock: function(t, e, n) {
    var r = n.readFloat(), s = n.readFloat();
    return cc.p(r, s);
  },
  parsePropTypeSize: function(t, e, n) {
    var r = n.readFloat(), s = n.readFloat(), o = n.readInt(!1), a = n.getAnimationManager().getContainerSize(e);
    switch (o) {
      case CCB_SIZETYPE_ABSOLUTE:
        break;
      case CCB_SIZETYPE_RELATIVE_CONTAINER:
        r = a.width - r, s = a.height - s;
        break;
      case CCB_SIZETYPE_PERCENT:
        r = a.width * r / 100, s = a.height * s / 100;
        break;
      case CCB_SIZETYPE_HORIZONTAL_PERCENT:
        r = a.width * r / 100;
        break;
      case CCB_SIZETYPE_VERTICAL_PERCENT:
        s = a.height * s / 100;
        break;
      case CCB_SIZETYPE_MULTIPLY_RESOLUTION:
        var c = cc.BuilderReader.getResolutionScale();
        r *= c, s *= c;
        break;
      default:
        cc.log("Unknown CCB type.");
        break;
    }
    return cc.size(r, s);
  },
  parsePropTypeScaleLock: function(t, e, n, r) {
    var s = n.readFloat(), o = n.readFloat(), a = n.readInt(!1);
    return cc.setRelativeScale(t, s, o, a, r), n.getAnimatedProperties().indexOf(r) > -1 && n.getAnimationManager().setBaseValue([s, o, a], t, r), a === CCB_SCALETYPE_MULTIPLY_RESOLUTION && (s *= cc.BuilderReader.getResolutionScale(), o *= cc.BuilderReader.getResolutionScale()), [s, o];
  },
  parsePropTypeFloat: function(t, e, n) {
    return n.readFloat();
  },
  parsePropTypeDegrees: function(t, e, n, r) {
    var s = n.readFloat();
    return n.getAnimatedProperties().indexOf(r) > -1 && n.getAnimationManager().setBaseValue(s, t, r), s;
  },
  parsePropTypeFloatScale: function(t, e, n) {
    var r = n.readFloat(), s = n.readInt(!1);
    return s === CCB_SCALETYPE_MULTIPLY_RESOLUTION && (r *= cc.BuilderReader.getResolutionScale()), r;
  },
  parsePropTypeInteger: function(t, e, n) {
    return n.readInt(!0);
  },
  parsePropTypeIntegerLabeled: function(t, e, n) {
    return n.readInt(!0);
  },
  parsePropTypeFloatVar: function(t, e, n) {
    var r = n.readFloat(), s = n.readFloat();
    return [r, s];
  },
  parsePropTypeCheck: function(t, e, n, r) {
    var s = n.readBool();
    return n.getAnimatedProperties().indexOf(r) > -1 && n.getAnimationManager().setBaseValue(s, t, r), s;
  },
  parsePropTypeSpriteFrame: function(t, e, n, r) {
    var s = n.readCachedString(), o = n.readCachedString(), a;
    if (o != null && o.length !== 0) {
      if (s.length === 0) {
        o = n.getCCBRootPath() + o;
        var c = cc.textureCache.addImage(o), l = c.getContentSize(), h = cc.rect(0, 0, l.width, l.height);
        a = new cc.SpriteFrame(c, h);
      } else {
        var u = cc.spriteFrameCache;
        s = n.getCCBRootPath() + s, n.getLoadedSpriteSheet().indexOf(s) === -1 && (u.addSpriteFrames(s), n.getLoadedSpriteSheet().push(s)), a = u.getSpriteFrame(o);
      }
      n.getAnimatedProperties().indexOf(r) > -1 && n.getAnimationManager().setBaseValue(a, t, r);
    }
    return a;
  },
  parsePropTypeAnimation: function(t, e, n) {
    var r = n.getCCBRootPath() + n.readCachedString(), s = n.readCachedString(), o = null;
    if (s = cc.BuilderReader.lastPathComponent(s), r = cc.BuilderReader.lastPathComponent(r), s != null && s !== "") {
      var a = cc.animationCache;
      a.addAnimations(r), o = a.getAnimation(s);
    }
    return o;
  },
  parsePropTypeTexture: function(t, e, n) {
    var r = n.getCCBRootPath() + n.readCachedString();
    return r !== "" ? cc.textureCache.addImage(r) : null;
  },
  parsePropTypeByte: function(t, e, n, r) {
    var s = n.readByte();
    return n.getAnimatedProperties().indexOf(r) > -1 && n.getAnimationManager().setBaseValue(s, t, r), s;
  },
  parsePropTypeColor3: function(t, e, n, r) {
    var s = n.readByte(), o = n.readByte(), a = n.readByte(), c = { r: s, g: o, b: a };
    return n.getAnimatedProperties().indexOf(r) > -1 && n.getAnimationManager().setBaseValue(cc.Color3BWapper.create(c), t, r), c;
  },
  parsePropTypeColor4FVar: function(t, e, n) {
    var r = 0 | n.readFloat() * 255, s = 0 | n.readFloat() * 255, o = 0 | n.readFloat() * 255, a = n.readFloat();
    a = a <= 1 ? 0 | a * 255 : a;
    var c = 0 | n.readFloat() * 255, l = 0 | n.readFloat() * 255, h = 0 | n.readFloat() * 255, u = n.readFloat();
    u = u <= 1 ? 0 | u * 255 : u;
    var _ = [];
    return _[0] = { r, g: s, b: o, a }, _[1] = { r: c, g: l, b: h, a: u }, _;
  },
  parsePropTypeFlip: function(t, e, n) {
    var r = n.readBool(), s = n.readBool();
    return [r, s];
  },
  parsePropTypeBlendFunc: function(t, e, n) {
    var r = n.readInt(!1), s = n.readInt(!1);
    return new cc.BlendFunc(r, s);
  },
  parsePropTypeFntFile: function(t, e, n) {
    return n.readCachedString();
  },
  parsePropTypeString: function(t, e, n) {
    return n.readCachedString();
  },
  parsePropTypeText: function(t, e, n) {
    return n.readCachedString();
  },
  parsePropTypeFontTTF: function(t, e, n) {
    return n.readCachedString();
  },
  parsePropTypeBlock: function(t, e, n) {
    var r = n.readCachedString(), s = n.readInt(!1);
    if (s !== CCB_TARGETTYPE_NONE) {
      var o = null;
      if (n.isJSControlled())
        s === CCB_TARGETTYPE_DOCUMENTROOT ? (n.addDocumentCallbackNode(t), n.addDocumentCallbackName(r), n.addDocumentCallbackControlEvents(0)) : (n.addOwnerCallbackNode(t), n.addOwnerCallbackName(r), n.addOwnerCallbackControlEvents(0));
      else if (s === CCB_TARGETTYPE_DOCUMENTROOT ? o = n.getAnimationManager().getRootNode() : s === CCB_TARGETTYPE_OWNER && (o = n.getOwner()), o !== null)
        if (r.length > 0) {
          var a = 0;
          if (o.onResolveCCBCCMenuItemSelector && (a = o.onResolveCCBCCMenuItemSelector(o, r)), a === 0) {
            var c = n.getCCBSelectorResolver();
            c != null && (a = c.onResolveCCBCCMenuItemSelector(o, r));
          }
          if (a === 0)
            cc.log("Skipping selector '" + r + "' since no CCBSelectorResolver is present.");
          else
            return new BlockData(a, o);
        } else
          cc.log("Unexpected empty selector.");
      else
        cc.log("Unexpected NULL target for selector.");
    }
    return null;
  },
  parsePropTypeBlockCCControl: function(t, e, n) {
    var r = n.readCachedString(), s = n.readInt(!1), o = n.readInt(!1);
    if (s !== CCB_TARGETTYPE_NONE)
      if (n.isJSControlled())
        s === CCB_TARGETTYPE_DOCUMENTROOT ? (n.addDocumentCallbackNode(t), n.addDocumentCallbackName(r), n.addDocumentCallbackControlEvents(o)) : (n.addOwnerCallbackNode(t), n.addOwnerCallbackName(r), n.addOwnerCallbackControlEvents(o));
      else {
        var a = null;
        if (s === CCB_TARGETTYPE_DOCUMENTROOT ? a = n.getAnimationManager().getRootNode() : s === CCB_TARGETTYPE_OWNER && (a = n.getOwner()), a !== null)
          if (r.length > 0) {
            var c = 0;
            if (a.onResolveCCBCCControlSelector && (c = a.onResolveCCBCCControlSelector(a, r)), c === 0) {
              var l = n.getCCBSelectorResolver();
              l != null && (c = l.onResolveCCBCCControlSelector(a, r));
            }
            if (c === 0)
              cc.log("Skipping selector '" + r + "' since no CCBSelectorResolver is present.");
            else
              return new BlockCCControlData(c, a, o);
          } else
            cc.log("Unexpected empty selector.");
        else
          cc.log("Unexpected NULL target for selector.");
      }
    return null;
  },
  parsePropTypeCCBFile: function(t, e, n) {
    var r = n.getCCBRootPath() + n.readCachedString(), s = cc.BuilderReader.deletePathExtension(r);
    r = s + ".ccbi";
    var o = new cc.BuilderReader(n), a = cc.loader.getRes(r);
    if (!a) {
      var c = cc.loader.getUrl(r);
      a = cc.loader.loadBinarySync(c), cc.loader.cache[r] = a;
    }
    o.initWithData(a, n.getOwner()), o.getAnimationManager().setRootContainerSize(e.getContentSize()), o.setAnimationManagers(n.getAnimationManagers()), o.getAnimationManager().setOwner(n.getOwner());
    var l = o.readFileWithCleanUp(!1);
    return n.setAnimationManagers(o.getAnimationManagers()), l && o.getAnimationManager().getAutoPlaySequenceId() !== -1 && o.getAnimationManager().runAnimations(o.getAnimationManager().getAutoPlaySequenceId(), 0), l;
  },
  parsePropTypeFloatXY: function(t, e, n) {
    var r = n.readFloat(), s = n.readFloat();
    return [r, s];
  },
  onHandlePropTypePosition: function(t, e, n, r, s) {
    n === PROPERTY_POSITION ? t.setPosition(r) : ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypePoint: function(t, e, n, r, s) {
    n === PROPERTY_ANCHORPOINT ? t.setAnchorPoint(r) : ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypePointLock: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeSize: function(t, e, n, r, s) {
    n === PROPERTY_CONTENTSIZE ? t.setContentSize(r) : ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeScaleLock: function(t, e, n, r, s) {
    n === PROPERTY_SCALE ? (t.setScaleX(r[0]), t.setScaleY(r[1])) : ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeFloatXY: function(t, e, n, r, s) {
    if (n === PROPERTY_SKEW)
      t.setSkewX(r[0]), t.setSkewY(r[1]);
    else {
      var o = n + "X", a = n + "Y";
      (!t[o] || !t[a]) && ASSERT_FAIL_UNEXPECTED_PROPERTY(n), t[o](r[0]), t[a](r[1]);
    }
  },
  onHandlePropTypeFloat: function(t, e, n, r, s) {
    this._customProperties.setObject(r, n);
  },
  onHandlePropTypeDegrees: function(t, e, n, r, s) {
    n === PROPERTY_ROTATION ? t.setRotation(r) : ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeFloatScale: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeInteger: function(t, e, n, r, s) {
    n === PROPERTY_TAG ? t.setTag(r) : ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeIntegerLabeled: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeFloatVar: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeCheck: function(t, e, n, r, s) {
    n === PROPERTY_VISIBLE ? t.setVisible(r) : n === PROPERTY_IGNOREANCHORPOINTFORPOSITION ? t.ignoreAnchorPointForPosition(r) : ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeSpriteFrame: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeAnimation: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeTexture: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeByte: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeColor3: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeColor4FVar: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeFlip: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeBlendFunc: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeFntFile: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeString: function(t, e, n, r, s) {
    this._customProperties.setObject(r, n);
  },
  onHandlePropTypeText: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeFontTTF: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeBlock: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeBlockCCControl: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  },
  onHandlePropTypeCCBFile: function(t, e, n, r, s) {
    ASSERT_FAIL_UNEXPECTED_PROPERTY(n);
  }
});
cc.NodeLoader.loader = function() {
  return new cc.NodeLoader();
};
cc.NodeLoaderListener = cc.Class.extend({
  onNodeLoaded: function(t, e) {
  }
});
cc.BuilderSelectorResolver = cc.Class.extend({
  onResolveCCBCCMenuItemSelector: function(t, e) {
  },
  onResolveCCBCCCallFuncSelector: function(t, e) {
  },
  onResolveCCBCCControlSelector: function(t, e) {
  }
});
cc.BuilderScriptOwnerProtocol = cc.Class.extend({
  createNew: function() {
  }
});
cc.BuilderMemberVariableAssigner = cc.Class.extend({
  onAssignCCBMemberVariable: function(t, e, n) {
    return !1;
  },
  onAssignCCBCustomProperty: function(t, e, n) {
    return !1;
  }
});
var PROPERTY_CCBFILE = "ccbFile";
cc.BuilderFileLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
    return cc.BuilderFile.create();
  },
  onHandlePropTypeCCBFile: function(t, e, n, r, s) {
    n === PROPERTY_CCBFILE ? t.setCCBFileNode(r) : cc.NodeLoader.prototype.onHandlePropTypeCCBFile.call(this, t, e, n, r, s);
  }
});
cc.BuilderFileLoader.loader = function() {
  return new cc.BuilderFileLoader();
};
var PROPERTY_ENABLED = "enabled", PROPERTY_SELECTED = "selected", PROPERTY_CCCONTROL = "ccControl";
cc.ControlLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
  },
  onHandlePropTypeBlockCCControl: function(t, e, n, r, s) {
    n === PROPERTY_CCCONTROL ? t.addTargetWithActionForControlEvents(r.target, r.selCCControlHandler, r.controlEvents) : cc.NodeLoader.prototype.onHandlePropTypeBlockCCControl.call(this, t, e, n, r, s);
  },
  onHandlePropTypeCheck: function(t, e, n, r, s) {
    n === PROPERTY_ENABLED ? t.setEnabled(r) : n === PROPERTY_SELECTED ? t.setSelected(r) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, t, e, n, r, s);
  }
});
var PROPERTY_ZOOMONTOUCHDOWN = "zoomOnTouchDown", PROPERTY_TITLE_NORMAL = "title|1", PROPERTY_TITLE_HIGHLIGHTED = "title|2", PROPERTY_TITLE_DISABLED = "title|3", PROPERTY_TITLECOLOR_NORMAL = "titleColor|1", PROPERTY_TITLECOLOR_HIGHLIGHTED = "titleColor|2", PROPERTY_TITLECOLOR_DISABLED = "titleColor|3", PROPERTY_TITLETTF_NORMAL = "titleTTF|1", PROPERTY_TITLETTF_HIGHLIGHTED = "titleTTF|2", PROPERTY_TITLETTF_DISABLED = "titleTTF|3", PROPERTY_TITLETTFSIZE_NORMAL = "titleTTFSize|1", PROPERTY_TITLETTFSIZE_HIGHLIGHTED = "titleTTFSize|2", PROPERTY_TITLETTFSIZE_DISABLED = "titleTTFSize|4", PROPERTY_LABELANCHORPOINT = "labelAnchorPoint", PROPERTY_PREFEREDSIZE = "preferedSize", PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL = "backgroundSpriteFrame|1", PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED = "backgroundSpriteFrame|2", PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED = "backgroundSpriteFrame|3";
cc.ControlButtonLoader = cc.ControlLoader.extend({
  _createCCNode: function(t, e) {
    return new cc.ControlButton();
  },
  onHandlePropTypeCheck: function(t, e, n, r, s) {
    n === PROPERTY_ZOOMONTOUCHDOWN ? t.setZoomOnTouchDown(r) : cc.ControlLoader.prototype.onHandlePropTypeCheck.call(this, t, e, n, r, s);
  },
  onHandlePropTypeString: function(t, e, n, r, s) {
    n === PROPERTY_TITLE_NORMAL ? t.setTitleForState(r, cc.CONTROL_STATE_NORMAL) : n === PROPERTY_TITLE_HIGHLIGHTED ? t.setTitleForState(r, cc.CONTROL_STATE_HIGHLIGHTED) : n === PROPERTY_TITLE_DISABLED ? t.setTitleForState(r, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeString.call(this, t, e, n, r, s);
  },
  onHandlePropTypeFontTTF: function(t, e, n, r, s) {
    n === PROPERTY_TITLETTF_NORMAL ? t.setTitleTTFForState(r, cc.CONTROL_STATE_NORMAL) : n === PROPERTY_TITLETTF_HIGHLIGHTED ? t.setTitleTTFForState(r, cc.CONTROL_STATE_HIGHLIGHTED) : n === PROPERTY_TITLETTF_DISABLED ? t.setTitleTTFForState(r, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeFontTTF.call(this, t, e, n, r, s);
  },
  onHandlePropTypeFloatScale: function(t, e, n, r, s) {
    n === PROPERTY_TITLETTFSIZE_NORMAL ? t.setTitleTTFSizeForState(r, cc.CONTROL_STATE_NORMAL) : n === PROPERTY_TITLETTFSIZE_HIGHLIGHTED ? t.setTitleTTFSizeForState(r, cc.CONTROL_STATE_HIGHLIGHTED) : n === PROPERTY_TITLETTFSIZE_DISABLED ? t.setTitleTTFSizeForState(r, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeFloatScale.call(this, t, e, n, r, s);
  },
  onHandlePropTypePoint: function(t, e, n, r, s) {
    n === PROPERTY_LABELANCHORPOINT ? t.setLabelAnchorPoint(r) : cc.ControlLoader.prototype.onHandlePropTypePoint.call(this, t, e, n, r, s);
  },
  onHandlePropTypeSize: function(t, e, n, r, s) {
    n === PROPERTY_PREFEREDSIZE ? t.setPreferredSize(r) : cc.ControlLoader.prototype.onHandlePropTypeSize.call(this, t, e, n, r, s);
  },
  onHandlePropTypeSpriteFrame: function(t, e, n, r, s) {
    n === PROPERTY_BACKGROUNDSPRITEFRAME_NORMAL ? r != null && t.setBackgroundSpriteFrameForState(r, cc.CONTROL_STATE_NORMAL) : n === PROPERTY_BACKGROUNDSPRITEFRAME_HIGHLIGHTED ? r != null && t.setBackgroundSpriteFrameForState(r, cc.CONTROL_STATE_HIGHLIGHTED) : n === PROPERTY_BACKGROUNDSPRITEFRAME_DISABLED ? r != null && t.setBackgroundSpriteFrameForState(r, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeSpriteFrame.call(this, t, e, n, r, s);
  },
  onHandlePropTypeColor3: function(t, e, n, r, s) {
    n === PROPERTY_TITLECOLOR_NORMAL ? t.setTitleColorForState(r, cc.CONTROL_STATE_NORMAL) : n === PROPERTY_TITLECOLOR_HIGHLIGHTED ? t.setTitleColorForState(r, cc.CONTROL_STATE_HIGHLIGHTED) : n === PROPERTY_TITLECOLOR_DISABLED ? t.setTitleColorForState(r, cc.CONTROL_STATE_DISABLED) : cc.ControlLoader.prototype.onHandlePropTypeColor3.call(this, t, e, n, r, s);
  }
});
cc.ControlButtonLoader.loader = function() {
  return new cc.ControlButtonLoader();
};
var PROPERTY_CONTAINER = "container", PROPERTY_DIRECTION = "direction", PROPERTY_CLIPSTOBOUNDS = "clipsToBounds", PROPERTY_BOUNCES = "bounces", PROPERTY_SCALE = "scale";
cc.ScrollViewLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
    return new cc.ScrollView();
  },
  onHandlePropTypeSize: function(t, e, n, r, s) {
    n === PROPERTY_CONTENTSIZE ? t.setViewSize(r) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, t, e, n, r, s);
  },
  onHandlePropTypeCCBFile: function(t, e, n, r, s) {
    n === PROPERTY_CONTAINER ? (t.setContainer(r), t.updateInset()) : cc.NodeLoader.prototype.onHandlePropTypeCCBFile.call(this, t, e, n, r, s);
  },
  onHandlePropTypeCheck: function(t, e, n, r, s) {
    n === PROPERTY_CLIPSTOBOUNDS ? t.setClippingToBounds(r) : n === PROPERTY_BOUNCES ? t.setBounceable(r) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, t, e, n, r, s);
  },
  onHandlePropTypeFloat: function(t, e, n, r, s) {
    n === PROPERTY_SCALE ? t.setScale(r) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, t, e, n, r, s);
  },
  onHandlePropTypeIntegerLabeled: function(t, e, n, r, s) {
    n === PROPERTY_DIRECTION ? t.setDirection(r) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, t, e, n, r, s);
  }
});
cc.ScrollViewLoader.loader = function() {
  return new cc.ScrollViewLoader();
};
var PROPERTY_CONTENTSIZE = "contentSize", PROPERTY_SPRITEFRAME = "spriteFrame", PROPERTY_COLOR = "color", PROPERTY_OPACITY = "opacity", PROPERTY_BLENDFUNC = "blendFunc", PROPERTY_INSETLEFT = "insetLeft", PROPERTY_INSETTOP = "insetTop", PROPERTY_INSETRIGHT = "insetRight", PROPERTY_INSETBOTTOM = "insetBottom";
cc.Scale9SpriteLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
    var n = new cc.Scale9Sprite();
    return n.setAnchorPoint(0, 0), n;
  },
  onHandlePropTypeColor3: function(t, e, n, r, s) {
    n === PROPERTY_COLOR ? (r.r !== 255 || r.g !== 255 || r.b !== 255) && t.setColor(r) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, t, e, n, r, s);
  },
  onHandlePropTypeByte: function(t, e, n, r, s) {
    n === PROPERTY_OPACITY ? t.setOpacity(r) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, t, e, n, r, s);
  },
  onHandlePropTypeBlendFunc: function(t, e, n, r, s) {
    n === PROPERTY_BLENDFUNC || cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, t, e, n, r, s);
  },
  onHandlePropTypeSpriteFrame: function(t, e, n, r, s) {
    n === PROPERTY_SPRITEFRAME ? t.setSpriteFrame(r) : cc.NodeLoader.prototype.onHandlePropTypeSpriteFrame.call(this, t, e, n, r, s);
  },
  onHandlePropTypeSize: function(t, e, n, r, s) {
    n === PROPERTY_CONTENTSIZE || (n === PROPERTY_PREFEREDSIZE ? t.setPreferredSize(r) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, t, e, n, r, s));
  },
  onHandlePropTypeFloat: function(t, e, n, r, s) {
    n === PROPERTY_INSETLEFT ? t.setInsetLeft(r) : n === PROPERTY_INSETTOP ? t.setInsetTop(r) : n === PROPERTY_INSETRIGHT ? t.setInsetRight(r) : n === PROPERTY_INSETBOTTOM ? t.setInsetBottom(r) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, t, e, n, r, s);
  }
});
cc.Scale9SpriteLoader.loader = function() {
  return new cc.Scale9SpriteLoader();
};
var PROPERTY_FLIP = "flip", PROPERTY_DISPLAYFRAME = "displayFrame", PROPERTY_COLOR = "color", PROPERTY_OPACITY = "opacity", PROPERTY_BLENDFUNC = "blendFunc";
cc.SpriteLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
    return new cc.Sprite();
  },
  onHandlePropTypeColor3: function(t, e, n, r, s) {
    n === PROPERTY_COLOR ? (r.r !== 255 || r.g !== 255 || r.b !== 255) && t.setColor(r) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, t, e, n, r, s);
  },
  onHandlePropTypeByte: function(t, e, n, r, s) {
    n === PROPERTY_OPACITY ? t.setOpacity(r) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, t, e, n, r, s);
  },
  onHandlePropTypeBlendFunc: function(t, e, n, r, s) {
    n === PROPERTY_BLENDFUNC ? t.setBlendFunc(r) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, t, e, n, r, s);
  },
  onHandlePropTypeSpriteFrame: function(t, e, n, r, s) {
    n === PROPERTY_DISPLAYFRAME ? r ? t.setSpriteFrame(r) : cc.log("ERROR: SpriteFrame is null") : cc.NodeLoader.prototype.onHandlePropTypeSpriteFrame.call(this, t, e, n, r, s);
  },
  onHandlePropTypeFlip: function(t, e, n, r, s) {
    n === PROPERTY_FLIP ? (t.setFlippedX(r[0]), t.setFlippedY(r[1])) : cc.NodeLoader.prototype.onHandlePropTypeFlip.call(this, t, e, n, r, s);
  }
});
cc.SpriteLoader.loader = function() {
  return new cc.SpriteLoader();
};
var PROPERTY_TOUCH_ENABLED = "touchEnabled", PROPERTY_IS_TOUCH_ENABLED = "isTouchEnabled", PROPERTY_ACCELEROMETER_ENABLED = "accelerometerEnabled", PROPERTY_IS_ACCELEROMETER_ENABLED = "isAccelerometerEnabled", PROPERTY_IS_MOUSE_ENABLED = "isMouseEnabled", PROPERTY_MOUSE_ENABLED = "mouseEnabled", PROPERTY_KEYBOARD_ENABLED = "keyboardEnabled", PROPERTY_IS_KEYBOARD_ENABLED = "isKeyboardEnabled";
cc.LayerLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
    var n = new cc.Layer();
    return n.setContentSize(0, 0), n;
  },
  onHandlePropTypeCheck: function(t, e, n, r, s) {
    n === PROPERTY_TOUCH_ENABLED || n === PROPERTY_IS_TOUCH_ENABLED || n === PROPERTY_ACCELEROMETER_ENABLED || n === PROPERTY_IS_ACCELEROMETER_ENABLED || n === PROPERTY_MOUSE_ENABLED || n === PROPERTY_IS_MOUSE_ENABLED || (n === PROPERTY_KEYBOARD_ENABLED || n === PROPERTY_IS_KEYBOARD_ENABLED ? t.setKeyboardEnabled && !cc.sys.isNative ? t.setKeyboardEnabled(r) : cc.log("The property '" + PROPERTY_IS_KEYBOARD_ENABLED + "' is not supported!") : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, t, e, n, r, s));
  }
});
cc.LayerLoader.loader = function() {
  return new cc.LayerLoader();
};
cc.LayerColorLoader = cc.LayerLoader.extend({
  _createCCNode: function(t, e) {
    return new cc.LayerColor();
  },
  onHandlePropTypeColor3: function(t, e, n, r, s) {
    n === PROPERTY_COLOR ? t.setColor(r) : cc.LayerLoader.prototype.onHandlePropTypeColor3.call(this, t, e, n, r, s);
  },
  onHandlePropTypeByte: function(t, e, n, r, s) {
    n === PROPERTY_OPACITY ? t.setOpacity(r) : cc.LayerLoader.prototype.onHandlePropTypeByte.call(this, t, e, n, r, s);
  },
  onHandlePropTypeBlendFunc: function(t, e, n, r, s) {
    n === PROPERTY_BLENDFUNC ? t.setBlendFunc(r) : cc.LayerLoader.prototype.onHandlePropTypeBlendFunc.call(this, t, e, n, r, s);
  }
});
cc.LayerColorLoader.loader = function() {
  return new cc.LayerColorLoader();
};
var PROPERTY_STARTCOLOR = "startColor", PROPERTY_ENDCOLOR = "endColor", PROPERTY_STARTOPACITY = "startOpacity", PROPERTY_ENDOPACITY = "endOpacity", PROPERTY_VECTOR = "vector";
cc.LayerGradientLoader = cc.LayerLoader.extend({
  _createCCNode: function(t, e) {
    return new cc.LayerGradient();
  },
  onHandlePropTypeColor3: function(t, e, n, r, s) {
    n === PROPERTY_STARTCOLOR ? t.setStartColor(r) : n === PROPERTY_ENDCOLOR ? t.setEndColor(r) : cc.LayerLoader.prototype.onHandlePropTypeColor3.call(this, t, e, n, r, s);
  },
  onHandlePropTypeByte: function(t, e, n, r, s) {
    n === PROPERTY_STARTOPACITY ? t.setStartOpacity(r) : n === PROPERTY_ENDOPACITY ? t.setEndOpacity(r) : cc.LayerLoader.prototype.onHandlePropTypeByte.call(this, t, e, n, r, s);
  },
  onHandlePropTypePoint: function(t, e, n, r, s) {
    n === PROPERTY_VECTOR ? t.setVector(r) : cc.LayerLoader.prototype.onHandlePropTypePoint.call(this, t, e, n, r, s);
  },
  onHandlePropTypeBlendFunc: function(t, e, n, r, s) {
    n === PROPERTY_BLENDFUNC ? t.setBlendFunc(r) : cc.LayerLoader.prototype.onHandlePropTypeBlendFunc.call(this, t, e, n, r, s);
  }
});
cc.LayerGradientLoader.loader = function() {
  return new cc.LayerGradientLoader();
};
cc.MenuLoader = cc.LayerLoader.extend({
  _createCCNode: function(t, e) {
    var n = new cc.Menu();
    return n.setContentSize(0, 0), n;
  }
});
cc.MenuLoader.loader = function() {
  return new cc.MenuLoader();
};
var PROPERTY_BLOCK = "block", PROPERTY_ISENABLED = "isEnabled";
cc.MenuItemLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
    return null;
  },
  onHandlePropTypeBlock: function(t, e, n, r, s) {
    n === PROPERTY_BLOCK ? r != null && t.setTarget(r.selMenuHander, r.target) : cc.NodeLoader.prototype.onHandlePropTypeBlock.call(this, t, e, n, r, s);
  },
  onHandlePropTypeCheck: function(t, e, n, r, s) {
    n === PROPERTY_ISENABLED ? t.setEnabled(r) : cc.NodeLoader.prototype.onHandlePropTypeCheck.call(this, t, e, n, r, s);
  }
});
var PROPERTY_NORMALDISPLAYFRAME = "normalSpriteFrame", PROPERTY_SELECTEDDISPLAYFRAME = "selectedSpriteFrame", PROPERTY_DISABLEDDISPLAYFRAME = "disabledSpriteFrame";
cc.MenuItemImageLoader = cc.MenuItemLoader.extend({
  _createCCNode: function(t, e) {
    return new cc.MenuItemImage();
  },
  onHandlePropTypeSpriteFrame: function(t, e, n, r, s) {
    n === PROPERTY_NORMALDISPLAYFRAME ? r != null && t.setNormalSpriteFrame(r) : n === PROPERTY_SELECTEDDISPLAYFRAME ? r != null && t.setSelectedSpriteFrame(r) : n === PROPERTY_DISABLEDDISPLAYFRAME ? r != null && t.setDisabledSpriteFrame(r) : cc.MenuItemLoader.prototype.onHandlePropTypeSpriteFrame.call(this, t, e, n, r, s);
  }
});
cc.MenuItemImageLoader.loader = function() {
  return new cc.MenuItemImageLoader();
};
var PROPERTY_FONTNAME = "fontName", PROPERTY_FONTSIZE = "fontSize", PROPERTY_HORIZONTALALIGNMENT = "horizontalAlignment", PROPERTY_VERTICALALIGNMENT = "verticalAlignment", PROPERTY_STRING = "string", PROPERTY_DIMENSIONS = "dimensions";
cc.LabelTTFLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
    return new cc.LabelTTF();
  },
  onHandlePropTypeColor3: function(t, e, n, r, s) {
    n === PROPERTY_COLOR ? (r.r !== 255 || r.g !== 255 || r.b !== 255) && t.setColor(r) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, t, e, n, r, s);
  },
  onHandlePropTypeByte: function(t, e, n, r, s) {
    n === PROPERTY_OPACITY ? t.setOpacity(r) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, t, e, n, r, s);
  },
  onHandlePropTypeBlendFunc: function(t, e, n, r, s) {
    n === PROPERTY_BLENDFUNC ? t.setBlendFunc(r) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, t, e, n, r, s);
  },
  onHandlePropTypeFontTTF: function(t, e, n, r, s) {
    n === PROPERTY_FONTNAME ? t.setFontName(r) : cc.NodeLoader.prototype.onHandlePropTypeFontTTF.call(this, t, e, n, r, s);
  },
  onHandlePropTypeText: function(t, e, n, r, s) {
    n === PROPERTY_STRING ? t.setString(r) : cc.NodeLoader.prototype.onHandlePropTypeText.call(this, t, e, n, r, s);
  },
  onHandlePropTypeFloatScale: function(t, e, n, r, s) {
    n === PROPERTY_FONTSIZE ? t.setFontSize(r) : cc.NodeLoader.prototype.onHandlePropTypeFloatScale.call(this, t, e, n, r, s);
  },
  onHandlePropTypeIntegerLabeled: function(t, e, n, r, s) {
    n === PROPERTY_HORIZONTALALIGNMENT ? t.setHorizontalAlignment(r) : n === PROPERTY_VERTICALALIGNMENT ? t.setVerticalAlignment(r) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, t, e, n, r, s);
  },
  onHandlePropTypeSize: function(t, e, n, r, s) {
    n === PROPERTY_DIMENSIONS ? t.setDimensions(r) : cc.NodeLoader.prototype.onHandlePropTypeSize.call(this, t, e, n, r, s);
  }
});
cc.LabelTTFLoader.loader = function() {
  return new cc.LabelTTFLoader();
};
var PROPERTY_FNTFILE = "fntFile";
cc.LabelBMFontLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
    return new cc.LabelBMFont();
  },
  onHandlePropTypeColor3: function(t, e, n, r, s) {
    n === PROPERTY_COLOR ? (r.r !== 255 || r.g !== 255 || r.b !== 255) && t.setColor(r) : cc.NodeLoader.prototype.onHandlePropTypeColor3.call(this, t, e, n, r, s);
  },
  onHandlePropTypeByte: function(t, e, n, r, s) {
    n === PROPERTY_OPACITY ? t.setOpacity(r) : cc.NodeLoader.prototype.onHandlePropTypeByte.call(this, t, e, n, r, s);
  },
  onHandlePropTypeBlendFunc: function(t, e, n, r, s) {
    n === PROPERTY_BLENDFUNC ? t.setBlendFunc(r) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, t, e, n, r, s);
  },
  onHandlePropTypeFntFile: function(t, e, n, r, s) {
    n === PROPERTY_FNTFILE ? t.setFntFile(r) : cc.NodeLoader.prototype.onHandlePropTypeFntFile.call(this, t, e, n, r, s);
  },
  onHandlePropTypeText: function(t, e, n, r, s) {
    n === PROPERTY_STRING ? t.setString(r) : cc.NodeLoader.prototype.onHandlePropTypeText.call(this, t, e, n, r, s);
  }
});
cc.LabelBMFontLoader.loader = function() {
  return new cc.LabelBMFontLoader();
};
var PROPERTY_EMITERMODE = "emitterMode", PROPERTY_POSVAR = "posVar", PROPERTY_EMISSIONRATE = "emissionRate", PROPERTY_DURATION = "duration", PROPERTY_TOTALPARTICLES = "totalParticles", PROPERTY_LIFE = "life", PROPERTY_STARTSIZE = "startSize", PROPERTY_ENDSIZE = "endSize", PROPERTY_STARTSPIN = "startSpin", PROPERTY_ENDSPIN = "endSpin", PROPERTY_ANGLE = "angle", PROPERTY_GRAVITY = "gravity", PROPERTY_SPEED = "speed", PROPERTY_TANGENTIALACCEL = "tangentialAccel", PROPERTY_RADIALACCEL = "radialAccel", PROPERTY_TEXTURE = "texture", PROPERTY_STARTRADIUS = "startRadius", PROPERTY_ENDRADIUS = "endRadius", PROPERTY_ROTATEPERSECOND = "rotatePerSecond";
cc.ParticleSystemLoader = cc.NodeLoader.extend({
  _createCCNode: function(t, e) {
    return new cc.ParticleSystem();
  },
  onHandlePropTypeIntegerLabeled: function(t, e, n, r, s) {
    n === PROPERTY_EMITERMODE ? t.setEmitterMode(r) : cc.NodeLoader.prototype.onHandlePropTypeIntegerLabeled.call(this, t, e, n, r, s);
  },
  onHandlePropTypePoint: function(t, e, n, r, s) {
    n === PROPERTY_POSVAR ? t.setPosVar(r) : n === PROPERTY_GRAVITY ? t.setGravity(r) : cc.NodeLoader.prototype.onHandlePropTypePoint.call(this, t, e, n, r, s);
  },
  onHandlePropTypeFloat: function(t, e, n, r, s) {
    n === PROPERTY_EMISSIONRATE ? t.setEmissionRate(r) : n === PROPERTY_DURATION ? t.setDuration(r) : cc.NodeLoader.prototype.onHandlePropTypeFloat.call(this, t, e, n, r, s);
  },
  onHandlePropTypeInteger: function(t, e, n, r, s) {
    n === PROPERTY_TOTALPARTICLES ? t.setTotalParticles(r) : cc.NodeLoader.prototype.onHandlePropTypeInteger.call(this, t, e, n, r, s);
  },
  onHandlePropTypeFloatVar: function(t, e, n, r, s) {
    n === PROPERTY_LIFE ? (t.setLife(r[0]), t.setLifeVar(r[1])) : n === PROPERTY_STARTSIZE ? (t.setStartSize(r[0]), t.setStartSizeVar(r[1])) : n === PROPERTY_ENDSIZE ? (t.setEndSize(r[0]), t.setEndSizeVar(r[1])) : n === PROPERTY_STARTSPIN ? (t.setStartSpin(r[0]), t.setStartSpinVar(r[1])) : n === PROPERTY_ENDSPIN ? (t.setEndSpin(r[0]), t.setEndSpinVar(r[1])) : n === PROPERTY_ANGLE ? (t.setAngle(r[0]), t.setAngleVar(r[1])) : n === PROPERTY_SPEED ? (t.setSpeed(r[0]), t.setSpeedVar(r[1])) : n === PROPERTY_TANGENTIALACCEL ? (t.setTangentialAccel(r[0]), t.setTangentialAccelVar(r[1])) : n === PROPERTY_RADIALACCEL ? (t.setRadialAccel(r[0]), t.setRadialAccelVar(r[1])) : n === PROPERTY_STARTRADIUS ? (t.setStartRadius(r[0]), t.setStartRadiusVar(r[1])) : n === PROPERTY_ENDRADIUS ? (t.setEndRadius(r[0]), t.setEndRadiusVar(r[1])) : n === PROPERTY_ROTATEPERSECOND ? (t.setRotatePerSecond(r[0]), t.setRotatePerSecondVar(r[1])) : cc.NodeLoader.prototype.onHandlePropTypeFloatVar.call(this, t, e, n, r, s);
  },
  onHandlePropTypeColor4FVar: function(t, e, n, r, s) {
    n === PROPERTY_STARTCOLOR ? (t.setStartColor(r[0]), t.setStartColorVar(r[1])) : n === PROPERTY_ENDCOLOR ? (t.setEndColor(r[0]), t.setEndColorVar(r[1])) : cc.NodeLoader.prototype.onHandlePropTypeColor4FVar.call(this, t, e, n, r, s);
  },
  onHandlePropTypeBlendFunc: function(t, e, n, r, s) {
    n === PROPERTY_BLENDFUNC ? t.setBlendFunc(r) : cc.NodeLoader.prototype.onHandlePropTypeBlendFunc.call(this, t, e, n, r, s);
  },
  onHandlePropTypeTexture: function(t, e, n, r, s) {
    n === PROPERTY_TEXTURE ? t.setTexture(r) : cc.NodeLoader.prototype.onHandlePropTypeTexture.call(this, t, e, n, r, s);
  }
});
cc.ParticleSystemLoader.loader = function() {
  return new cc.ParticleSystemLoader();
};
cc.NodeLoaderLibrary = cc.Class.extend({
  _ccNodeLoaders: null,
  ctor: function() {
    this._ccNodeLoaders = {};
  },
  registerDefaultCCNodeLoaders: function() {
    this.registerCCNodeLoader("CCNode", cc.NodeLoader.loader()), this.registerCCNodeLoader("CCLayer", cc.LayerLoader.loader()), this.registerCCNodeLoader("CCLayerColor", cc.LayerColorLoader.loader()), this.registerCCNodeLoader("CCLayerGradient", cc.LayerGradientLoader.loader()), this.registerCCNodeLoader("CCSprite", cc.SpriteLoader.loader()), this.registerCCNodeLoader("CCLabelBMFont", cc.LabelBMFontLoader.loader()), this.registerCCNodeLoader("CCLabelTTF", cc.LabelTTFLoader.loader()), this.registerCCNodeLoader("CCScale9Sprite", cc.Scale9SpriteLoader.loader()), this.registerCCNodeLoader("CCScrollView", cc.ScrollViewLoader.loader()), this.registerCCNodeLoader("CCBFile", cc.BuilderFileLoader.loader()), this.registerCCNodeLoader("CCMenu", cc.MenuLoader.loader()), this.registerCCNodeLoader("CCMenuItemImage", cc.MenuItemImageLoader.loader()), this.registerCCNodeLoader("CCControlButton", cc.ControlButtonLoader.loader()), this.registerCCNodeLoader("CCParticleSystemQuad", cc.ParticleSystemLoader.loader());
  },
  registerCCNodeLoader: function(t, e) {
    this._ccNodeLoaders[t] = e;
  },
  unregisterCCNodeLoader: function(t) {
    this._ccNodeLoaders[t] && delete this._ccNodeLoaders[t];
  },
  getCCNodeLoader: function(t) {
    return this._ccNodeLoaders[t] ? this._ccNodeLoaders[t] : null;
  },
  purge: function(t) {
    if (t)
      for (var e in this._ccNodeLoaders)
        delete this._ccNodeLoaders[e];
    this._ccNodeLoaders = {};
  }
});
cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null;
cc.NodeLoaderLibrary.library = function() {
  return new cc.NodeLoaderLibrary();
};
cc.NodeLoaderLibrary.sharedCCNodeLoaderLibrary = function() {
  return cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary == null && (cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = new cc.NodeLoaderLibrary(), cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary.registerDefaultCCNodeLoaders()), cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary;
};
cc.NodeLoaderLibrary.purgeSharedCCNodeLoaderLibrary = function() {
  cc.NodeLoaderLibrary.sSharedCCNodeLoaderLibrary = null;
};
cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary = function() {
  var t = cc.NodeLoaderLibrary.library();
  return t.registerDefaultCCNodeLoaders(), t;
};
var CCB_VERSION = 5, CCB_PROPTYPE_POSITION = 0, CCB_PROPTYPE_SIZE = 1, CCB_PROPTYPE_POINT = 2, CCB_PROPTYPE_POINTLOCK = 3, CCB_PROPTYPE_SCALELOCK = 4, CCB_PROPTYPE_DEGREES = 5, CCB_PROPTYPE_INTEGER = 6, CCB_PROPTYPE_FLOAT = 7, CCB_PROPTYPE_FLOATVAR = 8, CCB_PROPTYPE_CHECK = 9, CCB_PROPTYPE_SPRITEFRAME = 10, CCB_PROPTYPE_TEXTURE = 11, CCB_PROPTYPE_BYTE = 12, CCB_PROPTYPE_COLOR3 = 13, CCB_PROPTYPE_COLOR4VAR = 14, CCB_PROPTYPE_FLIP = 15, CCB_PROPTYPE_BLENDMODE = 16, CCB_PROPTYPE_FNTFILE = 17, CCB_PROPTYPE_TEXT = 18, CCB_PROPTYPE_FONTTTF = 19, CCB_PROPTYPE_INTEGERLABELED = 20, CCB_PROPTYPE_BLOCK = 21, CCB_PROPTYPE_ANIMATION = 22, CCB_PROPTYPE_CCBFILE = 23, CCB_PROPTYPE_STRING = 24, CCB_PROPTYPE_BLOCKCCCONTROL = 25, CCB_PROPTYPE_FLOATSCALE = 26, CCB_PROPTYPE_FLOATXY = 27, CCB_FLOAT0 = 0, CCB_FLOAT1 = 1, CCB_FLOAT_MINUS1 = 2, CCB_FLOAT05 = 3, CCB_FLOAT_INTEGER = 4, CCB_PLATFORM_ALL = 0, CCB_PLATFORM_IOS = 1, CCB_PLATFORM_MAC = 2, CCB_TARGETTYPE_NONE = 0, CCB_TARGETTYPE_DOCUMENTROOT = 1, CCB_TARGETTYPE_OWNER = 2, CCB_KEYFRAME_EASING_INSTANT = 0, CCB_KEYFRAME_EASING_LINEAR = 1, CCB_KEYFRAME_EASING_CUBIC_IN = 2, CCB_KEYFRAME_EASING_CUBIC_OUT = 3, CCB_KEYFRAME_EASING_CUBIC_INOUT = 4, CCB_KEYFRAME_EASING_ELASTIC_IN = 5, CCB_KEYFRAME_EASING_ELASTIC_OUT = 6, CCB_KEYFRAME_EASING_ELASTIC_INOUT = 7, CCB_KEYFRAME_EASING_BOUNCE_IN = 8, CCB_KEYFRAME_EASING_BOUNCE_OUT = 9, CCB_KEYFRAME_EASING_BOUNCE_INOUT = 10, CCB_KEYFRAME_EASING_BACK_IN = 11, CCB_KEYFRAME_EASING_BACK_OUT = 12, CCB_KEYFRAME_EASING_BACK_INOUT = 13, CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT = 0, CCB_POSITIONTYPE_RELATIVE_TOP_LEFT = 1, CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT = 2, CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT = 3, CCB_POSITIONTYPE_PERCENT = 4, CCB_POSITIONTYPE_MULTIPLY_RESOLUTION = 5, CCB_SIZETYPE_ABSOLUTE = 0, CCB_SIZETYPE_PERCENT = 1, CCB_SIZETYPE_RELATIVE_CONTAINER = 2, CCB_SIZETYPE_HORIZONTAL_PERCENT = 3, CCB_SIZETYPE_VERTICAL_PERCENT = 4, CCB_SIZETYPE_MULTIPLY_RESOLUTION = 5, CCB_SCALETYPE_MULTIPLY_RESOLUTION = 1;
cc.BuilderFile = cc.Node.extend({
  _ccbFileNode: null,
  getCCBFileNode: function() {
    return this._ccbFileNode;
  },
  setCCBFileNode: function(t) {
    this._ccbFileNode = t;
  }
});
cc.BuilderFile.create = function() {
  return new cc.BuilderFile();
};
cc.BuilderReader = cc.Class.extend({
  _jsControlled: !1,
  _data: null,
  _ccbRootPath: "",
  _bytes: 0,
  _currentByte: 0,
  _currentBit: 0,
  _stringCache: null,
  _loadedSpriteSheets: null,
  _owner: null,
  _animationManager: null,
  _animationManagers: null,
  _animatedProps: null,
  _ccNodeLoaderLibrary: null,
  _ccNodeLoaderListener: null,
  _ccbMemberVariableAssigner: null,
  _ccbSelectorResolver: null,
  _ownerOutletNames: null,
  _ownerOutletNodes: null,
  _nodesWithAnimationManagers: null,
  _animationManagerForNodes: null,
  _ownerCallbackNames: null,
  _ownerCallbackNodes: null,
  _ownerCallbackEvents: null,
  _readNodeGraphFromData: !1,
  ctor: function(t, e, n, r) {
    if (this._stringCache = [], this._loadedSpriteSheets = [], this._currentBit = -1, this._currentByte = -1, arguments.length !== 0)
      if (t instanceof cc.BuilderReader) {
        var s = t;
        this._loadedSpriteSheets = s._loadedSpriteSheets, this._ccNodeLoaderLibrary = s._ccNodeLoaderLibrary, this._ccbMemberVariableAssigner = s._ccbMemberVariableAssigner, this._ccbSelectorResolver = s._ccbSelectorResolver, this._ccNodeLoaderListener = s._ccNodeLoaderListener, this._ownerCallbackNames = s._ownerCallbackNames, this._ownerCallbackNodes = s._ownerCallbackNodes, this._ownerCallbackEvents = s._ownerCallbackEvents, this._ownerOutletNames = s._ownerOutletNames, this._ownerOutletNodes = s._ownerOutletNodes, this._ccbRootPath = s._ccbRootPath;
      } else
        this._ccNodeLoaderLibrary = t, this._ccbMemberVariableAssigner = e, this._ccbSelectorResolver = n, this._ccNodeLoaderListener = r;
  },
  getCCBRootPath: function() {
    return this._ccbRootPath;
  },
  setCCBRootPath: function(t) {
    this._ccbRootPath = t;
  },
  initWithData: function(t, e) {
    return this._animationManager = new cc.BuilderAnimationManager(), this._data = t, this._bytes = t.length, this._currentBit = 0, this._currentByte = 0, this._owner = e, this._animationManager.setRootContainerSize(cc.director.getWinSize()), !0;
  },
  _loadBinarySync: function(t) {
    var e = (this || window).getXMLHttpRequest(), n = "load " + t + " failed!";
    e.open("GET", t, !1);
    var r = null;
    if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
      if (e.setRequestHeader("Accept-Charset", "x-user-defined"), e.send(null), e.status !== 200)
        return cc.log(n), null;
      var s = cc._convertResponseBodyToText(e.responseBody);
      s && (r = (this || window)._stringConvertToArray(s), this._fileDataCache[t] = r);
    } else {
      if (e.overrideMimeType && e.overrideMimeType("text/plain; charset=x-user-defined"), e.send(null), e.status !== 200)
        return cc.log(n), null;
      r = (this || window)._stringConvertToArray(e.responseText), this._fileDataCache[t] = r;
    }
    return r;
  },
  readNodeGraphFromFile: function(t, e, n, r) {
    n == null ? n = cc.director.getWinSize() : n instanceof cc.BuilderAnimationManager && (r = n, n = cc.director.getWinSize());
    var s = cc.loader.getRes(t);
    if (!s) {
      var o = cc.loader.getUrl(t);
      s = cc.loader.loadBinarySync(o), cc.loader.cache[t] = s;
    }
    return this.readNodeGraphFromData(s, e, n, r);
  },
  readNodeGraphFromData: function(t, e, n) {
    this.initWithData(t, e);
    var r = (this || window)._animationManager;
    r.setRootContainerSize(n), r.setOwner(e), this._ownerOutletNames = [], this._ownerOutletNodes = [], this._ownerCallbackNames = [], this._ownerCallbackNodes = [], this._ownerCallbackEvents = [], this._animationManagers = new cc._Dictionary();
    var s = (this || window).readFileWithCleanUp(!0);
    if (s && r.getAutoPlaySequenceId() !== -1 && r.runAnimations(r.getAutoPlaySequenceId(), 0), this._jsControlled) {
      for (var o = [], a = [], c = (this || window)._animationManagers, l = c.allKeys(), h = 0; h < l.length; h++)
        o.push(l[h]), a.push(c.objectForKey(l[h]));
      this._nodesWithAnimationManagers = o, this._animationManagerForNodes = a;
    }
    return s;
  },
  createSceneWithNodeGraphFromFile: function(t, e, n, r) {
    var s = (this || window).readNodeGraphFromFile(t, e, n, r), o = new cc.Scene();
    return o.addChild(s), o;
  },
  getCCBMemberVariableAssigner: function() {
    return this._ccbMemberVariableAssigner;
  },
  getCCBSelectorResolver: function() {
    return this._ccbSelectorResolver;
  },
  getAnimationManager: function() {
    return this._animationManager;
  },
  setAnimationManager: function(t) {
    this._animationManager = t;
  },
  getAnimatedProperties: function() {
    return this._animatedProps;
  },
  getLoadedSpriteSheet: function() {
    return this._loadedSpriteSheets;
  },
  getOwner: function() {
    return this._owner;
  },
  readInt: function(t) {
    for (var e = 0; !this._getBit(); )
      e++;
    for (var n = 0, r = e - 1; r >= 0; r--)
      this._getBit() && (n |= 1 << r);
    n |= 1 << e;
    var s;
    if (t) {
      var o = n % 2;
      o ? s = 0 | n / 2 : s = 0 | -n / 2;
    } else
      s = n - 1;
    return this._alignBits(), s;
  },
  readByte: function() {
    var t = (this || window)._data[this._currentByte];
    return this._currentByte++, t;
  },
  readBool: function() {
    return this.readByte() !== 0;
  },
  readFloat: function() {
    var t = (this || window).readByte();
    switch (t) {
      case CCB_FLOAT0:
        return 0;
      case CCB_FLOAT1:
        return 1;
      case CCB_FLOAT_MINUS1:
        return -1;
      case CCB_FLOAT05:
        return 0.5;
      case CCB_FLOAT_INTEGER:
        return this.readInt(!0);
      default:
        var e = (this || window)._decodeFloat(23, 8);
        return e;
    }
  },
  _decodeFloat: function(t, e) {
    var n = t + e + 1, r = n >> 3;
    this._checkSize(n);
    var s = Math.pow(2, e - 1) - 1, o = (this || window)._readBitsOnly(t + e, 1, r), a = (this || window)._readBitsOnly(t, e, r), c = 0, l = 2, h = 0;
    do
      for (var u = (this || window)._readByteOnly(++h, r), _ = t % 8 || 8, d = 1 << _; d >>= 1; )
        u & d && (c += 1 / l), l *= 2;
    while (t -= _);
    return this._currentByte += r, a === (s << 1) + 1 ? c ? NaN : o ? -1 / 0 : 1 / 0 : (1 + o * -2) * (a || c ? a ? Math.pow(2, a - s) * (1 + c) : Math.pow(2, -s + 1) * c : 0);
  },
  _readBitsOnly: function(t, e, n) {
    var r = (t + e) % 8, s = t % 8, o = n - (t >> 3) - 1, a = n + (-(t + e) >> 3), c = o - a, l = (this || window)._readByteOnly(o, n) >> s & (1 << (c ? 8 - s : e)) - 1;
    for (c && r && (l += (this._readByteOnly(a++, n) & (1 << r) - 1) << (c-- << 3) - s); c; )
      l += (this || window)._shl(this._readByteOnly(a++, n), (c-- << 3) - s);
    return l;
  },
  _readByteOnly: function(t, e) {
    return this._data[this._currentByte + e - t - 1];
  },
  _shl: function(t, e) {
    for (++e; --e; t = ((t %= 2147483647 + 1) & 1073741824) === 1073741824 ? t * 2 : (t - 1073741824) * 2 + 2147483647 + 1)
      ;
    return t;
  },
  _checkSize: function(t) {
    if (!(this._currentByte + Math.ceil(t / 8) < this._data.length))
      throw new Error("Index out of bound");
  },
  readCachedString: function() {
    return this._stringCache[this.readInt(!1)];
  },
  isJSControlled: function() {
    return this._jsControlled;
  },
  getOwnerCallbackNames: function() {
    return this._ownerCallbackNames;
  },
  getOwnerCallbackNodes: function() {
    return this._ownerCallbackNodes;
  },
  getOwnerCallbackControlEvents: function() {
    return this._ownerCallbackEvents;
  },
  getOwnerOutletNames: function() {
    return this._ownerOutletNames;
  },
  getOwnerOutletNodes: function() {
    return this._ownerOutletNodes;
  },
  getNodesWithAnimationManagers: function() {
    return this._nodesWithAnimationManagers;
  },
  getAnimationManagersForNodes: function() {
    return this._animationManagerForNodes;
  },
  getAnimationManagers: function() {
    return this._animationManagers;
  },
  setAnimationManagers: function(t) {
    this._animationManagers = t;
  },
  addOwnerCallbackName: function(t) {
    this._ownerCallbackNames.push(t);
  },
  addOwnerCallbackNode: function(t) {
    this._ownerCallbackNodes.push(t);
  },
  addOwnerCallbackControlEvents: function(t) {
    this._ownerCallbackEvents.push(t);
  },
  addDocumentCallbackName: function(t) {
    this._animationManager.addDocumentCallbackName(t);
  },
  addDocumentCallbackNode: function(t) {
    this._animationManager.addDocumentCallbackNode(t);
  },
  addDocumentCallbackControlEvents: function(t) {
    this._animationManager.addDocumentCallbackControlEvents(t);
  },
  readFileWithCleanUp: function(t) {
    if (!this._readHeader() || !this._readStringCache() || !this._readSequences())
      return null;
    var e = (this || window)._readNodeGraph();
    return this._animationManagers.setObject(this._animationManager, e), t && this._cleanUpNodeGraph(e), e;
  },
  addOwnerOutletName: function(t) {
    this._ownerOutletNames.push(t);
  },
  addOwnerOutletNode: function(t) {
    t != null && this._ownerOutletNodes.push(t);
  },
  _cleanUpNodeGraph: function(t) {
    t.userObject = null;
    for (var e = t.getChildren(), n = 0, r = e.length; n < r; n++)
      this._cleanUpNodeGraph(e[n]);
  },
  _readCallbackKeyframesForSeq: function(t) {
    var e = (this || window).readInt(!1);
    if (!e)
      return !0;
    for (var n = new cc.BuilderSequenceProperty(), r = (this || window)._jsControlled, s = (this || window)._animationManager, o = n.getKeyframes(), a = 0; a < e; a++) {
      var c = (this || window).readFloat(), l = (this || window).readCachedString(), h = (this || window).readInt(!1), u = [l, h], _ = new cc.BuilderKeyframe();
      _.setTime(c), _.setValue(u), r && s.getKeyframeCallbacks().push(h + ":" + l), o.push(_);
    }
    return t.setCallbackChannel(n), !0;
  },
  _readSoundKeyframesForSeq: function(t) {
    var e = (this || window).readInt(!1);
    if (!e)
      return !0;
    for (var n = new cc.BuilderSequenceProperty(), r = n.getKeyframes(), s = 0; s < e; s++) {
      var o = (this || window).readFloat(), a = (this || window).readCachedString(), c = (this || window).readFloat(), l = (this || window).readFloat(), h = (this || window).readFloat(), u = [a, c, l, h], _ = new cc.BuilderKeyframe();
      _.setTime(o), _.setValue(u), r.push(_);
    }
    return t.setSoundChannel(n), !0;
  },
  _readSequences: function() {
    for (var t = (this || window)._animationManager.getSequences(), e = (this || window).readInt(!1), n = 0; n < e; n++) {
      var r = new cc.BuilderSequence();
      if (r.setDuration(this.readFloat()), r.setName(this.readCachedString()), r.setSequenceId(this.readInt(!1)), r.setChainedSequenceId(this.readInt(!0)), !this._readCallbackKeyframesForSeq(r) || !this._readSoundKeyframesForSeq(r))
        return !1;
      t.push(r);
    }
    return this._animationManager.setAutoPlaySequenceId(this.readInt(!0)), !0;
  },
  readKeyframe: function(t) {
    var e = new cc.BuilderKeyframe();
    e.setTime(this.readFloat());
    var n = (this || window).readInt(!1), r = 0, s = null;
    if ((n === CCB_KEYFRAME_EASING_CUBIC_IN || n === CCB_KEYFRAME_EASING_CUBIC_OUT || n === CCB_KEYFRAME_EASING_CUBIC_INOUT || n === CCB_KEYFRAME_EASING_ELASTIC_IN || n === CCB_KEYFRAME_EASING_ELASTIC_OUT || n === CCB_KEYFRAME_EASING_ELASTIC_INOUT) && (r = (this || window).readFloat()), e.setEasingType(n), e.setEasingOpt(r), t === CCB_PROPTYPE_CHECK)
      s = (this || window).readBool();
    else if (t === CCB_PROPTYPE_BYTE)
      s = (this || window).readByte();
    else if (t === CCB_PROPTYPE_COLOR3) {
      var o = cc.color(this.readByte(), this.readByte(), this.readByte());
      s = cc.Color3BWapper.create(o);
    } else if (t === CCB_PROPTYPE_FLOATXY)
      s = [this.readFloat(), this.readFloat()];
    else if (t === CCB_PROPTYPE_DEGREES)
      s = (this || window).readFloat();
    else if (t === CCB_PROPTYPE_SCALELOCK || t === CCB_PROPTYPE_POSITION || t === CCB_PROPTYPE_FLOATXY)
      s = [this.readFloat(), this.readFloat()];
    else if (t === CCB_PROPTYPE_SPRITEFRAME) {
      var a = (this || window).readCachedString(), c = (this || window).readCachedString();
      if (a === "") {
        c = (this || window)._ccbRootPath + c;
        var l = cc.textureCache.addImage(c), h = l.getContentSize(), u = cc.rect(0, 0, h.width, h.height);
        s = new cc.SpriteFrame(l, u);
      } else {
        a = (this || window)._ccbRootPath + a;
        var _ = cc.spriteFrameCache;
        this._loadedSpriteSheets.indexOf(a) === -1 && (_.addSpriteFrames(a), this._loadedSpriteSheets.push(a)), s = _.getSpriteFrame(c);
      }
    }
    return e.setValue(s), e;
  },
  _readHeader: function() {
    if (!this._data)
      return !1;
    var t = (this || window)._readStringFromBytes(this._currentByte, 4, !0);
    if (this._currentByte += 4, t !== "ccbi")
      return !1;
    var e = (this || window).readInt(!1);
    return e !== CCB_VERSION ? (cc.log("WARNING! Incompatible ccbi file version (file: " + e + " reader: " + CCB_VERSION + ")"), !1) : (this._jsControlled = (this || window).readBool(), this._animationManager._jsControlled = (this || window)._jsControlled, !0);
  },
  _readStringFromBytes: function(t, e, n) {
    n = n || !1;
    var r = "", s, o = (this || window)._data, a = (this || window)._currentByte;
    if (n)
      for (s = e - 1; s >= 0; s--)
        r += String.fromCharCode(o[a + s]);
    else
      for (s = 0; s < e; s++)
        r += String.fromCharCode(o[a + s]);
    return r;
  },
  _readStringCache: function() {
    for (var t = (this || window).readInt(!1), e = 0; e < t; e++)
      this._readStringCacheEntry();
    return !0;
  },
  _readStringCacheEntry: function() {
    for (var t = (this || window).readByte(), e = (this || window).readByte(), n = t << 8 | e, r = "", s = (this || window)._data, o = (this || window)._currentByte, a = 0; a < n; a++) {
      var c = s[o + a].toString("16").toUpperCase();
      c = c.length > 1 ? c : "0" + c, r += "%" + c;
    }
    r = decodeURIComponent(r), this._currentByte += n, this._stringCache.push(r);
  },
  _readNodeGraph: function(t) {
    var e = (this || window).readCachedString(), n, r = (this || window)._jsControlled, s = (this || window)._animationManager;
    r && (n = (this || window).readCachedString());
    var o = (this || window).readInt(!1), a;
    o !== CCB_TARGETTYPE_NONE && (a = (this || window).readCachedString());
    var c = (this || window)._ccNodeLoaderLibrary.getCCNodeLoader(e);
    c || (c = (this || window)._ccNodeLoaderLibrary.getCCNodeLoader("CCNode"));
    var l = c.loadCCNode(t, this);
    s.getRootNode() || s.setRootNode(l), r && l === s.getRootNode() && s.setDocumentControllerName(n);
    var h = new cc._Dictionary();
    this._animatedProps = [];
    var u, _ = (this || window)._animatedProps, d = (this || window).readInt(!1);
    for (u = 0; u < d; ++u) {
      for (var f = (this || window).readInt(!1), C = new cc._Dictionary(), m = (this || window).readInt(!1), g = 0; g < m; ++g) {
        var y = new cc.BuilderSequenceProperty();
        y.setName(this.readCachedString()), y.setType(this.readInt(!1)), _.push(y.getName());
        for (var A = (this || window).readInt(!1), D = y.getKeyframes(), N = 0; N < A; ++N) {
          var z = (this || window).readKeyframe(y.getType());
          D.push(z);
        }
        C.setObject(y, y.getName());
      }
      h.setObject(C, f);
    }
    h.count() > 0 && s.addNode(l, h), c.parseProperties(l, t, this);
    var M = l instanceof cc.BuilderFile;
    if (M) {
      var Z = l.getCCBFileNode();
      Z.setPosition(l.getPosition()), Z.setRotation(l.getRotation()), Z.setScaleX(l.getScaleX()), Z.setScaleY(l.getScaleY()), Z.setTag(l.getTag()), Z.setVisible(!0), s.moveAnimationsFromNode(l, Z), l.setCCBFileNode(null), l = Z;
    }
    var U = null, Q = null;
    if (o !== CCB_TARGETTYPE_NONE) {
      if (r)
        o === CCB_TARGETTYPE_DOCUMENTROOT ? (s.addDocumentOutletName(a), s.addDocumentOutletNode(l)) : (this._ownerOutletNames.push(a), this._ownerOutletNodes.push(l));
      else if (o === CCB_TARGETTYPE_DOCUMENTROOT ? U = s.getRootNode() : o === CCB_TARGETTYPE_OWNER && (U = (this || window)._owner), !U) {
        var et = !1;
        U.onAssignCCBMemberVariable && (et = U.onAssignCCBMemberVariable(U, a, l)), Q = (this || window)._ccbMemberVariableAssigner, !et && Q != null && Q.onAssignCCBMemberVariable && Q.onAssignCCBMemberVariable(U, a, l);
      }
    }
    if (c.getCustomProperties().length > 0) {
      var rt = !1;
      if (!r && (U = l, U != null && U.onAssignCCBCustomProperty != null)) {
        var w = c.getCustomProperties(), L = w.allKeys();
        for (u = 0; u < L.length; u++) {
          var G = w.objectForKey(L[u]);
          rt = U.onAssignCCBCustomProperty(U, L[u], G), Q = (this || window)._ccbMemberVariableAssigner, !rt && Q != null && Q.onAssignCCBCustomProperty != null && (rt = Q.onAssignCCBCustomProperty(U, L[u], G));
        }
      }
    }
    this._animatedProps = null;
    var I = (this || window).readInt(!1);
    for (u = 0; u < I; u++) {
      var O = (this || window)._readNodeGraph(l);
      l.addChild(O);
    }
    return M || (l != null && l.onNodeLoaded ? l.onNodeLoaded(l, c) : this._ccNodeLoaderListener != null && this._ccNodeLoaderListener.onNodeLoaded(l, c)), l;
  },
  _getBit: function() {
    var t = (this._data[this._currentByte] & 1 << this._currentBit) !== 0;
    if (this._currentBit++, this._currentBit >= 8 && (this._currentBit = 0, this._currentByte++, this._currentByte > this._data.length))
      throw new Error("out of the data bound");
    return t;
  },
  _alignBits: function() {
    this._currentBit && (this._currentBit = 0, this._currentByte++);
  },
  _readUTF8: function() {
  }
});
cc.BuilderReader._ccbResolutionScale = 1;
cc.BuilderReader.setResolutionScale = function(t) {
  cc.BuilderReader._ccbResolutionScale = t;
};
cc.BuilderReader.getResolutionScale = function() {
  return cc.BuilderReader._ccbResolutionScale;
};
cc.BuilderReader.loadAsScene = function(t, e, n, r) {
  r = r || cc.BuilderReader.getResourcePath();
  var s = cc.BuilderReader.load(t, e, n, r), o = new cc.Scene();
  return o.addChild(s), o;
};
cc.BuilderReader._controllerClassCache = {};
cc.BuilderReader.registerController = function(t, e) {
  cc.BuilderReader._controllerClassCache[t] = cc.Class.extend(e);
};
cc.BuilderReader.load = function(t, e, n, r) {
  r = r || cc.BuilderReader.getResourcePath();
  var s = new cc.BuilderReader(cc.NodeLoaderLibrary.newDefaultCCNodeLoaderLibrary());
  s.setCCBRootPath(r), (t.length < 5 || t.toLowerCase().lastIndexOf(".ccbi") !== t.length - 5) && (t = t + ".ccbi");
  var o = s.readNodeGraphFromFile(t, e, n), a, c, l, h, u, _;
  if (e) {
    var d = s.getOwnerCallbackNames(), f = s.getOwnerCallbackNodes(), C = s.getOwnerCallbackControlEvents();
    for (a = 0; a < d.length; a++)
      c = d[a], l = f[a], h = C[a], l instanceof cc.ControlButton ? l.addTargetWithActionForControlEvents(e, e[c], h) : l.setCallback(e[c], e);
    var m = s.getOwnerOutletNames(), g = s.getOwnerOutletNodes();
    for (a = 0; a < m.length; a++)
      u = m[a], _ = g[a], e[u] = _;
  }
  var y = s.getNodesWithAnimationManagers(), A = s.getAnimationManagersForNodes();
  if (!y || !A)
    return o;
  var D = cc.BuilderReader._controllerClassCache;
  for (a = 0; a < y.length; a++) {
    var N = y[a], z = A[a], M;
    N.animationManager = z;
    var Z = z.getDocumentControllerName();
    if (Z) {
      var U = D[Z];
      if (!U)
        throw new Error("Can not find controller : " + Z);
      var Q = new U();
      Q.controllerName = Z, N.controller = Q, Q.rootNode = N;
      var et = z.getDocumentCallbackNames(), rt = z.getDocumentCallbackNodes(), w = z.getDocumentCallbackControlEvents();
      for (M = 0; M < et.length; M++)
        c = et[M], l = rt[M], h = w[M], l instanceof cc.ControlButton ? l.addTargetWithActionForControlEvents(Q, Q[c], h) : l.setCallback(Q[c], Q);
      var L = z.getDocumentOutletNames(), G = z.getDocumentOutletNodes();
      for (M = 0; M < L.length; M++)
        u = L[M], _ = G[M], Q[u] = _;
      Q.onDidLoadFromCCB && cc.isFunction(Q.onDidLoadFromCCB) && Q.onDidLoadFromCCB();
      var I = z.getKeyframeCallbacks();
      for (M = 0; M < I.length; M++) {
        var O = I[M].split(":"), K = O[0], $ = O[1];
        K == 1 ? z.setCallFunc(cc.callFunc(Q[$], Q), I[M]) : K == 2 && e && z.setCallFunc(cc.callFunc(e[$], e), I[M]);
      }
    }
  }
  return z.runAnimations(z.getAutoPlaySequenceId(), 0), o;
};
cc.BuilderReader._resourcePath = "";
cc.BuilderReader.setResourcePath = function(t) {
  cc.BuilderReader._resourcePath = t;
};
cc.BuilderReader.getResourcePath = function() {
  return cc.BuilderReader._resourcePath;
};
cc.BuilderReader.lastPathComponent = function(t) {
  var e = t.lastIndexOf("/");
  return e !== -1 ? t.substring(e + 1, t.length - e) : t;
};
cc.BuilderReader.deletePathExtension = function(t) {
  var e = t.lastIndexOf(".");
  return e !== -1 ? t.substring(0, e) : t;
};
cc.BuilderReader.toLowerCase = function(t) {
  return t.toLowerCase();
};
cc.BuilderReader.endsWith = function(t, e) {
  return t.length >= e.length ? t.lastIndexOf(e) === 0 : !1;
};
cc.BuilderReader.concat = function(t, e) {
  return t + e;
};
cc.loader.register(["ccbi"], cc._binaryLoader);
cc.INT_VALUE = 0;
cc.FLOAT_VALUE = 1;
cc.POINTER_VALUE = 2;
cc.BOOL_VALUE = 3;
cc.UNSIGNEDCHAR_VALUE = 4;
cc.Color3BWapper = cc.Class.extend({
  _color: null,
  ctor: function() {
    this._color = cc.color(0, 0, 0);
  },
  getColor: function() {
    return this._color;
  }
});
cc.Color3BWapper.create = function(t) {
  var e = new cc.Color3BWapper();
  return e && (e._color.r = t.r, e._color.g = t.g, e._color.b = t.b), e;
};
cc.BuilderValue = cc.Class.extend({
  _value: null,
  _type: 0,
  getIntValue: function() {
  },
  getFloatValue: function() {
  },
  getBoolValue: function() {
  },
  getByteValue: function() {
  },
  getPointer: function() {
  },
  getValue: function() {
    return this._value;
  }
});
cc.BuilderValue.create = function(t) {
  return new cc.BuilderValue();
};
cc.BuilderKeyframe = cc.Class.extend({
  _value: null,
  _time: 0,
  _easingType: 0,
  _easingOpt: 0,
  getValue: function() {
    return this._value;
  },
  setValue: function(t) {
    this._value = t;
  },
  getTime: function() {
    return this._time;
  },
  setTime: function(t) {
    this._time = t;
  },
  getEasingType: function() {
    return this._easingType;
  },
  setEasingType: function(t) {
    this._easingType = t;
  },
  getEasingOpt: function() {
    return this._easingOpt;
  },
  setEasingOpt: function(t) {
    this._easingOpt = t;
  }
});
cc.BuilderSequence = cc.Class.extend({
  _duration: 0,
  _name: "",
  _sequenceId: 0,
  _chainedSequenceId: 0,
  _callbackChannel: null,
  _soundChannel: null,
  ctor: function() {
    this._name = "";
  },
  getDuration: function() {
    return this._duration;
  },
  setDuration: function(t) {
    this._duration = t;
  },
  getName: function() {
    return this._name;
  },
  setName: function(t) {
    this._name = t;
  },
  getSequenceId: function() {
    return this._sequenceId;
  },
  setSequenceId: function(t) {
    this._sequenceId = t;
  },
  getChainedSequenceId: function() {
    return this._chainedSequenceId;
  },
  setChainedSequenceId: function(t) {
    this._chainedSequenceId = t;
  },
  getCallbackChannel: function() {
    return this._callbackChannel;
  },
  setCallbackChannel: function(t) {
    this._callbackChannel = t;
  },
  getSoundChannel: function() {
    return this._soundChannel;
  },
  setSoundChannel: function(t) {
    this._soundChannel = t;
  }
});
cc.BuilderSequenceProperty = cc.Class.extend({
  _name: null,
  _type: 0,
  _keyFrames: null,
  ctor: function() {
    this.init();
  },
  init: function() {
    this._keyFrames = [], this._name = "";
  },
  getName: function() {
    return this._name;
  },
  setName: function(t) {
    this._name = t;
  },
  getType: function() {
    return this._type;
  },
  setType: function(t) {
    this._type = t;
  },
  getKeyframes: function() {
    return this._keyFrames;
  }
});
cc.getAbsolutePosition = function(t, e, n, r) {
  var s = cc.p(0, 0);
  if (e === CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT)
    s = t;
  else if (e === CCB_POSITIONTYPE_RELATIVE_TOP_LEFT)
    s.x = t.x, s.y = n.height - t.y;
  else if (e === CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT)
    s.x = n.width - t.x, s.y = n.height - t.y;
  else if (e === CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT)
    s.x = n.width - t.x, s.y = t.y;
  else if (e === CCB_POSITIONTYPE_PERCENT)
    s.x = n.width * t.x / 100, s.y = n.height * t.y / 100;
  else if (e === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION) {
    var o = cc.BuilderReader.getResolutionScale();
    s.x = t.x * o, s.y = t.y * o;
  }
  return s;
};
cc._getAbsolutePosition = function(t, e, n, r, s) {
  var o = cc.p(0, 0);
  if (n === CCB_POSITIONTYPE_RELATIVE_BOTTOM_LEFT)
    o.x = t, o.y = e;
  else if (n === CCB_POSITIONTYPE_RELATIVE_TOP_LEFT)
    o.x = t, o.y = r.height - e;
  else if (n === CCB_POSITIONTYPE_RELATIVE_TOP_RIGHT)
    o.x = r.width - t, o.y = r.height - e;
  else if (n === CCB_POSITIONTYPE_RELATIVE_BOTTOM_RIGHT)
    o.x = r.width - t, o.y = e;
  else if (n === CCB_POSITIONTYPE_PERCENT)
    o.x = r.width * t / 100, o.y = r.height * e / 100;
  else if (n === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION) {
    var a = cc.BuilderReader.getResolutionScale();
    o.x = t * a, o.y = e * a;
  }
  return o;
};
cc.setRelativeScale = function(t, e, n, r, s) {
  if (!t)
    throw new Error("cc.setRelativeScale(): node should be non-null");
  if (r === CCB_POSITIONTYPE_MULTIPLY_RESOLUTION) {
    var o = cc.BuilderReader.getResolutionScale();
    e *= o, n *= o;
  }
  t.setScaleX(e), t.setScaleY(n);
};
cc.BuilderAnimationManagerDelegate = cc.Class.extend({
  completedAnimationSequenceNamed: function(t) {
  }
});
cc.BuilderAnimationManager = cc.Class.extend({
  _sequences: null,
  _nodeSequences: null,
  _baseValues: null,
  _autoPlaySequenceId: 0,
  _rootNode: null,
  _owner: null,
  _rootContainerSize: null,
  _delegate: null,
  _runningSequence: null,
  _documentOutletNames: null,
  _documentOutletNodes: null,
  _documentCallbackNames: null,
  _documentCallbackNodes: null,
  _documentCallbackControlEvents: null,
  _documentControllerName: "",
  _lastCompletedSequenceName: "",
  _keyframeCallbacks: null,
  _keyframeCallFuncs: null,
  _animationCompleteCallbackFunc: null,
  _target: null,
  _jsControlled: !1,
  ctor: function() {
    this._rootContainerSize = cc.size(0, 0), this.init();
  },
  init: function() {
    return this._sequences = [], this._nodeSequences = new cc._Dictionary(), this._baseValues = new cc._Dictionary(), this._documentOutletNames = [], this._documentOutletNodes = [], this._documentCallbackNames = [], this._documentCallbackNodes = [], this._documentCallbackControlEvents = [], this._keyframeCallbacks = [], this._keyframeCallFuncs = {}, !0;
  },
  getSequences: function() {
    return this._sequences;
  },
  setSequences: function(t) {
    this._sequences = t;
  },
  getAutoPlaySequenceId: function() {
    return this._autoPlaySequenceId;
  },
  setAutoPlaySequenceId: function(t) {
    this._autoPlaySequenceId = t;
  },
  getRootNode: function() {
    return this._rootNode;
  },
  setRootNode: function(t) {
    this._rootNode = t;
  },
  getOwner: function() {
    return this._owner;
  },
  setOwner: function(t) {
    this._owner = t;
  },
  addDocumentCallbackNode: function(t) {
    this._documentCallbackNodes.push(t);
  },
  addDocumentCallbackName: function(t) {
    this._documentCallbackNames.push(t);
  },
  addDocumentCallbackControlEvents: function(t) {
    this._documentCallbackControlEvents.push(t);
  },
  addDocumentOutletNode: function(t) {
    this._documentOutletNodes.push(t);
  },
  addDocumentOutletName: function(t) {
    this._documentOutletNames.push(t);
  },
  setDocumentControllerName: function(t) {
    this._documentControllerName = t;
  },
  getDocumentControllerName: function() {
    return this._documentControllerName;
  },
  getDocumentCallbackNames: function() {
    return this._documentCallbackNames;
  },
  getDocumentCallbackNodes: function() {
    return this._documentCallbackNodes;
  },
  getDocumentCallbackControlEvents: function() {
    return this._documentCallbackControlEvents;
  },
  getDocumentOutletNames: function() {
    return this._documentOutletNames;
  },
  getDocumentOutletNodes: function() {
    return this._documentOutletNodes;
  },
  getLastCompletedSequenceName: function() {
    return this._lastCompletedSequenceName;
  },
  getKeyframeCallbacks: function() {
    return this._keyframeCallbacks;
  },
  getRootContainerSize: function() {
    return this._rootContainerSize;
  },
  setRootContainerSize: function(t) {
    this._rootContainerSize = cc.size(t.width, t.height);
  },
  getDelegate: function() {
    return this._delegate;
  },
  setDelegate: function(t) {
    this._delegate = t;
  },
  getRunningSequenceName: function() {
    return this._runningSequence ? this._runningSequence.getName() : null;
  },
  getContainerSize: function(t) {
    return t ? t.getContentSize() : this._rootContainerSize;
  },
  addNode: function(t, e) {
    this._nodeSequences.setObject(e, t);
  },
  setBaseValue: function(t, e, n) {
    var r = (this || window)._baseValues.objectForKey(e);
    r || (r = new cc._Dictionary(), this._baseValues.setObject(r, e)), r.setObject(t, n);
  },
  moveAnimationsFromNode: function(t, e) {
    var n = (this || window)._baseValues, r = n.objectForKey(t);
    r !== null && (n.setObject(r, e), n.removeObjectForKey(t));
    var s = (this || window)._nodeSequences, o = s.objectForKey(t);
    o != null && (s.setObject(o, e), s.removeObjectForKey(t));
  },
  getActionForCallbackChannel: function(t) {
    for (var e = 0, n = [], r = t.getKeyframes(), s = r.length, o = 0; o < s; ++o) {
      var a = r[o], c = a.getTime() - e;
      e = a.getTime(), c > 0 && n.push(cc.delayTime(c));
      var l = a.getValue(), h = l[0], u = l[1];
      if (this._jsControlled) {
        var _ = u + ":" + h, d = (this || window)._keyframeCallFuncs[_];
        d != null && n.push(d);
      } else {
        var f;
        if (u === CCB_TARGETTYPE_DOCUMENTROOT ? f = (this || window)._rootNode : u === CCB_TARGETTYPE_OWNER && (f = (this || window)._owner), f != null)
          if (h.length > 0) {
            var C = 0;
            f.onResolveCCBCCCallFuncSelector != null && (C = f.onResolveCCBCCCallFuncSelector(f, h)), C === 0 ? cc.log("Skipping selector '" + h + "' since no CCBSelectorResolver is present.") : n.push(cc.callFunc(C, f));
          } else
            cc.log("Unexpected empty selector.");
      }
    }
    return n.length < 1 ? null : cc.sequence(n);
  },
  getActionForSoundChannel: function(t) {
    for (var e = 0, n = [], r = t.getKeyframes(), s = r.length, o = 0; o < s; ++o) {
      var a = r[o], c = a.getTime() - e;
      e = a.getTime(), c > 0 && n.push(cc.delayTime(c));
      var l = a.getValue(), h = cc.BuilderReader.getResourcePath() + l[0], u = parseFloat(l[1]), _ = parseFloat(l[2]), d = parseFloat(l[3]);
      n.push(cc.BuilderSoundEffect.create(h, u, _, d));
    }
    return n.length < 1 ? null : cc.sequence(n);
  },
  runAnimationsForSequenceNamed: function(t) {
    this.runAnimationsForSequenceIdTweenDuration(this._getSequenceId(t), 0);
  },
  runAnimationsForSequenceNamedTweenDuration: function(t, e) {
    this.runAnimationsForSequenceIdTweenDuration(this._getSequenceId(t), e);
  },
  runAnimationsForSequenceIdTweenDuration: function(t, e) {
    if (t === -1)
      throw new Error("cc.BuilderAnimationManager.runAnimationsForSequenceIdTweenDuration(): Sequence id should not be -1");
    e = e || 0, this._rootNode.stopAllActions();
    for (var n = (this || window)._nodeSequences.allKeys(), r = 0, s = n.length; r < s; r++) {
      var o = n[r];
      o.stopAllActions();
      var a = (this || window)._nodeSequences.objectForKey(o), c = a.objectForKey(t), l, h = [];
      if (c) {
        var u = c.allKeys();
        for (l = 0; l < u.length; l++) {
          var _ = u[l], d = c.objectForKey(_);
          h.push(_), this._setFirstFrame(o, d, e), this._runAction(o, d, e);
        }
      }
      var f = (this || window)._baseValues.objectForKey(o);
      if (f) {
        var C = f.allKeys();
        for (l = 0; l < C.length; l++) {
          var m = C[l];
          if (h.indexOf(m) === -1) {
            var g = f.objectForKey(m);
            g != null && this._setAnimatedProperty(m, o, g, e);
          }
        }
      }
    }
    var y = (this || window)._getSequence(t), A = cc.sequence(
      cc.delayTime(y.getDuration() + e),
      cc.callFunc(this._sequenceCompleted, this)
    );
    this._rootNode.runAction(A);
    var D;
    y.getCallbackChannel() && (D = (this || window).getActionForCallbackChannel(y.getCallbackChannel()), D && this._rootNode.runAction(D)), y.getSoundChannel() && (D = (this || window).getActionForSoundChannel(y.getSoundChannel()), D && this._rootNode.runAction(D)), this._runningSequence = (this || window)._getSequence(t);
  },
  runAnimations: function(t, e) {
    e = e || 0;
    var n;
    cc.isString(t) ? n = (this || window)._getSequenceId(t) : n = t, this.runAnimationsForSequenceIdTweenDuration(n, e);
  },
  setAnimationCompletedCallback: function(t, e) {
    this._target = t, this._animationCompleteCallbackFunc = e;
  },
  setCompletedAnimationCallback: function(t, e) {
    this.setAnimationCompletedCallback(t, e);
  },
  setCallFunc: function(t, e) {
    this._keyframeCallFuncs[e] = t;
  },
  debug: function() {
  },
  _getBaseValue: function(t, e) {
    var n = (this || window)._baseValues.objectForKey(t);
    return n ? n.objectForKey(e) : null;
  },
  _getSequenceId: function(t) {
    for (var e = null, n = (this || window)._sequences, r = 0, s = n.length; r < s; r++)
      if (e = n[r], e && e.getName() === t)
        return e.getSequenceId();
    return -1;
  },
  _getSequence: function(t) {
    for (var e = null, n = (this || window)._sequences, r = 0, s = n.length; r < s; r++)
      if (e = n[r], e && e.getSequenceId() === t)
        return e;
    return null;
  },
  _getAction: function(t, e, n, r) {
    var s = e.getTime() - (t ? t.getTime() : 0), o, a, c, l, h;
    if (n === "rotation")
      return cc.BuilderRotateTo.create(s, e.getValue());
    if (n === "rotationX")
      return cc.BuilderRotateXTo.create(s, e.getValue());
    if (n === "rotationY")
      return cc.BuilderRotateYTo.create(s, e.getValue());
    if (n === "opacity")
      return cc.fadeTo(s, e.getValue());
    if (n === "color") {
      var u = e.getValue().getColor();
      return cc.tintTo(s, u.r, u.g, u.b);
    } else if (n === "visible") {
      var _ = e.getValue();
      return _ ? cc.sequence(cc.delayTime(s), cc.show()) : cc.sequence(cc.delayTime(s), cc.hide());
    } else {
      if (n === "displayFrame")
        return cc.sequence(cc.delayTime(s), cc.BuilderSetSpriteFrame.create(e.getValue()));
      if (n === "position") {
        o = (this || window)._getBaseValue(r, n), a = o[2], c = e.getValue(), l = c[0], h = c[1];
        var d = (this || window).getContainerSize(r.getParent()), f = cc._getAbsolutePosition(l, h, a, d, n);
        return cc.moveTo(s, f);
      } else if (n === "scale") {
        if (o = (this || window)._getBaseValue(r, n), a = o[2], c = e.getValue(), l = c[0], h = c[1], a === CCB_SCALETYPE_MULTIPLY_RESOLUTION) {
          var C = cc.BuilderReader.getResolutionScale();
          l *= C, h *= C;
        }
        return cc.scaleTo(s, l, h);
      } else {
        if (n === "skew")
          return c = e.getValue(), l = c[0], h = c[1], cc.skewTo(s, l, h);
        cc.log("BuilderReader: Failed to create animation for property: " + n);
      }
    }
    return null;
  },
  _setAnimatedProperty: function(t, e, n, r) {
    if (r > 0) {
      var s = new cc.BuilderKeyframe();
      s.setValue(n), s.setTime(r), s.setEasingType(CCB_KEYFRAME_EASING_LINEAR);
      var o = (this || window)._getAction(null, s, t, e);
      e.runAction(o);
    } else {
      var a, c, l, h;
      if (t === "position")
        a = (this || window)._getBaseValue(e, t), c = a[2], l = n[0], h = n[1], e.setPosition(cc._getAbsolutePosition(l, h, c, this.getContainerSize(e.getParent()), t));
      else if (t === "scale")
        a = (this || window)._getBaseValue(e, t), c = a[2], l = n[0], h = n[1], cc.setRelativeScale(e, l, h, c, t);
      else if (t === "skew")
        l = n[0], h = n[1], e.setSkewX(l), e.setSkewY(h);
      else if (t === "rotation")
        e.setRotation(n);
      else if (t === "rotationX")
        e.setRotationSkewX(n);
      else if (t === "rotationY")
        e.setRotationSkewY(n);
      else if (t === "opacity")
        e.setOpacity(n);
      else if (t === "displayFrame")
        e.setSpriteFrame(n);
      else if (t === "color") {
        var u = n.getColor();
        (u.r !== 255 || u.g !== 255 || u.b !== 255) && e.setColor(u);
      } else
        t === "visible" ? (n = n || !1, e.setVisible(n)) : cc.log("unsupported property name is " + t);
    }
  },
  _setFirstFrame: function(t, e, n) {
    var r = e.getKeyframes();
    if (r.length === 0) {
      var s = (this || window)._getBaseValue(t, e.getName());
      s || cc.log("cc.BuilderAnimationManager._setFirstFrame(): No baseValue found for property"), this._setAnimatedProperty(e.getName(), t, s, n);
    } else {
      var o = r[0];
      this._setAnimatedProperty(e.getName(), t, o.getValue(), n);
    }
  },
  _getEaseAction: function(t, e, n) {
    return e === CCB_KEYFRAME_EASING_LINEAR || e === CCB_KEYFRAME_EASING_INSTANT ? t : e === CCB_KEYFRAME_EASING_CUBIC_IN ? t.easing(cc.easeIn(n)) : e === CCB_KEYFRAME_EASING_CUBIC_OUT ? t.easing(cc.easeOut(n)) : e === CCB_KEYFRAME_EASING_CUBIC_INOUT ? t.easing(cc.easeInOut(n)) : e === CCB_KEYFRAME_EASING_BACK_IN ? t.easing(cc.easeBackIn()) : e === CCB_KEYFRAME_EASING_BACK_OUT ? t.easing(cc.easeBackOut()) : e === CCB_KEYFRAME_EASING_BACK_INOUT ? t.easing(cc.easeBackInOut()) : e === CCB_KEYFRAME_EASING_BOUNCE_IN ? t.easing(cc.easeBounceIn()) : e === CCB_KEYFRAME_EASING_BOUNCE_OUT ? t.easing(cc.easeBounceOut()) : e === CCB_KEYFRAME_EASING_BOUNCE_INOUT ? t.easing(cc.easeBounceInOut()) : e === CCB_KEYFRAME_EASING_ELASTIC_IN ? t.easing(cc.easeElasticIn(n)) : e === CCB_KEYFRAME_EASING_ELASTIC_OUT ? t.easing(cc.easeElasticOut(n)) : e === CCB_KEYFRAME_EASING_ELASTIC_INOUT ? t.easing(cc.easeElasticInOut(n)) : (cc.log("BuilderReader: Unknown easing type " + e), t);
  },
  _runAction: function(t, e, n) {
    var r = e.getKeyframes(), s = r.length;
    if (s > 1) {
      var o = [], a = r[0], c = a.getTime() + n;
      c > 0 && o.push(cc.delayTime(c));
      for (var l = 0; l < s - 1; ++l) {
        var h = r[l], u = r[l + 1], _ = (this || window)._getAction(h, u, e.getName(), t);
        _ && (_ = (this || window)._getEaseAction(_, h.getEasingType(), h.getEasingOpt()), o.push(_));
      }
      t.runAction(cc.sequence(o));
    }
  },
  _sequenceCompleted: function() {
    var t = (this || window)._runningSequence, e = t.getName();
    this._lastCompletedSequenceName != t.getName() && (this._lastCompletedSequenceName = t.getName());
    var n = t.getChainedSequenceId();
    this._runningSequence = null, n !== -1 && this.runAnimations(n, 0), this._delegate && this._delegate.completedAnimationSequenceNamed(e), this._target && this._animationCompleteCallbackFunc && this._animationCompleteCallbackFunc.call(this._target);
  }
});
cc.BuilderSetSpriteFrame = cc.ActionInstant.extend({
  _spriteFrame: null,
  initWithSpriteFrame: function(t) {
    return this._spriteFrame = t, !0;
  },
  update: function(t) {
    this.target.setSpriteFrame(this._spriteFrame);
  }
});
cc.BuilderSetSpriteFrame.create = function(t) {
  var e = new cc.BuilderSetSpriteFrame();
  return e && e.initWithSpriteFrame(t) ? e : null;
};
cc.BuilderRotateTo = cc.ActionInterval.extend({
  _startAngle: 0,
  _dstAngle: 0,
  _diffAngle: 0,
  initWithDuration: function(t, e) {
    return cc.ActionInterval.prototype.initWithDuration.call(this, t) ? (this._dstAngle = e, !0) : !1;
  },
  update: function(t) {
    this.target.setRotation(this._startAngle + this._diffAngle * t);
  },
  startWithTarget: function(t) {
    cc.ActionInterval.prototype.startWithTarget.call(this, t), this._startAngle = (this || window).target.getRotation(), this._diffAngle = (this || window)._dstAngle - this._startAngle;
  }
});
cc.BuilderRotateTo.create = function(t, e) {
  var n = new cc.BuilderRotateTo();
  return n && n.initWithDuration(t, e) ? n : null;
};
cc.BuilderRotateXTo = cc.ActionInterval.extend({});
cc.BuilderRotateXTo.create = function(t, e) {
  throw new Error("rotationX has not been implemented in cocos2d-html5");
};
cc.BuilderRotateYTo = cc.ActionInterval.extend({});
cc.BuilderRotateYTo.create = function(t, e) {
  throw new Error("rotationY has not been implemented in cocos2d-html5");
};
cc.BuilderSoundEffect = cc.ActionInstant.extend({
  init: function(t) {
    return this._file = t, !0;
  },
  update: function(t) {
    cc.audioEngine.playEffect(this._file);
  }
});
cc.BuilderSoundEffect.create = function(t, e, n, r) {
  var s = new cc.BuilderSoundEffect();
  return s && s.init(t) ? s : null;
};
cc.DOM = {};
cc.DOM._addMethods = function(t) {
  for (var e in cc.DOM.methods)
    t[e] = cc.DOM.methods[e];
  cc.defineGetterSetter(t, "x", t.getPositionX, t.setPositionX), cc.defineGetterSetter(t, "y", t.getPositionY, t.setPositionY), cc.defineGetterSetter(t, "width", t._getWidth, t._setWidth), cc.defineGetterSetter(t, "height", t._getHeight, t._setHeight), cc.defineGetterSetter(t, "anchorX", t._getAnchorX, t._setAnchorX), cc.defineGetterSetter(t, "anchorY", t._getAnchorY, t._setAnchorY), cc.defineGetterSetter(t, "scale", t.getScale, t.setScale), cc.defineGetterSetter(t, "scaleX", t.getScaleX, t.setScaleX), cc.defineGetterSetter(t, "scaleY", t.getScaleY, t.setScaleY), cc.defineGetterSetter(t, "rotation", t.getRotation, t.setRotation), cc.defineGetterSetter(t, "skewX", t.getSkewX, t.setSkewX), cc.defineGetterSetter(t, "skewY", t.getSkewY, t.setSkewY), cc.defineGetterSetter(t, "visible", t.isVisible, t.setVisible), cc.defineGetterSetter(t, "parent", t.getParent, t.setParent), cc.defineGetterSetter(t, "opacity", t.getOpacity, t.setOpacity);
};
cc.DOM.methods = {
  setPosition: function(t, e) {
    e === void 0 ? (this._position.x = t.x, this._position.y = t.y) : (this._position.x = t, this._position.y = e), this.setNodeDirty(), this.dom.translates(this._position.x, -this._position.y);
  },
  setPositionY: function(t) {
    this._position.y = t, this.setNodeDirty(), this.dom.translates(this._position.x, -this._position.y);
  },
  setPositionX: function(t) {
    this._position.x = t, this.setNodeDirty(), this.dom.translates(this._position.x, -this._position.y);
  },
  setScale: function(t, e) {
    this._scaleX = t, this._scaleY = e || t, this.setNodeDirty(), this.dom.resize(this._scaleX, this._scaleY);
  },
  setScaleX: function(t) {
    this._scaleX = t, this.setNodeDirty(), this.dom.resize(this._scaleX, this._scaleY);
  },
  setScaleY: function(t) {
    this._scaleY = t, this.setNodeDirty(), this.dom.resize(this._scaleX, this._scaleY);
  },
  setAnchorPoint: function(t, e) {
    var n = (this || window)._renderCmd, r = (this || window)._anchorPoint;
    e === void 0 ? (r.x = t.x, r.y = t.y) : (r.x = t, r.y = e);
    var s = n._anchorPointInPoints, o = (this || window)._contentSize;
    s.x = o.width * r.x, s.y = o.height * r.y, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + s.x + "px " + -s.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : (this.dom.style.marginLeft = (this || window).isToggler ? 0 : -s.x + "px", this.dom.style.marginBottom = -s.y + "px"), this.setNodeDirty();
  },
  _setAnchorX: function(t) {
    var e = (this || window)._anchorPoint, n = (this || window)._renderCmd;
    if (t !== e.x) {
      e.x = t;
      var r = n._anchorPointInPoints, s = (this || window)._contentSize;
      r.x = s.width * e.x, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + r.x + "px " + -r.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : this.dom.style.marginLeft = (this || window).isToggler ? 0 : -r.x + "px", this.setNodeDirty();
    }
  },
  _setAnchorY: function(t) {
    var e = (this || window)._anchorPoint, n = (this || window)._renderCmd;
    if (t !== e.y) {
      e.y = t;
      var r = n._anchorPointInPoints, s = (this || window)._contentSize;
      r.y = s.height * e.y, this.dom.style[cc.$.pfx + "TransformOrigin"] = "" + r.x + "px " + -r.y + "px", this.ignoreAnchor ? (this.dom.style.marginLeft = 0, this.dom.style.marginBottom = 0) : this.dom.style.marginBottom = -r.y + "px", this.setNodeDirty();
    }
  },
  setContentSize: function(t, e) {
    var n = (this || window)._renderCmd, r = (this || window)._contentSize;
    e === void 0 ? (r.width = t.width, r.height = t.height) : (r.width = t, r.height = e);
    var s = n._anchorPointInPoints, o = (this || window)._anchorPoint;
    s.x = r.width * o.x, s.y = r.height * o.y, this.dom.width = r.width, this.dom.height = r.height, this.setAnchorPoint(this.getAnchorPoint()), this.canvas && (this.canvas.width = r.width, this.canvas.height = r.height), this.setNodeDirty(), this.redraw();
  },
  _setWidth: function(t) {
    var e = (this || window)._contentSize, n = (this || window)._renderCmd;
    if (t !== e.width) {
      e.width = t;
      var r = n._anchorPointInPoints, s = (this || window)._anchorPoint;
      r.x = e.width * s.x, this.dom.width = e.width, this.anchorX = s.x, this.canvas && (this.canvas.width = e.width), this.setNodeDirty(), this.redraw();
    }
  },
  _setHeight: function(t) {
    var e = (this || window)._contentSize, n = (this || window)._renderCmd;
    if (t !== e.height) {
      e.height = t;
      var r = n._anchorPointInPoints, s = (this || window)._anchorPoint;
      r.y = e.height * s.y, this.dom.height = e.height, this.anchorY = s.y, this.canvas && (this.canvas.height = e.height), this.setNodeDirty(), this.redraw();
    }
  },
  setRotation: function(t) {
    this._rotation !== t && (this._rotationX = (this || window)._rotationY = t, this.setNodeDirty(), this.dom.rotate(t));
  },
  setSkewX: function(t) {
    this._skewX = t, this.setNodeDirty(), this.dom.setSkew(this._skewX, this._skewY);
  },
  setSkewY: function(t) {
    this._skewY = t, this.setNodeDirty(), this.dom.setSkew(this._skewX, this._skewY);
  },
  setVisible: function(t) {
    this._visible = t, this.setNodeDirty(), this.dom && (this.dom.style.display = t ? "block" : "none");
  },
  _setLocalZOrder: function(t) {
    this._localZOrder = t, this.setNodeDirty(), this.dom && (this.dom.zIndex = t);
  },
  setParent: function(t) {
    this._parent = t, t !== null && (t.setAnchorPoint(t.getAnchorPoint()), this.setNodeDirty(), cc.DOM.parentDOM(this));
  },
  resume: function() {
    this.getScheduler().resumeTarget(this), this.getActionManager().resumeTarget(this), cc.eventManager.resumeTarget(this), this.dom && !this.dom.parentNode && (this.getParent() ? cc.DOM.parentDOM(this) : this.dom.id === "" ? cc.DOM._createEGLViewDiv(this) : this.dom.appendTo(cc.container)), this.dom && (this.dom.style.visibility = "visible");
  },
  pause: function() {
    this.getScheduler().pauseTarget(this), this.getActionManager().pauseTarget(this), cc.eventManager.pauseTarget(this), this.dom && (this.dom.style.visibility = "hidden");
  },
  cleanup: function() {
    this.stopAllActions(), this.unscheduleAllCallbacks(), cc.eventManager.removeListeners(this), this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.cleanup), this.dom && this.dom.remove();
  },
  setOpacity: function(t) {
    this._opacity = t, this.dom.style.opacity = t / 255;
  },
  redraw: function() {
    if (this.isSprite) {
      var t = (this || window)._children;
      this._children = [], cc.Sprite.prototype.visit.call(this, this.ctx), this._children = t;
    } else
      cc.Sprite.prototype.visit.call(this, this.ctx);
  }
};
cc.DOM._resetEGLViewDiv = function() {
  var t = cc.$("#EGLViewDiv");
  if (t) {
    var e = cc.view, n = e.getDesignResolutionSize(), r = e.getViewPortRect(), s = e.getFrameSize(), o = e.getDevicePixelRatio(), a = n.width, c = n.height, l = parseInt(cc.container.style.paddingLeft), h = parseInt(cc.container.style.paddingBottom);
    n.width === 0 && n.height === 0 && (a = s.width, c = s.height), r.width / o, r.width === 0 && r.height === 0 && s.width, t.style.position = "absolute", t.style.width = a + "px", t.style.maxHeight = c + "px", t.style.margin = 0, t.resize(e.getScaleX() / o, e.getScaleY() / o), t.translates(l, -h), e.getResolutionPolicy() === e._rpNoBorder ? (t.style.left = (e.getFrameSize().width - a) / 2 + "px", t.style.bottom = (e.getFrameSize().height - c * e.getScaleY() / o) / 2 + "px") : (t.style.left = (a * e.getScaleX() / o - a) / 2 + "px", t.style.bottom = "0px");
  }
};
cc.DOM.parentDOM = function(t) {
  var e = t.getParent();
  if (!e || !t.dom)
    return !1;
  if (e.dom || (cc.DOM.placeHolder(e), e.setParent = cc.DOM.methods.setParent), t.dom.appendTo(e.dom), e.setAnchorPoint(e.getAnchorPoint()), e.getParent())
    cc.DOM.parentDOM(e);
  else if (e.isRunning()) {
    var n = cc.$("#EGLViewDiv");
    n ? e.dom.appendTo(n) : cc.DOM._createEGLViewDiv(e);
  }
  return !0;
};
cc.DOM._createEGLViewDiv = function(t) {
  var e = cc.$("#EGLViewDiv");
  e || (e = cc.$new("div"), e.id = "EGLViewDiv");
  var n = cc.view, r = n.getDesignResolutionSize(), s = n.getViewPortRect(), o = n.getFrameSize(), a = n.getDevicePixelRatio(), c = r.width, l = r.height, h = parseInt(cc.container.style.paddingLeft), u = parseInt(cc.container.style.paddingBottom);
  r.width === 0 && r.height === 0 && (c = o.width, l = o.height), s.width / a, s.width === 0 && s.height === 0 && o.width, e.style.position = "absolute", e.style.width = c + "px", e.style.maxHeight = l + "px", e.style.margin = 0, e.resize(n.getScaleX() / a, n.getScaleY() / a), e.translates(h, -u), n.getResolutionPolicy() === n._rpNoBorder ? (e.style.left = (o.width - c) / 2 + "px", e.style.bottom = (o.height - l * n.getScaleY() / a) / 2 + "px") : (e.style.left = (c * n.getScaleX() / a - c) / 2 + "px", e.style.bottom = "0px"), t.dom.appendTo(e), e.appendTo(cc.container);
};
cc.DOM.setTransform = function(t) {
  if (t.ctx)
    if (t.ctx.translate(t.getAnchorPointInPoints().x, t.getAnchorPointInPoints().y), t.isSprite) {
      var e = t._children;
      t._children = [], cc.Sprite.prototype.visit.call(t), t._children = e;
    } else
      cc.Sprite.prototype.visit.call(t);
  t.dom && (t.dom.position.x = t.getPositionX(), t.dom.position.y = -t.getPositionY(), t.dom.rotation = t.getRotation(), t.dom.scale = { x: t.getScaleX(), y: t.getScaleY() }, t.dom.skew = { x: t.getSkewX(), y: t.getSkewY() }, t.setAnchorPoint && t.setAnchorPoint(t.getAnchorPoint()), t.dom.transforms());
};
cc.DOM.forSprite = function(t) {
  t.dom = cc.$new("div"), t.canvas = cc.$new("canvas");
  var e = t.getContentSize();
  t.canvas.width = e.width, t.canvas.height = e.height, t.dom.style.position = "absolute", t.dom.style.bottom = 0, t.ctx = t.canvas.getContext("2d"), t.dom.appendChild(t.canvas), t.getParent() && cc.DOM.parentDOM(t), t.isSprite = !0;
};
cc.DOM.placeHolder = function(t) {
  t.dom = cc.$new("div"), t.placeholder = !0, t.dom.style.position = "absolute", t.dom.style.bottom = 0, t.dom.style.width = (t.getContentSize().width || cc.director.getWinSize().width) + "px", t.dom.style.maxHeight = (t.getContentSize().height || cc.director.getWinSize().height) + "px", t.dom.style.margin = 0, cc.DOM.setTransform(t), t.dom.transforms(), cc.DOM._addMethods(t);
};
cc.DOM.convert = function(t) {
  if (arguments.length > 1) {
    cc.DOM.convert(arguments);
    return;
  } else if (arguments.length === 1 && !arguments[0].length) {
    cc.DOM.convert([arguments[0]]);
    return;
  }
  for (var e = arguments[0], n = 0; n < e.length; n++)
    e[n] instanceof cc.Sprite ? e[n].dom || cc.DOM.forSprite(e[n]) : cc.log("DOM converter only supports sprite and menuitems yet"), cc.DOM._addMethods(e[n]), e[n].visit = function() {
    }, e[n].transform = function() {
    }, cc.DOM.setTransform(e[n]), e[n].setVisible(e[n].isVisible());
};
cc.KEYBOARD_RETURNTYPE_DEFAULT = 0;
cc.KEYBOARD_RETURNTYPE_DONE = 1;
cc.KEYBOARD_RETURNTYPE_SEND = 2;
cc.KEYBOARD_RETURNTYPE_SEARCH = 3;
cc.KEYBOARD_RETURNTYPE_GO = 4;
cc.EDITBOX_INPUT_MODE_ANY = 0;
cc.EDITBOX_INPUT_MODE_EMAILADDR = 1;
cc.EDITBOX_INPUT_MODE_NUMERIC = 2;
cc.EDITBOX_INPUT_MODE_PHONENUMBER = 3;
cc.EDITBOX_INPUT_MODE_URL = 4;
cc.EDITBOX_INPUT_MODE_DECIMAL = 5;
cc.EDITBOX_INPUT_MODE_SINGLELINE = 6;
cc.EDITBOX_INPUT_FLAG_PASSWORD = 0;
cc.EDITBOX_INPUT_FLAG_SENSITIVE = 1;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_WORD = 2;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_SENTENCE = 3;
cc.EDITBOX_INPUT_FLAG_INITIAL_CAPS_ALL_CHARACTERS = 4;
cc.EditBoxDelegate = cc.Class.extend({
  editBoxEditingDidBegin: function(t) {
  },
  editBoxEditingDidEnd: function(t) {
  },
  editBoxTextChanged: function(t, e) {
  },
  editBoxReturn: function(t) {
  }
});
cc.EditBox = cc.ControlButton.extend({
  _domInputSprite: null,
  _delegate: null,
  _editBoxInputMode: cc.EDITBOX_INPUT_MODE_ANY,
  _editBoxInputFlag: cc.EDITBOX_INPUT_FLAG_SENSITIVE,
  _keyboardReturnType: cc.KEYBOARD_RETURNTYPE_DEFAULT,
  _text: "",
  _placeholderText: "",
  _textColor: null,
  _placeholderColor: null,
  _maxLength: 50,
  _adjustHeight: 18,
  _edTxt: null,
  _edFontSize: 14,
  _edFontName: "Arial",
  _placeholderFontName: "",
  _placeholderFontSize: 14,
  _tooltip: !1,
  _className: "EditBox",
  _onCanvasClick: null,
  _inputEvent: null,
  _keyPressEvent: null,
  _focusEvent: null,
  _blurEvent: null,
  ctor: function(t, e, n, r) {
    cc.ControlButton.prototype.ctor.call(this), this._textColor = cc.color.WHITE, this._placeholderColor = cc.color.GRAY, this.setContentSize(t);
    var s = (this || window)._domInputSprite = new cc.Sprite();
    s.draw = function() {
    }, this.addChild(s);
    var o = (this || window)._edTxt = document.createElement("input");
    o.type = "text", o.style.fontSize = (this || window)._edFontSize + "px", o.style.color = "#000000", o.style.border = 0, o.style.background = "transparent", o.style.width = "100%", o.style.height = "100%", o.style.active = 0, o.style.outline = "medium", o.style.padding = "0";
    var a = /* @__PURE__ */ H(function() {
      this._edTxt.blur();
    }, "onCanvasClick");
    this._onCanvasClick = a.bind(this);
    var c = /* @__PURE__ */ H(function() {
      this._delegate && this._delegate.editBoxTextChanged && this._delegate.editBoxTextChanged(this, this._edTxt.value);
    }, "inputEvent");
    this._inputEvent = c.bind(this);
    var l = /* @__PURE__ */ H(function(_) {
      _.keyCode === cc.KEY.enter && (_.stopPropagation(), _.preventDefault(), this._delegate && this._delegate.editBoxReturn && this._delegate.editBoxReturn(this), cc._canvas.focus());
    }, "keypressEvent");
    this._keyPressEvent = l.bind(this);
    var h = /* @__PURE__ */ H(function() {
      this._edTxt.value === (this || window)._placeholderText && (this._edTxt.value = "", this._edTxt.style.fontSize = (this || window)._edFontSize + "px", this._edTxt.style.color = cc.colorToHex(this._textColor), this._editBoxInputFlag === cc.EDITBOX_INPUT_FLAG_PASSWORD ? this._edTxt.type = "password" : this._edTxt.type = "text"), this._delegate && this._delegate.editBoxEditingDidBegin && this._delegate.editBoxEditingDidBegin(this), cc._canvas.addEventListener("click", this._onCanvasClick);
    }, "focusEvent");
    this._focusEvent = h.bind(this);
    var u = /* @__PURE__ */ H(function() {
      this._edTxt.value === "" && (this._edTxt.value = (this || window)._placeholderText, this._edTxt.style.fontSize = (this || window)._placeholderFontSize + "px", this._edTxt.style.color = cc.colorToHex(this._placeholderColor), this._edTxt.type = "text"), this._delegate && this._delegate.editBoxEditingDidEnd && this._delegate.editBoxEditingDidEnd(this), cc._canvas.removeEventListener("click", this._onCanvasClick);
    }, "blurEvent");
    this._blurEvent = u.bind(this), o.addEventListener("input", this._inputEvent), o.addEventListener("keypress", this._keyPressEvent), o.addEventListener("focus", this._focusEvent), o.addEventListener("blur", this._blurEvent), cc.DOM.convert(s), s.dom.appendChild(o), s.dom.showTooltipDiv = !1, s.dom.style.width = t.width - 6 + "px", s.dom.style.height = t.height - 6 + "px", s.canvas.remove(), this.initWithSizeAndBackgroundSprite(t, e) && (n && this.setBackgroundSpriteForState(n, cc.CONTROL_STATE_HIGHLIGHTED), r && this.setBackgroundSpriteForState(r, cc.CONTROL_STATE_DISABLED));
  },
  setFont: function(t, e) {
    this._edFontSize = e, this._edFontName = t, this._setFontToEditBox();
  },
  _setFont: function(t) {
    var e = cc.LabelTTF._fontStyleRE.exec(t);
    e && (this._edFontSize = parseInt(e[1]), this._edFontName = e[2], this._setFontToEditBox());
  },
  setFontName: function(t) {
    this._edFontName = t, this._setFontToEditBox();
  },
  setFontSize: function(t) {
    this._edFontSize = t, this._setFontToEditBox();
  },
  _setFontToEditBox: function() {
    this._edTxt.value !== (this || window)._placeholderText && (this._edTxt.style.fontFamily = (this || window)._edFontName, this._edTxt.style.fontSize = (this || window)._edFontSize + "px", this._editBoxInputFlag === cc.EDITBOX_INPUT_FLAG_PASSWORD ? this._edTxt.type = "password" : this._edTxt.type = "text");
  },
  setText: function(t) {
    cc.log("Please use the setString"), this.setString(t);
  },
  setString: function(t) {
    t != null && (t === "" ? (this._edTxt.value = (this || window)._placeholderText, this._edTxt.style.color = cc.colorToHex(this._placeholderColor), this._edTxt.type = "text") : (this._edTxt.value = t, this._edTxt.style.color = cc.colorToHex(this._textColor), this._editBoxInputFlag === cc.EDITBOX_INPUT_FLAG_PASSWORD ? this._edTxt.type = "password" : this._edTxt.type = "text"));
  },
  setFontColor: function(t) {
    this._textColor = t, this._edTxt.value !== (this || window)._placeholderText && (this._edTxt.style.color = cc.colorToHex(t));
  },
  setMaxLength: function(t) {
    !isNaN(t) && t > 0 && (this._maxLength = t, this._edTxt.maxLength = t);
  },
  getMaxLength: function() {
    return this._maxLength;
  },
  setPlaceHolder: function(t) {
    if (t != null) {
      var e = (this || window)._placeholderText;
      this._placeholderText = t, this._edTxt.value === e && (this._edTxt.value = t, this._edTxt.style.color = cc.colorToHex(this._placeholderColor), this._setPlaceholderFontToEditText());
    }
  },
  setPlaceholderFont: function(t, e) {
    this._placeholderFontName = t, this._placeholderFontSize = e, this._setPlaceholderFontToEditText();
  },
  _setPlaceholderFont: function(t) {
    var e = cc.LabelTTF._fontStyleRE.exec(t);
    e && (this._placeholderFontName = e[2], this._placeholderFontSize = parseInt(e[1]), this._setPlaceholderFontToEditText());
  },
  setPlaceholderFontName: function(t) {
    this._placeholderFontName = t, this._setPlaceholderFontToEditText();
  },
  setPlaceholderFontSize: function(t) {
    this._placeholderFontSize = t, this._setPlaceholderFontToEditText();
  },
  _setPlaceholderFontToEditText: function() {
    this._edTxt.value === (this || window)._placeholderText && (this._edTxt.style.fontFamily = (this || window)._placeholderFontName, this._edTxt.style.fontSize = (this || window)._placeholderFontSize + "px", this._edTxt.type = "text");
  },
  setPlaceholderFontColor: function(t) {
    this._placeholderColor = t, this._edTxt.value === (this || window)._placeholderText && (this._edTxt.style.color = cc.colorToHex(t));
  },
  setInputFlag: function(t) {
    this._editBoxInputFlag = t, this._edTxt.value !== (this || window)._placeholderText && t === cc.EDITBOX_INPUT_FLAG_PASSWORD ? this._edTxt.type = "password" : this._edTxt.type = "text";
  },
  getText: function() {
    return cc.log("Please use the getString"), this._edTxt.value;
  },
  getString: function() {
    return this._edTxt.value === (this || window)._placeholderText ? "" : this._edTxt.value;
  },
  initWithSizeAndBackgroundSprite: function(t, e) {
    return this.initWithBackgroundSprite(e) ? (this._domInputSprite.x = 3, this._domInputSprite.y = 3, this.setZoomOnTouchDown(!1), this.setPreferredSize(t), this.x = 0, this.y = 0, this._addTargetWithActionForControlEvent(this, this.touchDownAction, cc.CONTROL_EVENT_TOUCH_UP_INSIDE), !0) : !1;
  },
  setDelegate: function(t) {
    this._delegate = t;
  },
  getPlaceHolder: function() {
    return this._placeholderText;
  },
  setInputMode: function(t) {
    this._editBoxInputMode = t;
  },
  setReturnType: function(t) {
    this._keyboardReturnType = t;
  },
  keyboardWillShow: function(t) {
    var e = cc.EditBox.getRect(this);
    if (e.y -= 4, !e.intersectsRect(t.end)) {
      cc.log("needn't to adjust view layout.");
      return;
    }
    this._adjustHeight = t.end.getMaxY() - e.getMinY();
  },
  keyboardDidShow: function(t) {
  },
  keyboardWillHide: function(t) {
  },
  keyboardDidHide: function(t) {
  },
  touchDownAction: function(t, e) {
  },
  initWithBackgroundColor: function(t, e) {
    this._edWidth = t.width, this.dom.style.width = (this || window)._edWidth.toString() + "px", this._edHeight = t.height, this.dom.style.height = (this || window)._edHeight.toString() + "px", this.dom.style.backgroundColor = cc.colorToHex(e);
  },
  cleanup: function() {
    this._edTxt.removeEventListener("input", this._inputEvent), this._edTxt.removeEventListener("keypress", this._keyPressEvent), this._edTxt.removeEventListener("focus", this._focusEvent), this._edTxt.removeEventListener("blur", this._blurEvent), cc._canvas.removeEventListener("click", this._onCanvasClick), this._super();
  }
});
var _p = cc.EditBox.prototype;
_p.font;
cc.defineGetterSetter(_p, "font", null, _p._setFont);
_p.fontName;
cc.defineGetterSetter(_p, "fontName", null, _p.setFontName);
_p.fontSize;
cc.defineGetterSetter(_p, "fontSize", null, _p.setFontSize);
_p.fontColor;
cc.defineGetterSetter(_p, "fontColor", null, _p.setFontColor);
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p.maxLength;
cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
_p.placeHolder;
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
_p.placeHolderFont;
cc.defineGetterSetter(_p, "placeHolderFont", null, _p._setPlaceholderFont);
_p.placeHolderFontName;
cc.defineGetterSetter(_p, "placeHolderFontName", null, _p.setPlaceholderFontName);
_p.placeHolderFontSize;
cc.defineGetterSetter(_p, "placeHolderFontSize", null, _p.setPlaceholderFontSize);
_p.placeHolderFontColor;
cc.defineGetterSetter(_p, "placeHolderFontColor", null, _p.setPlaceholderFontColor);
_p.inputFlag;
cc.defineGetterSetter(_p, "inputFlag", null, _p.setInputFlag);
_p.delegate;
cc.defineGetterSetter(_p, "delegate", null, _p.setDelegate);
_p.inputMode;
cc.defineGetterSetter(_p, "inputMode", null, _p.setInputMode);
_p.returnType;
cc.defineGetterSetter(_p, "returnType", null, _p.setReturnType);
_p = null;
cc.EditBox.getRect = function(t) {
  var e = t.getContentSize(), n = cc.rect(0, 0, e.width, e.height);
  return cc.rectApplyAffineTransform(n, t.getNodeToWorldTransform());
};
cc.EditBox.create = function(t, e, n, r) {
  return new cc.EditBox(t, e, n, r);
};
cc.ProtectedNode = cc.Node.extend({
  _protectedChildren: null,
  _reorderProtectedChildDirty: !1,
  _insertProtectedChild: function(t, e) {
    this._reorderProtectedChildDirty = !0, this._protectedChildren.push(t), t._setLocalZOrder(e);
  },
  ctor: function() {
    cc.Node.prototype.ctor.call(this), this._protectedChildren = [];
  },
  addProtectedChild: function(t, e, n) {
    cc.assert(t != null, "child must be non-nil"), cc.assert(!t.parent, "child already added. It can't be added again"), e = e || t.getLocalZOrder(), n && t.setTag(n), this._insertProtectedChild(t, e), t.setParent(this), t.setOrderOfArrival(cc.s_globalOrderOfArrival), this._running && (t.onEnter(), this._isTransitionFinished && t.onEnterTransitionDidFinish()), this._cascadeColorEnabled && this._renderCmd.setCascadeColorEnabledDirty(), this._cascadeOpacityEnabled && this._renderCmd.setCascadeOpacityEnabledDirty();
  },
  getProtectedChildByTag: function(t) {
    cc.assert(t !== cc.NODE_TAG_INVALID, "Invalid tag");
    for (var e = (this || window)._protectedChildren, n = 0, r = e.length; n < r; n++)
      if (e.getTag() === t)
        return e[n];
    return null;
  },
  removeProtectedChild: function(t, e) {
    e == null && (e = !0);
    var n = (this || window)._protectedChildren;
    if (n.length !== 0) {
      var r = n.indexOf(t);
      r > -1 && (this._running && (t.onExitTransitionDidStart(), t.onExit()), e && t.cleanup(), t.setParent(null), n.splice(r, 1));
    }
  },
  removeProtectedChildByTag: function(t, e) {
    cc.assert(t !== cc.NODE_TAG_INVALID, "Invalid tag"), e == null && (e = !0);
    var n = (this || window).getProtectedChildByTag(t);
    n == null ? cc.log("cocos2d: removeChildByTag(tag = %d): child not found!", t) : this.removeProtectedChild(n, e);
  },
  removeAllProtectedChildren: function() {
    this.removeAllProtectedChildrenWithCleanup(!0);
  },
  removeAllProtectedChildrenWithCleanup: function(t) {
    t == null && (t = !0);
    for (var e = (this || window)._protectedChildren, n = 0, r = e.length; n < r; n++) {
      var s = e[n];
      this._running && (s.onExitTransitionDidStart(), s.onExit()), t && s.cleanup(), s.setParent(null);
    }
    e.length = 0;
  },
  reorderProtectedChild: function(t, e) {
    cc.assert(t != null, "Child must be non-nil"), this._reorderProtectedChildDirty = !0, t.setOrderOfArrival(cc.s_globalOrderOfArrival++), t._setLocalZOrder(e);
  },
  sortAllProtectedChildren: function() {
    if (this._reorderProtectedChildDirty) {
      var t = (this || window)._protectedChildren, e = t.length, n, r, s;
      for (n = 1; n < e; n++) {
        for (s = t[n], r = n - 1; r >= 0; ) {
          if (s._localZOrder < t[r]._localZOrder)
            t[r + 1] = t[r];
          else if (s._localZOrder === t[r]._localZOrder && s.arrivalOrder < t[r].arrivalOrder)
            t[r + 1] = t[r];
          else
            break;
          r--;
        }
        t[r + 1] = s;
      }
      this._reorderProtectedChildDirty = !1;
    }
  },
  _changePosition: function() {
  },
  cleanup: function() {
    cc.Node.prototype.cleanup.call(this);
    for (var t = (this || window)._protectedChildren, e = 0, n = t.length; e < n; e++)
      t[e].cleanup();
  },
  onEnter: function() {
    cc.Node.prototype.onEnter.call(this);
    for (var t = (this || window)._protectedChildren, e = 0, n = t.length; e < n; e++)
      t[e].onEnter();
  },
  onEnterTransitionDidFinish: function() {
    cc.Node.prototype.onEnterTransitionDidFinish.call(this);
    for (var t = (this || window)._protectedChildren, e = 0, n = t.length; e < n; e++)
      t[e].onEnterTransitionDidFinish();
  },
  onExit: function() {
    cc.Node.prototype.onExit.call(this);
    for (var t = (this || window)._protectedChildren, e = 0, n = t.length; e < n; e++)
      t[e].onExit();
  },
  onExitTransitionDidStart: function() {
    cc.Node.prototype.onExitTransitionDidStart.call(this);
    for (var t = (this || window)._protectedChildren, e = 0, n = t.length; e < n; e++)
      t[e].onExitTransitionDidStart();
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ProtectedNode.CanvasRenderCmd(this) : new cc.ProtectedNode.WebGLRenderCmd(this);
  }
});
cc.ProtectedNode.create = function() {
  return new cc.ProtectedNode();
};
(function() {
  cc.ProtectedNode.RenderCmd = {
    _updateDisplayColor: function(e) {
      var n = (this || window)._node, r = (this || window)._displayedColor, s = n._realColor, o, a, c, l;
      if (this._cascadeColorEnabledDirty && !n._cascadeColorEnabled) {
        r.r = s.r, r.g = s.g, r.b = s.b;
        var h = new cc.Color(255, 255, 255, 255);
        for (c = n._children, o = 0, a = c.length; o < a; o++)
          l = c[o], l && l._renderCmd && l._renderCmd._updateDisplayColor(h);
        this._cascadeColorEnabledDirty = !1;
      } else {
        if (e === void 0) {
          var u = n._parent;
          u && u._cascadeColorEnabled ? e = u.getDisplayedColor() : e = cc.color.WHITE;
        }
        if (r.r = 0 | s.r * e.r / 255, r.g = 0 | s.g * e.g / 255, r.b = 0 | s.b * e.b / 255, n._cascadeColorEnabled)
          for (c = n._children, o = 0, a = c.length; o < a; o++)
            l = c[o], l && l._renderCmd && (l._renderCmd._updateDisplayColor(r), l._renderCmd._updateColor());
        for (c = n._protectedChildren, o = 0, a = c.length; o < a; o++)
          l = c[o], l && l._renderCmd && (l._renderCmd._updateDisplayColor(r), l._renderCmd._updateColor());
      }
      this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.colorDirty ^ this._dirtyFlag;
    },
    _updateDisplayOpacity: function(e) {
      var n = (this || window)._node, r, s, o, a;
      if (this._cascadeOpacityEnabledDirty && !n._cascadeOpacityEnabled) {
        for (this._displayedOpacity = n._realOpacity, o = n._children, r = 0, s = o.length; r < s; r++)
          a = o[r], a && a._renderCmd && a._renderCmd._updateDisplayOpacity(255);
        this._cascadeOpacityEnabledDirty = !1;
      } else {
        if (e === void 0) {
          var c = n._parent;
          e = 255, c && c._cascadeOpacityEnabled && (e = c.getDisplayedOpacity());
        }
        if (this._displayedOpacity = n._realOpacity * e / 255, n._cascadeOpacityEnabled)
          for (o = n._children, r = 0, s = o.length; r < s; r++)
            a = o[r], a && a._renderCmd && (a._renderCmd._updateDisplayOpacity(this._displayedOpacity), a._renderCmd._updateColor());
        for (o = n._protectedChildren, r = 0, s = o.length; r < s; r++)
          a = o[r], a && a._renderCmd && (a._renderCmd._updateDisplayOpacity(this._displayedOpacity), a._renderCmd._updateColor());
      }
      this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.opacityDirty ^ this._dirtyFlag;
    },
    _changeProtectedChild: function(e) {
      var n = e._renderCmd, r = n._dirtyFlag, s = cc.Node._dirtyFlags;
      this._dirtyFlag & s.colorDirty && (r |= s.colorDirty), this._dirtyFlag & s.opacityDirty && (r |= s.opacityDirty);
      var o = r & s.colorDirty, a = r & s.opacityDirty;
      o && n._updateDisplayColor(this._displayedColor), a && n._updateDisplayOpacity(this._displayedOpacity), (o || a) && n._updateColor();
    }
  }, cc.ProtectedNode.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._cachedParent = null, this._cacheDirty = !1;
  };
  var t = cc.ProtectedNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  cc.inject(cc.ProtectedNode.RenderCmd, t), t.constructor = cc.ProtectedNode.CanvasRenderCmd, t.visit = function(e) {
    var n = (this || window)._node;
    if (n._visible) {
      var r, s, o = n._children, a, c = n._children, l = n._protectedChildren, h = c.length, u = l.length;
      this._syncStatus(e), n.sortAllChildren(), n.sortAllProtectedChildren();
      var _;
      for (r = 0; r < h && (a = o[r], a._localZOrder < 0); r++)
        a.visit(this);
      for (s = 0; s < u && (_ = l[s], _ && _._localZOrder < 0); s++)
        this._changeProtectedChild(_), _.visit(this);
      for (cc.renderer.pushRenderCommand(this); r < h; r++)
        o[r] && o[r].visit(this);
      for (; s < u; s++)
        _ = l[s], _ && (this._changeProtectedChild(_), _.visit(this));
      this._dirtyFlag = 0, this._cacheDirty = !1;
    }
  }, t.transform = function(e, n) {
    var r = (this || window)._node;
    r._changePosition && r._changePosition(), this.originTransform(e, n);
    var s, o, a = r._protectedChildren;
    if (n && a && a.length !== 0)
      for (s = 0, o = a.length; s < o; s++)
        a[s]._renderCmd.transform(this, n);
  }, t.pNodeVisit = t.visit, t.pNodeTransform = t.transform;
})();
(function() {
  if (cc.Node.WebGLRenderCmd) {
    cc.ProtectedNode.WebGLRenderCmd = function(e) {
      cc.Node.WebGLRenderCmd.call(this, e);
    };
    var t = cc.ProtectedNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    cc.inject(cc.ProtectedNode.RenderCmd, t), t.constructor = cc.ProtectedNode.WebGLRenderCmd, t.visit = function(e) {
      var n = (this || window)._node;
      if (n._visible) {
        var r, s;
        this._syncStatus(e);
        var o = n.grid;
        o && o._active && o.beforeDraw();
        var a = n._children, c = n._protectedChildren, l = a.length, h = c.length;
        n.sortAllChildren(), n.sortAllProtectedChildren();
        var u;
        for (r = 0; r < l && (a[r] && a[r]._localZOrder < 0); r++)
          a[r].visit(this);
        for (s = 0; s < h && (u = c[s], u && u._localZOrder < 0); s++)
          this._changeProtectedChild(u), u.visit(this);
        for (cc.renderer.pushRenderCommand(this); r < l; r++)
          a[r] && a[r].visit(this);
        for (; s < h; s++)
          u = c[s], u && (this._changeProtectedChild(u), u.visit(this));
        o && o._active && o.afterDraw(n), this._dirtyFlag = 0;
      }
    }, t.transform = function(e, n) {
      this.originTransform(e, n);
      var r, s, o = (this || window)._node._protectedChildren;
      if (n && o && o.length !== 0)
        for (r = 0, s = o.length; r < s; r++)
          o[r]._renderCmd.transform(this, n);
    }, t.pNodeVisit = t.visit, t.pNodeTransform = t.transform;
  }
})();
var ccui = ccui || {};
ccui.Class = ccui.Class || cc.Class;
ccui.Class.extend = ccui.Class.extend || cc.Class.extend;
ccui.Node = ccui.Node || cc.Node;
ccui.Node.extend = ccui.Node.extend || cc.Node.extend;
ccui.ProtectedNode = ccui.ProtectedNode || cc.ProtectedNode;
ccui.ProtectedNode.extend = ccui.ProtectedNode.extend || cc.ProtectedNode.extend;
ccui.cocosGUIVersion = "CocosGUI v1.0.0.0";
ccui._FocusNavigationController = cc.Class.extend({
  _keyboardListener: null,
  _firstFocusedWidget: null,
  _enableFocusNavigation: !1,
  _keyboardEventPriority: 1,
  enableFocusNavigation: function(t) {
    this._enableFocusNavigation !== t && (this._enableFocusNavigation = t, t ? this._addKeyboardEventListener() : this._removeKeyboardEventListener());
  },
  _setFirstFocsuedWidget: function(t) {
    this._firstFocusedWidget = t;
  },
  _onKeyPressed: function(t, e) {
    this._enableFocusNavigation && this._firstFocusedWidget && (t === cc.KEY.dpadDown && (this._firstFocusedWidget = (this || window)._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.DOWN, this._firstFocusedWidget)), t === cc.KEY.dpadUp && (this._firstFocusedWidget = (this || window)._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.UP, this._firstFocusedWidget)), t === cc.KEY.dpadLeft && (this._firstFocusedWidget = (this || window)._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.LEFT, this._firstFocusedWidget)), t === cc.KEY.dpadRight && (this._firstFocusedWidget = (this || window)._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.RIGHT, this._firstFocusedWidget)));
  },
  _addKeyboardEventListener: function() {
    this._keyboardListener || (this._keyboardListener = cc.EventListener.create({
      event: cc.EventListener.KEYBOARD,
      onKeyReleased: this._onKeyPressed.bind(this)
    }), cc.eventManager.addListener(this._keyboardListener, this._keyboardEventPriority));
  },
  _removeKeyboardEventListener: function() {
    this._keyboardListener && (cc.eventManager.removeEventListener(this._keyboardListener), this._keyboardListener = null);
  }
});
ccui.__LAYOUT_COMPONENT_NAME = "__ui_layout";
ccui.Widget = ccui.ProtectedNode.extend({
  _enabled: !0,
  _bright: !0,
  _touchEnabled: !1,
  _brightStyle: null,
  _touchBeganPosition: null,
  _touchMovePosition: null,
  _touchEndPosition: null,
  _touchEventListener: null,
  _touchEventSelector: null,
  _name: "default",
  _widgetType: null,
  _actionTag: 0,
  _customSize: null,
  _layoutParameterDictionary: null,
  _layoutParameterType: 0,
  _focused: !1,
  _focusEnabled: !0,
  _ignoreSize: !1,
  _affectByClipping: !1,
  _sizeType: null,
  _sizePercent: null,
  _positionType: null,
  _positionPercent: null,
  _hit: !1,
  _nodes: null,
  _touchListener: null,
  _className: "Widget",
  _flippedX: !1,
  _flippedY: !1,
  _opacity: 255,
  _highlight: !1,
  _touchEventCallback: null,
  _clickEventListener: null,
  _propagateTouchEvents: !0,
  _unifySize: !1,
  _callbackName: null,
  _callbackType: null,
  _usingLayoutComponent: !1,
  _inViewRect: !0,
  ctor: function() {
    cc.ProtectedNode.prototype.ctor.call(this), this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._touchBeganPosition = cc.p(0, 0), this._touchMovePosition = cc.p(0, 0), this._touchEndPosition = cc.p(0, 0), this._widgetType = ccui.Widget.TYPE_WIDGET, this._customSize = cc.size(0, 0), this._layoutParameterDictionary = {}, this._sizeType = ccui.Widget.SIZE_ABSOLUTE, this._sizePercent = cc.p(0, 0), this._positionType = ccui.Widget.POSITION_ABSOLUTE, this._positionPercent = cc.p(0, 0), this._nodes = [], this._layoutParameterType = ccui.LayoutParameter.NONE, ccui.Widget.prototype.init.call(this);
  },
  /**
       * initializes state of widget. please do not call this function by yourself, you should pass the parameters to constructor to initialize it
  .
       * @returns {boolean}
       */
  init: function() {
    return cc.ProtectedNode.prototype.init.call(this) ? (this._layoutParameterDictionary = {}, this._initRenderer(), this.setBright(!0), this.onFocusChanged = (this || window).onFocusChange, this.onNextFocusedWidget = null, this.setAnchorPoint(cc.p(0.5, 0.5)), this.ignoreContentAdaptWithSize(!0), !0) : !1;
  },
  onEnter: function() {
    var t = (this || window)._touchListener;
    t && !t._isRegistered() && this._touchEnabled && cc.eventManager.addListener(t, this), this._usingLayoutComponent || this.updateSizeAndPosition(), cc.ProtectedNode.prototype.onEnter.call(this);
  },
  onExit: function() {
    this.unscheduleUpdate(), cc.ProtectedNode.prototype.onExit.call(this);
  },
  _getOrCreateLayoutComponent: function() {
    var t = (this || window).getComponent(ccui.__LAYOUT_COMPONENT_NAME);
    return t == null && (t = new ccui.LayoutComponent(), this.addComponent(t)), t;
  },
  getWidgetParent: function() {
    var t = (this || window).getParent();
    return t instanceof ccui.Widget ? t : null;
  },
  _updateContentSizeWithTextureSize: function(t) {
    if (this._unifySize) {
      this.setContentSize(t);
      return;
    }
    this.setContentSize(this._ignoreSize ? t : this._customSize);
  },
  _isAncestorsEnabled: function() {
    var t = (this || window)._getAncensterWidget(this);
    return t == null ? !0 : t && !t.isEnabled() ? !1 : t._isAncestorsEnabled();
  },
  setPropagateTouchEvents: function(t) {
    this._propagateTouchEvents = t;
  },
  isPropagateTouchEvents: function() {
    return this._propagateTouchEvents;
  },
  setSwallowTouches: function(t) {
    this._touchListener && this._touchListener.setSwallowTouches(t);
  },
  isSwallowTouches: function() {
    return this._touchListener ? this._touchListener.isSwallowTouches() : !1;
  },
  _getAncensterWidget: function(t) {
    if (t == null)
      return null;
    var e = t.getParent();
    return e == null ? null : e instanceof ccui.Widget ? e : this._getAncensterWidget(e.getParent());
  },
  _isAncestorsVisible: function(t) {
    if (t == null)
      return !0;
    var e = t.getParent();
    return e && !e.isVisible() ? !1 : this._isAncestorsVisible(e);
  },
  _cleanupWidget: function() {
    this._eventDispatcher.removeEventListener(this._touchListener), this._touchEnabled = !1, this._touchListener = null, ccui.Widget._focusedWidget === (this || window) && (ccui.Widget._focusedWidget = null, ccui.Widget._focusNavigationController = null);
  },
  setEnabled: function(t) {
    this._enabled = t;
  },
  _initRenderer: function() {
  },
  setContentSize: function(t, e) {
    var n = e === void 0 ? t.width : t, r = e === void 0 ? t.height : e;
    if (cc.Node.prototype.setContentSize.call(this, n, r), this._customSize.width = n, this._customSize.height = r, this._unifySize || this._ignoreSize && (this._contentSize = (this || window).getVirtualRendererSize()), !this._usingLayoutComponent && this._running) {
      var s = (this || window).getWidgetParent(), o = s ? s.getContentSize() : this._parent.getContentSize();
      this._sizePercent.x = o.width > 0 ? n / o.width : 0, this._sizePercent.y = o.height > 0 ? r / o.height : 0;
    }
    this._onSizeChanged();
  },
  _setWidth: function(t) {
    if (cc.Node.prototype._setWidth.call(this, t), this._customSize.width = t, this._unifySize || this._ignoreSize && (this._contentSize = (this || window).getVirtualRendererSize()), !this._usingLayoutComponent && this._running) {
      var e = (this || window).getWidgetParent(), n = e ? e.width : this._parent.width;
      this._sizePercent.x = n > 0 ? this._customSize.width / n : 0;
    }
    this._onSizeChanged();
  },
  _setHeight: function(t) {
    if (cc.Node.prototype._setHeight.call(this, t), this._customSize.height = t, this._unifySize || this._ignoreSize && (this._contentSize = (this || window).getVirtualRendererSize()), !this._usingLayoutComponent && this._running) {
      var e = (this || window).getWidgetParent(), n = e ? e.height : this._parent.height;
      this._sizePercent.y = n > 0 ? this._customSize.height / n : 0;
    }
    this._onSizeChanged();
  },
  setSizePercent: function(t) {
    if (this._usingLayoutComponent) {
      var e = (this || window)._getOrCreateLayoutComponent();
      e.setUsingPercentContentSize(!0), e.setPercentContentSize(t), e.refreshLayout();
      return;
    }
    this._sizePercent.x = t.x, this._sizePercent.y = t.y;
    var n = (this || window)._customSize.width, r = (this || window)._customSize.height;
    if (this._running) {
      var s = (this || window).getWidgetParent();
      s ? (n = s.width * t.x, r = s.height * t.y) : (n = (this || window)._parent.width * t.x, r = (this || window)._parent.height * t.y);
    }
    this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(n, r), this._customSize.width = n, this._customSize.height = r;
  },
  _setWidthPercent: function(t) {
    this._sizePercent.x = t;
    var e = (this || window)._customSize.width;
    if (this._running) {
      var n = (this || window).getWidgetParent();
      e = (n ? n.width : this._parent.width) * t;
    }
    this._ignoreSize ? this._setWidth(this.getVirtualRendererSize().width) : this._setWidth(e), this._customSize.width = e;
  },
  _setHeightPercent: function(t) {
    this._sizePercent.y = t;
    var e = (this || window)._customSize.height;
    if (this._running) {
      var n = (this || window).getWidgetParent();
      e = (n ? n.height : this._parent.height) * t;
    }
    this._ignoreSize ? this._setHeight(this.getVirtualRendererSize().height) : this._setHeight(e), this._customSize.height = e;
  },
  updateSizeAndPosition: function(t) {
    if (!t) {
      var e = (this || window).getWidgetParent();
      e ? t = e.getLayoutSize() : t = (this || window)._parent.getContentSize();
    }
    switch (this._sizeType) {
      case ccui.Widget.SIZE_ABSOLUTE:
        this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(this._customSize), this._sizePercent.x = t.width > 0 ? this._customSize.width / t.width : 0, this._sizePercent.y = t.height > 0 ? this._customSize.height / t.height : 0;
        break;
      case ccui.Widget.SIZE_PERCENT:
        var n = cc.size(t.width * this._sizePercent.x, t.height * this._sizePercent.y);
        this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(n), this._customSize.width = n.width, this._customSize.height = n.height;
        break;
    }
    this._onSizeChanged();
    var r = (this || window).getPosition();
    switch (this._positionType) {
      case ccui.Widget.POSITION_ABSOLUTE:
        t.width <= 0 || t.height <= 0 ? this._positionPercent.x = (this || window)._positionPercent.y = 0 : (this._positionPercent.x = r.x / t.width, this._positionPercent.y = r.y / t.height);
        break;
      case ccui.Widget.POSITION_PERCENT:
        r = cc.p(t.width * this._positionPercent.x, t.height * this._positionPercent.y);
        break;
    }
    if (this._parent instanceof ccui.ImageView) {
      var s = (this || window)._parent._imageRenderer;
      if (s && !s._textureLoaded)
        return;
    }
    this.setPosition(r);
  },
  setSizeType: function(t) {
    if (this._sizeType = t, this._usingLayoutComponent) {
      var e = (this || window)._getOrCreateLayoutComponent();
      e.setUsingPercentContentSize(this._sizeType === ccui.SIZE_PERCENT);
    }
  },
  getSizeType: function() {
    return this._sizeType;
  },
  ignoreContentAdaptWithSize: function(t) {
    if (this._unifySize) {
      this.setContentSize(this._customSize);
      return;
    }
    this._ignoreSize !== t && (this._ignoreSize = t, this.setContentSize(t ? this.getVirtualRendererSize() : this._customSize));
  },
  isIgnoreContentAdaptWithSize: function() {
    return this._ignoreSize;
  },
  getCustomSize: function() {
    return cc.size(this._customSize);
  },
  getLayoutSize: function() {
    return cc.size(this._contentSize);
  },
  getSizePercent: function() {
    if (this._usingLayoutComponent) {
      var t = (this || window)._getOrCreateLayoutComponent();
      this._sizePercent = t.getPercentContentSize();
    }
    return this._sizePercent;
  },
  _getWidthPercent: function() {
    return this._sizePercent.x;
  },
  _getHeightPercent: function() {
    return this._sizePercent.y;
  },
  getWorldPosition: function() {
    return this.convertToWorldSpace(cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height));
  },
  getVirtualRenderer: function() {
    return (this || window)
  },
  getVirtualRendererSize: function() {
    return cc.size(this._contentSize);
  },
  _onSizeChanged: function() {
    if (!this._usingLayoutComponent)
      for (var t = (this || window).getChildren(), e = 0, n = t.length; e < n; e++) {
        var r = t[e];
        r instanceof ccui.Widget && r.updateSizeAndPosition();
      }
  },
  setTouchEnabled: function(t) {
    this._touchEnabled !== t && (this._touchEnabled = t, this._touchEnabled ? (this._touchListener || (this._touchListener = cc.EventListener.create({
      event: cc.EventListener.TOUCH_ONE_BY_ONE,
      swallowTouches: !0,
      onTouchBegan: this.onTouchBegan.bind(this),
      onTouchMoved: this.onTouchMoved.bind(this),
      onTouchEnded: this.onTouchEnded.bind(this)
    })), cc.eventManager.addListener(this._touchListener, this)) : cc.eventManager.removeListener(this._touchListener));
  },
  isTouchEnabled: function() {
    return this._touchEnabled;
  },
  isHighlighted: function() {
    return this._highlight;
  },
  setHighlighted: function(t) {
    t !== (this || window)._highlight && (this._highlight = t, this._bright ? this._highlight ? this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT) : this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL) : this._onPressStateChangedToDisabled());
  },
  isFocused: function() {
    return this._focused;
  },
  setFocused: function(t) {
    this._focused = t, t && (ccui.Widget._focusedWidget = (this || window), ccui.Widget._focusNavigationController && ccui.Widget._focusNavigationController._setFirstFocsuedWidget(this));
  },
  isFocusEnabled: function() {
    return this._focusEnabled;
  },
  setFocusEnabled: function(t) {
    this._focusEnabled = t;
  },
  findNextFocusedWidget: function(t, e) {
    if (this.onNextFocusedWidget === null || this.onNextFocusedWidget(t) == null) {
      var n = e instanceof ccui.Layout;
      if (this.isFocused() || n) {
        var r = (this || window).getParent();
        return r === null || !(r instanceof ccui.Layout) ? n ? e.findNextFocusedWidget(t, e) : e : r.findNextFocusedWidget(t, e);
      } else
        return e;
    } else {
      var s = (this || window).onNextFocusedWidget(t);
      return this.dispatchFocusEvent(this, s), s;
    }
  },
  requestFocus: function() {
    this !== ccui.Widget._focusedWidget && this.dispatchFocusEvent(ccui.Widget._focusedWidget, this);
  },
  getCurrentFocusedWidget: function() {
    return ccui.Widget._focusedWidget;
  },
  onFocusChanged: null,
  onNextFocusedWidget: null,
  interceptTouchEvent: function(t, e, n) {
    var r = (this || window).getWidgetParent();
    r && r.interceptTouchEvent(t, e, n);
  },
  onFocusChange: function(t, e) {
    t && t.setFocused(!1), e && e.setFocused(!0);
  },
  dispatchFocusEvent: function(t, e) {
    t && !t.isFocused() && (t = ccui.Widget._focusedWidget), e !== t && (e && e.onFocusChanged && e.onFocusChanged(t, e), t && e.onFocusChanged && t.onFocusChanged(t, e), cc.eventManager.dispatchEvent(new cc.EventFocus(t, e)));
  },
  setBright: function(t) {
    this._bright = t, this._bright ? (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL)) : this._onPressStateChangedToDisabled();
  },
  setBrightStyle: function(t) {
    if (this._brightStyle !== t)
      switch (t = t || ccui.Widget.BRIGHT_STYLE_NORMAL, this._brightStyle = t, this._brightStyle) {
        case ccui.Widget.BRIGHT_STYLE_NORMAL:
          this._onPressStateChangedToNormal();
          break;
        case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
          this._onPressStateChangedToPressed();
          break;
      }
  },
  _onPressStateChangedToNormal: function() {
  },
  _onPressStateChangedToPressed: function() {
  },
  _onPressStateChangedToDisabled: function() {
  },
  _updateChildrenDisplayedRGBA: function() {
    this.setColor(this.getColor()), this.setOpacity(this.getOpacity());
  },
  didNotSelectSelf: function() {
  },
  onTouchBegan: function(t, e) {
    if (this._hit = !1, this.isVisible() && this.isEnabled() && this._isAncestorsEnabled() && this._isAncestorsVisible(this)) {
      var n = t.getLocation();
      this._touchBeganPosition.x = n.x, this._touchBeganPosition.y = n.y, this.hitTest(this._touchBeganPosition) && this.isClippingParentContainsPoint(this._touchBeganPosition) && (this._hit = !0);
    }
    return this._hit ? (this.setHighlighted(!0), this._propagateTouchEvents && this.propagateTouchEvent(ccui.Widget.TOUCH_BEGAN, this, t), this._pushDownEvent(), !0) : !1;
  },
  propagateTouchEvent: function(t, e, n) {
    var r = (this || window).getWidgetParent();
    r && r.interceptTouchEvent(t, e, n);
  },
  onTouchMoved: function(t, e) {
    var n = t.getLocation();
    this._touchMovePosition.x = n.x, this._touchMovePosition.y = n.y, this.setHighlighted(this.hitTest(n)), this._propagateTouchEvents && this.propagateTouchEvent(ccui.Widget.TOUCH_MOVED, this, t), this._moveEvent();
  },
  onTouchEnded: function(t, e) {
    var n = t.getLocation();
    this._touchEndPosition.x = n.x, this._touchEndPosition.y = n.y, this._propagateTouchEvents && this.propagateTouchEvent(ccui.Widget.TOUCH_ENDED, this, t);
    var r = (this || window)._highlight;
    this.setHighlighted(!1), r ? this._releaseUpEvent() : this._cancelUpEvent();
  },
  onTouchCancelled: function(t) {
    this.setHighlighted(!1), this._cancelUpEvent();
  },
  onTouchLongClicked: function(t) {
    this.longClickEvent();
  },
  _pushDownEvent: function() {
    this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_BEGAN), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_BEGAN);
  },
  _moveEvent: function() {
    this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_MOVED), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_MOVED);
  },
  _releaseUpEvent: function() {
    this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_ENDED), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_ENDED), this._clickEventListener && this._clickEventListener(this);
  },
  _cancelUpEvent: function() {
    this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_CANCELED), this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_CANCELED);
  },
  longClickEvent: function() {
  },
  addTouchEventListener: function(t, e) {
    e === void 0 ? this._touchEventCallback = t : (this._touchEventSelector = t, this._touchEventListener = e);
  },
  addClickEventListener: function(t) {
    this._clickEventListener = t;
  },
  hitTest: function(t) {
    var e = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
    return cc.rectContainsPoint(e, this.convertToNodeSpace(t));
  },
  isClippingParentContainsPoint: function(t) {
    this._affectByClipping = !1;
    for (var e = (this || window).getParent(), n = null; e; ) {
      if (e instanceof ccui.Layout && e.isClippingEnabled()) {
        this._affectByClipping = !0, n = e;
        break;
      }
      e = e.getParent();
    }
    return this._affectByClipping && n ? n.hitTest(t) ? n.isClippingParentContainsPoint(t) : !1 : !0;
  },
  checkChildInfo: function(t, e, n) {
    var r = (this || window).getWidgetParent();
    r && r.checkChildInfo(t, e, n);
  },
  setPosition: function(t, e) {
    if (!this._usingLayoutComponent && this._running) {
      var n = (this || window).getWidgetParent();
      if (n) {
        var r = n.getContentSize();
        r.width <= 0 || r.height <= 0 ? (this._positionPercent.x = 0, this._positionPercent.y = 0) : e === void 0 ? (this._positionPercent.x = t.x / r.width, this._positionPercent.y = t.y / r.height) : (this._positionPercent.x = t / r.width, this._positionPercent.y = e / r.height);
      }
    }
    cc.Node.prototype.setPosition.call(this, t, e);
  },
  setPositionX: function(t) {
    if (this._running) {
      var e = (this || window).getWidgetParent();
      if (e) {
        var n = e.width;
        n <= 0 ? this._positionPercent.x = 0 : this._positionPercent.x = t / n;
      }
    }
    cc.Node.prototype.setPositionX.call(this, t);
  },
  setPositionY: function(t) {
    if (this._running) {
      var e = (this || window).getWidgetParent();
      if (e) {
        var n = e.height;
        n <= 0 ? this._positionPercent.y = 0 : this._positionPercent.y = t / n;
      }
    }
    cc.Node.prototype.setPositionY.call(this, t);
  },
  setPositionPercent: function(t) {
    if (this._usingLayoutComponent) {
      var e = (this || window)._getOrCreateLayoutComponent();
      e.setPositionPercentX(t.x), e.setPositionPercentY(t.y), e.refreshLayout();
      return;
    } else
      this._setXPercent(t.x), this._setYPercent(t.y);
    this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  _setXPercent: function(t) {
    if (this._usingLayoutComponent) {
      var e = (this || window)._getOrCreateLayoutComponent();
      e.setPositionPercentX(t.x), e.refreshLayout();
      return;
    }
    this._positionPercent.x = t;
  },
  _setYPercent: function(t) {
    if (this._usingLayoutComponent) {
      var e = (this || window)._getOrCreateLayoutComponent();
      e.setPositionPercentY(t.x), e.refreshLayout();
      return;
    }
    this._positionPercent.y = t;
  },
  getPositionPercent: function() {
    if (this._usingLayoutComponent) {
      var t = (this || window)._getOrCreateLayoutComponent();
      this._positionPercent.x = t.getPositionPercentX(), this._positionPercent.y = t.getPositionPercentY();
    }
    return cc.p(this._positionPercent);
  },
  _getXPercent: function() {
    if (this._usingLayoutComponent) {
      var t = (this || window)._getOrCreateLayoutComponent();
      this._positionPercent.x = t.getPositionPercentX(), this._positionPercent.y = t.getPositionPercentY();
    }
    return this._positionPercent.x;
  },
  _getYPercent: function() {
    if (this._usingLayoutComponent) {
      var t = (this || window)._getOrCreateLayoutComponent();
      this._positionPercent.x = t.getPositionPercentX(), this._positionPercent.y = t.getPositionPercentY();
    }
    return this._positionPercent.y;
  },
  setPositionType: function(t) {
    if (this._positionType = t, this._usingLayoutComponent) {
      var e = (this || window)._getOrCreateLayoutComponent();
      t === ccui.POSITION_ABSOLUTE ? (e.setPositionPercentXEnabled(!1), e.setPositionPercentYEnabled(!1)) : (e.setPositionPercentXEnabled(!0), e.setPositionPercentYEnabled(!0));
    }
    this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
  },
  getPositionType: function() {
    return this._positionType;
  },
  setFlippedX: function(t) {
    var e = (this || window).getScaleX();
    this._flippedX = t, this.setScaleX(e);
  },
  isFlippedX: function() {
    return this._flippedX;
  },
  setFlippedY: function(t) {
    var e = (this || window).getScaleY();
    this._flippedY = t, this.setScaleY(e);
  },
  isFlippedY: function() {
    return this._flippedY;
  },
  _adaptRenderers: function() {
  },
  isBright: function() {
    return this._bright;
  },
  isEnabled: function() {
    return this._enabled;
  },
  getLeftBoundary: function() {
    return this.getPositionX() - this._getAnchorX() * this._contentSize.width;
  },
  getBottomBoundary: function() {
    return this.getPositionY() - this._getAnchorY() * this._contentSize.height;
  },
  getRightBoundary: function() {
    return this.getLeftBoundary() + this._contentSize.width;
  },
  getTopBoundary: function() {
    return this.getBottomBoundary() + this._contentSize.height;
  },
  getTouchBeganPosition: function() {
    return cc.p(this._touchBeganPosition);
  },
  getTouchMovePosition: function() {
    return cc.p(this._touchMovePosition);
  },
  getTouchEndPosition: function() {
    return cc.p(this._touchEndPosition);
  },
  getWidgetType: function() {
    return this._widgetType;
  },
  setLayoutParameter: function(t) {
    t && (this._layoutParameterDictionary[t.getLayoutType()] = t, this._layoutParameterType = t.getLayoutType());
  },
  getLayoutParameter: function(t) {
    return t = t || this._layoutParameterType, this._layoutParameterDictionary[t];
  },
  getDescription: function() {
    return "Widget";
  },
  clone: function() {
    var t = (this || window)._createCloneInstance();
    return t._copyProperties(this), t._copyClonedWidgetChildren(this), t;
  },
  _createCloneInstance: function() {
    return new ccui.Widget();
  },
  _copyClonedWidgetChildren: function(t) {
    for (var e = t.getChildren(), n = 0; n < e.length; n++) {
      var r = e[n];
      r instanceof ccui.Widget && this.addChild(r.clone());
    }
  },
  _copySpecialProperties: function(t) {
  },
  _copyProperties: function(t) {
    this.setEnabled(t.isEnabled()), this.setVisible(t.isVisible()), this.setBright(t.isBright()), this.setTouchEnabled(t.isTouchEnabled()), this.setLocalZOrder(t.getLocalZOrder()), this.setTag(t.getTag()), this.setName(t.getName()), this.setActionTag(t.getActionTag()), this._ignoreSize = t._ignoreSize, this.setContentSize(t._contentSize), this._customSize.width = t._customSize.width, this._customSize.height = t._customSize.height, this._copySpecialProperties(t), this._sizeType = t.getSizeType(), this._sizePercent.x = t._sizePercent.x, this._sizePercent.y = t._sizePercent.y, this._positionType = t._positionType, this._positionPercent.x = t._positionPercent.x, this._positionPercent.y = t._positionPercent.y, this.setPosition(t.getPosition()), this.setAnchorPoint(t.getAnchorPoint()), this.setScaleX(t.getScaleX()), this.setScaleY(t.getScaleY()), this.setRotation(t.getRotation()), this.setRotationX(t.getRotationX()), this.setRotationY(t.getRotationY()), this.setFlippedX(t.isFlippedX()), this.setFlippedY(t.isFlippedY()), this.setColor(t.getColor()), this.setOpacity(t.getOpacity()), this._touchEventCallback = t._touchEventCallback, this._touchEventListener = t._touchEventListener, this._touchEventSelector = t._touchEventSelector, this._clickEventListener = t._clickEventListener, this._focused = t._focused, this._focusEnabled = t._focusEnabled, this._propagateTouchEvents = t._propagateTouchEvents;
    for (var e in t._layoutParameterDictionary) {
      var n = t._layoutParameterDictionary[e];
      n && this.setLayoutParameter(n.clone());
    }
    this._onSizeChanged();
  },
  setActionTag: function(t) {
    this._actionTag = t;
  },
  getActionTag: function() {
    return this._actionTag;
  },
  getLeftInParent: function() {
    return cc.log("getLeftInParent is deprecated. Please use getLeftBoundary instead."), this.getLeftBoundary();
  },
  getBottomInParent: function() {
    return cc.log("getBottomInParent is deprecated. Please use getBottomBoundary instead."), this.getBottomBoundary();
  },
  getRightInParent: function() {
    return cc.log("getRightInParent is deprecated. Please use getRightBoundary instead."), this.getRightBoundary();
  },
  getTopInParent: function() {
    return cc.log("getTopInParent is deprecated. Please use getTopBoundary instead."), this.getTopBoundary();
  },
  getTouchEndPos: function() {
    return cc.log("getTouchEndPos is deprecated. Please use getTouchEndPosition instead."), this.getTouchEndPosition();
  },
  getTouchMovePos: function() {
    return cc.log("getTouchMovePos is deprecated. Please use getTouchMovePosition instead."), this.getTouchMovePosition();
  },
  clippingParentAreaContainPoint: function(t) {
    cc.log("clippingParentAreaContainPoint is deprecated. Please use isClippingParentContainsPoint instead."), this.isClippingParentContainsPoint(t);
  },
  getTouchStartPos: function() {
    return cc.log("getTouchStartPos is deprecated. Please use getTouchBeganPosition instead."), this.getTouchBeganPosition();
  },
  setSize: function(t) {
    this.setContentSize(t);
  },
  getSize: function() {
    return this.getContentSize();
  },
  addNode: function(t, e, n) {
    if (t instanceof ccui.Widget) {
      cc.log("Please use addChild to add a Widget.");
      return;
    }
    cc.Node.prototype.addChild.call(this, t, e, n), this._nodes.push(t);
  },
  getNodeByTag: function(t) {
    for (var e = (this || window)._nodes, n = 0; n < e.length; n++) {
      var r = e[n];
      if (r && r.getTag() === t)
        return r;
    }
    return null;
  },
  getNodes: function() {
    return this._nodes;
  },
  removeNode: function(t, e) {
    cc.Node.prototype.removeChild.call(this, t, e), cc.arrayRemoveObject(this._nodes, t);
  },
  removeNodeByTag: function(t, e) {
    var n = (this || window).getChildByTag(t);
    n ? this.removeChild(n, e) : cc.log("cocos2d: removeNodeByTag(tag = %d): child not found!", t);
  },
  removeAllNodes: function() {
    for (var t = 0; t < this._nodes.length; t++) {
      var e = (this || window)._nodes[t];
      cc.Node.prototype.removeChild.call(this, e);
    }
    this._nodes.length = 0;
  },
  _findLayout: function() {
    cc.renderer.childrenOrderDirty = !0;
    for (var t = (this || window)._parent; t; )
      if (t._doLayout) {
        t._doLayoutDirty = !0;
        break;
      } else
        t = t._parent;
  },
  isUnifySizeEnabled: function() {
    return this._unifySize;
  },
  setUnifySizeEnabled: function(t) {
    this._unifySize = t;
  },
  _ccEventCallback: null,
  addCCSEventListener: function(t) {
    this._ccEventCallback = t;
  },
  setScaleX: function(t) {
    this._flippedX && (t = t * -1), cc.Node.prototype.setScaleX.call(this, t);
  },
  setScaleY: function(t) {
    this._flippedY && (t = t * -1), cc.Node.prototype.setScaleY.call(this, t);
  },
  setScale: function(t, e) {
    e === void 0 && (e = t), this.setScaleX(t), this.setScaleY(e);
  },
  getScaleX: function() {
    var t = cc.Node.prototype.getScaleX.call(this);
    return this._flippedX && (t = t * -1), t;
  },
  getScaleY: function() {
    var t = cc.Node.prototype.getScaleY.call(this);
    return this._flippedY && (t = t * -1), t;
  },
  getScale: function() {
    return this.getScaleX() !== (this || window).getScaleY() && cc.log("Widget#scale. ScaleX != ScaleY. Don't know which one to return"), this.getScaleX();
  },
  setCallbackName: function(t) {
    this._callbackName = t;
  },
  getCallbackName: function() {
    return this._callbackName;
  },
  setCallbackType: function(t) {
    this._callbackType = t;
  },
  getCallbackType: function() {
    return this._callbackType;
  },
  setLayoutComponentEnabled: function(t) {
    this._usingLayoutComponent = t;
  },
  isLayoutComponentEnabled: function() {
    return this._usingLayoutComponent;
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new ccui.Widget.WebGLRenderCmd(this) : new ccui.Widget.CanvasRenderCmd(this);
  }
});
var _p = ccui.Widget.prototype;
_p.xPercent;
cc.defineGetterSetter(_p, "xPercent", _p._getXPercent, _p._setXPercent);
_p.yPercent;
cc.defineGetterSetter(_p, "yPercent", _p._getYPercent, _p._setYPercent);
_p.widthPercent;
cc.defineGetterSetter(_p, "widthPercent", _p._getWidthPercent, _p._setWidthPercent);
_p.heightPercent;
cc.defineGetterSetter(_p, "heightPercent", _p._getHeightPercent, _p._setHeightPercent);
_p.widgetParent;
cc.defineGetterSetter(_p, "widgetParent", _p.getWidgetParent);
_p.enabled;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
_p.focused;
cc.defineGetterSetter(_p, "focused", _p.isFocused, _p.setFocused);
_p.sizeType;
cc.defineGetterSetter(_p, "sizeType", _p.getSizeType, _p.setSizeType);
_p.widgetType;
cc.defineGetterSetter(_p, "widgetType", _p.getWidgetType);
_p.touchEnabled;
cc.defineGetterSetter(_p, "touchEnabled", _p.isTouchEnabled, _p.setTouchEnabled);
_p.updateEnabled;
cc.defineGetterSetter(_p, "updateEnabled", _p.isUpdateEnabled, _p.setUpdateEnabled);
_p.bright;
cc.defineGetterSetter(_p, "bright", _p.isBright, _p.setBright);
_p.name;
cc.defineGetterSetter(_p, "name", _p.getName, _p.setName);
_p.actionTag;
cc.defineGetterSetter(_p, "actionTag", _p.getActionTag, _p.setActionTag);
_p.opacity;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
_p = null;
ccui.Widget.create = function() {
  return new ccui.Widget();
};
ccui.Widget._focusedWidget = null;
ccui.Widget._focusNavigationController = null;
ccui.Widget.enableDpadNavigation = function(t) {
  t ? (ccui.Widget._focusNavigationController == null && (ccui.Widget._focusNavigationController = new ccui._FocusNavigationController(), ccui.Widget._focusedWidget && ccui.Widget._focusNavigationController._setFirstFocsuedWidget(ccui.Widget._focusedWidget)), ccui.Widget._focusNavigationController.enableFocusNavigation(!0)) : ccui.Widget._focusNavigationController && (ccui.Widget._focusNavigationController.enableFocusNavigation(!1), ccui.Widget._focusNavigationController = null);
};
ccui.Widget.getCurrentFocusedWidget = function() {
  return ccui.Widget._focusedWidget;
};
ccui.Widget.BRIGHT_STYLE_NONE = -1;
ccui.Widget.BRIGHT_STYLE_NORMAL = 0;
ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT = 1;
ccui.Widget.TYPE_WIDGET = 0;
ccui.Widget.TYPE_CONTAINER = 1;
ccui.Widget.LEFT = 0;
ccui.Widget.RIGHT = 1;
ccui.Widget.UP = 2;
ccui.Widget.DOWN = 3;
ccui.Widget.LOCAL_TEXTURE = 0;
ccui.Widget.PLIST_TEXTURE = 1;
ccui.Widget.TOUCH_BEGAN = 0;
ccui.Widget.TOUCH_MOVED = 1;
ccui.Widget.TOUCH_ENDED = 2;
ccui.Widget.TOUCH_CANCELED = 3;
ccui.Widget.SIZE_ABSOLUTE = 0;
ccui.Widget.SIZE_PERCENT = 1;
ccui.Widget.POSITION_ABSOLUTE = 0;
ccui.Widget.POSITION_PERCENT = 1;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
  if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
    ccui.Widget.CanvasRenderCmd = function(e) {
      cc.ProtectedNode.CanvasRenderCmd.call(this, e), this._needDraw = !1;
    };
    var t = ccui.Widget.CanvasRenderCmd.prototype = Object.create(cc.ProtectedNode.CanvasRenderCmd.prototype);
    t.constructor = ccui.Widget.CanvasRenderCmd, t.visit = function(e) {
      var n = (this || window)._node;
      n._visible && (n._adaptRenderers(), this.pNodeVisit(e));
    }, t.transform = function(e, n) {
      var r = (this || window)._node;
      if (r._visible && r._running) {
        if (r._adaptRenderers(), !this._usingLayoutComponent) {
          var s = r.getWidgetParent();
          if (s) {
            var o = s.getContentSize();
            o.width !== 0 && o.height !== 0 && (r._position.x = o.width * r._positionPercent.x, r._position.y = o.height * r._positionPercent.y);
          }
        }
        this.pNodeTransform(e, n);
      }
    }, t.widgetVisit = t.visit, t.widgetTransform = t.transform;
  } else {
    ccui.Widget.WebGLRenderCmd = function(n) {
      cc.ProtectedNode.WebGLRenderCmd.call(this, n), this._needDraw = !1;
    };
    var t = ccui.Widget.WebGLRenderCmd.prototype = Object.create(cc.ProtectedNode.WebGLRenderCmd.prototype);
    t.constructor = ccui.Widget.WebGLRenderCmd, t.visit = function(n) {
      var r = (this || window)._node;
      r._visible && (r._adaptRenderers(), this.pNodeVisit(n));
    }, t.transform = function(n, r) {
      var s = (this || window)._node;
      if (s._visible && s._running) {
        if (s._adaptRenderers(), !this._usingLayoutComponent) {
          var o = s.getWidgetParent();
          if (o) {
            var a = o.getContentSize();
            a.width !== 0 && a.height !== 0 && (s._position.x = a.width * s._positionPercent.x, s._position.y = a.height * s._positionPercent.y);
          }
        }
        this.pNodeTransform(n, r);
      }
    }, t.widgetVisit = t.visit, t.widgetTransform = t.transform;
  }
});
ccui.Scale9Sprite = cc.Scale9Sprite = cc.Node.extend({
  _spriteRect: null,
  _capInsetsInternal: null,
  _positionsAreDirty: !1,
  _scale9Image: null,
  _topLeft: null,
  _top: null,
  _topRight: null,
  _left: null,
  _centre: null,
  _right: null,
  _bottomLeft: null,
  _bottom: null,
  _bottomRight: null,
  _scale9Enabled: !0,
  _brightState: 0,
  _renderers: null,
  _opacityModifyRGB: !1,
  _originalSize: null,
  _preferredSize: null,
  _opacity: 0,
  _color: null,
  _capInsets: null,
  _insetLeft: 0,
  _insetTop: 0,
  _insetRight: 0,
  _insetBottom: 0,
  _spriteFrameRotated: !1,
  _textureLoaded: !1,
  _className: "Scale9Sprite",
  _flippedX: !1,
  _flippedY: !1,
  textureLoaded: function() {
    return this._textureLoaded;
  },
  addLoadedEventListener: function(t, e) {
    this.addEventListener("load", t, e);
  },
  _updateCapInset: function() {
    var t, e = (this || window)._insetLeft, n = (this || window)._insetTop, r = (this || window)._insetRight, s = (this || window)._spriteRect, o = (this || window)._insetBottom;
    e === 0 && n === 0 && r === 0 && o === 0 ? t = cc.rect(0, 0, 0, 0) : t = (this || window)._spriteFrameRotated ? cc.rect(
      o,
      e,
      s.width - r - e,
      s.height - n - o
    ) : cc.rect(
      e,
      n,
      s.width - e - r,
      s.height - n - o
    ), this.setCapInsets(t);
  },
  _updatePositions: function() {
    if (this._topLeft && this._topRight && this._bottomRight && this._bottomLeft && this._centre) {
      var t = (this || window)._contentSize, e = (this || window)._topLeft, n = (this || window)._topRight, r = (this || window)._bottomRight, s = (this || window)._bottomLeft, o = (this || window)._left, a = (this || window)._right, c = (this || window)._top, l = (this || window)._bottom, h = (this || window)._centre, u = (this || window)._centre.getContentSize(), _ = e.getContentSize(), d = s.getContentSize(), f = t.width - _.width - n.getContentSize().width, C = t.height - _.height - r.getContentSize().height, m = f / u.width, g = C / u.height, y = u.width * m, A = u.height * g, D = d.width, N = d.height, z = cc.p(this._offset.x * m, this._offset.y * g);
      if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        var M = Math.round(y);
        y !== M && (y = M, m = y / u.width);
        var Z = Math.round(A);
        A !== Z && (A = Z, g = A / u.height);
      }
      h.setScaleX(m), h.setScaleY(g), s.setAnchorPoint(1, 1), s.setPosition(D, N), r.setAnchorPoint(0, 1), r.setPosition(D + y, N), e.setAnchorPoint(1, 0), e.setPosition(D, N + A), n.setAnchorPoint(0, 0), n.setPosition(D + y, N + A), o.setAnchorPoint(1, 0.5), o.setPosition(D, N + A / 2 + z.y), o.setScaleY(g), a.setAnchorPoint(0, 0.5), a.setPosition(D + y, N + A / 2 + z.y), a.setScaleY(g), c.setAnchorPoint(0.5, 0), c.setPosition(D + y / 2 + z.x, N + A), c.setScaleX(m), l.setAnchorPoint(0.5, 1), l.setPosition(D + y / 2 + z.x, N), l.setScaleX(m), h.setAnchorPoint(0.5, 0.5), h.setPosition(D + y / 2 + z.x, N + A / 2 + z.y), h.setScaleX(m), h.setScaleY(g);
    }
  },
  ctor: function(t, e, n) {
    if (cc.Node.prototype.ctor.call(this), this._loader = new cc.Sprite.LoadManager(), this._spriteRect = cc.rect(0, 0, 0, 0), this._capInsetsInternal = cc.rect(0, 0, 0, 0), this._originalSize = cc.size(0, 0), this._preferredSize = cc.size(0, 0), this._capInsets = cc.rect(0, 0, 0, 0), this._renderers = [], t !== void 0)
      if (t instanceof cc.SpriteFrame)
        this.initWithSpriteFrame(t, e);
      else {
        var r = cc.spriteFrameCache.getSpriteFrame(t);
        r ? this.initWithSpriteFrame(r, e) : this.initWithFile(t, e, n);
      }
    else
      this.init(), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), this.setAnchorPoint(0.5, 0.5), this._positionsAreDirty = !0;
  },
  getSprite: function() {
    return this._scale9Image;
  },
  getOriginalSize: function() {
    return cc.size(this._originalSize);
  },
  getPreferredSize: function() {
    return cc.size(this._preferredSize);
  },
  _getPreferredWidth: function() {
    return this._preferredSize.width;
  },
  _getPreferredHeight: function() {
    return this._preferredSize.height;
  },
  _asyncSetPreferredSize: function() {
    this.removeEventListener("load", this._asyncSetPreferredSize, this), this.setPreferredSize(this._cachePreferredSize), this._cachePreferredSize = null;
  },
  setPreferredSize: function(t) {
    if (t) {
      if (!this._textureLoaded)
        return this._cachePreferredSize = t, this.removeEventListener("load", this._asyncSetPreferredSize, this), this.addEventListener("load", this._asyncSetPreferredSize, this), !1;
      this.setContentSize(t), this._preferredSize = t, this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty));
    }
  },
  _setPreferredWidth: function(t) {
    this._setWidth(t), this._preferredSize.width = t;
  },
  _setPreferredHeight: function(t) {
    this._setHeight(t), this._preferredSize.height = t;
  },
  setOpacity: function(t) {
    if (cc.Node.prototype.setOpacity.call(this, t), this._scale9Enabled)
      for (var e = (this || window)._renderers, n = 0; n < e.length; n++)
        e[n].setOpacity(t);
    else
      this._scale9Image && this._scale9Image.setOpacity(t);
    this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty);
  },
  setColor: function(t) {
    if (cc.Node.prototype.setColor.call(this, t), this._scale9Enabled)
      for (var e = (this || window)._renderers, n = 0; n < e.length; n++) {
        var r = e[n];
        r && r.setColor(t);
      }
    else
      this._scale9Image && this._scale9Image.setColor(t);
    this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty);
  },
  getCapInsets: function() {
    return cc.rect(this._capInsets);
  },
  _asyncSetCapInsets: function() {
    this.removeEventListener("load", this._asyncSetCapInsets, this), this.setCapInsets(this._cacheCapInsets), this._cacheCapInsets = null;
  },
  setCapInsets: function(t) {
    var e = (this || window)._contentSize, n = e.width, r = e.height;
    if (!this._textureLoaded)
      return this._cacheCapInsets = t, this.removeEventListener("load", this._asyncSetCapInsets, this), this.addEventListener("load", this._asyncSetCapInsets, this), !1;
    this.updateWithSprite(
      this._scale9Image,
      this._spriteRect,
      this._spriteFrameRotated,
      this._offset,
      this._originalSize,
      t
    ), this._insetLeft = t.x, this._insetTop = t.y, this._insetRight = (this || window)._originalSize.width - this._insetLeft - t.width, this._insetBottom = (this || window)._originalSize.height - this._insetTop - t.height, this.setContentSize(n, r);
  },
  getInsetLeft: function() {
    return this._insetLeft;
  },
  setInsetLeft: function(t) {
    this._insetLeft = t, this._updateCapInset();
  },
  getInsetTop: function() {
    return this._insetTop;
  },
  setInsetTop: function(t) {
    this._insetTop = t, this._updateCapInset();
  },
  getInsetRight: function() {
    return this._insetRight;
  },
  setInsetRight: function(t) {
    this._insetRight = t, this._updateCapInset();
  },
  getInsetBottom: function() {
    return this._insetBottom;
  },
  setInsetBottom: function(t) {
    this._insetBottom = t, this._updateCapInset();
  },
  setContentSize: function(t, e) {
    cc.Node.prototype.setContentSize.call(this, t, e), this._positionsAreDirty = !0;
  },
  setAnchorPoint: function(t, e) {
    cc.Node.prototype.setAnchorPoint.call(this, t, e), this._scale9Enabled || this._scale9Image && (this._scale9Image.setAnchorPoint(t, e), this._positionsAreDirty = !0);
  },
  _setWidth: function(t) {
    cc.Node.prototype._setWidth.call(this, t), this._positionsAreDirty = !0;
  },
  _setHeight: function(t) {
    cc.Node.prototype._setHeight.call(this, t), this._positionsAreDirty = !0;
  },
  init: function() {
    return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), !1, cc.rect(0, 0, 0, 0));
  },
  initWithBatchNode: function(t, e, n, r) {
    return t ? (r === void 0 && (r = n, n = !1), this.updateWithBatchNode(t, e, n, r), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0), this.setAnchorPoint(0.5, 0.5), this._positionsAreDirty = !0, !0) : !1;
  },
  initWithFile: function(t, e, n) {
    if (t instanceof cc.Rect ? (t = arguments[1], n = arguments[0], e = cc.rect(0, 0, 0, 0)) : (e = e || cc.rect(0, 0, 0, 0), n = n || cc.rect(0, 0, 0, 0)), !t)
      throw new Error("ccui.Scale9Sprite.initWithFile(): file should be non-null");
    var r = cc.textureCache.getTextureForKey(t);
    r || (r = cc.textureCache.addImage(t));
    var s = r.isLoaded();
    return this._textureLoaded = s, this._loader.clear(), s ? this.initWithBatchNode(new cc.SpriteBatchNode(t, 9), e, !1, n) : (this._loader.once(r, function() {
      this.initWithFile(t, e, n), this.dispatchEvent("load");
    }, this), !1);
  },
  initWithSpriteFrame: function(t, e) {
    if (!t || !t.getTexture())
      throw new Error("ccui.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null");
    e = e || cc.rect(0, 0, 0, 0);
    var n = t.getTexture(), r = (this || window)._textureLoaded = n.isLoaded();
    if (this._loader.clear(), !r)
      return this._loader.once(n, function() {
        this.initWithSpriteFrame(t, e), this.dispatchEvent("load");
      }, this), !1;
    var s = new cc.SpriteBatchNode(t.getTexture(), 9);
    return this.initWithBatchNode(s, t.getRect(), cc._renderType === cc.game.RENDER_TYPE_WEBGL && t.isRotated(), e), !0;
  },
  initWithSpriteFrameName: function(t, e) {
    if (!t)
      throw new Error("ccui.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null");
    e = e || cc.rect(0, 0, 0, 0);
    var n = cc.spriteFrameCache.getSpriteFrame(t);
    return n == null ? (cc.log("ccui.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName"), !1) : this.initWithSpriteFrame(n, e);
  },
  resizableSpriteWithCapInsets: function(t) {
    var e = new ccui.Scale9Sprite();
    return e && e.initWithBatchNode(this._scale9Image, this._spriteRect, !1, t) ? e : null;
  },
  setOpacityModifyRGB: function(t) {
    if (this._scale9Image) {
      this._opacityModifyRGB = t;
      var e = (this || window)._scale9Image.getChildren();
      if (e)
        for (var n = 0, r = e.length; n < r; n++)
          e[n].setOpacityModifyRGB(t);
      this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty);
    }
  },
  isOpacityModifyRGB: function() {
    return this._opacityModifyRGB;
  },
  createSlicedSprites: function() {
    var t = (this || window)._originalSize.width, e = (this || window)._originalSize.height, n = (this || window)._spriteRect, r = Math.floor(this._offset.x + (t - n.width) / 2), s = Math.floor(this._offset.y + (e - n.height) / 2), o = n.x, a = n.y, c = (this || window)._capInsetsInternal, l = (this || window)._scale9Image, h = l.getTexture(), u = (this || window)._spriteFrameRotated, _ = cc.rect(n.x, n.y, n.width, n.height);
    cc._rectEqualToZero(c) && (c = cc.rect(t / 3, e / 3, t / 3, e / 3)), this._spriteFrameRotated ? (o -= s, a -= r) : (o -= r, a -= s), n = cc.rect(o, a, t, e);
    var d = c.x, f = c.width, C = n.width - (d + f), m = c.y, g = c.height, y = n.height - (m + g), A = 0, D = 0, N = cc.rect(A + 0.5 | 0, D + 0.5 | 0, d + 0.5 | 0, m + 0.5 | 0), z = N;
    A += d;
    var M = cc.rect(A + 0.5 | 0, D + 0.5 | 0, f + 0.5 | 0, m + 0.5 | 0), Z = M;
    A += f;
    var U = cc.rect(A + 0.5 | 0, D + 0.5 | 0, C + 0.5 | 0, m + 0.5 | 0), Q = U;
    A = 0, D = 0, D += m;
    var et = cc.rect(A + 0.5 | 0, D + 0.5 | 0, d + 0.5 | 0, g + 0.5 | 0);
    A += d;
    var rt = cc.rect(A + 0.5 | 0, D + 0.5 | 0, f + 0.5 | 0, g + 0.5 | 0), w = rt;
    A += f;
    var L = cc.rect(A + 0.5 | 0, D + 0.5 | 0, C + 0.5 | 0, g + 0.5 | 0);
    A = 0, D = 0, D += m, D += g;
    var G = cc.rect(A + 0.5 | 0, D + 0.5 | 0, d + 0.5 | 0, y + 0.5 | 0);
    A += d;
    var I = cc.rect(A + 0.5 | 0, D + 0.5 | 0, f + 0.5 | 0, y + 0.5 | 0);
    A += f;
    var O = cc.rect(A + 0.5 | 0, D + 0.5 | 0, C + 0.5 | 0, y + 0.5 | 0), K = O, $ = N, S = rt, b = O, W = w, x = K, E = G, R = Q, F = z, k = L, X = et, j = I, V = Z, Y = cc.affineTransformMakeIdentity();
    u ? (Y = cc.affineTransformTranslate(Y, _.height + _.x, _.y), Y = cc.affineTransformRotate(Y, 1.57079633), N = cc.rectApplyAffineTransform(N, Y), rt = cc.rectApplyAffineTransform(rt, Y), O = cc.rectApplyAffineTransform(O, Y), w = cc.rectApplyAffineTransform(w, Y), K = cc.rectApplyAffineTransform(K, Y), G = cc.rectApplyAffineTransform(G, Y), Q = cc.rectApplyAffineTransform(Q, Y), z = cc.rectApplyAffineTransform(z, Y), L = cc.rectApplyAffineTransform(L, Y), et = cc.rectApplyAffineTransform(et, Y), I = cc.rectApplyAffineTransform(I, Y), Z = cc.rectApplyAffineTransform(Z, Y), $.x = N.x, S.x = rt.x, b.x = O.x, W.x = w.x, x.x = K.x, E.x = G.x, R.x = Q.x, F.x = z.x, k.x = L.x, X.x = et.x, j.x = I.x, V.x = Z.x, $.y = N.y, S.y = rt.y, b.y = O.y, W.y = w.y, x.y = K.y, E.y = G.y, R.y = Q.y, F.y = z.y, k.y = L.y, X.y = et.y, j.y = I.y, V.y = Z.y) : (Y = cc.affineTransformTranslate(Y, _.x, _.y), $ = cc.rectApplyAffineTransform($, Y), S = cc.rectApplyAffineTransform(S, Y), b = cc.rectApplyAffineTransform(b, Y), W = cc.rectApplyAffineTransform(W, Y), x = cc.rectApplyAffineTransform(x, Y), E = cc.rectApplyAffineTransform(E, Y), R = cc.rectApplyAffineTransform(R, Y), F = cc.rectApplyAffineTransform(F, Y), k = cc.rectApplyAffineTransform(k, Y), X = cc.rectApplyAffineTransform(X, Y), j = cc.rectApplyAffineTransform(j, Y), V = cc.rectApplyAffineTransform(V, Y)), this._centre || (this._centre = new cc.Sprite()), this._centre.initWithTexture(h, W, u), W.width > 0 && W.height > 0 && this._renderers.push(this._centre), this._top || (this._top = new cc.Sprite()), this._top.initWithTexture(h, V, u), V.width > 0 && V.height > 0 && this._renderers.push(this._top), this._bottom || (this._bottom = new cc.Sprite()), this._bottom.initWithTexture(h, j, u), j.width > 0 && j.height > 0 && this._renderers.push(this._bottom), this._left || (this._left = new cc.Sprite()), this._left.initWithTexture(h, X, u), X.width > 0 && X.height > 0 && this._renderers.push(this._left), this._right || (this._right = new cc.Sprite()), this._right.initWithTexture(h, k, u), k.width > 0 && k.height > 0 && this._renderers.push(this._right), this._topLeft || (this._topLeft = new cc.Sprite()), this._topLeft.initWithTexture(h, F, u), F.width > 0 && F.height > 0 && this._renderers.push(this._topLeft), this._topRight || (this._topRight = new cc.Sprite()), this._topRight.initWithTexture(h, R, u), R.width > 0 && R.height > 0 && this._renderers.push(this._topRight), this._bottomLeft || (this._bottomLeft = new cc.Sprite()), this._bottomLeft.initWithTexture(h, E, u), E.width > 0 && E.height > 0 && this._renderers.push(this._bottomLeft), this._bottomRight || (this._bottomRight = new cc.Sprite()), this._bottomRight.initWithTexture(h, x, u), x.width > 0 && x.height > 0 && this._renderers.push(this._bottomRight);
  },
  updateWithSprite: function(t, e, n, r, s, o) {
    if (!t)
      return !1;
    if (this._loader.clear(), this._textureLoaded = t._textureLoaded, !t._textureLoaded)
      return this._loader.once(t, function() {
        this.updateWithSprite(t, e, n, r, s, o), this.dispatchEvent("load");
      }, this), !1;
    if (this._scale9Image = t, !this._scale9Image)
      return !1;
    var a = (this || window)._scale9Image.getTexture();
    this._textureLoaded = a && a.isLoaded();
    var c = t.getSpriteFrame();
    cc._renderType === cc.game.RENDER_TYPE_CANVAS && c && a._htmlElementObj instanceof window.HTMLCanvasElement && (n = !1, e = { x: 0, y: 0, height: e.height, width: e.width });
    var l = (this || window).getOpacity(), h = (this || window).getColor();
    this._renderers.length = 0;
    var u = e, _ = s;
    if (cc._rectEqualToZero(u)) {
      var d = a.getContentSize();
      u = cc.rect(0, 0, d.width, d.height);
    }
    return _.width === 0 && _.height === 0 && (_ = cc.size(u.width, u.height)), this._capInsets = o, this._spriteRect = u, this._offset = r, this._spriteFrameRotated = n, this._originalSize = _, this._preferredSize = _, this._capInsetsInternal = o, this._scale9Enabled ? this.createSlicedSprites() : this._scale9Image.initWithTexture(a, this._spriteRect, this._spriteFrameRotated), this.setState(this._brightState), this.setContentSize(_), this.setOpacity(l), this.setColor(h), !0;
  },
  updateWithBatchNode: function(t, e, n, r) {
    if (!t)
      return !1;
    var s = t.getTexture();
    this._loader.clear();
    var o = (this || window)._textureLoaded = s.isLoaded();
    if (!o)
      return this._loader.once(s, function() {
        this.updateWithBatchNode(t, e, n, r), this.dispatchEvent("load");
      }, this), !1;
    var a = new cc.Sprite(s), c = cc.p(0, 0), l = cc.size(e.width, e.height);
    return this.updateWithSprite(a, e, n, c, l, r);
  },
  setSpriteFrame: function(t, e) {
    e = e || cc.rect();
    var n = t.getTexture();
    if (this._textureLoaded = n._textureLoaded, this._loader.clear(), !n._textureLoaded)
      return this._loader.once(t, function() {
        this.setSpriteFrame(t, e), this.dispatchEvent("load");
      }, this), !1;
    var r = new cc.Sprite(t.getTexture());
    this.updateWithSprite(r, t.getRect(), t.isRotated(), t.getOffset(), t.getOriginalSize(), e), this._insetLeft = e.x, this._insetTop = e.y, this._insetRight = (this || window)._originalSize.width - this._insetLeft - e.width, this._insetBottom = (this || window)._originalSize.height - this._insetTop - e.height;
  },
  setState: function(t) {
    (t === ccui.Scale9Sprite.state.NORMAL || t === ccui.Scale9Sprite.state.GRAY) && (this._brightState = t, this._renderCmd.setState(t));
  },
  setScale9Enabled: function(t) {
    this._scale9Enabled !== t && (this._scale9Enabled = t, this._renderers.length = 0, cc.Node.transformDirty = !0, this._scale9Enabled && this._scale9Image && this.updateWithSprite(
      this._scale9Image,
      this._spriteRect,
      this._spriteFrameRotated,
      this._offset,
      this._originalSize,
      this._capInsets
    ), this._positionsAreDirty = !0);
  },
  _setRenderersPosition: function() {
    this._positionsAreDirty && (this._updatePositions(), this._adjustScale9ImagePosition(), this._positionsAreDirty = !1);
  },
  _adjustScale9ImagePosition: function() {
    var t = (this || window)._scale9Image, e = (this || window)._contentSize;
    t && (t.x = e.width * t.getAnchorPoint().x, t.y = e.height * t.getAnchorPoint().y);
  },
  _adjustScale9ImageScale: function() {
    var t = (this || window)._scale9Image, e = (this || window)._contentSize;
    t && t.setScale(e.width / t.width, e.height / t.height);
  },
  setFlippedX: function(t) {
    var e = (this || window).getScaleX();
    this._flippedX = t, this.setScaleX(e), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty);
  },
  isFlippedX: function() {
    return this._flippedX;
  },
  setFlippedY: function(t) {
    var e = (this || window).getScaleY();
    this._flippedY = t, this.setScaleY(e), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty);
  },
  isFlippedY: function() {
    return this._flippedY;
  },
  setScaleX: function(t) {
    this._flippedX && (t = t * -1), cc.Node.prototype.setScaleX.call(this, t), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty);
  },
  setScaleY: function(t) {
    this._flippedY && (t = t * -1), cc.Node.prototype.setScaleY.call(this, t), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty);
  },
  setScale: function(t, e) {
    e === void 0 && (e = t), this.setScaleX(t), this.setScaleY(e);
  },
  getScaleX: function() {
    var t = cc.Node.prototype.getScaleX.call(this);
    return this._flippedX && (t = t * -1), t;
  },
  getScaleY: function() {
    var t = cc.Node.prototype.getScaleY.call(this);
    return this._flippedY && (t = t * -1), t;
  },
  getScale: function() {
    return this.getScaleX() !== (this || window).getScaleY() && cc.log("Scale9Sprite#scale. ScaleX != ScaleY. Don't know which one to return"), this.getScaleX();
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccui.Scale9Sprite.CanvasRenderCmd(this) : new ccui.Scale9Sprite.WebGLRenderCmd(this);
  }
});
var _p = ccui.Scale9Sprite.prototype;
cc.EventHelper.prototype.apply(_p);
_p.preferredSize;
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
_p.capInsets;
cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets);
_p.insetLeft;
cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft);
_p.insetTop;
cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop);
_p.insetRight;
cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight);
_p.insetBottom;
cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom);
_p = null;
ccui.Scale9Sprite.create = function(t, e, n) {
  return new ccui.Scale9Sprite(t, e, n);
};
ccui.Scale9Sprite.createWithSpriteFrame = function(t, e) {
  return new ccui.Scale9Sprite(t, e);
};
ccui.Scale9Sprite.createWithSpriteFrameName = function(t, e) {
  return new ccui.Scale9Sprite(t, e);
};
ccui.Scale9Sprite.POSITIONS_CENTRE = 0;
ccui.Scale9Sprite.POSITIONS_TOP = 1;
ccui.Scale9Sprite.POSITIONS_LEFT = 2;
ccui.Scale9Sprite.POSITIONS_RIGHT = 3;
ccui.Scale9Sprite.POSITIONS_BOTTOM = 4;
ccui.Scale9Sprite.POSITIONS_TOPRIGHT = 5;
ccui.Scale9Sprite.POSITIONS_TOPLEFT = 6;
ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7;
ccui.Scale9Sprite.state = { NORMAL: 0, GRAY: 1 };
(function() {
  ccui.Scale9Sprite.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._cachedParent = null, this._cacheDirty = !1, this._state = ccui.Scale9Sprite.state.NORMAL;
    var n = (this || window)._node, r = (this || window)._cacheCanvas = document.createElement("canvas");
    r.width = 1, r.height = 1, this._cacheContext = new cc.CanvasContextWrapper(r.getContext("2d"));
    var s = (this || window)._cacheTexture = new cc.Texture2D();
    s.initWithElement(r), s.handleLoadedTexture(), this._cacheSprite = new cc.Sprite(s), this._cacheSprite.setAnchorPoint(0, 0), n.addChild(this._cacheSprite);
  };
  var t = ccui.Scale9Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = ccui.Scale9Sprite.CanvasRenderCmd, t.visit = function(e) {
    var n = (this || window)._node;
    n._visible && (n._positionsAreDirty && (n._updatePositions(), n._positionsAreDirty = !1), this.originVisit(e));
  }, t.transform = function(e) {
    var n = (this || window)._node;
    cc.Node.CanvasRenderCmd.prototype.transform.call(this, e), n._positionsAreDirty && (n._updatePositions(), n._positionsAreDirty = !1);
    for (var r = n._children, s = 0; s < r.length; s++)
      r[s].transform(this, !0);
  }, t._updateDisplayColor = function(e) {
    cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, e);
    var n = (this || window)._node;
    if (n) {
      var r = n._renderers;
      if (n._scale9Enabled)
        for (var s = r.length, o = 0; o < s; o++) {
          var a = r[o];
          if (a)
            a._renderCmd._updateDisplayColor(e), a._renderCmd._updateColor();
          else
            break;
        }
      else
        n._scale9Image && (n._scale9Image._renderCmd._updateDisplayColor(e), n._scale9Image._renderCmd._updateColor());
    }
  }, t.updateStatus = function() {
    var e = cc.Node._dirtyFlags, n = (this || window)._dirtyFlag;
    cc.Node.RenderCmd.prototype.updateStatus.call(this), n & e.cacheDirty && (this._cacheScale9Sprite(), this._dirtyFlag = (this || window)._dirtyFlag & e.cacheDirty ^ this._dirtyFlag);
  }, t._syncStatus = function(e) {
    var n = cc.Node._dirtyFlags, r = (this || window)._dirtyFlag;
    cc.Node.RenderCmd.prototype._syncStatus.call(this, e), r & n.cacheDirty && (this._cacheScale9Sprite(), this._dirtyFlag = (this || window)._dirtyFlag & n.cacheDirty ^ this._dirtyFlag);
  }, t._cacheScale9Sprite = function() {
    var e = (this || window)._node;
    if (e._scale9Image) {
      var n = cc.contentScaleFactor(), r = e._contentSize, s = cc.size(r.width * n, r.height * n), o = (this || window)._cacheCanvas, a = (this || window)._cacheContext, c = a.getContext(), l = !1;
      if ((o.width !== s.width || o.height !== s.height) && (o.width = s.width, o.height = s.height, l = !0), cc.renderer._turnToCacheMode(e.__instanceId), e._scale9Enabled) {
        var h = e._renderers;
        e._setRenderersPosition();
        for (var u = h.length, _ = 0; _ < u; _++) {
          var d = h[_];
          if (d) {
            var f = d._renderCmd;
            f.updateStatus(), cc.renderer.pushRenderCommand(f);
          } else
            break;
        }
      } else {
        var f = e._scale9Image._renderCmd;
        e._adjustScale9ImagePosition(), e._adjustScale9ImageScale(), f.updateStatus(), cc.renderer.pushRenderCommand(e._scale9Image._renderCmd);
      }
      var C = e._scale9Image.getTexture();
      C && this._state === ccui.Scale9Sprite.state.GRAY && C._switchToGray(!0), c.setTransform(1, 0, 0, 1, 0, 0), c.clearRect(0, 0, s.width, s.height), cc.renderer._renderingToCacheCanvas(a, e.__instanceId, n, n), cc.renderer._turnToNormalMode(), C && this._state === ccui.Scale9Sprite.state.GRAY && C._switchToGray(!1), l && this._cacheSprite.setTextureRect(cc.rect(0, 0, r.width, r.height)), this._cacheSprite.getParent() || e.addChild(this._cacheSprite, -1), this._cacheSprite._renderCmd._updateColor();
    }
  }, t.setState = function(e) {
    var n = (this || window)._node._scale9Image;
    n && (this._state = e, this.setDirtyFlag(cc.Node._dirtyFlags.cacheDirty));
  };
})();
(function() {
  if (cc.Node.WebGLRenderCmd) {
    ccui.Scale9Sprite.WebGLRenderCmd = function(e) {
      cc.Node.WebGLRenderCmd.call(this, e), this._cachedParent = null, this._cacheDirty = !1;
    };
    var t = ccui.Scale9Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    t.constructor = ccui.Scale9Sprite.WebGLRenderCmd, t.setShaderProgram = function(e) {
      var n = (this || window)._node;
      if (n._scale9Enabled)
        for (var r = n._renderers, s = r.length, o = 0; o < s; o++)
          r[o] && (r[o]._renderCmd._shaderProgram = e);
      else
        n._scale9Image._renderCmd._shaderProgram = e;
      this._shaderProgram = e;
    }, t.visit = function(e) {
      var n = (this || window)._node;
      if (n._visible && n._scale9Image) {
        if (n._positionsAreDirty && (n._updatePositions(), n._positionsAreDirty = !1), e = e || this.getParentRenderCmd(), n._parent && n._parent._renderCmd && (this._curLevel = n._parent._renderCmd._curLevel + 1), this._syncStatus(e), n._scale9Enabled)
          for (var r = n._renderers, s = r.length, o = 0; o < s; o++) {
            var a = r[o];
            if (a) {
              var c = a._renderCmd;
              c.visit(this);
            } else
              break;
          }
        else
          n._adjustScale9ImageScale(), n._adjustScale9ImagePosition(), n._scale9Image._renderCmd.visit(this);
        this._dirtyFlag = 0, this.originVisit(e);
      }
    }, t.transform = function(e, n) {
      var r = (this || window)._node;
      if (e = e || this.getParentRenderCmd(), this.originTransform(e, n), r._positionsAreDirty && (r._updatePositions(), r._positionsAreDirty = !1), r._scale9Enabled)
        for (var s = r._renderers, o = s.length, a = cc.Node._dirtyFlags, c = 0; c < o; c++) {
          var l = s[c];
          if (l) {
            l._vertexZ = e._node._vertexZ;
            var h = l._renderCmd;
            h.transform(this, !0), h._dirtyFlag = h._dirtyFlag & a.transformDirty ^ h._dirtyFlag;
          } else
            break;
        }
      else
        r._adjustScale9ImageScale(), r._adjustScale9ImagePosition(), r._scale9Image._renderCmd.transform(this, !0);
    }, t.setDirtyFlag = function(e, n) {
      e === cc.Node._dirtyFlags.cacheDirty && (e = cc.Node._dirtyFlags.transformDirty), cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, e, n);
    }, t._syncStatus = function(e) {
      cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this, e), this._updateDisplayColor(this._displayedColor), this._updateDisplayOpacity(this._displayedOpacity);
    }, t._updateDisplayColor = function(e) {
      cc.Node.WebGLRenderCmd.prototype._updateDisplayColor.call(this, e);
      var n = (this || window)._node, r = n._scale9Image;
      if (e = (this || window)._displayedColor, n._scale9Enabled)
        for (var s = n._renderers, o = 0; o < s.length; o++)
          s[o]._renderCmd._updateDisplayColor(e), s[o]._renderCmd._updateColor();
      else
        r._renderCmd._updateDisplayColor(e), r._renderCmd._updateColor();
    }, t._updateDisplayOpacity = function(e) {
      cc.Node.WebGLRenderCmd.prototype._updateDisplayOpacity.call(this, e);
      var n = (this || window)._node, r = n._scale9Image;
      if (e = (this || window)._displayedOpacity, n._scale9Enabled)
        for (var s = n._renderers, o = 0; o < s.length; o++)
          s[o]._renderCmd._updateDisplayOpacity(e), s[o]._renderCmd._updateColor();
      else
        r._renderCmd._updateDisplayOpacity(e), r._renderCmd._updateColor();
    }, t.setState = function(e) {
      e === ccui.Scale9Sprite.state.NORMAL ? this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLOR)) : e === ccui.Scale9Sprite.state.GRAY && this.setShaderProgram(ccui.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram());
    }, ccui.Scale9Sprite.WebGLRenderCmd._grayShaderProgram = null, ccui.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram = function() {
      var e = ccui.Scale9Sprite.WebGLRenderCmd._grayShaderProgram;
      return e || (e = new cc.GLProgram(), e.initWithVertexShaderByteArray(cc.SHADER_SPRITE_POSITION_TEXTURE_COLOR_VERT, ccui.Scale9Sprite.WebGLRenderCmd._grayShaderFragment), e.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), e.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), e.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS), e.link(), e.updateUniforms(), ccui.Scale9Sprite.WebGLRenderCmd._grayShaderProgram = e, e);
    }, ccui.Scale9Sprite.WebGLRenderCmd._grayShaderFragment = `precision lowp float;
varying vec4 v_fragmentColor; 
varying vec2 v_texCoord; 
void main() 
{ 
    vec4 c = texture2D(CC_Texture0, v_texCoord); 
    gl_FragColor.xyz = vec3(0.2126*c.r + 0.7152*c.g + 0.0722*c.b); 
     gl_FragColor.w = c.w ; 
}`;
  }
})();
ccui.Layout = ccui.Widget.extend({
  _clippingEnabled: !1,
  _backGroundScale9Enabled: null,
  _backGroundImage: null,
  _backGroundImageFileName: null,
  _backGroundImageCapInsets: null,
  _colorType: null,
  _bgImageTexType: ccui.Widget.LOCAL_TEXTURE,
  _colorRender: null,
  _gradientRender: null,
  _color: null,
  _startColor: null,
  _endColor: null,
  _alongVector: null,
  _opacity: 255,
  _backGroundImageTextureSize: null,
  _layoutType: null,
  _doLayoutDirty: !0,
  _clippingRectDirty: !0,
  _clippingType: null,
  _clippingStencil: null,
  _scissorRectDirty: !1,
  _clippingRect: null,
  _clippingParent: null,
  _className: "Layout",
  _backGroundImageColor: null,
  _finalPositionX: 0,
  _finalPositionY: 0,
  _backGroundImageOpacity: 0,
  _loopFocus: !1,
  __passFocusToChild: !0,
  _isFocusPassing: !1,
  _isInterceptTouch: !1,
  ctor: function() {
    this._layoutType = ccui.Layout.ABSOLUTE, this._widgetType = ccui.Widget.TYPE_CONTAINER, this._clippingType = ccui.Layout.CLIPPING_SCISSOR, this._colorType = ccui.Layout.BG_COLOR_NONE, ccui.Widget.prototype.ctor.call(this), this.ignoreContentAdaptWithSize(!1), this.setContentSize(cc.size(0, 0)), this.setAnchorPoint(0, 0), this.onPassFocusToChild = (this || window)._findNearestChildWidgetIndex.bind(this), this._backGroundImageCapInsets = cc.rect(0, 0, 0, 0), this._color = cc.color(255, 255, 255, 255), this._startColor = cc.color(255, 255, 255, 255), this._endColor = cc.color(255, 255, 255, 255), this._alongVector = cc.p(0, -1), this._backGroundImageTextureSize = cc.size(0, 0), this._clippingRect = cc.rect(0, 0, 0, 0), this._backGroundImageColor = cc.color(255, 255, 255, 255);
  },
  onEnter: function() {
    ccui.Widget.prototype.onEnter.call(this), this._clippingStencil && this._clippingStencil.onEnter(), this._doLayoutDirty = !0, this._clippingRectDirty = !0;
  },
  onExit: function() {
    ccui.Widget.prototype.onExit.call(this), this._clippingStencil && this._clippingStencil.onExit();
  },
  setLoopFocus: function(t) {
    this._loopFocus = t;
  },
  isLoopFocus: function() {
    return this._loopFocus;
  },
  setPassFocusToChild: function(t) {
    this.__passFocusToChild = t;
  },
  isPassFocusToChild: function() {
    return this.__passFocusToChild;
  },
  findNextFocusedWidget: function(t, e) {
    if (this._isFocusPassing || this.isFocused()) {
      var n = (this || window).getParent();
      if (this._isFocusPassing = !1, this.__passFocusToChild) {
        var r = (this || window)._passFocusToChild(t, e);
        return r instanceof ccui.Layout && n ? (n._isFocusPassing = !0, n.findNextFocusedWidget(t, this)) : r;
      }
      return n == null || !(n instanceof ccui.Layout) ? this : (n._isFocusPassing = !0, n.findNextFocusedWidget(t, this));
    } else if (e.isFocused() || e instanceof ccui.Layout)
      if (this._layoutType === ccui.Layout.LINEAR_HORIZONTAL)
        switch (t) {
          case ccui.Widget.LEFT:
            return this._getPreviousFocusedWidget(t, e);
          case ccui.Widget.RIGHT:
            return this._getNextFocusedWidget(t, e);
          case ccui.Widget.DOWN:
          case ccui.Widget.UP:
            return this._isLastWidgetInContainer(this, t) ? this._isWidgetAncestorSupportLoopFocus(e, t) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, t, this) : e : ccui.Widget.prototype.findNextFocusedWidget.call(this, t, this);
          default:
            return cc.assert(0, "Invalid Focus Direction"), e;
        }
      else if (this._layoutType === ccui.Layout.LINEAR_VERTICAL)
        switch (t) {
          case ccui.Widget.LEFT:
          case ccui.Widget.RIGHT:
            return this._isLastWidgetInContainer(this, t) ? this._isWidgetAncestorSupportLoopFocus(e, t) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, t, this) : e : ccui.Widget.prototype.findNextFocusedWidget.call(this, t, this);
          case ccui.Widget.DOWN:
            return this._getNextFocusedWidget(t, e);
          case ccui.Widget.UP:
            return this._getPreviousFocusedWidget(t, e);
          default:
            return cc.assert(0, "Invalid Focus Direction"), e;
        }
      else
        return cc.assert(0, "Un Supported Layout type, please use VBox and HBox instead!!!"), e;
    else
      return e;
  },
  onPassFocusToChild: null,
  addChild: function(t, e, n) {
    t instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(t), ccui.Widget.prototype.addChild.call(this, t, e, n), this._doLayoutDirty = !0;
  },
  removeChild: function(t, e) {
    ccui.Widget.prototype.removeChild.call(this, t, e), this._doLayoutDirty = !0;
  },
  removeAllChildren: function(t) {
    ccui.Widget.prototype.removeAllChildren.call(this, t), this._doLayoutDirty = !0;
  },
  removeAllChildrenWithCleanup: function(t) {
    ccui.Widget.prototype.removeAllChildrenWithCleanup.call(this, t), this._doLayoutDirty = !0;
  },
  isClippingEnabled: function() {
    return this._clippingEnabled;
  },
  visit: function(t) {
    if (this._visible)
      if (this._adaptRenderers(), this._doLayout(), this._clippingEnabled)
        switch (this._clippingType) {
          case ccui.Layout.CLIPPING_STENCIL:
            this._renderCmd.stencilClippingVisit(t);
            break;
          case ccui.Layout.CLIPPING_SCISSOR:
            this._renderCmd.scissorClippingVisit(t);
            break;
        }
      else
        ccui.Widget.prototype.visit.call(this, t);
  },
  setClippingEnabled: function(t) {
    if (t !== (this || window)._clippingEnabled)
      switch (this._clippingEnabled = t, this._clippingType) {
        case ccui.Layout.CLIPPING_SCISSOR:
        case ccui.Layout.CLIPPING_STENCIL:
          t ? (this._clippingStencil = new cc.DrawNode(), this._renderCmd.rebindStencilRendering(this._clippingStencil), this._running && this._clippingStencil.onEnter(), this._setStencilClippingSize(this._contentSize)) : (this._running && this._clippingStencil && this._clippingStencil.onExit(), this._clippingStencil = null);
          break;
      }
  },
  setClippingType: function(t) {
    if (t !== (this || window)._clippingType) {
      var e = (this || window).isClippingEnabled();
      this.setClippingEnabled(!1), this._clippingType = t, this.setClippingEnabled(e);
    }
  },
  getClippingType: function() {
    return this._clippingType;
  },
  _setStencilClippingSize: function(t) {
    if (this._clippingEnabled) {
      var e = [];
      e[0] = cc.p(0, 0), e[1] = cc.p(t.width, 0), e[2] = cc.p(t.width, t.height), e[3] = cc.p(0, t.height);
      var n = cc.color.GREEN;
      this._clippingStencil.clear(), this._clippingStencil.setLocalBB && this._clippingStencil.setLocalBB(0, 0, t.width, t.height), this._clippingStencil.drawPoly(e, 4, n, 0, n);
    }
  },
  _getClippingRect: function() {
    if (this._clippingRectDirty) {
      for (var t = (this || window).convertToWorldSpace(cc.p(0, 0)), e = (this || window).getNodeToWorldTransform(), n = (this || window)._contentSize.width * e.a, r = (this || window)._contentSize.height * e.d, s, o = (this || window); o; )
        if (o = o.getParent(), o && o instanceof ccui.Layout && o.isClippingEnabled()) {
          this._clippingParent = o;
          break;
        }
      if (this._clippingParent) {
        s = (this || window)._clippingParent._getClippingRect(), this._clippingRect.x = Math.max(t.x, s.x), this._clippingRect.y = Math.max(t.y, s.y);
        var a = Math.min(t.x + n, s.x + s.width), c = Math.min(t.y + r, s.y + s.height);
        this._clippingRect.width = Math.max(0, a - this._clippingRect.x), this._clippingRect.height = Math.max(0, c - this._clippingRect.y);
      } else
        this._clippingRect.x = t.x, this._clippingRect.y = t.y, this._clippingRect.width = n, this._clippingRect.height = r;
      this._clippingRectDirty = !1;
    }
    return this._clippingRect;
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this);
    var t = (this || window)._contentSize;
    this._setStencilClippingSize(t), this._doLayoutDirty = !0, this._clippingRectDirty = !0, this._backGroundImage && (this._backGroundImage.setPosition(t.width * 0.5, t.height * 0.5), this._backGroundScale9Enabled && this._backGroundImage instanceof ccui.Scale9Sprite && this._backGroundImage.setPreferredSize(t)), this._colorRender && this._colorRender.setContentSize(t), this._gradientRender && this._gradientRender.setContentSize(t);
  },
  setBackGroundImageScale9Enabled: function(t) {
    this._backGroundScale9Enabled !== t && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundScale9Enabled = t, this._addBackGroundImage(), this.setBackGroundImage(this._backGroundImageFileName, this._bgImageTexType), this.setBackGroundImageCapInsets(this._backGroundImageCapInsets));
  },
  isBackGroundImageScale9Enabled: function() {
    return this._backGroundScale9Enabled;
  },
  setBackGroundImage: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._backGroundImage === null && (this._addBackGroundImage(), this.setBackGroundImageScale9Enabled(this._backGroundScale9Enabled)), this._backGroundImageFileName = t, this._bgImageTexType = e;
      var n = (this || window)._backGroundImage;
      switch (this._bgImageTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n.initWithSpriteFrameName(t);
          break;
      }
      this._backGroundScale9Enabled && n.setPreferredSize(this._contentSize), this._backGroundImageTextureSize = n.getContentSize(), n.setPosition(this._contentSize.width * 0.5, this._contentSize.height * 0.5), this._updateBackGroundImageColor();
    }
  },
  setBackGroundImageCapInsets: function(t) {
    if (t) {
      var e = (this || window)._backGroundImageCapInsets;
      e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, this._backGroundScale9Enabled && this._backGroundImage.setCapInsets(t);
    }
  },
  getBackGroundImageCapInsets: function() {
    return cc.rect(this._backGroundImageCapInsets);
  },
  _supplyTheLayoutParameterLackToChild: function(t) {
    if (t)
      switch (this._layoutType) {
        case ccui.Layout.ABSOLUTE:
          break;
        case ccui.Layout.LINEAR_HORIZONTAL:
        case ccui.Layout.LINEAR_VERTICAL:
          var e = t.getLayoutParameter(ccui.LayoutParameter.LINEAR);
          e || t.setLayoutParameter(new ccui.LinearLayoutParameter());
          break;
        case ccui.Layout.RELATIVE:
          var e = t.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
          e || t.setLayoutParameter(new ccui.RelativeLayoutParameter());
          break;
      }
  },
  _addBackGroundImage: function() {
    var t = (this || window)._contentSize;
    this._backGroundScale9Enabled ? (this._backGroundImage = new ccui.Scale9Sprite(), this._backGroundImage.setPreferredSize(t)) : this._backGroundImage = new cc.Sprite(), this.addProtectedChild(this._backGroundImage, ccui.Layout.BACKGROUND_IMAGE_ZORDER, -1), this._backGroundImage.setPosition(t.width * 0.5, t.height * 0.5);
  },
  removeBackGroundImage: function() {
    this._backGroundImage && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundImageFileName = "", this._backGroundImageTextureSize.width = 0, this._backGroundImageTextureSize.height = 0);
  },
  setBackGroundColorType: function(t) {
    if (this._colorType !== t) {
      switch (this._colorType) {
        case ccui.Layout.BG_COLOR_NONE:
          this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null), this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null);
          break;
        case ccui.Layout.BG_COLOR_SOLID:
          this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
          break;
        case ccui.Layout.BG_COLOR_GRADIENT:
          this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null);
          break;
      }
      switch (this._colorType = t, this._colorType) {
        case ccui.Layout.BG_COLOR_NONE:
          break;
        case ccui.Layout.BG_COLOR_SOLID:
          this._colorRender = new cc.LayerColor(), this._colorRender.setContentSize(this._contentSize), this._colorRender.setOpacity(this._opacity), this._colorRender.setColor(this._color), this.addProtectedChild(this._colorRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1);
          break;
        case ccui.Layout.BG_COLOR_GRADIENT:
          this._gradientRender = new cc.LayerGradient(cc.color(255, 0, 0, 255), cc.color(0, 255, 0, 255)), this._gradientRender.setContentSize(this._contentSize), this._gradientRender.setOpacity(this._opacity), this._gradientRender.setStartColor(this._startColor), this._gradientRender.setEndColor(this._endColor), this._gradientRender.setVector(this._alongVector), this.addProtectedChild(this._gradientRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1);
          break;
      }
    }
  },
  getBackGroundColorType: function() {
    return this._colorType;
  },
  setBackGroundColor: function(t, e) {
    e ? (this._startColor.r = t.r, this._startColor.g = t.g, this._startColor.b = t.b, this._gradientRender && this._gradientRender.setStartColor(t), this._endColor.r = e.r, this._endColor.g = e.g, this._endColor.b = e.b, this._gradientRender && this._gradientRender.setEndColor(e)) : (this._color.r = t.r, this._color.g = t.g, this._color.b = t.b, this._colorRender && this._colorRender.setColor(t));
  },
  getBackGroundColor: function() {
    var t = (this || window)._color;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  getBackGroundStartColor: function() {
    var t = (this || window)._startColor;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  getBackGroundEndColor: function() {
    var t = (this || window)._endColor;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  setBackGroundColorOpacity: function(t) {
    switch (this._opacity = t, this._colorType) {
      case ccui.Layout.BG_COLOR_NONE:
        break;
      case ccui.Layout.BG_COLOR_SOLID:
        this._colorRender.setOpacity(t);
        break;
      case ccui.Layout.BG_COLOR_GRADIENT:
        this._gradientRender.setOpacity(t);
        break;
    }
  },
  getBackGroundColorOpacity: function() {
    return this._opacity;
  },
  setBackGroundColorVector: function(t) {
    this._alongVector.x = t.x, this._alongVector.y = t.y, this._gradientRender && this._gradientRender.setVector(t);
  },
  getBackGroundColorVector: function() {
    return this._alongVector;
  },
  setBackGroundImageColor: function(t) {
    this._backGroundImageColor.r = t.r, this._backGroundImageColor.g = t.g, this._backGroundImageColor.b = t.b, this._updateBackGroundImageColor();
  },
  setBackGroundImageOpacity: function(t) {
    this._backGroundImageColor.a = t, this.getBackGroundImageColor();
  },
  getBackGroundImageColor: function() {
    var t = (this || window)._backGroundImageColor;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  getBackGroundImageOpacity: function() {
    return this._backGroundImageColor.a;
  },
  _updateBackGroundImageColor: function() {
    this._backGroundImage && this._backGroundImage.setColor(this._backGroundImageColor);
  },
  getBackGroundImageTextureSize: function() {
    return this._backGroundImageTextureSize;
  },
  setLayoutType: function(t) {
    this._layoutType = t;
    for (var e = (this || window)._children, n = null, r = 0; r < e.length; r++)
      n = e[r], n instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(n);
    this._doLayoutDirty = !0;
  },
  getLayoutType: function() {
    return this._layoutType;
  },
  requestDoLayout: function() {
    this._doLayoutDirty = !0;
  },
  _doLayout: function() {
    if (this._doLayoutDirty) {
      this.sortAllChildren();
      var t = ccui.getLayoutManager(this._layoutType);
      t && t._doLayout(this), this._doLayoutDirty = !1;
    }
  },
  _getLayoutContentSize: function() {
    return this.getContentSize();
  },
  _getLayoutElements: function() {
    return this.getChildren();
  },
  _updateBackGroundImageOpacity: function() {
    this._backGroundImage && this._backGroundImage.setOpacity(this._backGroundImageOpacity);
  },
  _updateBackGroundImageRGBA: function() {
    this._backGroundImage && (this._backGroundImage.setColor(this._backGroundImageColor), this._backGroundImage.setOpacity(this._backGroundImageOpacity));
  },
  _getLayoutAccumulatedSize: function() {
    for (var t = (this || window).getChildren(), e = cc.size(0, 0), n = 0, r, s = 0, o = t.length; s < o; s++) {
      var a = t[s];
      if (a !== null && a instanceof ccui.Layout)
        r = a._getLayoutAccumulatedSize(), e.width += r.width, e.height += r.height;
      else if (a instanceof ccui.Widget) {
        n++;
        var c = a.getLayoutParameter().getMargin();
        r = a.getContentSize(), e.width += r.width + (c.right + c.left) * 0.5, e.height += r.height + (c.top + c.bottom) * 0.5;
      }
    }
    var l = (this || window).getLayoutType();
    return l === ccui.Layout.LINEAR_HORIZONTAL && (e.height = e.height - e.height / n * (n - 1)), l === ccui.Layout.LINEAR_VERTICAL && (e.width = e.width - e.width / n * (n - 1)), e;
  },
  _findNearestChildWidgetIndex: function(t, e) {
    if (e == null || e === (this || window))
      return this._findFirstFocusEnabledWidgetIndex();
    var n = 0, r = (this || window).getChildren(), s = r.length, o, a = cc.FLT_MAX, c = 0;
    if (t === ccui.Widget.LEFT || t === ccui.Widget.RIGHT || t === ccui.Widget.DOWN || t === ccui.Widget.UP) {
      for (o = (this || window)._getWorldCenterPoint(e); n < s; ) {
        var l = r[n];
        if (l && l instanceof ccui.Widget && l.isFocusEnabled()) {
          var h = l instanceof ccui.Layout ? l._calculateNearestDistance(e) : cc.pLength(cc.pSub(this._getWorldCenterPoint(l), o));
          h < a && (c = n, a = h);
        }
        n++;
      }
      return c;
    }
    return cc.log("invalid focus direction!"), 0;
  },
  _findFarthestChildWidgetIndex: function(t, e) {
    if (e == null || e === (this || window))
      return this._findFirstFocusEnabledWidgetIndex();
    var n = 0, r = (this || window).getChildren(), s = r.length, o = -cc.FLT_MAX, a = 0;
    if (t === ccui.Widget.LEFT || t === ccui.Widget.RIGHT || t === ccui.Widget.DOWN || t === ccui.Widget.UP) {
      for (var c = (this || window)._getWorldCenterPoint(e); n < s; ) {
        var l = r[n];
        if (l && l instanceof ccui.Widget && l.isFocusEnabled()) {
          var h = l instanceof ccui.Layout ? l._calculateFarthestDistance(e) : cc.pLength(cc.pSub(this._getWorldCenterPoint(l), c));
          h > o && (a = n, o = h);
        }
        n++;
      }
      return a;
    }
    return cc.log("invalid focus direction!!!"), 0;
  },
  _calculateNearestDistance: function(t) {
    for (var e = cc.FLT_MAX, n = (this || window)._getWorldCenterPoint(t), r = (this || window)._children, s = 0, o = r.length; s < o; s++) {
      var a = r[s], c;
      if (a instanceof ccui.Layout)
        c = a._calculateNearestDistance(t);
      else if (a instanceof ccui.Widget && a.isFocusEnabled())
        c = cc.pLength(cc.pSub(this._getWorldCenterPoint(a), n));
      else
        continue;
      c < e && (e = c);
    }
    return e;
  },
  _calculateFarthestDistance: function(t) {
    for (var e = -cc.FLT_MAX, n = (this || window)._getWorldCenterPoint(t), r = (this || window)._children, s = 0, o = r.length; s < o; s++) {
      var a = r[s], c;
      if (a instanceof ccui.Layout)
        c = a._calculateFarthestDistance(t);
      else if (a instanceof ccui.Widget && a.isFocusEnabled()) {
        var l = (this || window)._getWorldCenterPoint(a);
        c = cc.pLength(cc.pSub(l, n));
      } else
        continue;
      c > e && (e = c);
    }
    return e;
  },
  _findProperSearchingFunctor: function(t, e) {
    if (e !== void 0) {
      var n = (this || window)._getWorldCenterPoint(e), r = (this || window)._getWorldCenterPoint(this._findFirstNonLayoutWidget());
      t === ccui.Widget.LEFT ? this.onPassFocusToChild = n.x > r.x ? this._findNearestChildWidgetIndex : this._findFarthestChildWidgetIndex : t === ccui.Widget.RIGHT ? this.onPassFocusToChild = n.x > r.x ? this._findFarthestChildWidgetIndex : this._findNearestChildWidgetIndex : t === ccui.Widget.DOWN ? this.onPassFocusToChild = n.y > r.y ? this._findNearestChildWidgetIndex : this._findFarthestChildWidgetIndex : t === ccui.Widget.UP ? this.onPassFocusToChild = n.y < r.y ? this._findNearestChildWidgetIndex : this._findFarthestChildWidgetIndex : cc.log("invalid direction!");
    }
  },
  _findFirstNonLayoutWidget: function() {
    for (var t = (this || window)._children, e = 0, n = t.length; e < n; e++) {
      var r = t[e];
      if (r instanceof ccui.Layout) {
        var s = r._findFirstNonLayoutWidget();
        if (s)
          return s;
      } else if (r instanceof ccui.Widget)
        return r;
    }
    return null;
  },
  _findFirstFocusEnabledWidgetIndex: function() {
    for (var t = 0, e = (this || window).getChildren(), n = e.length; t < n; ) {
      var r = e[t];
      if (r && r instanceof ccui.Widget && r.isFocusEnabled())
        return t;
      t++;
    }
    return 0;
  },
  _findFocusEnabledChildWidgetByIndex: function(t) {
    var e = (this || window)._getChildWidgetByIndex(t);
    return e ? e.isFocusEnabled() ? e : (t = t + 1, this._findFocusEnabledChildWidgetByIndex(t)) : null;
  },
  _getWorldCenterPoint: function(t) {
    var e = t instanceof ccui.Layout ? t._getLayoutAccumulatedSize() : t.getContentSize();
    return t.convertToWorldSpace(cc.p(e.width / 2, e.height / 2));
  },
  _getNextFocusedWidget: function(t, e) {
    var n = null, r = (this || window)._children, s = r.indexOf(e);
    return s = s + 1, s < r.length ? (n = (this || window)._getChildWidgetByIndex(s), n ? n.isFocusEnabled() ? n instanceof ccui.Layout ? (n._isFocusPassing = !0, n.findNextFocusedWidget(t, n)) : (this.dispatchFocusEvent(e, n), n) : this._getNextFocusedWidget(t, n) : e) : this._loopFocus ? this._checkFocusEnabledChild() ? (s = 0, n = (this || window)._getChildWidgetByIndex(s), n.isFocusEnabled() ? n instanceof ccui.Layout ? (n._isFocusPassing = !0, n.findNextFocusedWidget(t, n)) : (this.dispatchFocusEvent(e, n), n) : this._getNextFocusedWidget(t, n)) : e instanceof ccui.Layout ? e : ccui.Widget._focusedWidget : this._isLastWidgetInContainer(e, t) ? this._isWidgetAncestorSupportLoopFocus(this, t) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, t, this) : e instanceof ccui.Layout ? e : ccui.Widget._focusedWidget : ccui.Widget.prototype.findNextFocusedWidget.call(this, t, this);
  },
  _getPreviousFocusedWidget: function(t, e) {
    var n = null, r = (this || window)._children, s = r.indexOf(e);
    return s = s - 1, s >= 0 ? (n = (this || window)._getChildWidgetByIndex(s), n.isFocusEnabled() ? n instanceof ccui.Layout ? (n._isFocusPassing = !0, n.findNextFocusedWidget(t, n)) : (this.dispatchFocusEvent(e, n), n) : this._getPreviousFocusedWidget(t, n)) : this._loopFocus ? this._checkFocusEnabledChild() ? (s = r.length - 1, n = (this || window)._getChildWidgetByIndex(s), n.isFocusEnabled() ? n instanceof ccui.Layout ? (n._isFocusPassing = !0, n.findNextFocusedWidget(t, n)) : (this.dispatchFocusEvent(e, n), n) : this._getPreviousFocusedWidget(t, n)) : e instanceof ccui.Layout ? e : ccui.Widget._focusedWidget : this._isLastWidgetInContainer(e, t) ? this._isWidgetAncestorSupportLoopFocus(this, t) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, t, this) : e instanceof ccui.Layout ? e : ccui.Widget._focusedWidget : ccui.Widget.prototype.findNextFocusedWidget.call(this, t, this);
  },
  _getChildWidgetByIndex: function(t) {
    for (var e = (this || window)._children, n = e.length, r = t; t < n; ) {
      var s = e[t];
      if (s && s instanceof ccui.Widget)
        return s;
      t++;
    }
    for (var o = 0; o < r; ) {
      var a = e[o];
      if (a && a instanceof ccui.Widget)
        return a;
      o++;
    }
    return null;
  },
  _isLastWidgetInContainer: function(t, e) {
    var n = t.getParent();
    if (n == null || !(n instanceof ccui.Layout))
      return !0;
    var r = n.getChildren(), s = r.indexOf(t);
    if (n.getLayoutType() === ccui.Layout.LINEAR_HORIZONTAL) {
      if (e === ccui.Widget.LEFT)
        return s === 0 ? this._isLastWidgetInContainer(n, e) : !1;
      if (e === ccui.Widget.RIGHT)
        return s === r.length - 1 ? this._isLastWidgetInContainer(n, e) : !1;
      if (e === ccui.Widget.DOWN)
        return this._isLastWidgetInContainer(n, e);
      if (e === ccui.Widget.UP)
        return this._isLastWidgetInContainer(n, e);
    } else if (n.getLayoutType() === ccui.Layout.LINEAR_VERTICAL) {
      if (e === ccui.Widget.UP)
        return s === 0 ? this._isLastWidgetInContainer(n, e) : !1;
      if (e === ccui.Widget.DOWN)
        return s === r.length - 1 ? this._isLastWidgetInContainer(n, e) : !1;
      if (e === ccui.Widget.LEFT)
        return this._isLastWidgetInContainer(n, e);
      if (e === ccui.Widget.RIGHT)
        return this._isLastWidgetInContainer(n, e);
    } else
      return cc.log("invalid layout Type"), !1;
  },
  _isWidgetAncestorSupportLoopFocus: function(t, e) {
    var n = t.getParent();
    if (n == null || !(n instanceof ccui.Layout))
      return !1;
    if (n.isLoopFocus()) {
      var r = n.getLayoutType();
      return r === ccui.Layout.LINEAR_HORIZONTAL ? e === ccui.Widget.LEFT || e === ccui.Widget.RIGHT ? !0 : this._isWidgetAncestorSupportLoopFocus(n, e) : r === ccui.Layout.LINEAR_VERTICAL ? e === ccui.Widget.DOWN || e === ccui.Widget.UP ? !0 : this._isWidgetAncestorSupportLoopFocus(n, e) : (cc.assert(0, "invalid layout type"), !1);
    } else
      return this._isWidgetAncestorSupportLoopFocus(n, e);
  },
  _passFocusToChild: function(t, e) {
    if (this._checkFocusEnabledChild()) {
      var n = ccui.Widget.getCurrentFocusedWidget();
      this._findProperSearchingFunctor(t, n);
      var r = (this || window).onPassFocusToChild(t, n), s = (this || window)._getChildWidgetByIndex(r);
      return s instanceof ccui.Layout ? (s._isFocusPassing = !0, s.findNextFocusedWidget(t, s)) : (this.dispatchFocusEvent(e, s), s);
    } else
      return (this || window)
  },
  _checkFocusEnabledChild: function() {
    for (var t = (this || window)._children, e = 0, n = t.length; e < n; e++) {
      var r = t[e];
      if (r && r instanceof ccui.Widget && r.isFocusEnabled())
        return !0;
    }
    return !1;
  },
  getDescription: function() {
    return "Layout";
  },
  _createCloneInstance: function() {
    return new ccui.Layout();
  },
  _copyClonedWidgetChildren: function(t) {
    ccui.Widget.prototype._copyClonedWidgetChildren.call(this, t);
  },
  _copySpecialProperties: function(t) {
    t instanceof ccui.Layout && (this.setBackGroundImageScale9Enabled(t._backGroundScale9Enabled), this.setBackGroundImage(t._backGroundImageFileName, t._bgImageTexType), this.setBackGroundImageCapInsets(t._backGroundImageCapInsets), this.setBackGroundColorType(t._colorType), this.setBackGroundColor(t._color), this.setBackGroundColor(t._startColor, t._endColor), this.setBackGroundColorOpacity(t._opacity), this.setBackGroundColorVector(t._alongVector), this.setLayoutType(t._layoutType), this.setClippingEnabled(t._clippingEnabled), this.setClippingType(t._clippingType), this._loopFocus = t._loopFocus, this.__passFocusToChild = t.__passFocusToChild, this._isInterceptTouch = t._isInterceptTouch);
  },
  forceDoLayout: function() {
    this.requestDoLayout(), this._doLayout();
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new ccui.Layout.WebGLRenderCmd(this) : new ccui.Layout.CanvasRenderCmd(this);
  }
});
var _p = ccui.Layout.prototype;
_p.clippingEnabled;
cc.defineGetterSetter(_p, "clippingEnabled", _p.isClippingEnabled, _p.setClippingEnabled);
_p.clippingType;
cc.defineGetterSetter(_p, "clippingType", null, _p.setClippingType);
_p.layoutType;
cc.defineGetterSetter(_p, "layoutType", _p.getLayoutType, _p.setLayoutType);
_p = null;
ccui.Layout.create = function() {
  return new ccui.Layout();
};
ccui.Layout.BG_COLOR_NONE = 0;
ccui.Layout.BG_COLOR_SOLID = 1;
ccui.Layout.BG_COLOR_GRADIENT = 2;
ccui.Layout.ABSOLUTE = 0;
ccui.Layout.LINEAR_VERTICAL = 1;
ccui.Layout.LINEAR_HORIZONTAL = 2;
ccui.Layout.RELATIVE = 3;
ccui.Layout.CLIPPING_STENCIL = 0;
ccui.Layout.CLIPPING_SCISSOR = 1;
ccui.Layout.BACKGROUND_IMAGE_ZORDER = -1;
ccui.Layout.BACKGROUND_RENDERER_ZORDER = -2;
(function() {
  ccui.Layout.CanvasRenderCmd = function(e) {
    ccui.ProtectedNode.CanvasRenderCmd.call(this, e), this._needDraw = !1, this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._onRenderSaveCmd), this._rendererClipCmd = new cc.CustomRenderCmd(this, this._onRenderClipCmd), this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._onRenderRestoreCmd), this._rendererSaveCmd._canUseDirtyRegion = !0, this._rendererClipCmd._canUseDirtyRegion = !0, this._rendererRestoreCmd._canUseDirtyRegion = !0;
  };
  var t = ccui.Layout.CanvasRenderCmd.prototype = Object.create(ccui.ProtectedNode.CanvasRenderCmd.prototype);
  t.constructor = ccui.Layout.CanvasRenderCmd, cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    ccui.Widget.CanvasRenderCmd && (ccui.Layout.CanvasRenderCmd.prototype.widgetVisit = ccui.Widget.CanvasRenderCmd.prototype.widgetVisit);
  }), t.visit = function(e) {
    var n = (this || window)._node;
    if (n._visible)
      if (n._adaptRenderers(), n._doLayout(), n._clippingEnabled)
        switch (n._clippingType) {
          case ccui.Layout.CLIPPING_STENCIL:
            this.stencilClippingVisit(e);
            break;
          case ccui.Layout.CLIPPING_SCISSOR:
            this.scissorClippingVisit(e);
            break;
        }
      else
        this.widgetVisit(e);
  }, t.layoutVisit = t.visit, t._onRenderSaveCmd = function(e, n, r) {
    var s = e || cc._renderContext, o = s.getContext();
    s.save(), s.save(), s.setTransform(this._worldTransform, n, r);
    for (var a = (this || window)._node._clippingStencil._renderCmd._buffer, c = 0, l = a.length; c < l; c++) {
      var h = a[c], u = h.verts, _ = u[0];
      o.beginPath(), o.moveTo(_.x, -_.y);
      for (var d = 1, f = u.length; d < f; d++)
        o.lineTo(u[d].x, -u[d].y);
      o.closePath();
    }
  }, t._onRenderClipCmd = function(e) {
    var n = e || cc._renderContext, r = n.getContext();
    n.restore(), r.clip();
  }, t._onRenderRestoreCmd = function(e) {
    var n = e || cc._renderContext;
    n.getContext(), n.restore();
  }, t.rebindStencilRendering = function(e) {
    e._renderCmd.rendering = (this || window).__stencilDraw, e._renderCmd._canUseDirtyRegion = !0;
  }, t.__stencilDraw = function(e, n, r) {
  }, t.stencilClippingVisit = t.scissorClippingVisit = function(e) {
    var n = (this || window)._node;
    if (!(!n._clippingStencil || !n._clippingStencil.isVisible())) {
      this._syncStatus(e), cc.renderer.pushRenderCommand(this._rendererSaveCmd), n._clippingStencil.visit(this), cc.renderer.pushRenderCommand(this._rendererClipCmd), n.sortAllChildren(), n.sortAllProtectedChildren();
      for (var r = n._children, s = 0, o = n._protectedChildren, a = 0, c, l = r.length, h = o.length; a < l && (c = r[a], c && c.getLocalZOrder() < 0); a++)
        c.visit(this);
      for (; s < h && (c = o[s], c && c.getLocalZOrder() < 0); s++)
        c.visit(this);
      for (; a < l; a++)
        r[a].visit(this);
      for (; s < h; s++)
        o[s].visit(this);
      cc.renderer.pushRenderCommand(this._rendererRestoreCmd), this._dirtyFlag = 0;
    }
  }, ccui.Layout.CanvasRenderCmd._getSharedCache = function() {
    return cc.ClippingNode._sharedCache || (cc.ClippingNode._sharedCache = document.createElement("canvas"));
  };
})();
(function() {
  if (ccui.ProtectedNode.WebGLRenderCmd) {
    ccui.Layout.WebGLRenderCmd = function(e) {
      ccui.ProtectedNode.WebGLRenderCmd.call(this, e), this._needDraw = !1, this._currentStencilEnabled = 0, this._scissorOldState = !1, this._clippingOldRect = null, this._mask_layer_le = 0, this._beforeVisitCmdStencil = new cc.CustomRenderCmd(this, this._onBeforeVisitStencil), this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil), this._afterVisitCmdStencil = new cc.CustomRenderCmd(this, this._onAfterVisitStencil), this._beforeVisitCmdScissor = new cc.CustomRenderCmd(this, this._onBeforeVisitScissor), this._afterVisitCmdScissor = new cc.CustomRenderCmd(this, this._onAfterVisitScissor);
    };
    var t = ccui.Layout.WebGLRenderCmd.prototype = Object.create(ccui.ProtectedNode.WebGLRenderCmd.prototype);
    t.constructor = ccui.Layout.WebGLRenderCmd, t.visit = function(e) {
      var n = (this || window)._node;
      if (n._visible)
        if (e && e._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (n._clippingRectDirty = !0), n._adaptRenderers(), n._doLayout(), n._clippingEnabled)
          switch (n._clippingType) {
            case ccui.Layout.CLIPPING_STENCIL:
              this.stencilClippingVisit(e);
              break;
            case ccui.Layout.CLIPPING_SCISSOR:
              this.scissorClippingVisit(e);
              break;
          }
        else
          this.pNodeVisit(e);
    }, t.layoutVisit = t.visit, t._onBeforeVisitStencil = function(e) {
      var n = e || cc._renderContext;
      ccui.Layout.WebGLRenderCmd._layer++;
      var r = 1 << ccui.Layout.WebGLRenderCmd._layer, s = r - 1;
      this._mask_layer_le = r | s, this._currentStencilEnabled = n.isEnabled(n.STENCIL_TEST), n.clear(n.DEPTH_BUFFER_BIT), n.enable(n.STENCIL_TEST), n.depthMask(!1), n.stencilFunc(n.NEVER, r, r), n.stencilOp(n.REPLACE, n.KEEP, n.KEEP), n.stencilMask(r), n.clear(n.STENCIL_BUFFER_BIT);
    }, t._onAfterDrawStencil = function(e) {
      var n = e || cc._renderContext;
      n.depthMask(!0), n.stencilFunc(n.EQUAL, this._mask_layer_le, this._mask_layer_le), n.stencilOp(n.KEEP, n.KEEP, n.KEEP);
    }, t._onAfterVisitStencil = function(e) {
      var n = e || cc._renderContext;
      if (ccui.Layout.WebGLRenderCmd._layer--, this._currentStencilEnabled) {
        var r = 1 << ccui.Layout.WebGLRenderCmd._layer, s = r - 1, o = r | s;
        n.stencilMask(r), n.stencilFunc(n.EQUAL, o, o);
      } else
        n.disable(n.STENCIL_TEST);
    }, t._onBeforeVisitScissor = function(e) {
      this._node._clippingRectDirty = !0;
      var n = (this || window)._node._getClippingRect(), r = e || cc._renderContext;
      this._scissorOldState = r.isEnabled(r.SCISSOR_TEST), this._scissorOldState ? (this._clippingOldRect = cc.view.getScissorRect(), cc.rectEqualToRect(this._clippingOldRect, n) || cc.view.setScissorInPoints(n.x, n.y, n.width, n.height)) : (r.enable(r.SCISSOR_TEST), cc.view.setScissorInPoints(n.x, n.y, n.width, n.height));
    }, t._onAfterVisitScissor = function(e) {
      var n = e || cc._renderContext;
      this._scissorOldState ? cc.rectEqualToRect(this._clippingOldRect, this._node._clippingRect) || cc.view.setScissorInPoints(
        this._clippingOldRect.x,
        this._clippingOldRect.y,
        this._clippingOldRect.width,
        this._clippingOldRect.height
      ) : n.disable(n.SCISSOR_TEST);
    }, t.rebindStencilRendering = function(e) {
    }, t.transform = function(e, n) {
      var r = (this || window)._node;
      this.pNodeTransform(e, n), r._clippingStencil && r._clippingStencil._renderCmd.transform(this, n);
    }, t.stencilClippingVisit = function(e) {
      var n = (this || window)._node;
      if (!(!n._clippingStencil || !n._clippingStencil.isVisible())) {
        if (ccui.Layout.WebGLRenderCmd._layer + 1 === cc.stencilBits) {
          ccui.Layout.WebGLRenderCmd._visit_once = !0, ccui.Layout.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."), ccui.Layout.WebGLRenderCmd._visit_once = !1), cc.Node.prototype.visit.call(n, e);
          return;
        }
        cc.renderer.pushRenderCommand(this._beforeVisitCmdStencil);
        var r = cc.current_stack;
        r.stack.push(r.top), this._syncStatus(e), this._dirtyFlag = 0, r.top = (this || window)._stackMatrix, n._clippingStencil.visit(this), cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
        var s = 0, o = 0;
        n.sortAllChildren(), n.sortAllProtectedChildren();
        for (var a = n._children, c = n._protectedChildren, l = a.length, h = c.length, u; s < l && (u = a[s], u && u.getLocalZOrder() < 0); s++)
          u.visit(this);
        for (; o < h && (u = c[o], u && u.getLocalZOrder() < 0); o++)
          u.visit(this);
        for (; s < l; s++)
          a[s].visit(this);
        for (; o < h; o++)
          c[o].visit(this);
        cc.renderer.pushRenderCommand(this._afterVisitCmdStencil), r.top = r.stack.pop();
      }
    }, t.scissorClippingVisit = function(e) {
      cc.renderer.pushRenderCommand(this._beforeVisitCmdScissor), this.pNodeVisit(e), cc.renderer.pushRenderCommand(this._afterVisitCmdScissor);
    }, ccui.Layout.WebGLRenderCmd._layer = -1, ccui.Layout.WebGLRenderCmd._visit_once = null;
  }
})();
ccui.Margin = ccui.Class.extend({
  left: 0,
  top: 0,
  right: 0,
  bottom: 0,
  ctor: function(t, e, n, r) {
    t !== void 0 && e === void 0 && (this.left = t.left, this.top = t.top, this.right = t.right, this.bottom = t.bottom), r !== void 0 && (this.left = t, this.top = e, this.right = n, this.bottom = r);
  },
  setMargin: function(t, e, n, r) {
    this.left = t, this.top = e, this.right = n, this.bottom = r;
  },
  equals: function(t) {
    return this.left === t.left && this.top === t.top && this.right === t.right && this.bottom === t.bottom;
  }
});
ccui.MarginZero = function() {
  return new ccui.Margin(0, 0, 0, 0);
};
ccui.LayoutParameter = ccui.Class.extend({
  _margin: null,
  _layoutParameterType: null,
  ctor: function() {
    this._margin = new ccui.Margin(), this._layoutParameterType = ccui.LayoutParameter.NONE;
  },
  setMargin: function(t) {
    cc.isObject(t) ? (this._margin.left = t.left, this._margin.top = t.top, this._margin.right = t.right, this._margin.bottom = t.bottom) : (this._margin.left = arguments[0], this._margin.top = arguments[1], this._margin.right = arguments[2], this._margin.bottom = arguments[3]);
  },
  getMargin: function() {
    return this._margin;
  },
  getLayoutType: function() {
    return this._layoutParameterType;
  },
  clone: function() {
    var t = (this || window)._createCloneInstance();
    return t._copyProperties(this), t;
  },
  _createCloneInstance: function() {
    return new ccui.LayoutParameter();
  },
  _copyProperties: function(t) {
    this._margin.bottom = t._margin.bottom, this._margin.left = t._margin.left, this._margin.right = t._margin.right, this._margin.top = t._margin.top;
  }
});
ccui.LayoutParameter.create = function() {
  return new ccui.LayoutParameter();
};
ccui.LayoutParameter.NONE = 0;
ccui.LayoutParameter.LINEAR = 1;
ccui.LayoutParameter.RELATIVE = 2;
ccui.LinearLayoutParameter = ccui.LayoutParameter.extend({
  _linearGravity: null,
  ctor: function() {
    ccui.LayoutParameter.prototype.ctor.call(this), this._linearGravity = ccui.LinearLayoutParameter.NONE, this._layoutParameterType = ccui.LayoutParameter.LINEAR;
  },
  setGravity: function(t) {
    this._linearGravity = t;
  },
  getGravity: function() {
    return this._linearGravity;
  },
  _createCloneInstance: function() {
    return new ccui.LinearLayoutParameter();
  },
  _copyProperties: function(t) {
    ccui.LayoutParameter.prototype._copyProperties.call(this, t), t instanceof ccui.LinearLayoutParameter && this.setGravity(t._linearGravity);
  }
});
ccui.LinearLayoutParameter.create = function() {
  return new ccui.LinearLayoutParameter();
};
ccui.LinearLayoutParameter.NONE = 0;
ccui.LinearLayoutParameter.LEFT = 1;
ccui.LinearLayoutParameter.TOP = 2;
ccui.LinearLayoutParameter.RIGHT = 3;
ccui.LinearLayoutParameter.BOTTOM = 4;
ccui.LinearLayoutParameter.CENTER_VERTICAL = 5;
ccui.LinearLayoutParameter.CENTER_HORIZONTAL = 6;
ccui.RelativeLayoutParameter = ccui.LayoutParameter.extend({
  _relativeAlign: null,
  _relativeWidgetName: "",
  _relativeLayoutName: "",
  _put: !1,
  ctor: function() {
    ccui.LayoutParameter.prototype.ctor.call(this), this._relativeAlign = ccui.RelativeLayoutParameter.NONE, this._relativeWidgetName = "", this._relativeLayoutName = "", this._put = !1, this._layoutParameterType = ccui.LayoutParameter.RELATIVE;
  },
  setAlign: function(t) {
    this._relativeAlign = t;
  },
  getAlign: function() {
    return this._relativeAlign;
  },
  setRelativeToWidgetName: function(t) {
    this._relativeWidgetName = t;
  },
  getRelativeToWidgetName: function() {
    return this._relativeWidgetName;
  },
  setRelativeName: function(t) {
    this._relativeLayoutName = t;
  },
  getRelativeName: function() {
    return this._relativeLayoutName;
  },
  _createCloneInstance: function() {
    return new ccui.RelativeLayoutParameter();
  },
  _copyProperties: function(t) {
    ccui.LayoutParameter.prototype._copyProperties.call(this, t), t instanceof ccui.RelativeLayoutParameter && (this.setAlign(t._relativeAlign), this.setRelativeToWidgetName(t._relativeWidgetName), this.setRelativeName(t._relativeLayoutName));
  }
});
ccui.RelativeLayoutParameter.create = function() {
  return new ccui.RelativeLayoutParameter();
};
ccui.RelativeLayoutParameter.NONE = 0;
ccui.RelativeLayoutParameter.PARENT_TOP_LEFT = 1;
ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT = 3;
ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RelativeLayoutParameter.CENTER_IN_PARENT = 5;
ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM = 7;
ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM = 9;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN = 10;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER = 11;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN = 12;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN = 13;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER = 14;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN = 15;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN = 16;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER = 17;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN = 18;
ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN = 19;
ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER = 20;
ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN = 21;
ccui.LINEAR_GRAVITY_NONE = 0;
ccui.LINEAR_GRAVITY_LEFT = 1;
ccui.LINEAR_GRAVITY_TOP = 2;
ccui.LINEAR_GRAVITY_RIGHT = 3;
ccui.LINEAR_GRAVITY_BOTTOM = 4;
ccui.LINEAR_GRAVITY_CENTER_VERTICAL = 5;
ccui.LINEAR_GRAVITY_CENTER_HORIZONTAL = 6;
ccui.RELATIVE_ALIGN_NONE = 0;
ccui.RELATIVE_ALIGN_PARENT_TOP_LEFT = 1;
ccui.RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RELATIVE_ALIGN_PARENT_TOP_RIGHT = 3;
ccui.RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RELATIVE_ALIGN_PARENT_CENTER = 5;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RELATIVE_ALIGN_PARENT_LEFT_BOTTOM = 7;
ccui.RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM = 9;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_LEFT = 10;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_CENTER = 11;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_RIGHT = 12;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_TOP = 13;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_CENTER = 14;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_BOTTOM = 15;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_TOP = 16;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_CENTER = 17;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_BOTTOM = 18;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_TOP = 19;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_CENTER = 20;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_BOTTOM = 21;
ccui.getLayoutManager = function(t) {
  switch (t) {
    case ccui.Layout.LINEAR_VERTICAL:
      return ccui.linearVerticalLayoutManager;
    case ccui.Layout.LINEAR_HORIZONTAL:
      return ccui.linearHorizontalLayoutManager;
    case ccui.Layout.RELATIVE:
      return ccui.relativeLayoutManager;
  }
  return null;
};
ccui.linearVerticalLayoutManager = {
  _doLayout: function(t) {
    for (var e = t._getLayoutContentSize(), n = t._getLayoutElements(), r = e.height, s = 0, o = n.length; s < o; s++) {
      var a = n[s];
      if (a) {
        var c = a.getLayoutParameter();
        if (c) {
          var l = c.getGravity(), h = a.getAnchorPoint(), u = a.getContentSize(), _ = h.x * u.width, d = r - (1 - h.y) * u.height;
          switch (l) {
            case ccui.LinearLayoutParameter.NONE:
            case ccui.LinearLayoutParameter.LEFT:
              break;
            case ccui.LinearLayoutParameter.RIGHT:
              _ = e.width - (1 - h.x) * u.width;
              break;
            case ccui.LinearLayoutParameter.CENTER_HORIZONTAL:
              _ = e.width / 2 - u.width * (0.5 - h.x);
              break;
          }
          var f = c.getMargin();
          _ += f.left, d -= f.top, a.setPosition(_, d), r = a.getPositionY() - h.y * u.height - f.bottom;
        }
      }
    }
  }
};
ccui.linearHorizontalLayoutManager = {
  _doLayout: function(t) {
    for (var e = t._getLayoutContentSize(), n = t._getLayoutElements(), r = 0, s = 0, o = n.length; s < o; s++) {
      var a = n[s];
      if (a) {
        var c = a.getLayoutParameter();
        if (c) {
          var l = c.getGravity(), h = a.getAnchorPoint(), u = a.getContentSize(), _ = r + h.x * u.width, d = e.height - (1 - h.y) * u.height;
          switch (l) {
            case ccui.LinearLayoutParameter.NONE:
            case ccui.LinearLayoutParameter.TOP:
              break;
            case ccui.LinearLayoutParameter.BOTTOM:
              d = h.y * u.height;
              break;
            case ccui.LinearLayoutParameter.CENTER_VERTICAL:
              d = e.height / 2 - u.height * (0.5 - h.y);
              break;
          }
          var f = c.getMargin();
          _ += f.left, d -= f.top, a.setPosition(_, d), r = a.getRightBoundary() + f.right;
        }
      }
    }
  }
};
ccui.relativeLayoutManager = {
  _unlayoutChildCount: 0,
  _widgetChildren: [],
  _widget: null,
  _finalPositionX: 0,
  _finalPositionY: 0,
  _relativeWidgetLP: null,
  _doLayout: function(t) {
    this._widgetChildren = (this || window)._getAllWidgets(t);
    for (var e = (this || window)._widgetChildren; this._unlayoutChildCount > 0; ) {
      for (var n = 0, r = e.length; n < r; n++) {
        this._widget = e[n];
        var s = (this || window)._widget.getLayoutParameter();
        if (s) {
          if (s._put)
            continue;
          var o = (this || window)._calculateFinalPositionWithRelativeWidget(t);
          if (!o)
            continue;
          this._calculateFinalPositionWithRelativeAlign(), this._widget.setPosition(this._finalPositionX, this._finalPositionY), s._put = !0;
        }
      }
      this._unlayoutChildCount--;
    }
    this._widgetChildren.length = 0;
  },
  _getAllWidgets: function(t) {
    var e = t._getLayoutElements(), n = (this || window)._widgetChildren;
    n.length = 0;
    for (var r = 0, s = e.length; r < s; r++) {
      var o = e[r];
      if (o && o instanceof ccui.Widget) {
        var a = o.getLayoutParameter();
        a._put = !1, this._unlayoutChildCount++, n.push(o);
      }
    }
    return n;
  },
  _getRelativeWidget: function(t) {
    var e = null, n = t.getLayoutParameter(), r = n.getRelativeToWidgetName();
    if (r && r.length !== 0)
      for (var s = (this || window)._widgetChildren, o = 0, a = s.length; o < a; o++) {
        var c = s[o];
        if (c) {
          var l = c.getLayoutParameter();
          if (l && l.getRelativeName() === r) {
            e = c, this._relativeWidgetLP = l;
            break;
          }
        }
      }
    return e;
  },
  _calculateFinalPositionWithRelativeWidget: function(t) {
    var e = (this || window)._widget, n = e.getAnchorPoint(), r = e.getContentSize();
    this._finalPositionX = 0, this._finalPositionY = 0;
    var s = (this || window)._getRelativeWidget(e), o = e.getLayoutParameter(), a = o.getAlign(), c = t._getLayoutContentSize();
    switch (a) {
      case ccui.RelativeLayoutParameter.NONE:
      case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
        this._finalPositionX = n.x * r.width, this._finalPositionY = c.height - (1 - n.y) * r.height;
        break;
      case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
        this._finalPositionX = c.width * 0.5 - r.width * (0.5 - n.x), this._finalPositionY = c.height - (1 - n.y) * r.height;
        break;
      case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
        this._finalPositionX = c.width - (1 - n.x) * r.width, this._finalPositionY = c.height - (1 - n.y) * r.height;
        break;
      case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
        this._finalPositionX = n.x * r.width, this._finalPositionY = c.height * 0.5 - r.height * (0.5 - n.y);
        break;
      case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
        this._finalPositionX = c.width * 0.5 - r.width * (0.5 - n.x), this._finalPositionY = c.height * 0.5 - r.height * (0.5 - n.y);
        break;
      case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
        this._finalPositionX = c.width - (1 - n.x) * r.width, this._finalPositionY = c.height * 0.5 - r.height * (0.5 - n.y);
        break;
      case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
        this._finalPositionX = n.x * r.width, this._finalPositionY = n.y * r.height;
        break;
      case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
        this._finalPositionX = c.width * 0.5 - r.width * (0.5 - n.x), this._finalPositionY = n.y * r.height;
        break;
      case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
        this._finalPositionX = c.width - (1 - n.x) * r.width, this._finalPositionY = n.y * r.height;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          this._finalPositionY = s.getTopBoundary() + n.y * r.height, this._finalPositionX = s.getLeftBoundary() + n.x * r.width;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          var l = s.getContentSize();
          this._finalPositionY = s.getTopBoundary() + n.y * r.height, this._finalPositionX = s.getLeftBoundary() + l.width * 0.5 + n.x * r.width - r.width * 0.5;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          this._finalPositionY = s.getTopBoundary() + n.y * r.height, this._finalPositionX = s.getRightBoundary() - (1 - n.x) * r.width;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          this._finalPositionY = s.getTopBoundary() - (1 - n.y) * r.height, this._finalPositionX = s.getLeftBoundary() - (1 - n.x) * r.width;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          var l = s.getContentSize();
          this._finalPositionX = s.getLeftBoundary() - (1 - n.x) * r.width, this._finalPositionY = s.getBottomBoundary() + l.height * 0.5 + n.y * r.height - r.height * 0.5;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          this._finalPositionY = s.getBottomBoundary() + n.y * r.height, this._finalPositionX = s.getLeftBoundary() - (1 - n.x) * r.width;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          this._finalPositionY = s.getTopBoundary() - (1 - n.y) * r.height, this._finalPositionX = s.getRightBoundary() + n.x * r.width;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          var l = s.getContentSize(), h = s.getRightBoundary();
          this._finalPositionX = h + n.x * r.width, this._finalPositionY = s.getBottomBoundary() + l.height * 0.5 + n.y * r.height - r.height * 0.5;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          this._finalPositionY = s.getBottomBoundary() + n.y * r.height, this._finalPositionX = s.getRightBoundary() + n.x * r.width;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          this._finalPositionY = s.getBottomBoundary() - (1 - n.y) * r.height, this._finalPositionX = s.getLeftBoundary() + n.x * r.width;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          var l = s.getContentSize();
          this._finalPositionY = s.getBottomBoundary() - (1 - n.y) * r.height, this._finalPositionX = s.getLeftBoundary() + l.width * 0.5 + n.x * r.width - r.width * 0.5;
        }
        break;
      case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
        if (s) {
          if (this._relativeWidgetLP && !this._relativeWidgetLP._put)
            return !1;
          this._finalPositionY = s.getBottomBoundary() - (1 - n.y) * r.height, this._finalPositionX = s.getRightBoundary() - (1 - n.x) * r.width;
        }
        break;
    }
    return !0;
  },
  _calculateFinalPositionWithRelativeAlign: function() {
    var t = (this || window)._widget.getLayoutParameter(), e = t.getMargin(), n = t.getAlign();
    switch (n) {
      case ccui.RelativeLayoutParameter.NONE:
      case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
        this._finalPositionX += e.left, this._finalPositionY -= e.top;
        break;
      case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
        this._finalPositionY -= e.top;
        break;
      case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
        this._finalPositionX -= e.right, this._finalPositionY -= e.top;
        break;
      case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
        this._finalPositionX += e.left;
        break;
      case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
        break;
      case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
        this._finalPositionX -= e.right;
        break;
      case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
        this._finalPositionX += e.left, this._finalPositionY += e.bottom;
        break;
      case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
        this._finalPositionY += e.bottom;
        break;
      case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
        this._finalPositionX -= e.right, this._finalPositionY += e.bottom;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
        this._finalPositionY += e.bottom, this._finalPositionX += e.left;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
        this._finalPositionY += e.bottom, this._finalPositionX -= e.right;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
        this._finalPositionY += e.bottom;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
        this._finalPositionX -= e.right, this._finalPositionY -= e.top;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
        this._finalPositionX -= e.right, this._finalPositionY += e.bottom;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
        this._finalPositionX -= e.right;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
        this._finalPositionX += e.left, this._finalPositionY -= e.top;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
        this._finalPositionX += e.left, this._finalPositionY += e.bottom;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
        this._finalPositionX += e.left;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
        this._finalPositionY -= e.top, this._finalPositionX += e.left;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
        this._finalPositionY -= e.top, this._finalPositionX -= e.right;
        break;
      case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
        this._finalPositionY -= e.top;
        break;
    }
  }
};
ccui.HBox = ccui.Layout.extend({
  ctor: function(t) {
    ccui.Layout.prototype.ctor.call(this), this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL), t && this.setContentSize(t);
  }
});
ccui.HBox.create = function(t) {
  return new ccui.HBox(t);
};
ccui.RelativeBox = ccui.Layout.extend({
  ctor: function(t) {
    ccui.Layout.prototype.ctor.call(this), this.setLayoutType(ccui.Layout.RELATIVE), t && this.setContentSize(t);
  }
});
ccui.RelativeBox.create = function(t) {
  return new ccui.RelativeBox(t);
};
ccui.VBox = ccui.Layout.extend({
  ctor: function(t) {
    ccui.Layout.prototype.ctor.call(this), this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), t && this.setContentSize(t);
  },
  initWithSize: function(t) {
    return !!this.init();
  }
});
ccui.VBox.create = function(t) {
  return new ccui.VBox(t);
};
ccui.helper = {
  seekWidgetByTag: function(t, e) {
    if (!t)
      return null;
    if (t.getTag() === e)
      return t;
    for (var n = t.getChildren(), r = n.length, s = 0; s < r; s++) {
      var o = n[s], a = ccui.helper.seekWidgetByTag(o, e);
      if (a !== null)
        return a;
    }
    return null;
  },
  seekWidgetByName: function(t, e) {
    if (!t)
      return null;
    if (t.getName() === e)
      return t;
    for (var n = t.getChildren(), r = n.length, s = 0; s < r; s++) {
      var o = n[s], a = ccui.helper.seekWidgetByName(o, e);
      if (a !== null)
        return a;
    }
    return null;
  },
  seekWidgetByRelativeName: function(t, e) {
    if (!t)
      return null;
    for (var n = t.getChildren(), r = n.length, s = 0; s < r; s++) {
      var o = n[s], a = o.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
      if (a && a.getRelativeName() === e)
        return o;
    }
    return null;
  },
  seekActionWidgetByActionTag: function(t, e) {
    if (!t)
      return null;
    if (t.getActionTag() === e)
      return t;
    for (var n = t.getChildren(), r = 0; r < n.length; r++) {
      var s = n[r], o = ccui.helper.seekActionWidgetByActionTag(s, e);
      if (o !== null)
        return o;
    }
    return null;
  },
  _activeLayout: !0,
  doLayout: function(t) {
    if (this._activeLayout)
      for (var e = t.getChildren(), n, r = 0, s = e.length; r < s; r++) {
        n = e[r];
        var o = n.getComponent(ccui.LayoutComponent.NAME), a = n.getParent();
        o != null && a !== null && o.refreshLayout && o.refreshLayout();
      }
  },
  changeLayoutSystemActiveState: function(t) {
    this._activeLayout = t;
  },
  restrictCapInsetRect: function(t, e) {
    var n = t.x, r = t.y, s = t.width, o = t.height;
    return e.width < s && (n = 0, s = 0), e.height < o && (r = 0, o = 0), cc.rect(n, r, s, o);
  },
  _createSpriteFromBase64: function(t, e) {
    var n = cc.textureCache.getTextureForKey(e);
    if (!n) {
      var r = new Image();
      r.src = t, cc.textureCache.cacheImage(e, r), n = cc.textureCache.getTextureForKey(e);
    }
    var s = new cc.Sprite(n);
    return s;
  }
};
ccui.Button = ccui.Widget.extend({
  _buttonNormalRenderer: null,
  _buttonClickedRenderer: null,
  _buttonDisableRenderer: null,
  _titleRenderer: null,
  _normalFileName: "",
  _clickedFileName: "",
  _disabledFileName: "",
  _prevIgnoreSize: !0,
  _scale9Enabled: !1,
  _capInsetsNormal: null,
  _capInsetsPressed: null,
  _capInsetsDisabled: null,
  _normalTexType: ccui.Widget.LOCAL_TEXTURE,
  _pressedTexType: ccui.Widget.LOCAL_TEXTURE,
  _disabledTexType: ccui.Widget.LOCAL_TEXTURE,
  _normalTextureSize: null,
  _pressedTextureSize: null,
  _disabledTextureSize: null,
  pressedActionEnabled: !1,
  _titleColor: null,
  _normalTextureScaleXInSize: 1,
  _normalTextureScaleYInSize: 1,
  _pressedTextureScaleXInSize: 1,
  _pressedTextureScaleYInSize: 1,
  _zoomScale: 0.1,
  _normalTextureLoaded: !1,
  _pressedTextureLoaded: !1,
  _disabledTextureLoaded: !1,
  _className: "Button",
  _normalTextureAdaptDirty: !0,
  _pressedTextureAdaptDirty: !0,
  _disabledTextureAdaptDirty: !0,
  _fontName: "Thonburi",
  _fontSize: 12,
  _type: 0,
  ctor: function(t, e, n, r) {
    this._capInsetsNormal = cc.rect(0, 0, 0, 0), this._capInsetsPressed = cc.rect(0, 0, 0, 0), this._capInsetsDisabled = cc.rect(0, 0, 0, 0), this._normalTextureSize = cc.size(0, 0), this._pressedTextureSize = cc.size(0, 0), this._disabledTextureSize = cc.size(0, 0), this._titleColor = cc.color.WHITE, ccui.Widget.prototype.ctor.call(this), this.setTouchEnabled(!0), t && this.loadTextures(t, e, n, r);
  },
  _initRenderer: function() {
    this._buttonNormalRenderer = new cc.Sprite(), this._buttonClickedRenderer = new cc.Sprite(), this._buttonDisableRenderer = new cc.Sprite(), this._titleRenderer = new cc.LabelTTF(""), this._titleRenderer.setAnchorPoint(0.5, 0.5), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1), this.addProtectedChild(this._titleRenderer, ccui.Button.TITLE_RENDERER_ZORDER, -1);
  },
  setScale9Enabled: function(t) {
    if (this._scale9Enabled !== t) {
      if (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._scale9Enabled = t, this.removeProtectedChild(this._buttonNormalRenderer), this.removeProtectedChild(this._buttonClickedRenderer), this.removeProtectedChild(this._buttonDisableRenderer), this._scale9Enabled ? (this._buttonNormalRenderer = new ccui.Scale9Sprite(), this._buttonClickedRenderer = new ccui.Scale9Sprite(), this._buttonDisableRenderer = new ccui.Scale9Sprite()) : (this._buttonNormalRenderer = new cc.Sprite(), this._buttonClickedRenderer = new cc.Sprite(), this._buttonDisableRenderer = new cc.Sprite()), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!1), this.loadTextureNormal(this._normalFileName, this._normalTexType), this.loadTexturePressed(this._clickedFileName, this._pressedTexType), this.loadTextureDisabled(this._disabledFileName, this._disabledTexType), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1), this._scale9Enabled) {
        var e = (this || window)._ignoreSize;
        this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = e;
      } else
        this.ignoreContentAdaptWithSize(this._prevIgnoreSize);
      this.setCapInsetsNormalRenderer(this._capInsetsNormal), this.setCapInsetsPressedRenderer(this._capInsetsPressed), this.setCapInsetsDisabledRenderer(this._capInsetsDisabled), this.setBright(this._bright), this._normalTextureAdaptDirty = !0, this._pressedTextureAdaptDirty = !0, this._disabledTextureAdaptDirty = !0;
    }
  },
  isScale9Enabled: function() {
    return this._scale9Enabled;
  },
  ignoreContentAdaptWithSize: function(t) {
    if (this._unifySize) {
      this._updateContentSize();
      return;
    }
    (!this._scale9Enabled || this._scale9Enabled && !t) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, t), this._prevIgnoreSize = t);
  },
  getVirtualRendererSize: function() {
    return this._unifySize ? this._getNormalSize() : !this._normalTextureLoaded && this._titleRenderer.getString().length > 0 ? this._titleRenderer.getContentSize() : cc.size(this._normalTextureSize);
  },
  loadTextures: function(t, e, n, r) {
    this.loadTextureNormal(t, r), this.loadTexturePressed(e, r), this.loadTextureDisabled(n, r);
  },
  loadTextureNormal: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._normalFileName = t, this._normalTexType = e;
      var n = (this || window), r = (this || window)._buttonNormalRenderer;
      switch (r._textureLoaded || r.addEventListener("load", function() {
        n.loadTextureNormal(n._normalFileName, n._normalTexType);
      }), this._normalTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          r.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          r.initWithSpriteFrameName(t);
          break;
      }
      this._normalTextureLoaded = r._textureLoaded, this._normalTextureSize = (this || window)._buttonNormalRenderer.getContentSize(), this._updateChildrenDisplayedRGBA(), this._unifySize ? this._scale9Enabled && (r.setCapInsets(this._capInsetsNormal), this._updateContentSizeWithTextureSize(this._getNormalSize())) : this._updateContentSizeWithTextureSize(this._normalTextureSize), this._normalTextureAdaptDirty = !0, this._findLayout();
    }
  },
  loadTexturePressed: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._clickedFileName = t, this._pressedTexType = e;
      var n = (this || window), r = (this || window)._buttonClickedRenderer;
      switch (r._textureLoaded || r.addEventListener("load", function() {
        n.loadTexturePressed(n._clickedFileName, n._pressedTexType);
      }), this._pressedTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          r.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          r.initWithSpriteFrameName(t);
          break;
      }
      this._scale9Enabled && r.setCapInsets(this._capInsetsPressed), this._pressedTextureSize = (this || window)._buttonClickedRenderer.getContentSize(), this._updateChildrenDisplayedRGBA(), this._pressedTextureLoaded = !0, this._pressedTextureAdaptDirty = !0, this._findLayout();
    }
  },
  loadTextureDisabled: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._disabledFileName = t, this._disabledTexType = e;
      var n = (this || window), r = (this || window)._buttonDisableRenderer;
      switch (r._textureLoaded || r.addEventListener("load", function() {
        n.loadTextureDisabled(n._disabledFileName, n._disabledTexType);
      }), this._disabledTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          r.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          r.initWithSpriteFrameName(t);
          break;
      }
      this._scale9Enabled && r.setCapInsets(this._capInsetsDisabled), this._disabledTextureSize = (this || window)._buttonDisableRenderer.getContentSize(), this._updateChildrenDisplayedRGBA(), this._disabledTextureLoaded = !0, this._disabledTextureAdaptDirty = !0, this._findLayout();
    }
  },
  setCapInsets: function(t) {
    this.setCapInsetsNormalRenderer(t), this.setCapInsetsPressedRenderer(t), this.setCapInsetsDisabledRenderer(t);
  },
  setCapInsetsNormalRenderer: function(t) {
    if (t) {
      var e = t.x, n = t.y, r = t.width, s = t.height;
      this._normalTextureSize.width < r && (e = 0, r = 0), this._normalTextureSize.height < s && (n = 0, s = 0);
      var o = (this || window)._capInsetsNormal;
      o.x = e, o.y = n, o.width = r, o.height = s, this._scale9Enabled && this._buttonNormalRenderer.setCapInsets(o);
    }
  },
  getCapInsetsNormalRenderer: function() {
    return cc.rect(this._capInsetsNormal);
  },
  setCapInsetsPressedRenderer: function(t) {
    if (!(!t || !this._scale9Enabled)) {
      var e = t.x, n = t.y, r = t.width, s = t.height;
      this._pressedTextureSize.width < r && (e = 0, r = 0), this._pressedTextureSize.height < s && (n = 0, s = 0);
      var o = (this || window)._capInsetsPressed;
      o.x = e, o.y = n, o.width = r, o.height = s, this._buttonClickedRenderer.setCapInsets(o);
    }
  },
  getCapInsetsPressedRenderer: function() {
    return cc.rect(this._capInsetsPressed);
  },
  setCapInsetsDisabledRenderer: function(t) {
    if (!(!t || !this._scale9Enabled)) {
      var e = t.x, n = t.y, r = t.width, s = t.height;
      this._disabledTextureSize.width < r && (e = 0, r = 0), this._disabledTextureSize.height < s && (n = 0, s = 0);
      var o = (this || window)._capInsetsDisabled;
      o.x = e, o.y = n, o.width = r, o.height = s, this._buttonDisableRenderer.setCapInsets(o);
    }
  },
  getCapInsetsDisabledRenderer: function() {
    return cc.rect(this._capInsetsDisabled);
  },
  _onPressStateChangedToNormal: function() {
    if (this._buttonNormalRenderer.setVisible(!0), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!1), this._scale9Enabled && this._buttonNormalRenderer.setState(ccui.Scale9Sprite.state.NORMAL), this._pressedTextureLoaded) {
      if (this.pressedActionEnabled)
        if (this._buttonNormalRenderer.stopAllActions(), this._buttonClickedRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize), this._titleRenderer.stopAllActions(), this._unifySize) {
          var t = cc.scaleTo(ccui.Button.ZOOM_ACTION_TIME_STEP, 1, 1);
          this._titleRenderer.runAction(t);
        } else
          this._titleRenderer.setScaleX(1), this._titleRenderer.setScaleY(1);
    } else
      this._buttonNormalRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._titleRenderer.stopAllActions(), this._scale9Enabled && this._buttonNormalRenderer.setColor(cc.color.WHITE), this._titleRenderer.setScaleX(1), this._titleRenderer.setScaleY(1);
  },
  _onPressStateChangedToPressed: function() {
    var t = (this || window)._buttonNormalRenderer;
    if (this._scale9Enabled && t.setState(ccui.Scale9Sprite.state.NORMAL), this._pressedTextureLoaded) {
      if (t.setVisible(!1), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this.pressedActionEnabled) {
        t.stopAllActions(), this._buttonClickedRenderer.stopAllActions();
        var e = cc.scaleTo(
          ccui.Button.ZOOM_ACTION_TIME_STEP,
          this._pressedTextureScaleXInSize + this._zoomScale,
          this._pressedTextureScaleYInSize + this._zoomScale
        );
        this._buttonClickedRenderer.runAction(e), t.setScale(this._pressedTextureScaleXInSize + this._zoomScale, this._pressedTextureScaleYInSize + this._zoomScale), this._titleRenderer.stopAllActions(), this._titleRenderer.runAction(cc.scaleTo(ccui.Button.ZOOM_ACTION_TIME_STEP, 1 + this._zoomScale, 1 + this._zoomScale));
      }
    } else
      t.setVisible(!0), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), t.stopAllActions(), t.setScale(this._normalTextureScaleXInSize + this._zoomScale, this._normalTextureScaleYInSize + this._zoomScale), this._titleRenderer.stopAllActions(), this._titleRenderer.setScaleX(1 + this._zoomScale), this._titleRenderer.setScaleY(1 + this._zoomScale);
  },
  _onPressStateChangedToDisabled: function() {
    this._disabledTextureLoaded ? (this._buttonNormalRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!0)) : this._normalTextureLoaded && this._scale9Enabled && this._buttonNormalRenderer.setState(ccui.Scale9Sprite.state.GRAY), this._buttonClickedRenderer.setVisible(!1), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize);
  },
  _updateContentSize: function() {
    if (this._unifySize) {
      if (this._scale9Enabled)
        ccui.ProtectedNode.setContentSize(this._customSize);
      else {
        var t = (this || window)._getNormalSize();
        ccui.ProtectedNode.setContentSize(t);
      }
      this._onSizeChanged();
      return;
    }
    this._ignoreSize && this.setContentSize(this.getVirtualRendererSize());
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this), this._updateTitleLocation(), this._normalTextureAdaptDirty = !0, this._pressedTextureAdaptDirty = !0, this._disabledTextureAdaptDirty = !0;
  },
  getVirtualRenderer: function() {
    if (this._bright)
      switch (this._brightStyle) {
        case ccui.Widget.BRIGHT_STYLE_NORMAL:
          return this._buttonNormalRenderer;
        case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
          return this._buttonClickedRenderer;
        default:
          return null;
      }
    else
      return this._buttonDisableRenderer;
  },
  _normalTextureScaleChangedWithSize: function() {
    if (this._ignoreSize && !this._unifySize)
      this._scale9Enabled || (this._buttonNormalRenderer.setScale(1), this._normalTextureScaleXInSize = (this || window)._normalTextureScaleYInSize = 1);
    else if (this._scale9Enabled)
      this._buttonNormalRenderer.setPreferredSize(this._contentSize), this._normalTextureScaleXInSize = (this || window)._normalTextureScaleYInSize = 1, this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
    else {
      var t = (this || window)._normalTextureSize;
      if (t.width <= 0 || t.height <= 0) {
        this._buttonNormalRenderer.setScale(1);
        return;
      }
      var e = (this || window)._contentSize.width / t.width, n = (this || window)._contentSize.height / t.height;
      this._buttonNormalRenderer.setScaleX(e), this._buttonNormalRenderer.setScaleY(n), this._normalTextureScaleXInSize = e, this._normalTextureScaleYInSize = n;
    }
    this._buttonNormalRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
  },
  _pressedTextureScaleChangedWithSize: function() {
    if (this._ignoreSize && !this._unifySize)
      this._scale9Enabled || (this._buttonClickedRenderer.setScale(1), this._pressedTextureScaleXInSize = (this || window)._pressedTextureScaleYInSize = 1);
    else if (this._scale9Enabled)
      this._buttonClickedRenderer.setPreferredSize(this._contentSize), this._pressedTextureScaleXInSize = (this || window)._pressedTextureScaleYInSize = 1, this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize);
    else {
      var t = (this || window)._pressedTextureSize;
      if (t.width <= 0 || t.height <= 0) {
        this._buttonClickedRenderer.setScale(1);
        return;
      }
      var e = (this || window)._contentSize.width / t.width, n = (this || window)._contentSize.height / t.height;
      this._buttonClickedRenderer.setScaleX(e), this._buttonClickedRenderer.setScaleY(n), this._pressedTextureScaleXInSize = e, this._pressedTextureScaleYInSize = n;
    }
    this._buttonClickedRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
  },
  _disabledTextureScaleChangedWithSize: function() {
    if (this._ignoreSize && !this._unifySize)
      this._scale9Enabled && this._buttonDisableRenderer.setScale(1);
    else if (this._scale9Enabled)
      this._buttonDisableRenderer.setScale(1), this._buttonDisableRenderer.setPreferredSize(this._contentSize);
    else {
      var t = (this || window)._disabledTextureSize;
      if (t.width <= 0 || t.height <= 0) {
        this._buttonDisableRenderer.setScale(1);
        return;
      }
      var e = (this || window)._contentSize.width / t.width, n = (this || window)._contentSize.height / t.height;
      this._buttonDisableRenderer.setScaleX(e), this._buttonDisableRenderer.setScaleY(n);
    }
    this._buttonDisableRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
  },
  _adaptRenderers: function() {
    this._normalTextureAdaptDirty && (this._normalTextureScaleChangedWithSize(), this._normalTextureAdaptDirty = !1), this._pressedTextureAdaptDirty && (this._pressedTextureScaleChangedWithSize(), this._pressedTextureAdaptDirty = !1), this._disabledTextureAdaptDirty && (this._disabledTextureScaleChangedWithSize(), this._disabledTextureAdaptDirty = !1);
  },
  _updateTitleLocation: function() {
    this._titleRenderer.setPosition(this._contentSize.width * 0.5, this._contentSize.height * 0.5);
  },
  setPressedActionEnabled: function(t) {
    this.pressedActionEnabled = t;
  },
  setTitleText: function(t) {
    if (t !== (this || window).getTitleText())
      if (this._titleRenderer.setString(t), this._ignoreSize) {
        var e = (this || window).getVirtualRendererSize();
        this.setContentSize(e);
      } else
        this._titleRenderer._renderCmd._updateTTF();
  },
  getTitleText: function() {
    return this._titleRenderer.getString();
  },
  setTitleColor: function(t) {
    this._titleRenderer.setFontFillColor(t);
  },
  getTitleColor: function() {
    return this._titleRenderer._getFillStyle();
  },
  setTitleFontSize: function(t) {
    this._titleRenderer.setFontSize(t), this._fontSize = t;
  },
  getTitleFontSize: function() {
    return this._titleRenderer.getFontSize();
  },
  setZoomScale: function(t) {
    this._zoomScale = t;
  },
  getZoomScale: function() {
    return this._zoomScale;
  },
  getNormalTextureSize: function() {
    return this._normalTextureSize;
  },
  setTitleFontName: function(t) {
    this._titleRenderer.setFontName(t), this._fontName = t;
  },
  getTitleRenderer: function() {
    return this._titleRenderer;
  },
  getTitleFontName: function() {
    return this._titleRenderer.getFontName();
  },
  _setTitleFont: function(t) {
    this._titleRenderer.font = t;
  },
  _getTitleFont: function() {
    return this._titleRenderer.font;
  },
  getDescription: function() {
    return "Button";
  },
  _createCloneInstance: function() {
    return new ccui.Button();
  },
  _copySpecialProperties: function(t) {
    this._prevIgnoreSize = t._prevIgnoreSize, this.setScale9Enabled(t._scale9Enabled), this.loadTextureNormal(t._normalFileName, t._normalTexType), this.loadTexturePressed(t._clickedFileName, t._pressedTexType), this.loadTextureDisabled(t._disabledFileName, t._disabledTexType), this.setCapInsetsNormalRenderer(t._capInsetsNormal), this.setCapInsetsPressedRenderer(t._capInsetsPressed), this.setCapInsetsDisabledRenderer(t._capInsetsDisabled), this.setTitleText(t.getTitleText()), this.setTitleFontName(t.getTitleFontName()), this.setTitleFontSize(t.getTitleFontSize()), this.setTitleColor(t.getTitleColor()), this.setPressedActionEnabled(t.pressedActionEnabled), this.setZoomScale(t._zoomScale);
  },
  _getNormalSize: function() {
    var t;
    this._titleRenderer !== null && (t = (this || window)._titleRenderer.getContentSize());
    var e;
    this._buttonNormalRenderer !== null && (e = (this || window)._buttonNormalRenderer.getContentSize());
    var n = t.width > e.width ? t.width : e.width, r = t.height > e.height ? t.height : e.height;
    return cc.size(n, r);
  }
});
var _p = ccui.Button.prototype;
_p.titleText;
cc.defineGetterSetter(_p, "titleText", _p.getTitleText, _p.setTitleText);
_p.titleFont;
cc.defineGetterSetter(_p, "titleFont", _p._getTitleFont, _p._setTitleFont);
_p.titleFontSize;
cc.defineGetterSetter(_p, "titleFontSize", _p.getTitleFontSize, _p.setTitleFontSize);
_p.titleFontName;
cc.defineGetterSetter(_p, "titleFontName", _p.getTitleFontName, _p.setTitleFontName);
_p.titleColor;
cc.defineGetterSetter(_p, "titleColor", _p.getTitleColor, _p.setTitleColor);
_p = null;
ccui.Button.create = function(t, e, n, r) {
  return new ccui.Button(t, e, n, r);
};
ccui.Button.NORMAL_RENDERER_ZORDER = -2;
ccui.Button.PRESSED_RENDERER_ZORDER = -2;
ccui.Button.DISABLED_RENDERER_ZORDER = -2;
ccui.Button.TITLE_RENDERER_ZORDER = -1;
ccui.Button.ZOOM_ACTION_TIME_STEP = 0.05;
ccui.Button.SYSTEM = 0;
ccui.Button.TTF = 1;
ccui.CheckBox = ccui.Widget.extend({
  _backGroundBoxRenderer: null,
  _backGroundSelectedBoxRenderer: null,
  _frontCrossRenderer: null,
  _backGroundBoxDisabledRenderer: null,
  _frontCrossDisabledRenderer: null,
  _isSelected: !0,
  _checkBoxEventListener: null,
  _checkBoxEventSelector: null,
  _backGroundTexType: ccui.Widget.LOCAL_TEXTURE,
  _backGroundSelectedTexType: ccui.Widget.LOCAL_TEXTURE,
  _frontCrossTexType: ccui.Widget.LOCAL_TEXTURE,
  _backGroundDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
  _frontCrossDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
  _backGroundFileName: "",
  _backGroundSelectedFileName: "",
  _frontCrossFileName: "",
  _backGroundDisabledFileName: "",
  _frontCrossDisabledFileName: "",
  _className: "CheckBox",
  _zoomScale: 0.1,
  _backgroundTextureScaleX: 0.1,
  _backgroundTextureScaleY: 0.1,
  _backGroundBoxRendererAdaptDirty: !0,
  _backGroundSelectedBoxRendererAdaptDirty: !0,
  _frontCrossRendererAdaptDirty: !0,
  _backGroundBoxDisabledRendererAdaptDirty: !0,
  _frontCrossDisabledRendererAdaptDirty: !0,
  ctor: function(t, e, n, r, s, o) {
    ccui.Widget.prototype.ctor.call(this), this.setTouchEnabled(!0);
    for (var a = 0, c = 0; c < arguments.length; c++) {
      var l = typeof arguments[c];
      l === "string" ? isNaN(arguments[c] - 0) ? a++ : (o = arguments[c], arguments[c] = void 0) : l === "number" && a++;
    }
    switch (a) {
      case 2:
        o = n, n = e, e = void 0;
    }
    o = o === void 0 ? 0 : o, this._isSelected = !0, this.setSelected(!1), this.loadTextures(t, e, n, r, s, o);
  },
  _initRenderer: function() {
    this._backGroundBoxRenderer = new cc.Sprite(), this._backGroundSelectedBoxRenderer = new cc.Sprite(), this._frontCrossRenderer = new cc.Sprite(), this._backGroundBoxDisabledRenderer = new cc.Sprite(), this._frontCrossDisabledRenderer = new cc.Sprite(), this.addProtectedChild(this._backGroundBoxRenderer, ccui.CheckBox.BOX_RENDERER_ZORDER, -1), this.addProtectedChild(this._backGroundSelectedBoxRenderer, ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER, -1), this.addProtectedChild(this._frontCrossRenderer, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER, -1), this.addProtectedChild(this._backGroundBoxDisabledRenderer, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER, -1), this.addProtectedChild(this._frontCrossDisabledRenderer, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER, -1);
  },
  loadTextures: function(t, e, n, r, s, o) {
    t && this.loadTextureBackGround(t, o), e && this.loadTextureBackGroundSelected(e, o), n && this.loadTextureFrontCross(n, o), r && this.loadTextureBackGroundDisabled(r, o), s && this.loadTextureFrontCrossDisabled(s, o);
  },
  loadTextureBackGround: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._backGroundFileName = t, this._backGroundTexType = e;
      var n = (this || window)._backGroundBoxRenderer;
      switch (n._textureLoaded ? this._backGroundBoxRenderer.setContentSize(this._customSize) : n.addEventListener("load", function() {
        this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize()), this.loadTextureBackGround(this._backGroundFileName, this._backGroundTexType);
      }, this), this._backGroundTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize()), this._backGroundBoxRendererAdaptDirty = !0, this._findLayout();
    }
  },
  loadTextureBackGroundSelected: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._backGroundSelectedFileName = t, this._backGroundSelectedTexType = e;
      var n = (this || window)._backGroundSelectedBoxRenderer;
      switch (n._textureLoaded || n.addEventListener("load", function() {
        this.loadTextureBackGroundSelected(this._backGroundSelectedFileName, this._backGroundSelectedTexType);
      }, this), this._backGroundSelectedTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._backGroundSelectedBoxRendererAdaptDirty = !0, this._findLayout();
    }
  },
  loadTextureFrontCross: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._frontCrossFileName = t, this._frontCrossTexType = e;
      var n = (this || window)._frontCrossRenderer;
      switch (n._textureLoaded || n.addEventListener("load", function() {
        this.loadTextureFrontCross(this._frontCrossFileName, this._frontCrossTexType);
      }, this), this._frontCrossTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._frontCrossRendererAdaptDirty = !0, this._findLayout();
    }
  },
  loadTextureBackGroundDisabled: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._backGroundDisabledFileName = t, this._backGroundDisabledTexType = e;
      var n = (this || window)._backGroundBoxDisabledRenderer;
      switch (n._textureLoaded || n.addEventListener("load", function() {
        this.loadTextureBackGroundDisabled(this._backGroundDisabledFileName, this._backGroundDisabledTexType);
      }, this), this._backGroundDisabledTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._backGroundBoxDisabledRendererAdaptDirty = !0, this._findLayout();
    }
  },
  loadTextureFrontCrossDisabled: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._frontCrossDisabledFileName = t, this._frontCrossDisabledTexType = e;
      var n = (this || window)._frontCrossDisabledRenderer;
      switch (n._textureLoaded || n.addEventListener("load", function() {
        this.loadTextureFrontCrossDisabled(this._frontCrossDisabledFileName, this._frontCrossDisabledTexType);
      }, this), this._frontCrossDisabledTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._frontCrossDisabledRendererAdaptDirty = !0, this._findLayout();
    }
  },
  _onPressStateChangedToNormal: function() {
    this._backGroundBoxRenderer.setVisible(!0), this._backGroundSelectedBoxRenderer.setVisible(!1), this._backGroundBoxDisabledRenderer.setVisible(!1), this._frontCrossDisabledRenderer.setVisible(!1), this._backGroundBoxRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY), this._frontCrossRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY), this._isSelected && (this._frontCrossRenderer.setVisible(!0), this._frontCrossRendererAdaptDirty = !0);
  },
  _onPressStateChangedToPressed: function() {
    this._backGroundSelectedFileName ? (this._backGroundBoxRenderer.setVisible(!1), this._backGroundSelectedBoxRenderer.setVisible(!0), this._backGroundBoxDisabledRenderer.setVisible(!1), this._frontCrossDisabledRenderer.setVisible(!1)) : (this._backGroundBoxRenderer.setScale(this._backgroundTextureScaleX + this._zoomScale, this._backgroundTextureScaleY + this._zoomScale), this._frontCrossRenderer.setScale(this._backgroundTextureScaleX + this._zoomScale, this._backgroundTextureScaleY + this._zoomScale));
  },
  _onPressStateChangedToDisabled: function() {
    this._backGroundDisabledFileName && this._frontCrossDisabledFileName && (this._backGroundBoxRenderer.setVisible(!1), this._backGroundBoxDisabledRenderer.setVisible(!0)), this._backGroundSelectedBoxRenderer.setVisible(!1), this._frontCrossRenderer.setVisible(!1), this._backGroundBoxRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY), this._frontCrossRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY), this._isSelected && (this._frontCrossDisabledRenderer.setVisible(!0), this._frontCrossDisabledRendererAdaptDirty = !0);
  },
  setZoomScale: function(t) {
    this._zoomScale = t;
  },
  getZoomScale: function() {
    return this._zoomScale;
  },
  setSelectedState: function(t) {
    this.setSelected(t);
  },
  setSelected: function(t) {
    t !== (this || window)._isSelected && (this._isSelected = t, this._frontCrossRenderer.setVisible(this._isSelected));
  },
  getSelectedState: function() {
    return this.isSelected();
  },
  isSelected: function() {
    return this._isSelected;
  },
  _selectedEvent: function() {
    this._checkBoxEventSelector && (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_SELECTED) : this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_SELECTED));
  },
  _unSelectedEvent: function() {
    this._checkBoxEventSelector && (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_UNSELECTED) : this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_UNSELECTED));
  },
  _releaseUpEvent: function() {
    ccui.Widget.prototype._releaseUpEvent.call(this), this._isSelected ? (this.setSelected(!1), this._unSelectedEvent()) : (this.setSelected(!0), this._selectedEvent());
  },
  addEventListenerCheckBox: function(t, e) {
    this.addEventListener(t, e);
  },
  addEventListener: function(t, e) {
    this._checkBoxEventSelector = t, this._checkBoxEventListener = e;
  },
  getVirtualRendererSize: function() {
    return this._backGroundBoxRenderer.getContentSize();
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this), this._backGroundBoxRendererAdaptDirty = !0, this._backGroundSelectedBoxRendererAdaptDirty = !0, this._frontCrossRendererAdaptDirty = !0, this._backGroundBoxDisabledRendererAdaptDirty = !0, this._frontCrossDisabledRendererAdaptDirty = !0;
  },
  getVirtualRenderer: function() {
    return this._backGroundBoxRenderer;
  },
  _backGroundTextureScaleChangedWithSize: function() {
    var t = (this || window)._backGroundBoxRenderer, e = (this || window)._contentSize;
    if (this._ignoreSize)
      t.setScale(1), this._backgroundTextureScaleX = (this || window)._backgroundTextureScaleY = 1;
    else {
      var n = t.getContentSize();
      if (n.width <= 0 || n.height <= 0) {
        t.setScale(1), this._backgroundTextureScaleX = (this || window)._backgroundTextureScaleY = 1;
        return;
      }
      var r = e.width / n.width, s = e.height / n.height;
      this._backgroundTextureScaleX = r, this._backgroundTextureScaleY = s, t.setScaleX(r), t.setScaleY(s);
    }
    t.setPosition(e.width * 0.5, e.height * 0.5);
  },
  _backGroundSelectedTextureScaleChangedWithSize: function() {
    var t = (this || window)._backGroundSelectedBoxRenderer, e = (this || window)._contentSize;
    if (this._ignoreSize)
      t.setScale(1);
    else {
      var n = t.getContentSize();
      if (n.width <= 0 || n.height <= 0) {
        t.setScale(1);
        return;
      }
      var r = e.width / n.width, s = e.height / n.height;
      t.setScaleX(r), t.setScaleY(s);
    }
    t.setPosition(e.width * 0.5, e.height * 0.5);
  },
  _frontCrossTextureScaleChangedWithSize: function() {
    var t = (this || window)._frontCrossRenderer, e = (this || window)._contentSize;
    if (this._ignoreSize)
      t.setScale(1);
    else {
      var n = t.getContentSize();
      if (n.width <= 0 || n.height <= 0) {
        t.setScale(1);
        return;
      }
      var r = e.width / n.width, s = e.height / n.height;
      t.setScaleX(r), t.setScaleY(s);
    }
    t.setPosition(e.width * 0.5, e.height * 0.5);
  },
  _backGroundDisabledTextureScaleChangedWithSize: function() {
    var t = (this || window)._backGroundBoxDisabledRenderer, e = (this || window)._contentSize;
    if (this._ignoreSize)
      t.setScale(1);
    else {
      var n = t.getContentSize();
      if (n.width <= 0 || n.height <= 0) {
        t.setScale(1);
        return;
      }
      var r = e.width / n.width, s = e.height / n.height;
      t.setScaleX(r), t.setScaleY(s);
    }
    t.setPosition(e.width * 0.5, e.height * 0.5);
  },
  _frontCrossDisabledTextureScaleChangedWithSize: function() {
    var t = (this || window)._frontCrossDisabledRenderer, e = (this || window)._contentSize;
    if (this._ignoreSize)
      t.setScale(1);
    else {
      var n = t.getContentSize();
      if (n.width <= 0 || n.height <= 0) {
        t.setScale(1);
        return;
      }
      var r = e.width / n.width, s = e.height / n.height;
      t.setScaleX(r), t.setScaleY(s);
    }
    t.setPosition(e.width * 0.5, e.height * 0.5);
  },
  getDescription: function() {
    return "CheckBox";
  },
  _createCloneInstance: function() {
    return new ccui.CheckBox();
  },
  _copySpecialProperties: function(t) {
    t instanceof ccui.CheckBox && (this.loadTextureBackGround(t._backGroundFileName, t._backGroundTexType), this.loadTextureBackGroundSelected(t._backGroundSelectedFileName, t._backGroundSelectedTexType), this.loadTextureFrontCross(t._frontCrossFileName, t._frontCrossTexType), this.loadTextureBackGroundDisabled(t._backGroundDisabledFileName, t._backGroundDisabledTexType), this.loadTextureFrontCrossDisabled(t._frontCrossDisabledFileName, t._frontCrossDisabledTexType), this.setSelected(t._isSelected), this._checkBoxEventListener = t._checkBoxEventListener, this._checkBoxEventSelector = t._checkBoxEventSelector, this._ccEventCallback = t._ccEventCallback, this._zoomScale = t._zoomScale, this._backgroundTextureScaleX = t._backgroundTextureScaleX, this._backgroundTextureScaleY = t._backgroundTextureScaleY);
  },
  _adaptRenderers: function() {
    this._backGroundBoxRendererAdaptDirty && (this._backGroundTextureScaleChangedWithSize(), this._backGroundBoxRendererAdaptDirty = !1), this._backGroundSelectedBoxRendererAdaptDirty && (this._backGroundSelectedTextureScaleChangedWithSize(), this._backGroundSelectedBoxRendererAdaptDirty = !1), this._frontCrossRendererAdaptDirty && (this._frontCrossTextureScaleChangedWithSize(), this._frontCrossRendererAdaptDirty = !1), this._backGroundBoxDisabledRendererAdaptDirty && (this._backGroundDisabledTextureScaleChangedWithSize(), this._backGroundBoxDisabledRendererAdaptDirty = !1), this._frontCrossDisabledRendererAdaptDirty && (this._frontCrossDisabledTextureScaleChangedWithSize(), this._frontCrossDisabledRendererAdaptDirty = !1);
  }
});
var _p = ccui.CheckBox.prototype;
_p.selected;
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
_p = null;
ccui.CheckBox.create = function(t, e, n, r, s, o) {
  return new ccui.CheckBox(t, e, n, r, s, o);
};
ccui.CheckBox.EVENT_SELECTED = 0;
ccui.CheckBox.EVENT_UNSELECTED = 1;
ccui.CheckBox.BOX_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER = -1;
ccui.ImageView = ccui.Widget.extend({
  _scale9Enabled: !1,
  _prevIgnoreSize: !0,
  _capInsets: null,
  _imageRenderer: null,
  _textureFile: "",
  _imageTexType: ccui.Widget.LOCAL_TEXTURE,
  _imageTextureSize: null,
  _className: "ImageView",
  _imageRendererAdaptDirty: !0,
  ctor: function(t, e) {
    this._capInsets = cc.rect(0, 0, 0, 0), this._imageTextureSize = cc.size(this._capInsets.width, this._capInsets.height), ccui.Widget.prototype.ctor.call(this), e = e === void 0 ? 0 : e, t ? this.loadTexture(t, e) : this._imageTexType = ccui.Widget.LOCAL_TEXTURE;
  },
  _initRenderer: function() {
    this._imageRenderer = new cc.Sprite(), this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1);
  },
  loadTexture: function(t, e) {
    if (t) {
      var n = (this || window);
      e = e || ccui.Widget.LOCAL_TEXTURE, this._textureFile = t, this._imageTexType = e;
      var r = n._imageRenderer;
      switch (r._textureLoaded || r.addEventListener("load", function() {
        n.loadTexture(n._textureFile, n._imageTexType);
      }), n._imageTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n._scale9Enabled ? (r.initWithFile(t), r.setCapInsets(n._capInsets)) : r.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n._scale9Enabled ? (r.initWithSpriteFrameName(t), r.setCapInsets(n._capInsets)) : r.initWithSpriteFrameName(t);
          break;
      }
      n._imageTextureSize = r.getContentSize(), this._updateChildrenDisplayedRGBA(), n._updateContentSizeWithTextureSize(n._imageTextureSize), n._imageRendererAdaptDirty = !0, n._findLayout();
    }
  },
  setTextureRect: function(t) {
    this._scale9Enabled || this._imageRenderer.setTextureRect(t);
  },
  setScale9Enabled: function(t) {
    if (this._scale9Enabled !== t) {
      if (this._scale9Enabled = t, this.removeProtectedChild(this._imageRenderer), this._imageRenderer = null, this._scale9Enabled ? this._imageRenderer = new ccui.Scale9Sprite() : this._imageRenderer = new cc.Sprite(), this.loadTexture(this._textureFile, this._imageTexType), this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1), this._scale9Enabled) {
        var e = (this || window)._ignoreSize;
        this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = e;
      } else
        this.ignoreContentAdaptWithSize(this._prevIgnoreSize);
      this.setCapInsets(this._capInsets), this._imageRendererAdaptDirty = !0;
    }
  },
  isScale9Enabled: function() {
    return this._scale9Enabled;
  },
  ignoreContentAdaptWithSize: function(t) {
    (!this._scale9Enabled || this._scale9Enabled && !t) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, t), this._prevIgnoreSize = t);
  },
  setCapInsets: function(t) {
    if (t) {
      var e = (this || window)._capInsets;
      e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, this._scale9Enabled && this._imageRenderer.setCapInsets(t);
    }
  },
  getCapInsets: function() {
    return cc.rect(this._capInsets);
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this), this._imageRendererAdaptDirty = !0;
  },
  _adaptRenderers: function() {
    this._imageRendererAdaptDirty && (this._imageTextureScaleChangedWithSize(), this._imageRendererAdaptDirty = !1);
  },
  getVirtualRendererSize: function() {
    return cc.size(this._imageTextureSize);
  },
  getVirtualRenderer: function() {
    return this._imageRenderer;
  },
  _imageTextureScaleChangedWithSize: function() {
    if (this._ignoreSize)
      this._scale9Enabled || this._imageRenderer.setScale(1);
    else if (this._scale9Enabled)
      this._imageRenderer.setPreferredSize(this._contentSize), this._imageRenderer.setScale(1);
    else {
      var t = (this || window)._imageTextureSize;
      if (t.width <= 0 || t.height <= 0) {
        this._imageRenderer.setScale(1);
        return;
      }
      this._imageRenderer.setScaleX(this._contentSize.width / t.width), this._imageRenderer.setScaleY(this._contentSize.height / t.height);
    }
    this._imageRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
  },
  getDescription: function() {
    return "ImageView";
  },
  _createCloneInstance: function() {
    return new ccui.ImageView();
  },
  _copySpecialProperties: function(t) {
    t instanceof ccui.ImageView && (this._prevIgnoreSize = t._prevIgnoreSize, this.setScale9Enabled(t._scale9Enabled), this.loadTexture(t._textureFile, t._imageTexType), this.setCapInsets(t._capInsets));
  },
  setContentSize: function(t, e) {
    if (e != null && (t = cc.size(t, e)), ccui.Widget.prototype.setContentSize.call(this, t), this._scale9Enabled)
      this._imageRenderer.setContentSize(t);
    else {
      var n = (this || window)._imageRenderer.getContentSize();
      this._imageRenderer.setScaleX(t.width / n.width), this._imageRenderer.setScaleY(t.height / n.height);
    }
  }
});
ccui.ImageView.create = function(t, e) {
  return new ccui.ImageView(t, e);
};
ccui.ImageView.RENDERER_ZORDER = -1;
ccui.LoadingBar = ccui.Widget.extend({
  _direction: null,
  _percent: 100,
  _totalLength: 0,
  _barRenderer: null,
  _renderBarTexType: ccui.Widget.LOCAL_TEXTURE,
  _barRendererTextureSize: null,
  _scale9Enabled: !1,
  _prevIgnoreSize: !0,
  _capInsets: null,
  _textureFile: "",
  _isTextureLoaded: !1,
  _className: "LoadingBar",
  _barRendererAdaptDirty: !0,
  ctor: function(t, e) {
    this._direction = ccui.LoadingBar.TYPE_LEFT, this._barRendererTextureSize = cc.size(0, 0), this._capInsets = cc.rect(0, 0, 0, 0), ccui.Widget.prototype.ctor.call(this), t !== void 0 && this.loadTexture(t), e !== void 0 && this.setPercent(e);
  },
  _initRenderer: function() {
    this._barRenderer = new cc.Sprite(), this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._barRenderer.setAnchorPoint(0, 0.5);
  },
  setDirection: function(t) {
    if (this._direction !== t)
      switch (this._direction = t, this._direction) {
        case ccui.LoadingBar.TYPE_LEFT:
          this._barRenderer.setAnchorPoint(0, 0.5), this._barRenderer.setPosition(0, this._contentSize.height * 0.5), this._scale9Enabled || this._barRenderer.setFlippedX(!1);
          break;
        case ccui.LoadingBar.TYPE_RIGHT:
          this._barRenderer.setAnchorPoint(1, 0.5), this._barRenderer.setPosition(this._totalLength, this._contentSize.height * 0.5), this._scale9Enabled || this._barRenderer.setFlippedX(!0);
          break;
      }
  },
  getDirection: function() {
    return this._direction;
  },
  loadTexture: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._renderBarTexType = e, this._textureFile = t;
      var n = (this || window)._barRenderer, r = (this || window);
      switch (n._textureLoaded || n.addEventListener("load", function() {
        r.loadTexture(r._textureFile, r._renderBarTexType), r._setPercent(r._percent);
      }), this._renderBarTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n.initWithSpriteFrameName(t);
          break;
      }
      var s = n.getContentSize();
      switch (this._barRendererTextureSize.width = s.width, this._barRendererTextureSize.height = s.height, this._direction) {
        case ccui.LoadingBar.TYPE_LEFT:
          n.setAnchorPoint(0, 0.5), this._scale9Enabled || n.setFlippedX(!1);
          break;
        case ccui.LoadingBar.TYPE_RIGHT:
          n.setAnchorPoint(1, 0.5), this._scale9Enabled || n.setFlippedX(!0);
          break;
      }
      this._scale9Enabled && n.setCapInsets(this._capInsets), this._updateChildrenDisplayedRGBA(), this._barRendererScaleChangedWithSize(), this._updateContentSizeWithTextureSize(this._barRendererTextureSize), this._barRendererAdaptDirty = !0, this._findLayout();
    }
  },
  setScale9Enabled: function(t) {
    if (this._scale9Enabled !== t) {
      if (this._scale9Enabled = t, this.removeProtectedChild(this._barRenderer), this._barRenderer = (this || window)._scale9Enabled ? new ccui.Scale9Sprite() : new cc.Sprite(), this.loadTexture(this._textureFile, this._renderBarTexType), this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._scale9Enabled) {
        var e = (this || window)._ignoreSize;
        this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = e;
      } else
        this.ignoreContentAdaptWithSize(this._prevIgnoreSize);
      this.setCapInsets(this._capInsets), this.setPercent(this._percent), this._barRendererAdaptDirty = !0;
    }
  },
  isScale9Enabled: function() {
    return this._scale9Enabled;
  },
  setCapInsets: function(t) {
    if (t) {
      var e = (this || window)._capInsets;
      e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, this._scale9Enabled && this._barRenderer.setCapInsets(t);
    }
  },
  getCapInsets: function() {
    return cc.rect(this._capInsets);
  },
  setPercent: function(t) {
    t > 100 && (t = 100), t < 0 && (t = 0), t !== (this || window)._percent && (this._percent = t, this._setPercent(t));
  },
  _setPercent: function() {
    var t, e, n, r;
    this._totalLength <= 0 || (t = (this || window)._percent / 100, this._scale9Enabled ? this._setScale9Scale() : (n = (this || window)._barRenderer, r = (this || window)._barRendererTextureSize, e = n.getTextureRect(), e.width = r.width * t, n.setTextureRect(
      cc.rect(
        e.x,
        e.y,
        r.width * t,
        r.height
      ),
      n._rectRotated
    )));
  },
  setContentSize: function(t, e) {
    ccui.Widget.prototype.setContentSize.call(this, t, e), this._totalLength = e === void 0 ? t.width : t;
  },
  getPercent: function() {
    return this._percent;
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this), this._barRendererAdaptDirty = !0;
  },
  _adaptRenderers: function() {
    this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1);
  },
  ignoreContentAdaptWithSize: function(t) {
    (!this._scale9Enabled || this._scale9Enabled && !t) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, t), this._prevIgnoreSize = t);
  },
  getVirtualRendererSize: function() {
    return cc.size(this._barRendererTextureSize);
  },
  getVirtualRenderer: function() {
    return this._barRenderer;
  },
  _barRendererScaleChangedWithSize: function() {
    var t = (this || window)._barRenderer, e = (this || window)._contentSize;
    if (this._unifySize)
      this._totalLength = (this || window)._contentSize.width, this.setPercent(this._percent);
    else if (this._ignoreSize)
      this._scale9Enabled || (this._totalLength = (this || window)._barRendererTextureSize.width, t.setScale(1));
    else if (this._totalLength = e.width, this._scale9Enabled)
      this._setScale9Scale(), t.setScale(1);
    else {
      var n = (this || window)._barRendererTextureSize;
      if (n.width <= 0 || n.height <= 0) {
        t.setScale(1);
        return;
      }
      var r = e.width / n.width, s = e.height / n.height;
      t.setScaleX(r), t.setScaleY(s);
    }
    switch (this._direction) {
      case ccui.LoadingBar.TYPE_LEFT:
        t.setPosition(0, e.height * 0.5);
        break;
      case ccui.LoadingBar.TYPE_RIGHT:
        t.setPosition(this._totalLength, e.height * 0.5);
        break;
    }
  },
  _setScale9Scale: function() {
    var t = (this || window)._percent / 100 * this._totalLength;
    this._barRenderer.setPreferredSize(cc.size(t, this._contentSize.height));
  },
  getDescription: function() {
    return "LoadingBar";
  },
  _createCloneInstance: function() {
    return new ccui.LoadingBar();
  },
  _copySpecialProperties: function(t) {
    t instanceof ccui.LoadingBar && (this._prevIgnoreSize = t._prevIgnoreSize, this.setScale9Enabled(t._scale9Enabled), this.loadTexture(t._textureFile, t._renderBarTexType), this.setCapInsets(t._capInsets), this.setPercent(t._percent), this.setDirection(t._direction));
  }
});
var _p = ccui.LoadingBar.prototype;
_p.direction;
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
_p.percent;
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.LoadingBar.create = function(t, e) {
  return new ccui.LoadingBar(t, e);
};
ccui.LoadingBar.TYPE_LEFT = 0;
ccui.LoadingBar.TYPE_RIGHT = 1;
ccui.LoadingBar.RENDERER_ZORDER = -1;
ccui.Slider = ccui.Widget.extend({
  _barRenderer: null,
  _progressBarRenderer: null,
  _barTextureSize: null,
  _progressBarTextureSize: null,
  _slidBallNormalRenderer: null,
  _slidBallPressedRenderer: null,
  _slidBallDisabledRenderer: null,
  _slidBallRenderer: null,
  _barLength: 0,
  _percent: 0,
  _scale9Enabled: !1,
  _prevIgnoreSize: !0,
  _textureFile: "",
  _progressBarTextureFile: "",
  _slidBallNormalTextureFile: "",
  _slidBallPressedTextureFile: "",
  _slidBallDisabledTextureFile: "",
  _capInsetsBarRenderer: null,
  _capInsetsProgressBarRenderer: null,
  _sliderEventListener: null,
  _sliderEventSelector: null,
  _barTexType: ccui.Widget.LOCAL_TEXTURE,
  _progressBarTexType: ccui.Widget.LOCAL_TEXTURE,
  _ballNTexType: ccui.Widget.LOCAL_TEXTURE,
  _ballPTexType: ccui.Widget.LOCAL_TEXTURE,
  _ballDTexType: ccui.Widget.LOCAL_TEXTURE,
  _isTextureLoaded: !1,
  _className: "Slider",
  _barRendererAdaptDirty: !0,
  _progressBarRendererDirty: !0,
  _unifySize: !1,
  _zoomScale: 0.1,
  _sliderBallNormalTextureScaleX: 1,
  _sliderBallNormalTextureScaleY: 1,
  ctor: function(t, e, n) {
    this._barTextureSize = cc.size(0, 0), this._progressBarTextureSize = cc.size(0, 0), this._capInsetsBarRenderer = cc.rect(0, 0, 0, 0), this._capInsetsProgressBarRenderer = cc.rect(0, 0, 0, 0), ccui.Widget.prototype.ctor.call(this), n = n || 0, this.setTouchEnabled(!0), t && this.loadBarTexture(t, n), e && this.loadSlidBallTextures(e, n);
  },
  _initRenderer: function() {
    this._barRenderer = new cc.Sprite(), this._progressBarRenderer = new cc.Sprite(), this._progressBarRenderer.setAnchorPoint(0, 0.5), this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._slidBallNormalRenderer = new cc.Sprite(), this._slidBallPressedRenderer = new cc.Sprite(), this._slidBallPressedRenderer.setVisible(!1), this._slidBallDisabledRenderer = new cc.Sprite(), this._slidBallDisabledRenderer.setVisible(!1), this._slidBallRenderer = new cc.Node(), this._slidBallRenderer.addChild(this._slidBallNormalRenderer), this._slidBallRenderer.addChild(this._slidBallPressedRenderer), this._slidBallRenderer.addChild(this._slidBallDisabledRenderer), this._slidBallRenderer.setCascadeColorEnabled(!0), this._slidBallRenderer.setCascadeOpacityEnabled(!0), this.addProtectedChild(this._slidBallRenderer, ccui.Slider.BALL_RENDERER_ZORDER, -1);
  },
  loadBarTexture: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._textureFile = t, this._barTexType = e;
      var n = (this || window)._barRenderer, r = (this || window);
      switch (n._textureLoaded || n.addEventListener("load", function() {
        r.loadBarTexture(r._textureFile, r._barTexType);
      }), this._barTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._barRendererAdaptDirty = !0, this._progressBarRendererDirty = !0, this._updateContentSizeWithTextureSize(this._barRenderer.getContentSize()), this._findLayout(), this._barTextureSize = (this || window)._barRenderer.getContentSize();
    }
  },
  loadProgressBarTexture: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._progressBarTextureFile = t, this._progressBarTexType = e;
      var n = (this || window)._progressBarRenderer, r = (this || window);
      switch (n._textureLoaded || n.addEventListener("load", function() {
        r.loadProgressBarTexture(r._progressBarTextureFile, r._progressBarTexType);
      }), this._progressBarTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          n.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          n.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._progressBarRenderer.setAnchorPoint(cc.p(0, 0.5));
      var s = (this || window)._progressBarRenderer.getContentSize();
      this._progressBarTextureSize = { width: s.width, height: s.height }, this._progressBarRendererDirty = !0, this._findLayout();
    }
  },
  setScale9Enabled: function(t) {
    if (this._scale9Enabled !== t) {
      if (this._scale9Enabled = t, this.removeProtectedChild(this._barRenderer, !0), this.removeProtectedChild(this._progressBarRenderer, !0), this._barRenderer = null, this._progressBarRenderer = null, this._scale9Enabled ? (this._barRenderer = new ccui.Scale9Sprite(), this._progressBarRenderer = new ccui.Scale9Sprite()) : (this._barRenderer = new cc.Sprite(), this._progressBarRenderer = new cc.Sprite()), this.loadBarTexture(this._textureFile, this._barTexType), this.loadProgressBarTexture(this._progressBarTextureFile, this._progressBarTexType), this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._scale9Enabled) {
        var e = (this || window)._ignoreSize;
        this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = e;
      } else
        this.ignoreContentAdaptWithSize(this._prevIgnoreSize);
      this.setCapInsetsBarRenderer(this._capInsetsBarRenderer), this.setCapInsetProgressBarRenderer(this._capInsetsProgressBarRenderer), this._barRendererAdaptDirty = !0, this._progressBarRendererDirty = !0;
    }
  },
  isScale9Enabled: function() {
    return this._scale9Enabled;
  },
  ignoreContentAdaptWithSize: function(t) {
    (!this._scale9Enabled || this._scale9Enabled && !t) && (ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, t), this._prevIgnoreSize = t);
  },
  setCapInsets: function(t) {
    this.setCapInsetsBarRenderer(t), this.setCapInsetProgressBarRenderer(t);
  },
  setCapInsetsBarRenderer: function(t) {
    if (t) {
      var e = (this || window)._capInsetsBarRenderer;
      e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, this._scale9Enabled && this._barRenderer.setCapInsets(t);
    }
  },
  getCapInsetsBarRenderer: function() {
    return cc.rect(this._capInsetsBarRenderer);
  },
  setCapInsetProgressBarRenderer: function(t) {
    if (t) {
      var e = (this || window)._capInsetsProgressBarRenderer;
      e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, this._scale9Enabled && this._progressBarRenderer.setCapInsets(t);
    }
  },
  getCapInsetsProgressBarRenderer: function() {
    return cc.rect(this._capInsetsProgressBarRenderer);
  },
  loadSlidBallTextures: function(t, e, n, r) {
    this.loadSlidBallTextureNormal(t, r), this.loadSlidBallTexturePressed(e, r), this.loadSlidBallTextureDisabled(n, r);
  },
  loadSlidBallTextureNormal: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._slidBallNormalTextureFile = t, this._ballNTexType = e;
      var n = (this || window);
      switch (this._slidBallNormalRenderer._textureLoaded || this._slidBallNormalRenderer.addEventListener("load", function() {
        n.loadSlidBallTextureNormal(n._slidBallNormalTextureFile, n._ballNTexType);
      }), this._ballNTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          this._slidBallNormalRenderer.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          this._slidBallNormalRenderer.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._findLayout();
    }
  },
  loadSlidBallTexturePressed: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._slidBallPressedTextureFile = t, this._ballPTexType = e;
      var n = (this || window);
      switch (this._slidBallPressedRenderer._textureLoaded || this._slidBallPressedRenderer.addEventListener("load", function() {
        n.loadSlidBallTexturePressed(n._slidBallPressedTextureFile, n._ballPTexType);
      }), this._ballPTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          this._slidBallPressedRenderer.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          this._slidBallPressedRenderer.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._findLayout();
    }
  },
  loadSlidBallTextureDisabled: function(t, e) {
    if (t) {
      e = e || ccui.Widget.LOCAL_TEXTURE, this._slidBallDisabledTextureFile = t, this._ballDTexType = e;
      var n = (this || window);
      switch (this._slidBallDisabledRenderer._textureLoaded || this._slidBallDisabledRenderer.addEventListener("load", function() {
        n.loadSlidBallTextureDisabled(n._slidBallDisabledTextureFile, n._ballDTexType);
      }), this._ballDTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          this._slidBallDisabledRenderer.initWithFile(t);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          this._slidBallDisabledRenderer.initWithSpriteFrameName(t);
          break;
      }
      this._updateChildrenDisplayedRGBA(), this._findLayout();
    }
  },
  setPercent: function(t) {
    t > 100 && (t = 100), t < 0 && (t = 0), this._percent = t;
    var e = t / 100, n = (this || window)._barLength * e;
    if (this._slidBallRenderer.setPosition(n, this._contentSize.height / 2), this._scale9Enabled)
      this._progressBarRenderer.setPreferredSize(cc.size(n, this._contentSize.height));
    else {
      var r = (this || window)._progressBarRenderer, s = r.getTextureRect();
      r.setTextureRect(
        cc.rect(s.x, s.y, n / r._scaleX, s.height),
        r.isTextureRectRotated()
      );
    }
  },
  hitTest: function(t) {
    var e = (this || window)._slidBallNormalRenderer.convertToNodeSpace(t), n = (this || window)._slidBallNormalRenderer.getContentSize(), r = cc.rect(0, 0, n.width, n.height);
    return e.x >= r.x && e.x <= r.x + r.width && e.y >= r.y && e.y <= r.y + r.height;
  },
  onTouchBegan: function(t, e) {
    var n = ccui.Widget.prototype.onTouchBegan.call(this, t, e);
    if (this._hit) {
      var r = (this || window).convertToNodeSpace(this._touchBeganPosition);
      this.setPercent(this._getPercentWithBallPos(r.x)), this._percentChangedEvent();
    }
    return n;
  },
  onTouchMoved: function(t, e) {
    var n = t.getLocation(), r = (this || window).convertToNodeSpace(n);
    this.setPercent(this._getPercentWithBallPos(r.x)), this._percentChangedEvent();
  },
  onTouchEnded: function(t, e) {
    ccui.Widget.prototype.onTouchEnded.call(this, t, e);
  },
  onTouchCancelled: function(t, e) {
    ccui.Widget.prototype.onTouchCancelled.call(this, t, e);
  },
  _getPercentWithBallPos: function(t) {
    return t / this._barLength * 100;
  },
  addEventListenerSlider: function(t, e) {
    this.addEventListener(t, e);
  },
  addEventListener: function(t, e) {
    this._sliderEventSelector = t, this._sliderEventListener = e;
  },
  _percentChangedEvent: function() {
    this._sliderEventSelector && (this._sliderEventListener ? this._sliderEventSelector.call(this._sliderEventListener, this, ccui.Slider.EVENT_PERCENT_CHANGED) : this._sliderEventSelector(this, ccui.Slider.EVENT_PERCENT_CHANGED)), this._ccEventCallback && this._ccEventCallback(this, ccui.Slider.EVENT_PERCENT_CHANGED);
  },
  getPercent: function() {
    return this._percent;
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this), this._barRendererAdaptDirty = !0, this._progressBarRendererDirty = !0;
  },
  _adaptRenderers: function() {
    this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1), this._progressBarRendererDirty && (this._progressBarRendererScaleChangedWithSize(), this._progressBarRendererDirty = !1);
  },
  getVirtualRendererSize: function() {
    return this._barRenderer.getContentSize();
  },
  getVirtualRenderer: function() {
    return this._barRenderer;
  },
  _barRendererScaleChangedWithSize: function() {
    if (this._unifySize)
      this._barLength = (this || window)._contentSize.width, this._barRenderer.setPreferredSize(this._contentSize);
    else if (this._ignoreSize)
      this._barRenderer.setScale(1), this._barLength = (this || window)._contentSize.width;
    else if (this._barLength = (this || window)._contentSize.width, this._scale9Enabled)
      this._barRenderer.setPreferredSize(this._contentSize), this._barRenderer.setScale(1);
    else {
      var t = (this || window)._barTextureSize;
      if (t.width <= 0 || t.height <= 0)
        this._barRenderer.setScale(1);
      else {
        var e = (this || window)._contentSize.width / t.width, n = (this || window)._contentSize.height / t.height;
        this._barRenderer.setScaleX(e), this._barRenderer.setScaleY(n);
      }
    }
    this._barRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2), this.setPercent(this._percent);
  },
  _progressBarRendererScaleChangedWithSize: function() {
    if (this._unifySize)
      this._progressBarRenderer.setPreferredSize(this._contentSize);
    else if (this._ignoreSize) {
      if (!this._scale9Enabled) {
        var t = (this || window)._progressBarTextureSize, e = (this || window)._contentSize.width / t.width, n = (this || window)._contentSize.height / t.height;
        this._progressBarRenderer.setScaleX(e), this._progressBarRenderer.setScaleY(n);
      }
    } else if (this._scale9Enabled)
      this._progressBarRenderer.setPreferredSize(this._contentSize), this._progressBarRenderer.setScale(1);
    else {
      var t = (this || window)._progressBarTextureSize;
      if (t.width <= 0 || t.height <= 0) {
        this._progressBarRenderer.setScale(1);
        return;
      }
      var e = (this || window)._contentSize.width / t.width, n = (this || window)._contentSize.height / t.height;
      this._progressBarRenderer.setScaleX(e), this._progressBarRenderer.setScaleY(n);
    }
    this._progressBarRenderer.setPosition(0, this._contentSize.height / 2), this.setPercent(this._percent);
  },
  _onPressStateChangedToNormal: function() {
    this._slidBallNormalRenderer.setVisible(!0), this._slidBallPressedRenderer.setVisible(!1), this._slidBallDisabledRenderer.setVisible(!1), this._slidBallNormalRenderer.setScale(this._sliderBallNormalTextureScaleX, this._sliderBallNormalTextureScaleY);
  },
  _onPressStateChangedToPressed: function() {
    this._slidBallPressedTextureFile ? (this._slidBallNormalRenderer.setVisible(!1), this._slidBallPressedRenderer.setVisible(!0), this._slidBallDisabledRenderer.setVisible(!1)) : this._slidBallNormalRenderer.setScale(this._sliderBallNormalTextureScaleX + this._zoomScale, this._sliderBallNormalTextureScaleY + this._zoomScale);
  },
  _onPressStateChangedToDisabled: function() {
    this._slidBallDisabledTextureFile && (this._slidBallNormalRenderer.setVisible(!1), this._slidBallDisabledRenderer.setVisible(!0)), this._slidBallNormalRenderer.setScale(this._sliderBallNormalTextureScaleX, this._sliderBallNormalTextureScaleY), this._slidBallPressedRenderer.setVisible(!1);
  },
  setZoomScale: function(t) {
    this._zoomScale = t;
  },
  getZoomScale: function() {
    return this._zoomScale;
  },
  getDescription: function() {
    return "Slider";
  },
  _createCloneInstance: function() {
    return new ccui.Slider();
  },
  _copySpecialProperties: function(t) {
    this._prevIgnoreSize = t._prevIgnoreSize, this.setScale9Enabled(t._scale9Enabled), this.loadBarTexture(t._textureFile, t._barTexType), this.loadProgressBarTexture(t._progressBarTextureFile, t._progressBarTexType), this.loadSlidBallTextureNormal(t._slidBallNormalTextureFile, t._ballNTexType), this.loadSlidBallTexturePressed(t._slidBallPressedTextureFile, t._ballPTexType), this.loadSlidBallTextureDisabled(t._slidBallDisabledTextureFile, t._ballDTexType), this.setPercent(t.getPercent()), this._sliderEventListener = t._sliderEventListener, this._sliderEventSelector = t._sliderEventSelector, this._zoomScale = t._zoomScale, this._ccEventCallback = t._ccEventCallback;
  }
});
var _p = ccui.Slider.prototype;
_p.percent;
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.Slider.create = function(t, e, n) {
  return new ccui.Slider(t, e, n);
};
ccui.Slider.EVENT_PERCENT_CHANGED = 0;
ccui.Slider.BASEBAR_RENDERER_ZORDER = -3;
ccui.Slider.PROGRESSBAR_RENDERER_ZORDER = -2;
ccui.Slider.BALL_RENDERER_ZORDER = -1;
ccui.Text = ccui.Widget.extend({
  _touchScaleChangeEnabled: !1,
  _normalScaleValueX: 1,
  _normalScaleValueY: 1,
  _fontName: "Arial",
  _fontSize: 16,
  _onSelectedScaleOffset: 0.5,
  _labelRenderer: null,
  _textAreaSize: null,
  _textVerticalAlignment: 0,
  _textHorizontalAlignment: 0,
  _className: "Text",
  _type: null,
  _labelRendererAdaptDirty: !0,
  ctor: function(t, e, n) {
    this._type = ccui.Text.Type.SYSTEM, this._textAreaSize = cc.size(0, 0), ccui.Widget.prototype.ctor.call(this), n !== void 0 ? (this.setFontName(e), this.setFontSize(n), this.setString(t)) : this.setFontName(this._fontName);
  },
  _initRenderer: function() {
    this._labelRenderer = new cc.LabelTTF(), this.addProtectedChild(this._labelRenderer, ccui.Text.RENDERER_ZORDER, -1);
  },
  setText: function(t) {
    cc.log("Please use the setString"), this.setString(t);
  },
  setString: function(t) {
    t !== (this || window)._labelRenderer.getString() && (this._labelRenderer.setString(t), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0);
  },
  getStringValue: function() {
    return cc.log("Please use the getString"), this._labelRenderer.getString();
  },
  getString: function() {
    return this._labelRenderer.getString();
  },
  getStringLength: function() {
    return this._labelRenderer.getStringLength();
  },
  setFontSize: function(t) {
    this._labelRenderer.setFontSize(t), this._fontSize = t, this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0;
  },
  getFontSize: function() {
    return this._fontSize;
  },
  setFontName: function(t) {
    this._fontName = t, this._labelRenderer.setFontName(t), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0;
  },
  getFontName: function() {
    return this._fontName;
  },
  _setFont: function(t) {
    var e = cc.LabelTTF._fontStyleRE.exec(t);
    e && (this._fontSize = parseInt(e[1]), this._fontName = e[2], this._labelRenderer._setFont(t), this._labelScaleChangedWithSize());
  },
  _getFont: function() {
    return this._labelRenderer._getFont();
  },
  getType: function() {
    return this._type;
  },
  setTextAreaSize: function(t) {
    this._labelRenderer.setDimensions(t), this._ignoreSize || (this._customSize = t), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0;
  },
  getTextAreaSize: function() {
    return this._labelRenderer.getDimensions();
  },
  setTextHorizontalAlignment: function(t) {
    this._labelRenderer.setHorizontalAlignment(t), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0;
  },
  getTextHorizontalAlignment: function() {
    return this._labelRenderer.getHorizontalAlignment();
  },
  setTextVerticalAlignment: function(t) {
    this._labelRenderer.setVerticalAlignment(t), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0;
  },
  getTextVerticalAlignment: function() {
    return this._labelRenderer.getVerticalAlignment();
  },
  setTouchScaleChangeEnabled: function(t) {
    this._touchScaleChangeEnabled = t;
  },
  isTouchScaleChangeEnabled: function() {
    return this._touchScaleChangeEnabled;
  },
  _onPressStateChangedToNormal: function() {
    this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX), this._labelRenderer.setScaleY(this._normalScaleValueY));
  },
  _onPressStateChangedToPressed: function() {
    this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX + this._onSelectedScaleOffset), this._labelRenderer.setScaleY(this._normalScaleValueY + this._onSelectedScaleOffset));
  },
  _onPressStateChangedToDisabled: function() {
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this), this._labelRendererAdaptDirty = !0;
  },
  _adaptRenderers: function() {
    this._labelRendererAdaptDirty && (this._labelScaleChangedWithSize(), this._labelRendererAdaptDirty = !1);
  },
  getVirtualRendererSize: function() {
    return this._labelRenderer.getContentSize();
  },
  getVirtualRenderer: function() {
    return this._labelRenderer;
  },
  getAutoRenderSize: function() {
    var t = (this || window)._labelRenderer.getContentSize();
    return this._ignoreSize || (this._labelRenderer.setDimensions(0, 0), t = (this || window)._labelRenderer.getContentSize(), this._labelRenderer.setDimensions(this._contentSize.width, this._contentSize.height)), t;
  },
  _labelScaleChangedWithSize: function() {
    var t = (this || window)._contentSize;
    if (this._ignoreSize)
      this._labelRenderer.setDimensions(0, 0), this._labelRenderer.setScale(1), this._normalScaleValueX = (this || window)._normalScaleValueY = 1;
    else {
      this._labelRenderer.setDimensions(cc.size(t.width, t.height));
      var e = (this || window)._labelRenderer.getContentSize();
      if (e.width <= 0 || e.height <= 0) {
        this._labelRenderer.setScale(1);
        return;
      }
      var n = t.width / e.width, r = t.height / e.height;
      this._labelRenderer.setScaleX(n), this._labelRenderer.setScaleY(r), this._normalScaleValueX = n, this._normalScaleValueY = r;
    }
    this._labelRenderer.setPosition(t.width / 2, t.height / 2);
  },
  getDescription: function() {
    return "Label";
  },
  enableShadow: function(t, e, n) {
    this._labelRenderer.enableShadow(t, e, n);
  },
  enableOutline: function(t, e) {
    this._labelRenderer.enableStroke(t, e);
  },
  enableGlow: function(t) {
    this._type === ccui.Text.Type.TTF && this._labelRenderer.enableGlow(t);
  },
  disableEffect: function() {
    this._labelRenderer.disableEffect && this._labelRenderer.disableEffect();
  },
  _createCloneInstance: function() {
    return new ccui.Text();
  },
  _copySpecialProperties: function(t) {
    t instanceof ccui.Text && (this.setFontName(t._fontName), this.setFontSize(t.getFontSize()), this.setString(t.getString()), this.setTouchScaleChangeEnabled(t.touchScaleEnabled), this.setTextAreaSize(t._textAreaSize), this.setTextHorizontalAlignment(t._labelRenderer.getHorizontalAlignment()), this.setTextVerticalAlignment(t._labelRenderer.getVerticalAlignment()), this.setContentSize(t.getContentSize()), this.setTextColor(t.getTextColor()));
  },
  _setBoundingWidth: function(t) {
    this._textAreaSize.width = t, this._labelRenderer._setBoundingWidth(t), this._labelScaleChangedWithSize();
  },
  _setBoundingHeight: function(t) {
    this._textAreaSize.height = t, this._labelRenderer._setBoundingHeight(t), this._labelScaleChangedWithSize();
  },
  _getBoundingWidth: function() {
    return this._textAreaSize.width;
  },
  _getBoundingHeight: function() {
    return this._textAreaSize.height;
  },
  _changePosition: function() {
    this._adaptRenderers();
  },
  setColor: function(t) {
    cc.ProtectedNode.prototype.setColor.call(this, t), this._labelRenderer.setColor(t);
  },
  setTextColor: function(t) {
    this._labelRenderer.setFontFillColor(t);
  },
  getTextColor: function() {
    return this._labelRenderer._getFillStyle();
  }
});
var _p = ccui.Text.prototype;
_p.boundingWidth;
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth);
_p.boundingHeight;
cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight);
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p.stringLength;
cc.defineGetterSetter(_p, "stringLength", _p.getStringLength);
_p.font;
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
_p.fontSize;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
_p.fontName;
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
_p.textAlign;
cc.defineGetterSetter(_p, "textAlign", _p.getTextHorizontalAlignment, _p.setTextHorizontalAlignment);
_p.verticalAlign;
cc.defineGetterSetter(_p, "verticalAlign", _p.getTextVerticalAlignment, _p.setTextVerticalAlignment);
_p = null;
ccui.Label = ccui.Text.create = function(t, e, n) {
  return new ccui.Text(t, e, n);
};
ccui.Text.RENDERER_ZORDER = -1;
ccui.Text.Type = {
  SYSTEM: 0,
  TTF: 1
};
ccui.TextAtlas = ccui.Widget.extend({
  _labelAtlasRenderer: null,
  _stringValue: "",
  _charMapFileName: "",
  _itemWidth: 0,
  _itemHeight: 0,
  _startCharMap: "",
  _className: "TextAtlas",
  _labelAtlasRendererAdaptDirty: null,
  ctor: function(t, e, n, r, s) {
    ccui.Widget.prototype.ctor.call(this), s !== void 0 && this.setProperty(t, e, n, r, s);
  },
  _initRenderer: function() {
    this._labelAtlasRenderer = new cc.LabelAtlas(), this._labelAtlasRenderer.setAnchorPoint(cc.p(0.5, 0.5)), this.addProtectedChild(this._labelAtlasRenderer, ccui.TextAtlas.RENDERER_ZORDER, -1);
  },
  setProperty: function(t, e, n, r, s) {
    this._stringValue = t, this._charMapFileName = e, this._itemWidth = n, this._itemHeight = r, this._startCharMap = s, this._labelAtlasRenderer.initWithString(
      t,
      this._charMapFileName,
      this._itemWidth,
      this._itemHeight,
      this._startCharMap[0]
    ), this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize()), this._labelAtlasRendererAdaptDirty = !0;
  },
  setString: function(t) {
    t !== (this || window)._labelAtlasRenderer.getString() && (this._stringValue = t, this._labelAtlasRenderer.setString(t), this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize()), this._labelAtlasRendererAdaptDirty = !0);
  },
  setStringValue: function(t) {
    cc.log("Please use the setString"), this.setString(t);
  },
  getStringValue: function() {
    return cc.log("Please use the getString"), this.getString();
  },
  getString: function() {
    return this._labelAtlasRenderer.getString();
  },
  getStringLength: function() {
    return this._labelAtlasRenderer.getStringLength();
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this), this._labelAtlasRendererAdaptDirty = !0;
  },
  _adaptRenderers: function() {
    this._labelAtlasRendererAdaptDirty && (this._labelAtlasScaleChangedWithSize(), this._labelAtlasRendererAdaptDirty = !1);
  },
  getVirtualRendererSize: function() {
    return this._labelAtlasRenderer.getContentSize();
  },
  getVirtualRenderer: function() {
    return this._labelAtlasRenderer;
  },
  _labelAtlasScaleChangedWithSize: function() {
    var t = (this || window)._labelAtlasRenderer;
    if (this._ignoreSize)
      t.setScale(1);
    else {
      var e = t.getContentSize();
      if (e.width <= 0 || e.height <= 0) {
        t.setScale(1);
        return;
      }
      t.setScaleX(this._contentSize.width / e.width), t.setScaleY(this._contentSize.height / e.height);
    }
    t.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
  },
  getDescription: function() {
    return "LabelAtlas";
  },
  _copySpecialProperties: function(t) {
    t && this.setProperty(t._stringValue, t._charMapFileName, t._itemWidth, t._itemHeight, t._startCharMap);
  },
  _createCloneInstance: function() {
    return new ccui.TextAtlas();
  }
});
var _p = ccui.TextAtlas.prototype;
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextAtlas.create = function(t, e, n, r, s) {
  return new ccui.TextAtlas(t, e, n, r, s);
};
ccui.TextAtlas.RENDERER_ZORDER = -1;
ccui.LabelBMFont = ccui.TextBMFont = ccui.Widget.extend({
  _labelBMFontRenderer: null,
  _fntFileHasInit: !1,
  _fntFileName: "",
  _stringValue: "",
  _className: "TextBMFont",
  _labelBMFontRendererAdaptDirty: !0,
  ctor: function(t, e) {
    ccui.Widget.prototype.ctor.call(this), e !== void 0 && (this.setFntFile(e), this.setString(t));
  },
  _initRenderer: function() {
    this._labelBMFontRenderer = new cc.LabelBMFont(), this.addProtectedChild(this._labelBMFontRenderer, ccui.TextBMFont.RENDERER_ZORDER, -1);
  },
  setFntFile: function(t) {
    if (t) {
      this._fntFileName = t, this._fntFileHasInit = !0, this._labelBMFontRenderer.initWithString(this._stringValue, t), this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize()), this._labelBMFontRendererAdaptDirty = !0;
      var e = (this || window), n = e._labelBMFontRenderer;
      n._textureLoaded || n.addEventListener("load", function() {
        e.setFntFile(e._fntFileName);
        for (var r = e.parent; r; ) {
          if (r.requestDoLayout) {
            r.requestDoLayout();
            break;
          }
          r = r.parent;
        }
      });
    }
  },
  setText: function(t) {
    cc.log("Please use the setString"), this.setString(t);
  },
  setString: function(t) {
    t !== (this || window)._labelBMFontRenderer.getString() && (this._stringValue = t, this._labelBMFontRenderer.setString(t), this._fntFileHasInit && (this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize()), this._labelBMFontRendererAdaptDirty = !0));
  },
  getString: function() {
    return this._stringValue;
  },
  getStringLength: function() {
    return this._labelBMFontRenderer.getStringLength();
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this), this._labelBMFontRendererAdaptDirty = !0;
  },
  _adaptRenderers: function() {
    this._labelBMFontRendererAdaptDirty && (this._labelBMFontScaleChangedWithSize(), this._labelBMFontRendererAdaptDirty = !1);
  },
  getVirtualRendererSize: function() {
    return this._labelBMFontRenderer.getContentSize();
  },
  getVirtualRenderer: function() {
    return this._labelBMFontRenderer;
  },
  _labelBMFontScaleChangedWithSize: function() {
    var t = (this || window)._labelBMFontRenderer;
    if (this._ignoreSize)
      t.setScale(1);
    else {
      var e = t.getContentSize();
      if (e.width <= 0 || e.height <= 0) {
        t.setScale(1);
        return;
      }
      t.setScaleX(this._contentSize.width / e.width), t.setScaleY(this._contentSize.height / e.height);
    }
    t.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
  },
  getDescription: function() {
    return "TextBMFont";
  },
  _createCloneInstance: function() {
    return new ccui.TextBMFont();
  },
  _copySpecialProperties: function(t) {
    this.setFntFile(t._fntFileName), this.setString(t._stringValue);
  }
});
var _p = ccui.TextBMFont.prototype;
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextBMFont.create = function(t, e) {
  return new ccui.TextBMFont(t, e);
};
ccui.TextBMFont.RENDERER_ZORDER = -1;
ccui._TextFieldRenderer = cc.TextFieldTTF.extend({
  _maxLengthEnabled: !1,
  _maxLength: 0,
  _passwordEnabled: !1,
  _passwordStyleText: "",
  _attachWithIME: !1,
  _detachWithIME: !1,
  _insertText: !1,
  _deleteBackward: !1,
  _className: "_TextFieldRenderer",
  ctor: function() {
    cc.TextFieldTTF.prototype.ctor.call(this), this._maxLengthEnabled = !1, this._maxLength = 0, this._passwordEnabled = !1, this._passwordStyleText = "*", this._attachWithIME = !1, this._detachWithIME = !1, this._insertText = !1, this._deleteBackward = !1;
  },
  onEnter: function() {
    cc.TextFieldTTF.prototype.onEnter.call(this), cc.TextFieldTTF.prototype.setDelegate.call(this, this);
  },
  onTextFieldAttachWithIME: function(t) {
    return this.setAttachWithIME(!0), !1;
  },
  onTextFieldInsertText: function(t, e, n) {
    return n === 1 && e === `
` ? !1 : (this.setInsertText(!0), this._maxLengthEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) >= (this || window)._maxLength);
  },
  onTextFieldDeleteBackward: function(t, e, n) {
    return this.setDeleteBackward(!0), !1;
  },
  onTextFieldDetachWithIME: function(t) {
    return this.setDetachWithIME(!0), !1;
  },
  insertText: function(t, e) {
    var n = t;
    if (t !== `
` && this._maxLengthEnabled) {
      var r = (this || window).getString().length;
      if (r >= (this || window)._maxLength) {
        this._passwordEnabled && this.setPasswordText(this.getString());
        return;
      }
    }
    cc.TextFieldTTF.prototype.insertText.call(this, n, e), this._passwordEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) > 0 && this.setPasswordText(this.getString());
  },
  deleteBackward: function() {
    cc.TextFieldTTF.prototype.deleteBackward.call(this), cc.TextFieldTTF.prototype.getCharCount.call(this) > 0 && this._passwordEnabled && this.setPasswordText(this._inputText);
  },
  openIME: function() {
    cc.TextFieldTTF.prototype.attachWithIME.call(this);
  },
  closeIME: function() {
    cc.TextFieldTTF.prototype.detachWithIME.call(this);
  },
  setMaxLengthEnabled: function(t) {
    this._maxLengthEnabled = t;
  },
  isMaxLengthEnabled: function() {
    return this._maxLengthEnabled;
  },
  setMaxLength: function(t) {
    this._maxLength = t;
  },
  getMaxLength: function() {
    return this._maxLength;
  },
  getCharCount: function() {
    return cc.TextFieldTTF.prototype.getCharCount.call(this);
  },
  setPasswordEnabled: function(t) {
    this._passwordEnabled = t;
  },
  isPasswordEnabled: function() {
    return this._passwordEnabled;
  },
  setPasswordStyleText: function(t) {
    if (!(t.length > 1)) {
      var e = t.charCodeAt(0);
      e < 33 || e > 126 || (this._passwordStyleText = t);
    }
  },
  setPasswordText: function(t) {
    var e = "", n = t.length, r = n;
    this._maxLengthEnabled && n > this._maxLength && (r = (this || window)._maxLength);
    for (var s = 0; s < r; ++s)
      e += (this || window)._passwordStyleText;
    cc.LabelTTF.prototype.setString.call(this, e);
  },
  setAttachWithIME: function(t) {
    this._attachWithIME = t;
  },
  getAttachWithIME: function() {
    return this._attachWithIME;
  },
  setDetachWithIME: function(t) {
    this._detachWithIME = t;
  },
  getDetachWithIME: function() {
    return this._detachWithIME;
  },
  setInsertText: function(t) {
    this._insertText = t;
  },
  getInsertText: function() {
    return this._insertText;
  },
  setDeleteBackward: function(t) {
    this._deleteBackward = t;
  },
  getDeleteBackward: function() {
    return this._deleteBackward;
  },
  onDraw: function(t) {
    return !1;
  }
});
ccui._TextFieldRenderer.create = function(t, e, n) {
  var r = new ccui._TextFieldRenderer();
  return r && r.initWithString("", e, n) ? (t && r.setPlaceHolder(t), r) : null;
};
ccui.TextField = ccui.Widget.extend({
  _textFieldRenderer: null,
  _touchWidth: 0,
  _touchHeight: 0,
  _useTouchArea: !1,
  _textFieldEventListener: null,
  _textFieldEventSelector: null,
  _passwordStyleText: "",
  _textFieldRendererAdaptDirty: !0,
  _fontName: "",
  _fontSize: 12,
  _ccEventCallback: null,
  ctor: function(t, e, n) {
    ccui.Widget.prototype.ctor.call(this), this.setTouchEnabled(!0), e && this.setFontName(e), n && this.setFontSize(n), t && this.setPlaceHolder(t);
  },
  onEnter: function() {
    ccui.Widget.prototype.onEnter.call(this), this.scheduleUpdate();
  },
  _initRenderer: function() {
    this._textFieldRenderer = ccui._TextFieldRenderer.create("input words here", "Thonburi", 20), this.addProtectedChild(this._textFieldRenderer, ccui.TextField.RENDERER_ZORDER, -1);
  },
  setTouchSize: function(t) {
    this._touchWidth = t.width, this._touchHeight = t.height;
  },
  setTouchAreaEnabled: function(t) {
    this._useTouchArea = t;
  },
  hitTest: function(t) {
    if (this._useTouchArea) {
      var e = (this || window).convertToNodeSpace(t), n = cc.rect(
        -this._touchWidth * this._anchorPoint.x,
        -this._touchHeight * this._anchorPoint.y,
        this._touchWidth,
        this._touchHeight
      );
      return e.x >= n.x && e.x <= n.x + n.width && e.y >= n.y && e.y <= n.y + n.height;
    } else
      return ccui.Widget.prototype.hitTest.call(this, t);
  },
  getTouchSize: function() {
    return cc.size(this._touchWidth, this._touchHeight);
  },
  setText: function(t) {
    cc.log("Please use the setString"), this.setString(t);
  },
  setString: function(t) {
    t != null && (t = String(t), this.isMaxLengthEnabled() && (t = t.substr(0, this.getMaxLength())), this.isPasswordEnabled() ? (this._textFieldRenderer.setPasswordText(t), this._textFieldRenderer.setString(""), this._textFieldRenderer.insertText(t, t.length)) : this._textFieldRenderer.setString(t), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()));
  },
  setPlaceHolder: function(t) {
    this._textFieldRenderer.setPlaceHolder(t), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize());
  },
  getPlaceHolder: function() {
    return this._textFieldRenderer.getPlaceHolder();
  },
  getPlaceHolderColor: function() {
    return this._textFieldRenderer.getPlaceHolderColor();
  },
  setPlaceHolderColor: function(t) {
    this._textFieldRenderer.setColorSpaceHolder(t);
  },
  setTextColor: function(t) {
    this._textFieldRenderer.setTextColor(t);
  },
  setFontSize: function(t) {
    this._textFieldRenderer.setFontSize(t), this._fontSize = t, this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize());
  },
  getFontSize: function() {
    return this._fontSize;
  },
  setFontName: function(t) {
    this._textFieldRenderer.setFontName(t), this._fontName = t, this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize());
  },
  getFontName: function() {
    return this._fontName;
  },
  didNotSelectSelf: function() {
    this._textFieldRenderer.detachWithIME();
  },
  getStringValue: function() {
    return cc.log("Please use the getString"), this.getString();
  },
  getString: function() {
    return this._textFieldRenderer.getString();
  },
  getStringLength: function() {
    return this._textFieldRenderer.getStringLength();
  },
  onTouchBegan: function(t, e) {
    var n = (this || window), r = ccui.Widget.prototype.onTouchBegan.call(n, t, e);
    return n._hit ? setTimeout(function() {
      n._textFieldRenderer.attachWithIME();
    }, 0) : setTimeout(function() {
      n._textFieldRenderer.detachWithIME();
    }, 0), r;
  },
  setMaxLengthEnabled: function(t) {
    this._textFieldRenderer.setMaxLengthEnabled(t);
  },
  isMaxLengthEnabled: function() {
    return this._textFieldRenderer.isMaxLengthEnabled();
  },
  setMaxLength: function(t) {
    this._textFieldRenderer.setMaxLength(t), this.setString(this.getString());
  },
  getMaxLength: function() {
    return this._textFieldRenderer.getMaxLength();
  },
  setPasswordEnabled: function(t) {
    this._textFieldRenderer.setPasswordEnabled(t);
  },
  isPasswordEnabled: function() {
    return this._textFieldRenderer.isPasswordEnabled();
  },
  setPasswordStyleText: function(t) {
    this._textFieldRenderer.setPasswordStyleText(t), this._passwordStyleText = t, this.setString(this.getString());
  },
  getPasswordStyleText: function() {
    return this._passwordStyleText;
  },
  update: function(t) {
    this.getDetachWithIME() && (this._detachWithIMEEvent(), this.setDetachWithIME(!1)), this.getAttachWithIME() && (this._attachWithIMEEvent(), this.setAttachWithIME(!1)), this.getInsertText() && (this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()), this._insertTextEvent(), this.setInsertText(!1)), this.getDeleteBackward() && (this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()), this._deleteBackwardEvent(), this.setDeleteBackward(!1));
  },
  getAttachWithIME: function() {
    return this._textFieldRenderer.getAttachWithIME();
  },
  setAttachWithIME: function(t) {
    this._textFieldRenderer.setAttachWithIME(t);
  },
  getDetachWithIME: function() {
    return this._textFieldRenderer.getDetachWithIME();
  },
  setDetachWithIME: function(t) {
    this._textFieldRenderer.setDetachWithIME(t);
  },
  getInsertText: function() {
    return this._textFieldRenderer.getInsertText();
  },
  setInsertText: function(t) {
    this._textFieldRenderer.setInsertText(t);
  },
  getDeleteBackward: function() {
    return this._textFieldRenderer.getDeleteBackward();
  },
  setDeleteBackward: function(t) {
    this._textFieldRenderer.setDeleteBackward(t);
  },
  _attachWithIMEEvent: function() {
    this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_ATTACH_WITH_IME) : this._textFieldEventSelector(this, ccui.TextField.EVENT_ATTACH_WITH_IME)), this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_ATTACH_WITH_IME);
  },
  _detachWithIMEEvent: function() {
    this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DETACH_WITH_IME) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DETACH_WITH_IME)), this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_DETACH_WITH_IME);
  },
  _insertTextEvent: function() {
    this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_INSERT_TEXT) : this._textFieldEventSelector(this, ccui.TextField.EVENT_INSERT_TEXT)), this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_INSERT_TEXT);
  },
  _deleteBackwardEvent: function() {
    this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DELETE_BACKWARD) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DELETE_BACKWARD)), this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_DELETE_BACKWARD);
  },
  addEventListenerTextField: function(t, e) {
    this.addEventListener(t, e);
  },
  addEventListener: function(t, e) {
    this._textFieldEventSelector = t, this._textFieldEventListener = e;
  },
  _onSizeChanged: function() {
    ccui.Widget.prototype._onSizeChanged.call(this), this._textFieldRendererAdaptDirty = !0;
  },
  _adaptRenderers: function() {
    this._textFieldRendererAdaptDirty && (this._textfieldRendererScaleChangedWithSize(), this._textFieldRendererAdaptDirty = !1);
  },
  _textfieldRendererScaleChangedWithSize: function() {
    this._ignoreSize || this._textFieldRenderer.setDimensions(this._contentSize), this._textFieldRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
  },
  getAutoRenderSize: function() {
    var t = (this || window)._textFieldRenderer.getContentSize();
    return this._ignoreSize || (this._textFieldRenderer.setDimensions(0, 0), t = (this || window)._textFieldRenderer.getContentSize(), this._textFieldRenderer.setDimensions(this._contentSize.width, this._contentSize.height)), t;
  },
  getVirtualRendererSize: function() {
    return this._textFieldRenderer.getContentSize();
  },
  getVirtualRenderer: function() {
    return this._textFieldRenderer;
  },
  getDescription: function() {
    return "TextField";
  },
  attachWithIME: function() {
    this._textFieldRenderer.attachWithIME();
  },
  _createCloneInstance: function() {
    return new ccui.TextField();
  },
  _copySpecialProperties: function(t) {
    this.setString(t._textFieldRenderer.getString()), this.setPlaceHolder(t.getString()), this.setFontSize(t._textFieldRenderer.getFontSize()), this.setFontName(t._textFieldRenderer.getFontName()), this.setMaxLengthEnabled(t.isMaxLengthEnabled()), this.setMaxLength(t.getMaxLength()), this.setPasswordEnabled(t.isPasswordEnabled()), this.setPasswordStyleText(t._passwordStyleText), this.setAttachWithIME(t.getAttachWithIME()), this.setDetachWithIME(t.getDetachWithIME()), this.setInsertText(t.getInsertText()), this.setDeleteBackward(t.getDeleteBackward()), this._ccEventCallback = t._ccEventCallback, this._textFieldEventListener = t._textFieldEventListener, this._textFieldEventSelector = t._textFieldEventSelector;
  },
  setTextAreaSize: function(t) {
    this.setContentSize(t);
  },
  setTextHorizontalAlignment: function(t) {
    this._textFieldRenderer.setHorizontalAlignment(t);
  },
  setTextVerticalAlignment: function(t) {
    this._textFieldRenderer.setVerticalAlignment(t);
  },
  _setFont: function(t) {
    this._textFieldRenderer._setFont(t), this._textFieldRendererAdaptDirty = !0;
  },
  _getFont: function() {
    return this._textFieldRenderer._getFont();
  },
  _changePosition: function() {
    this._adaptRenderers();
  }
});
ccui.TextField.create = function(t, e, n) {
  return new ccui.TextField(t, e, n);
};
var _p = ccui.TextField.prototype;
_p.string;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p.placeHolder;
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
_p.font;
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
_p.fontSize;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
_p.fontName;
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
_p.maxLengthEnabled;
cc.defineGetterSetter(_p, "maxLengthEnabled", _p.isMaxLengthEnabled, _p.setMaxLengthEnabled);
_p.maxLength;
cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
_p.passwordEnabled;
cc.defineGetterSetter(_p, "passwordEnabled", _p.isPasswordEnabled, _p.setPasswordEnabled);
_p = null;
ccui.TextField.EVENT_ATTACH_WITH_IME = 0;
ccui.TextField.EVENT_DETACH_WITH_IME = 1;
ccui.TextField.EVENT_INSERT_TEXT = 2;
ccui.TextField.EVENT_DELETE_BACKWARD = 3;
ccui.TextField.RENDERER_ZORDER = -1;
ccui.RichElement = ccui.Class.extend({
  _type: 0,
  _tag: 0,
  _color: null,
  _opacity: 0,
  ctor: function(t, e, n) {
    this._type = 0, this._tag = t || 0, this._color = cc.color(255, 255, 255, 255), e && (this._color.r = e.r, this._color.g = e.g, this._color.b = e.b), this._opacity = n || 0, n === void 0 ? this._color.a = e.a : this._color.a = n;
  }
});
ccui.RichElementText = ccui.RichElement.extend({
  _text: "",
  _fontName: "",
  _fontSize: 0,
  _fontDefinition: null,
  ctor: function(t, e, n, r, s, o) {
    var a = e;
    e && e instanceof cc.FontDefinition && (a = e.fillStyle, s = e.fontName, o = e.fontSize, this._fontDefinition = e), ccui.RichElement.prototype.ctor.call(this, t, a, n), this._type = ccui.RichElement.TEXT, this._text = r, this._fontName = s, this._fontSize = o;
  }
});
ccui.RichElementText.create = function(t, e, n, r, s, o) {
  return new ccui.RichElementText(t, e, n, r, s, o);
};
ccui.RichElementImage = ccui.RichElement.extend({
  _filePath: "",
  _textureRect: null,
  _textureType: 0,
  ctor: function(t, e, n, r) {
    ccui.RichElement.prototype.ctor.call(this, t, e, n), this._type = ccui.RichElement.IMAGE, this._filePath = r || "", this._textureRect = cc.rect(0, 0, 0, 0), this._textureType = 0;
  }
});
ccui.RichElementImage.create = function(t, e, n, r) {
  return new ccui.RichElementImage(t, e, n, r);
};
ccui.RichElementCustomNode = ccui.RichElement.extend({
  _customNode: null,
  ctor: function(t, e, n, r) {
    ccui.RichElement.prototype.ctor.call(this, t, e, n), this._type = ccui.RichElement.CUSTOM, this._customNode = r || null;
  }
});
ccui.RichElementCustomNode.create = function(t, e, n, r) {
  return new ccui.RichElementCustomNode(t, e, n, r);
};
ccui.RichText = ccui.Widget.extend({
  _formatTextDirty: !1,
  _richElements: null,
  _elementRenders: null,
  _leftSpaceWidth: 0,
  _verticalSpace: 0,
  _elementRenderersContainer: null,
  _lineBreakOnSpace: !1,
  _textHorizontalAlignment: null,
  _textVerticalAlignment: null,
  ctor: function() {
    ccui.Widget.prototype.ctor.call(this), this._formatTextDirty = !1, this._richElements = [], this._elementRenders = [], this._leftSpaceWidth = 0, this._verticalSpace = 0, this._textHorizontalAlignment = cc.TEXT_ALIGNMENT_LEFT, this._textVerticalAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
  },
  _initRenderer: function() {
    this._elementRenderersContainer = new cc.Node(), this._elementRenderersContainer.setAnchorPoint(0.5, 0.5), this.addProtectedChild(this._elementRenderersContainer, 0, -1);
  },
  insertElement: function(t, e) {
    this._richElements.splice(e, 0, t), this._formatTextDirty = !0;
  },
  pushBackElement: function(t) {
    this._richElements.push(t), this._formatTextDirty = !0;
  },
  removeElement: function(t) {
    cc.isNumber(t) ? this._richElements.splice(t, 1) : cc.arrayRemoveObject(this._richElements, t), this._formatTextDirty = !0;
  },
  formatText: function() {
    if (this._formatTextDirty) {
      this._elementRenderersContainer.removeAllChildren(), this._elementRenders.length = 0;
      var t, e, n = (this || window)._richElements;
      if (this._ignoreSize)
        for (this._addNewLine(), t = 0; t < n.length; t++) {
          e = n[t];
          var r = null;
          switch (e._type) {
            case ccui.RichElement.TEXT:
              e._fontDefinition ? r = new cc.LabelTTF(e._text, e._fontDefinition) : r = new cc.LabelTTF(e._text, e._fontName, e._fontSize);
              break;
            case ccui.RichElement.IMAGE:
              r = new cc.Sprite(e._filePath);
              break;
            case ccui.RichElement.CUSTOM:
              r = e._customNode;
              break;
          }
          r.setColor(e._color), r.setOpacity(e._color.a), this._pushToContainer(r);
        }
      else
        for (this._addNewLine(), t = 0; t < n.length; t++)
          switch (e = n[t], e._type) {
            case ccui.RichElement.TEXT:
              e._fontDefinition ? this._handleTextRenderer(e._text, e._fontDefinition, e._fontDefinition.fontSize, e._fontDefinition.fillStyle) : this._handleTextRenderer(e._text, e._fontName, e._fontSize, e._color);
              break;
            case ccui.RichElement.IMAGE:
              this._handleImageRenderer(e._filePath, e._color, e._color.a);
              break;
            case ccui.RichElement.CUSTOM:
              this._handleCustomRenderer(e._customNode);
              break;
          }
      this.formatRenderers(), this._formatTextDirty = !1;
    }
  },
  _handleTextRenderer: function(t, e, n, r) {
    if (t !== "") {
      if (t === `
`) {
        this._addNewLine();
        return;
      }
      var s = e instanceof cc.FontDefinition ? new cc.LabelTTF(t, e) : new cc.LabelTTF(t, e, n), o = s.getContentSize().width;
      if (this._leftSpaceWidth -= o, this._leftSpaceWidth < 0) {
        var a = -this._leftSpaceWidth / o, c = t, l = c.length, h = l * (1 - a), u = c.substr(0, h), _ = c.substr(h, c.length - 1), d = h > 0;
        if (this._lineBreakOnSpace) {
          var f = u.lastIndexOf(" ");
          h = f === -1 ? h : f + 1, _ = c.substr(h, c.length - 1), d = h > 0 && _ !== " ";
        }
        if (d) {
          var C = null;
          e instanceof cc.FontDefinition ? (C = new cc.LabelTTF(u.substr(0, h), e), C.setOpacity(e.fillStyle.a)) : (C = new cc.LabelTTF(u.substr(0, h), e, n), C.setColor(r), C.setOpacity(r.a)), this._pushToContainer(C);
        }
        this._addNewLine(), this._handleTextRenderer(_, e, n, r);
      } else
        e instanceof cc.FontDefinition ? s.setOpacity(e.fillStyle.a) : (s.setColor(r), s.setOpacity(r.a)), this._pushToContainer(s);
    }
  },
  _handleImageRenderer: function(t, e, n) {
    var r = new cc.Sprite(t);
    this._handleCustomRenderer(r);
  },
  _handleCustomRenderer: function(t) {
    var e = t.getContentSize();
    this._leftSpaceWidth -= e.width, this._leftSpaceWidth < 0 ? (this._addNewLine(), this._pushToContainer(t), this._leftSpaceWidth -= e.width) : this._pushToContainer(t);
  },
  _addNewLine: function() {
    this._leftSpaceWidth = (this || window)._customSize.width, this._elementRenders.push([]);
  },
  formatRenderers: function() {
    var t = 0, e = (this || window)._elementRenderersContainer, n = (this || window)._elementRenders, r, s, o, a, c, l, h;
    if (this._ignoreSize) {
      var u = 0;
      for (o = n[0], a = 0, s = 0; s < o.length; s++) {
        c = o[s], c.setAnchorPoint(cc.p(0, 0)), c.setPosition(a, 0), e.addChild(c, 1, s), l = c.getLineHeight ? c.getLineHeight() : t;
        var _ = c.getContentSize();
        u += _.width, t = Math.max(Math.min(t, l), _.height), a += _.width;
      }
      if (this._textHorizontalAlignment !== cc.TEXT_ALIGNMENT_LEFT)
        for (h = 0, this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_RIGHT ? h = (this || window)._contentSize.width - a : this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_CENTER && (h = (this._contentSize.width - a) / 2), s = 0; s < o.length; s++)
          o[s].x += h;
      e.setContentSize(u, t);
    } else {
      var d = [];
      for (r = 0; r < n.length; r++) {
        o = n[r];
        var f = 0;
        for (s = 0; s < o.length; s++)
          c = o[s], l = c.getLineHeight ? c.getLineHeight() : c.getContentSize().height, f = Math.max(Math.min(c.getContentSize().height, l), f);
        d[r] = f, t += d[r];
      }
      var C = (this || window)._customSize.height;
      for (r = 0; r < n.length; r++) {
        for (o = n[r], a = 0, C -= d[r] + this._verticalSpace, s = 0; s < o.length; s++)
          c = o[s], c.setAnchorPoint(cc.p(0, 0)), c.setPosition(cc.p(a, C)), e.addChild(c, 1), a += c.getContentSize().width;
        if (this._textHorizontalAlignment !== cc.TEXT_ALIGNMENT_LEFT || this._textVerticalAlignment !== cc.VERTICAL_TEXT_ALIGNMENT_TOP) {
          h = 0, this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_RIGHT ? h = (this || window)._contentSize.width - a : this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_CENTER && (h = (this._contentSize.width - a) / 2);
          var m = 0;
          for (this._textVerticalAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? m = (this || window)._customSize.height - t : this._textVerticalAlignment === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (m = (this._customSize.height - t) / 2), s = 0; s < o.length; s++)
            c = o[s], c.x += h, c.y -= m;
        }
      }
      e.setContentSize(this._contentSize);
    }
    var g = n.length;
    for (r = 0; r < g; r++)
      n[r].length = 0;
    this._elementRenders.length = 0, this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : this._customSize), this._updateContentSizeWithTextureSize(this._contentSize), e.setPosition(this._contentSize.width * 0.5, this._contentSize.height * 0.5);
  },
  _pushToContainer: function(t) {
    this._elementRenders.length <= 0 || this._elementRenders[this._elementRenders.length - 1].push(t);
  },
  _adaptRenderers: function() {
    this.formatText();
  },
  setVerticalSpace: function(t) {
    this._verticalSpace = t;
  },
  setAnchorPoint: function(t) {
    ccui.Widget.prototype.setAnchorPoint.call(this, t), this._elementRenderersContainer.setAnchorPoint(t);
  },
  _setAnchorX: function(t) {
    ccui.Widget.prototype._setAnchorX.call(this, t), this._elementRenderersContainer._setAnchorX(t);
  },
  _setAnchorY: function(t) {
    ccui.Widget.prototype._setAnchorY.call(this, t), this._elementRenderersContainer._setAnchorY(t);
  },
  getVirtualRendererSize: function() {
    return this._elementRenderersContainer.getContentSize();
  },
  ignoreContentAdaptWithSize: function(t) {
    this._ignoreSize !== t && (this._formatTextDirty = !0, ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, t));
  },
  getContentSize: function() {
    return this.formatText(), cc.Node.prototype.getContentSize.call(this);
  },
  _getWidth: function() {
    return this.formatText(), cc.Node.prototype._getWidth.call(this);
  },
  _getHeight: function() {
    return this.formatText(), cc.Node.prototype._getHeight.call(this);
  },
  setContentSize: function(t, e) {
    var n = e === void 0 ? t.width : t, r = e === void 0 ? t.height : e;
    ccui.Widget.prototype.setContentSize.call(this, n, r), this._formatTextDirty = !0;
  },
  getDescription: function() {
    return "RichText";
  },
  setCascadeOpacityEnabled: function(t) {
    this._super(t), this._elementRenderersContainer.setCascadeOpacityEnabled(t);
  },
  setLineBreakOnSpace: function(t) {
    this._lineBreakOnSpace = t, this._formatTextDirty = !0, this.formatText();
  },
  setTextHorizontalAlignment: function(t) {
    t !== (this || window)._textHorizontalAlignment && (this._textHorizontalAlignment = t, this.formatText());
  },
  setTextVerticalAlignment: function(t) {
    t !== (this || window)._textVerticalAlignment && (this._textVerticalAlignment = t, this.formatText());
  }
});
ccui.RichText.create = function() {
  return new ccui.RichText();
};
ccui.RichElement.TEXT = 0;
ccui.RichElement.IMAGE = 1;
ccui.RichElement.CUSTOM = 2;
ccui.ScrollViewBar = ccui.ProtectedNode.extend({
  _parentScroll: null,
  _direction: null,
  _upperHalfCircle: null,
  _lowerHalfCircle: null,
  _body: null,
  _opacity: 255,
  _marginFromBoundary: 0,
  _marginForLength: 0,
  _touching: !1,
  _autoHideEnabled: !0,
  autoHideTime: 0,
  _autoHideRemainingTime: 0,
  _className: "ScrollViewBar",
  ctor: function(t, e) {
    cc.ProtectedNode.prototype.ctor.call(this), this._direction = e, this._parentScroll = t, this._marginFromBoundary = ccui.ScrollViewBar.DEFAULT_MARGIN, this._marginForLength = ccui.ScrollViewBar.DEFAULT_MARGIN, this.opacity = 255 * ccui.ScrollViewBar.DEFAULT_SCROLLBAR_OPACITY, this.autoHideTime = ccui.ScrollViewBar.DEFAULT_AUTO_HIDE_TIME, this._autoHideEnabled = !0, ccui.ScrollViewBar.prototype.init.call(this), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0);
  },
  init: function() {
    this._upperHalfCircle = ccui.helper._createSpriteFromBase64(ccui.ScrollViewBar.HALF_CIRCLE_IMAGE, ccui.ScrollViewBar.HALF_CIRCLE_IMAGE_KEY), this._upperHalfCircle.setAnchorPoint(cc.p(0.5, 0)), this._lowerHalfCircle = ccui.helper._createSpriteFromBase64(ccui.ScrollViewBar.HALF_CIRCLE_IMAGE, ccui.ScrollViewBar.HALF_CIRCLE_IMAGE_KEY), this._lowerHalfCircle.setAnchorPoint(cc.p(0.5, 0)), this._lowerHalfCircle.setScaleY(-1), this.addProtectedChild(this._upperHalfCircle), this.addProtectedChild(this._lowerHalfCircle), this._body = ccui.helper._createSpriteFromBase64(ccui.ScrollViewBar.BODY_IMAGE_1_PIXEL_HEIGHT, ccui.ScrollViewBar.BODY_IMAGE_1_PIXEL_HEIGHT_KEY), this._body.setAnchorPoint(cc.p(0.5, 0)), this.addProtectedChild(this._body), this.setColor(ccui.ScrollViewBar.DEFAULT_COLOR), this.onScrolled(cc.p(0, 0)), cc.ProtectedNode.prototype.setOpacity.call(this, 0), this._autoHideRemainingTime = 0, this._direction === ccui.ScrollView.DIR_HORIZONTAL && this.setRotation(90);
  },
  setPositionFromCorner: function(t) {
    this._direction === ccui.ScrollView.DIR_VERTICAL ? (this._marginForLength = t.y, this._marginFromBoundary = t.x) : (this._marginForLength = t.x, this._marginFromBoundary = t.y);
  },
  onEnter: function() {
    cc.ProtectedNode.prototype.onEnter.call(this), this.scheduleUpdate();
  },
  getPositionFromCorner: function() {
    return this._direction === ccui.ScrollView.DIR_VERTICAL ? cc.p(this._marginFromBoundary, this._marginForLength) : cc.p(this._marginForLength, this._marginFromBoundary);
  },
  setWidth: function(t) {
    var e = t / this._body.width;
    this._body.setScaleX(e), this._upperHalfCircle.setScale(e), this._lowerHalfCircle.setScale(-e);
  },
  getWidth: function() {
    return this._body.getBoundingBox().width;
  },
  setAutoHideEnabled: function(t) {
    this._autoHideEnabled = t, !this._autoHideEnabled && !this._touching && this._autoHideRemainingTime <= 0 ? cc.ProtectedNode.prototype.setOpacity.call(this, this.opacity) : cc.ProtectedNode.prototype.setOpacity.call(this, 0);
  },
  isAutoHideEnabled: function() {
    return this._autoHideEnabled;
  },
  setOpacity: function(t) {
    this._opacity = t;
  },
  getOpacity: function() {
    return this._opacity;
  },
  _updateLength: function(t) {
    var e = t / this._body.getTextureRect().height;
    this._body.setScaleY(e), this._upperHalfCircle.setPositionY(this._body.getPositionY() + t);
  },
  _processAutoHide: function(t) {
    !this._autoHideEnabled || this._autoHideRemainingTime <= 0 || this._touching || (this._autoHideRemainingTime -= t, this._autoHideRemainingTime <= (this || window).autoHideTime && (this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime), cc.ProtectedNode.prototype.setOpacity.call(this, this._opacity * (this._autoHideRemainingTime / this.autoHideTime))));
  },
  update: function(t) {
    this._processAutoHide(t);
  },
  onTouchBegan: function() {
    this._autoHideEnabled && (this._touching = !0);
  },
  onTouchEnded: function() {
    this._autoHideEnabled && (this._touching = !1, !(this._autoHideRemainingTime <= 0) && (this._autoHideRemainingTime = (this || window).autoHideTime));
  },
  onScrolled: function(t) {
    this._autoHideEnabled && (this._autoHideRemainingTime = (this || window).autoHideTime, cc.ProtectedNode.prototype.setOpacity.call(this, this.opacity));
    var e = (this || window)._parentScroll.getInnerContainer(), n = 0, r = 0, s = 0, o = 0;
    this._direction === ccui.ScrollView.DIR_VERTICAL ? (n = e.height, r = (this || window)._parentScroll.height, s = t.y, o = -e.getPositionY()) : this._direction === ccui.ScrollView.DIR_HORIZONTAL && (n = e.width, r = (this || window)._parentScroll.width, s = t.x, o = -e.getPositionX());
    var a = (this || window)._calculateLength(n, r, s), c = (this || window)._calculatePosition(n, r, o, s, a);
    this._updateLength(a), this.setPosition(c);
  },
  _calculateLength: function(t, e, n) {
    var r = t;
    if (n !== 0) {
      var s = 20;
      r += (n > 0 ? n : -n) * s;
    }
    var o = e / r;
    return Math.abs(e - 2 * this._marginForLength) * o;
  },
  _calculatePosition: function(t, e, n, r, s) {
    var o = t - e;
    r !== 0 && (o += Math.abs(r));
    var a = 0;
    o !== 0 && (a = n / o, a = Math.max(a, 0), a = Math.min(a, 1));
    var c = (e - s - 2 * this._marginForLength) * a + this._marginForLength;
    return this._direction === ccui.ScrollView.DIR_VERTICAL ? cc.p(this._parentScroll.width - this._marginFromBoundary, c) : cc.p(c, this._marginFromBoundary);
  }
});
var _p = ccui.ScrollViewBar.prototype;
_p.opacity;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
_p.autoHideEnabled;
cc.defineGetterSetter(_p, "autoHideEnabled", _p.isAutoHideEnabled, _p.setAutoHideEnabled);
ccui.ScrollViewBar.DEFAULT_COLOR = cc.color(52, 65, 87);
ccui.ScrollViewBar.DEFAULT_MARGIN = 20;
ccui.ScrollViewBar.DEFAULT_AUTO_HIDE_TIME = 0.2;
ccui.ScrollViewBar.DEFAULT_SCROLLBAR_OPACITY = 0.4;
ccui.ScrollViewBar.HALF_CIRCLE_IMAGE_KEY = "/__half_circle_image";
ccui.ScrollViewBar.HALF_CIRCLE_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAGCAMAAADAMI+zAAAAJ1BMVEX///////////////////////////////////////////////////9Ruv0SAAAADHRSTlMABgcbbW7Hz9Dz+PmlcJP5AAAAMElEQVR4AUXHwQ2AQAhFwYcLH1H6r1djzDK3ASxUpTBeK/uTCyz7dx54b44m4p5cD1MwAooEJyk3AAAAAElFTkSuQmCC";
ccui.ScrollViewBar.BODY_IMAGE_1_PIXEL_HEIGHT_KEY = "/__body_image_height";
ccui.ScrollViewBar.BODY_IMAGE_1_PIXEL_HEIGHT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAABCAMAAADdNb8LAAAAA1BMVEX///+nxBvIAAAACklEQVR4AWNABgAADQABYc2cpAAAAABJRU5ErkJggg==";
ccui.ScrollView = ccui.Layout.extend({
  _innerContainer: null,
  _direction: null,
  _topBoundary: 0,
  _bottomBoundary: 0,
  _leftBoundary: 0,
  _rightBoundary: 0,
  _touchMoveDisplacements: null,
  _touchMoveTimeDeltas: null,
  _touchMovePreviousTimestamp: 0,
  _touchTotalTimeThreshold: 0.5,
  _autoScrolling: !1,
  _autoScrollTargetDelta: null,
  _autoScrollAttenuate: !0,
  _autoScrollStartPosition: null,
  _autoScrollTotalTime: 0,
  _autoScrollAccumulatedTime: 0,
  _autoScrollCurrentlyOutOfBoundary: !1,
  _autoScrollBraking: !1,
  _autoScrollBrakingStartPosition: null,
  _bePressed: !1,
  _childFocusCancelOffset: 0,
  bounceEnabled: !1,
  _outOfBoundaryAmount: null,
  _outOfBoundaryAmountDirty: !0,
  inertiaScrollEnabled: !1,
  _scrollBarEnabled: !0,
  _verticalScrollBar: null,
  _horizontalScrollBar: null,
  _scrollViewEventListener: null,
  _scrollViewEventSelector: null,
  _className: "ScrollView",
  ctor: function() {
    ccui.Layout.prototype.ctor.call(this), this.setClippingEnabled(!0), this._innerContainer.setTouchEnabled(!1), this._direction = ccui.ScrollView.DIR_NONE, this._childFocusCancelOffset = 5, this.inertiaScrollEnabled = !0, this._outOfBoundaryAmount = cc.p(0, 0), this._autoScrollTargetDelta = cc.p(0, 0), this._autoScrollStartPosition = cc.p(0, 0), this._autoScrollBrakingStartPosition = cc.p(0, 0), this._touchMoveDisplacements = [], this._touchMoveTimeDeltas = [], this._touchMovePreviousTimestamp = 0, this._scrollBarEnabled = !0, this._initScrollBar(), this.setTouchEnabled(!0);
  },
  init: function() {
    return !!ccui.Layout.prototype.init.call(this);
  },
  onEnter: function() {
    ccui.Layout.prototype.onEnter.call(this), this.scheduleUpdate();
  },
  onExit: function() {
    cc.renderer._removeCache(this.__instanceId), ccui.Layout.prototype.onExit.call(this);
  },
  findNextFocusedWidget: function(t, e) {
    return this.getLayoutType() === ccui.Layout.LINEAR_VERTICAL || this.getLayoutType() === ccui.Layout.LINEAR_HORIZONTAL ? this._innerContainer.findNextFocusedWidget(t, e) : ccui.Widget.prototype.findNextFocusedWidget.call(this, t, e);
  },
  _initRenderer: function() {
    ccui.Layout.prototype._initRenderer.call(this), this._innerContainer = new ccui.Layout(), this._innerContainer.setColor(cc.color(255, 255, 255)), this._innerContainer.setOpacity(255), this._innerContainer.setCascadeColorEnabled(!0), this._innerContainer.setCascadeOpacityEnabled(!0), this.addProtectedChild(this._innerContainer, 1, 1);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new ccui.ScrollView.WebGLRenderCmd(this) : new ccui.ScrollView.CanvasRenderCmd(this);
  },
  _onSizeChanged: function() {
    ccui.Layout.prototype._onSizeChanged.call(this);
    var t = (this || window)._contentSize;
    this._topBoundary = t.height, this._rightBoundary = t.width;
    var e = (this || window)._innerContainer.getContentSize();
    this._innerContainer.setContentSize(cc.size(Math.max(e.width, t.width), Math.max(e.height, t.height))), this._innerContainer.setPosition(0, t.height - this._innerContainer.getContentSize().height), this._verticalScrollBar && this._verticalScrollBar.onScrolled(this._getHowMuchOutOfBoundary()), this._horizontalScrollBar && this._horizontalScrollBar.onScrolled(this._getHowMuchOutOfBoundary());
  },
  setInnerContainerSize: function(t) {
    var e = (this || window)._innerContainer, n = (this || window)._contentSize, r = n.width, s = n.height;
    t.width < n.width ? cc.log("Inner width <= ScrollView width, it will be force sized!") : r = t.width, t.height < n.height ? cc.log("Inner height <= ScrollView height, it will be force sized!") : s = t.height, e.setContentSize(cc.size(r, s));
    var o = (this || window)._innerContainer.getPosition(), a = (this || window)._innerContainer.getAnchorPoint();
    this._innerContainer.getLeftBoundary() != 0 && (o.x = a.x * r), this._innerContainer.getTopBoundary() != (this || window)._contentSize.height && (o.y = (this || window)._contentSize.height - (1 - a.y) * s), this.setInnerContainerPosition(o), this._updateScrollBar(cc.p(0, 0));
  },
  _setInnerWidth: function(t) {
    var e = (this || window)._contentSize.width, n = e, r = (this || window)._innerContainer, s = r.width;
    switch (t < e ? cc.log("Inner width <= scrollview width, it will be force sized!") : n = t, r.width = n, this._direction) {
      case ccui.ScrollView.DIR_HORIZONTAL:
      case ccui.ScrollView.DIR_BOTH:
        if (r.getRightBoundary() <= e) {
          var o = r.width, a = s - o;
          this._scrollChildren(a, 0);
        }
        break;
    }
    var c = r.anchorX;
    r.getLeftBoundary() > 0 && (r.x = c * n), r.getRightBoundary() < e && (r.x = e - (1 - c) * n);
  },
  _setInnerHeight: function(t) {
    var e = (this || window)._contentSize.height, n = e, r = (this || window)._innerContainer, s = r.height;
    switch (t < e ? cc.log("Inner height <= scrollview height, it will be force sized!") : n = t, r.height = n, this._direction) {
      case ccui.ScrollView.DIR_VERTICAL:
      case ccui.ScrollView.DIR_BOTH:
        var o = n, a = s - o;
        this._scrollChildren(0, a);
        break;
    }
    var c = r.anchorY;
    r.getLeftBoundary() > 0 && (r.y = c * n), r.getRightBoundary() < e && (r.y = e - (1 - c) * n);
  },
  setInnerContainerPosition: function(t) {
    if (!(t.x === (this || window)._innerContainer.getPositionX() && t.y === (this || window)._innerContainer.getPositionY())) {
      if (this._innerContainer.setPosition(t), this._outOfBoundaryAmountDirty = !0, this.bounceEnabled)
        for (var e = ccui.ScrollView.MOVEDIR_TOP; e < ccui.ScrollView.MOVEDIR_RIGHT; ++e)
          this._isOutOfBoundary(e) && this._processScrollEvent(e, !0);
      this._dispatchEvent(ccui.ScrollView.EVENT_CONTAINER_MOVED);
    }
  },
  getInnerContainerPosition: function() {
    return this._innerContainer.getPosition();
  },
  getInnerContainerSize: function() {
    return this._innerContainer.getContentSize();
  },
  _getInnerWidth: function() {
    return this._innerContainer.width;
  },
  _getInnerHeight: function() {
    return this._innerContainer.height;
  },
  _isInContainer: function(t) {
    if (!this._clippingEnabled)
      return !0;
    var e = t._position, n = t._contentSize, r = t._anchorPoint, s = (this || window)._customSize, o = (this || window)._innerContainer._position, a = 0, c = 0;
    return !((a = e.y - r.y * n.height) >= s.height - o.y || a + n.height <= -o.y || (c = e.x - r.x * n.width) >= s.width - o.x || c + n.width <= -o.x);
  },
  updateChildren: function() {
    var t, e, n, r = (this || window)._innerContainer._children;
    for (e = 0, n = r.length; e < n; e++)
      t = r[e], t._inViewRect === !0 && this._isInContainer(t) === !1 ? t._inViewRect = !1 : t._inViewRect === !1 && this._isInContainer(t) === !0 && (t._inViewRect = !0);
  },
  addChild: function(t, e, n) {
    return t ? (this._isInContainer(t) === !1 && (t._inViewRect = !1), e = e || t.getLocalZOrder(), n = n || t.getTag(), this._innerContainer.addChild(t, e, n)) : !1;
  },
  removeAllChildren: function() {
    this.removeAllChildrenWithCleanup(!0);
  },
  removeAllChildrenWithCleanup: function(t) {
    this._innerContainer.removeAllChildrenWithCleanup(t);
  },
  removeChild: function(t, e) {
    return this._innerContainer.removeChild(t, e);
  },
  getChildren: function() {
    return this._innerContainer.getChildren();
  },
  getChildrenCount: function() {
    return this._innerContainer.getChildrenCount();
  },
  getChildByTag: function(t) {
    return this._innerContainer.getChildByTag(t);
  },
  getChildByName: function(t) {
    return this._innerContainer.getChildByName(t);
  },
  _flattenVectorByDirection: function(t) {
    var e = cc.p(0, 0);
    return e.x = (this || window)._direction === ccui.ScrollView.DIR_VERTICAL ? 0 : t.x, e.y = (this || window)._direction === ccui.ScrollView.DIR_HORIZONTAL ? 0 : t.y, e;
  },
  _getHowMuchOutOfBoundary: function(t) {
    if (t === void 0 && (t = cc.p(0, 0)), t.x === 0 && t.y === 0 && !this._outOfBoundaryAmountDirty)
      return this._outOfBoundaryAmount;
    var e = cc.p(0, 0);
    return this._innerContainer.getLeftBoundary() + t.x > this._leftBoundary ? e.x = (this || window)._leftBoundary - (this._innerContainer.getLeftBoundary() + t.x) : this._innerContainer.getRightBoundary() + t.x < this._rightBoundary && (e.x = (this || window)._rightBoundary - (this._innerContainer.getRightBoundary() + t.x)), this._innerContainer.getTopBoundary() + t.y < this._topBoundary ? e.y = (this || window)._topBoundary - (this._innerContainer.getTopBoundary() + t.y) : this._innerContainer.getBottomBoundary() + t.y > this._bottomBoundary && (e.y = (this || window)._bottomBoundary - (this._innerContainer.getBottomBoundary() + t.y)), t.x === 0 && t.y === 0 && (this._outOfBoundaryAmount = e, this._outOfBoundaryAmountDirty = !1), e;
  },
  _isOutOfBoundary: function(t) {
    var e = (this || window)._getHowMuchOutOfBoundary();
    if (t !== void 0)
      switch (t) {
        case ccui.ScrollView.MOVEDIR_TOP:
          return e.y > 0;
        case ccui.ScrollView.MOVEDIR_BOTTOM:
          return e.y < 0;
        case ccui.ScrollView.MOVEDIR_LEFT:
          return e.x < 0;
        case ccui.ScrollView.MOVEDIR_RIGHT:
          return e.x > 0;
      }
    else
      return !this._fltEqualZero(e);
    return !1;
  },
  _moveInnerContainer: function(t, e) {
    var n = (this || window)._flattenVectorByDirection(t);
    this.setInnerContainerPosition(cc.pAdd(this.getInnerContainerPosition(), n));
    var r = (this || window)._getHowMuchOutOfBoundary();
    this._updateScrollBar(r), this.bounceEnabled && e && this._startBounceBackIfNeeded();
  },
  _updateScrollBar: function(t) {
    this._verticalScrollBar && this._verticalScrollBar.onScrolled(t), this._horizontalScrollBar && this._horizontalScrollBar.onScrolled(t);
  },
  _calculateTouchMoveVelocity: function() {
    for (var t = 0, e = 0; e < this._touchMoveTimeDeltas.length; ++e)
      t += (this || window)._touchMoveTimeDeltas[e];
    if (t == 0 || t >= (this || window)._touchTotalTimeThreshold)
      return cc.p(0, 0);
    for (var n = cc.p(0, 0), e = 0; e < this._touchMoveDisplacements.length; ++e)
      n.x += (this || window)._touchMoveDisplacements[e].x, n.y += (this || window)._touchMoveDisplacements[e].y;
    return cc.pMult(n, 1 / t);
  },
  setTouchTotalTimeThreshold: function(t) {
    this._touchTotalTimeThreshold = t;
  },
  getTouchTotalTimeThreshold: function() {
    return this._touchTotalTimeThreshold;
  },
  _startInertiaScroll: function(t) {
    var e = 0.7, n = cc.pMult(t, e);
    this._startAttenuatingAutoScroll(n, t);
  },
  _startBounceBackIfNeeded: function() {
    if (!this.bounceEnabled)
      return !1;
    var t = (this || window)._getHowMuchOutOfBoundary();
    if (this._fltEqualZero(t))
      return !1;
    var e = 1;
    return this._startAutoScroll(t, e, !0), !0;
  },
  _startAutoScrollToDestination: function(t, e, n) {
    this._startAutoScroll(cc.pSub(t, this._innerContainer.getPosition()), e, n);
  },
  _calculateAutoScrollTimeByInitialSpeed: function(t) {
    return Math.sqrt(Math.sqrt(t / 5));
  },
  _startAttenuatingAutoScroll: function(t, e) {
    var n = (this || window)._calculateAutoScrollTimeByInitialSpeed(cc.pLength(e));
    this._startAutoScroll(t, n, !0);
  },
  _startAutoScroll: function(t, e, n) {
    var r = (this || window)._flattenVectorByDirection(t);
    this._autoScrolling = !0, this._autoScrollTargetDelta = r, this._autoScrollAttenuate = n, this._autoScrollStartPosition = (this || window)._innerContainer.getPosition(), this._autoScrollTotalTime = e, this._autoScrollAccumulatedTime = 0, this._autoScrollBraking = !1, this._autoScrollBrakingStartPosition = cc.p(0, 0);
    var s = (this || window)._getHowMuchOutOfBoundary();
    if (!this._fltEqualZero(s)) {
      this._autoScrollCurrentlyOutOfBoundary = !0;
      var o = (this || window)._getHowMuchOutOfBoundary(r);
      (s.x * o.x > 0 || s.y * o.y > 0) && (this._autoScrollBraking = !0);
    }
  },
  stopAutoScroll: function() {
    this._autoScrolling = !1, this._autoScrollAttenuate = !0, this._autoScrollTotalTime = 0, this._autoScrollAccumulatedTime = 0;
  },
  _isNecessaryAutoScrollBrake: function() {
    if (this._autoScrollBraking)
      return !0;
    if (this._isOutOfBoundary()) {
      if (!this._autoScrollCurrentlyOutOfBoundary)
        return this._autoScrollCurrentlyOutOfBoundary = !0, this._autoScrollBraking = !0, this._autoScrollBrakingStartPosition = (this || window).getInnerContainerPosition(), !0;
    } else
      this._autoScrollCurrentlyOutOfBoundary = !1;
    return !1;
  },
  _getAutoScrollStopEpsilon: function() {
    return 1e-4;
  },
  _fltEqualZero: function(t) {
    return Math.abs(t.x) <= 1e-4 && Math.abs(t.y) <= 1e-4;
  },
  _processAutoScrolling: function(t) {
    var e = 0.05, n = (this || window)._isNecessaryAutoScrollBrake() ? e : 1;
    this._autoScrollAccumulatedTime += t * (1 / n);
    var r = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
    this._autoScrollAttenuate && (r -= 1, r = r * r * r * r * r + 1);
    var s = cc.pAdd(this._autoScrollStartPosition, cc.pMult(this._autoScrollTargetDelta, r)), o = Math.abs(r - 1) <= (this || window)._getAutoScrollStopEpsilon();
    if (this.bounceEnabled)
      s = cc.pAdd(this._autoScrollBrakingStartPosition, cc.pMult(cc.pSub(s, this._autoScrollBrakingStartPosition), n));
    else {
      var a = cc.pSub(s, this.getInnerContainerPosition()), c = (this || window)._getHowMuchOutOfBoundary(a);
      this._fltEqualZero(c) || (s.x += c.x, s.y += c.y, o = !0);
    }
    o && (this._autoScrolling = !1, this._dispatchEvent(ccui.ScrollView.EVENT_AUTOSCROLL_ENDED)), this._moveInnerContainer(cc.pSub(s, this.getInnerContainerPosition()), o);
  },
  _jumpToDestination: function(t, e) {
    t.x === void 0 && (t = cc.p(t, e)), this._autoScrolling = !1, this._moveInnerContainer(cc.pSub(t, this.getInnerContainerPosition()), !0);
  },
  _scrollChildren: function(t) {
    var e = t;
    if (this.bounceEnabled) {
      var n = (this || window)._getHowMuchOutOfBoundary();
      e.x *= n.x == 0 ? 1 : 0.5, e.y *= n.y == 0 ? 1 : 0.5;
    }
    if (!this.bounceEnabled) {
      var n = (this || window)._getHowMuchOutOfBoundary(e);
      e.x += n.x, e.y += n.y;
    }
    var r = !1, s = !1, o = !1, a = !1;
    if (e.y > 0) {
      var c = (this || window)._innerContainer.getBottomBoundary();
      c + e.y >= (this || window)._bottomBoundary && (a = !0);
    } else if (e.y < 0) {
      var l = (this || window)._innerContainer.getTopBoundary();
      l + e.y <= (this || window)._topBoundary && (o = !0);
    }
    if (e.x < 0) {
      var h = (this || window)._innerContainer.getRightBoundary();
      h + e.x <= (this || window)._rightBoundary && (s = !0);
    } else if (e.x > 0) {
      var u = (this || window)._innerContainer.getLeftBoundary();
      u + e.x >= (this || window)._leftBoundary && (r = !0);
    }
    this._moveInnerContainer(e, !1), (e.x != 0 || e.y != 0) && this._processScrollingEvent(), a && this._processScrollEvent(ccui.ScrollView.MOVEDIR_BOTTOM, !1), o && this._processScrollEvent(ccui.ScrollView.MOVEDIR_TOP, !1), r && this._processScrollEvent(ccui.ScrollView.MOVEDIR_LEFT, !1), s && this._processScrollEvent(ccui.ScrollView.MOVEDIR_RIGHT, !1);
  },
  scrollToBottom: function(t, e) {
    this._startAutoScrollToDestination(cc.p(this._innerContainer.getPositionX(), 0), t, e);
  },
  scrollToTop: function(t, e) {
    this._startAutoScrollToDestination(
      cc.p(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height),
      t,
      e
    );
  },
  scrollToLeft: function(t, e) {
    this._startAutoScrollToDestination(cc.p(0, this._innerContainer.getPositionY()), t, e);
  },
  scrollToRight: function(t, e) {
    this._startAutoScrollToDestination(
      cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY()),
      t,
      e
    );
  },
  scrollToTopLeft: function(t, e) {
    if (this._direction !== ccui.ScrollView.DIR_BOTH) {
      cc.log("Scroll direction is not both!");
      return;
    }
    this._startAutoScrollToDestination(cc.p(0, this._contentSize.height - this._innerContainer.getContentSize().height), t, e);
  },
  scrollToTopRight: function(t, e) {
    if (this._direction !== ccui.ScrollView.DIR_BOTH) {
      cc.log("Scroll direction is not both!");
      return;
    }
    var n = (this || window)._innerContainer.getContentSize();
    this._startAutoScrollToDestination(cc.p(
      this._contentSize.width - n.width,
      this._contentSize.height - n.height
    ), t, e);
  },
  scrollToBottomLeft: function(t, e) {
    if (this._direction !== ccui.ScrollView.DIR_BOTH) {
      cc.log("Scroll direction is not both!");
      return;
    }
    this._startAutoScrollToDestination(cc.p(0, 0), t, e);
  },
  scrollToBottomRight: function(t, e) {
    if (this._direction !== ccui.ScrollView.DIR_BOTH) {
      cc.log("Scroll direction is not both!");
      return;
    }
    this._startAutoScrollToDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, 0), t, e);
  },
  scrollToPercentVertical: function(t, e, n) {
    var r = (this || window)._contentSize.height - this._innerContainer.getContentSize().height, s = -r;
    this._startAutoScrollToDestination(cc.p(this._innerContainer.getPositionX(), r + t * s / 100), e, n);
  },
  scrollToPercentHorizontal: function(t, e, n) {
    var r = (this || window)._innerContainer.getContentSize().width - this._contentSize.width;
    this._startAutoScrollToDestination(cc.p(-(t * r / 100), this._innerContainer.getPositionY()), e, n);
  },
  scrollToPercentBothDirection: function(t, e, n) {
    if (this._direction === ccui.ScrollView.DIR_BOTH) {
      var r = (this || window)._contentSize.height - this._innerContainer.getContentSize().height, s = -r, o = (this || window)._innerContainer.getContentSize().width - this._contentSize.width;
      this._startAutoScrollToDestination(cc.p(-(t.x * o / 100), r + t.y * s / 100), e, n);
    }
  },
  jumpToBottom: function() {
    this._jumpToDestination(this._innerContainer.getPositionX(), 0);
  },
  jumpToTop: function() {
    this._jumpToDestination(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height);
  },
  jumpToLeft: function() {
    this._jumpToDestination(0, this._innerContainer.getPositionY());
  },
  jumpToRight: function() {
    this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY());
  },
  jumpToTopLeft: function() {
    if (this._direction !== ccui.ScrollView.DIR_BOTH) {
      cc.log("Scroll _direction is not both!");
      return;
    }
    this._jumpToDestination(0, this._contentSize.height - this._innerContainer.getContentSize().height);
  },
  jumpToTopRight: function() {
    if (this._direction !== ccui.ScrollView.DIR_BOTH) {
      cc.log("Scroll _direction is not both!");
      return;
    }
    var t = (this || window)._innerContainer.getContentSize();
    this._jumpToDestination(this._contentSize.width - t.width, this._contentSize.height - t.height);
  },
  jumpToBottomLeft: function() {
    if (this._direction !== ccui.ScrollView.DIR_BOTH) {
      cc.log("Scroll _direction is not both!");
      return;
    }
    this._jumpToDestination(0, 0);
  },
  jumpToBottomRight: function() {
    if (this._direction !== ccui.ScrollView.DIR_BOTH) {
      cc.log("Scroll _direction is not both!");
      return;
    }
    this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, 0);
  },
  jumpToPercentVertical: function(t) {
    var e = (this || window)._contentSize.height - this._innerContainer.getContentSize().height, n = -e;
    this._jumpToDestination(this._innerContainer.getPositionX(), e + t * n / 100);
  },
  jumpToPercentHorizontal: function(t) {
    var e = (this || window)._innerContainer.getContentSize().width - this._contentSize.width;
    this._jumpToDestination(-(t * e / 100), this._innerContainer.getPositionY());
  },
  jumpToPercentBothDirection: function(t) {
    if (this._direction === ccui.ScrollView.DIR_BOTH) {
      var e = (this || window)._innerContainer.getContentSize(), n = (this || window)._contentSize.height - e.height, r = -n, s = e.width - this._contentSize.width;
      this._jumpToDestination(-(t.x * s / 100), n + t.y * r / 100);
    }
  },
  _gatherTouchMove: function(t) {
    for (var e = 5; this._touchMoveDisplacements.length >= e; )
      this._touchMoveDisplacements.splice(0, 1), this._touchMoveTimeDeltas.splice(0, 1);
    this._touchMoveDisplacements.push(t);
    var n = (/* @__PURE__ */ new Date()).getTime();
    this._touchMoveTimeDeltas.push((n - this._touchMovePreviousTimestamp) / 1e3), this._touchMovePreviousTimestamp = n;
  },
  _handlePressLogic: function(t) {
    this._bePressed = !0, this._autoScrolling = !1, this._touchMovePreviousTimestamp = (/* @__PURE__ */ new Date()).getTime(), this._touchMoveDisplacements.length = 0, this._touchMoveTimeDeltas.length = 0, this._verticalScrollBar && this._verticalScrollBar.onTouchBegan(), this._horizontalScrollBar && this._horizontalScrollBar.onTouchBegan();
  },
  _handleMoveLogic: function(t) {
    var e = (this || window).convertToNodeSpace(t.getLocation()), n = (this || window).convertToNodeSpace(t.getPreviousLocation()), r = cc.pSub(e, n);
    this._scrollChildren(r), this._gatherTouchMove(r);
  },
  _handleReleaseLogic: function(t) {
    var e = (this || window).convertToNodeSpace(t.getLocation()), n = (this || window).convertToNodeSpace(t.getPreviousLocation()), r = cc.pSub(e, n);
    this._gatherTouchMove(r), this._bePressed = !1;
    var s = (this || window)._startBounceBackIfNeeded();
    if (!s && this.inertiaScrollEnabled) {
      var o = (this || window)._calculateTouchMoveVelocity();
      (o.x !== 0 || o.y !== 0) && this._startInertiaScroll(o);
    }
    this._verticalScrollBar && this._verticalScrollBar.onTouchEnded(), this._horizontalScrollBar && this._horizontalScrollBar.onTouchEnded();
  },
  onTouchBegan: function(t, e) {
    var n = ccui.Layout.prototype.onTouchBegan.call(this, t, e);
    return this._isInterceptTouch || this._hit && this._handlePressLogic(t), n;
  },
  onTouchMoved: function(t, e) {
    ccui.Layout.prototype.onTouchMoved.call(this, t, e), this._isInterceptTouch || this._handleMoveLogic(t);
  },
  onTouchEnded: function(t, e) {
    ccui.Layout.prototype.onTouchEnded.call(this, t, e), this._isInterceptTouch || this._handleReleaseLogic(t), this._isInterceptTouch = !1;
  },
  onTouchCancelled: function(t, e) {
    ccui.Layout.prototype.onTouchCancelled.call(this, t, e), this._isInterceptTouch || this._handleReleaseLogic(t), this._isInterceptTouch = !1;
  },
  update: function(t) {
    this._autoScrolling && this._processAutoScrolling(t);
  },
  interceptTouchEvent: function(t, e, n) {
    if (!this._touchEnabled) {
      ccui.Layout.prototype.interceptTouchEvent.call(this, t, e, n);
      return;
    }
    if (this._direction !== ccui.ScrollView.DIR_NONE) {
      var r = n.getLocation();
      switch (t) {
        case ccui.Widget.TOUCH_BEGAN:
          this._isInterceptTouch = !0, this._touchBeganPosition.x = r.x, this._touchBeganPosition.y = r.y, this._handlePressLogic(n);
          break;
        case ccui.Widget.TOUCH_MOVED:
          var s = cc.pLength(cc.pSub(e.getTouchBeganPosition(), r));
          this._touchMovePosition.x = r.x, this._touchMovePosition.y = r.y, s > this._childFocusCancelOffset && (e.setHighlighted(!1), this._handleMoveLogic(n));
          break;
        case ccui.Widget.TOUCH_CANCELED:
        case ccui.Widget.TOUCH_ENDED:
          this._touchEndPosition.x = r.x, this._touchEndPosition.y = r.y, this._handleReleaseLogic(n), e.isSwallowTouches() && (this._isInterceptTouch = !1);
          break;
      }
    }
  },
  _processScrollEvent: function(t, e) {
    var n = 0;
    switch (t) {
      case ccui.ScrollView.MOVEDIR_TOP:
        n = e ? ccui.ScrollView.EVENT_BOUNCE_TOP : ccui.ScrollView.EVENT_SCROLL_TO_TOP;
        break;
      case ccui.ScrollView.MOVEDIR_BOTTOM:
        n = e ? ccui.ScrollView.EVENT_BOUNCE_BOTTOM : ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM;
        break;
      case ccui.ScrollView.MOVEDIR_LEFT:
        n = e ? ccui.ScrollView.EVENT_BOUNCE_LEFT : ccui.ScrollView.EVENT_SCROLL_TO_LEFT;
        break;
      case ccui.ScrollView.MOVEDIR_RIGHT:
        n = e ? ccui.ScrollView.EVENT_BOUNCE_RIGHT : ccui.ScrollView.EVENT_SCROLL_TO_RIGHT;
        break;
    }
    this._dispatchEvent(n);
  },
  _processScrollingEvent: function() {
    this._dispatchEvent(ccui.ScrollView.EVENT_SCROLLING);
  },
  _dispatchEvent: function(t) {
    this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, t) : this._scrollViewEventSelector(this, t)), this._ccEventCallback && this._ccEventCallback(this, t);
  },
  addEventListenerScrollView: function(t, e) {
    this._scrollViewEventSelector = t, this._scrollViewEventListener = e;
  },
  addEventListener: function(t) {
    this._ccEventCallback = t;
  },
  setDirection: function(t) {
    this._direction = t, this._scrollBarEnabled && (this._removeScrollBar(), this._initScrollBar());
  },
  getDirection: function() {
    return this._direction;
  },
  setBounceEnabled: function(t) {
    this.bounceEnabled = t;
  },
  isBounceEnabled: function() {
    return this.bounceEnabled;
  },
  setInertiaScrollEnabled: function(t) {
    this.inertiaScrollEnabled = t;
  },
  isInertiaScrollEnabled: function() {
    return this.inertiaScrollEnabled;
  },
  setScrollBarEnabled: function(t) {
    this._scrollBarEnabled !== t && (this._scrollBarEnabled && this._removeScrollBar(), this._scrollBarEnabled = t, this._scrollBarEnabled && this._initScrollBar());
  },
  isScrollBarEnabled: function() {
    return this._scrollBarEnabled;
  },
  setScrollBarPositionFromCorner: function(t) {
    this._direction !== ccui.ScrollView.DIR_HORIZONTAL && this.setScrollBarPositionFromCornerForVertical(t), this._direction !== ccui.ScrollView.DIR_VERTICAL && this.setScrollBarPositionFromCornerForHorizontal(t);
  },
  setScrollBarPositionFromCornerForVertical: function(t) {
    cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), cc.assert(this._direction !== ccui.ScrollView.DIR_HORIZONTAL, "Scroll view doesn't have a vertical scroll bar!"), this._verticalScrollBar.setPositionFromCorner(t);
  },
  getScrollBarPositionFromCornerForVertical: function() {
    return cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), cc.assert(this._direction !== ccui.ScrollView.DIR_HORIZONTAL, "Scroll view doesn't have a vertical scroll bar!"), this._verticalScrollBar.getPositionFromCorner();
  },
  setScrollBarPositionFromCornerForHorizontal: function(t) {
    cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), cc.assert(this._direction !== ccui.ScrollView.DIR_VERTICAL, "Scroll view doesn't have a horizontal scroll bar!"), this._horizontalScrollBar.setPositionFromCorner(t);
  },
  getScrollBarPositionFromCornerForHorizontal: function() {
    return cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), cc.assert(this._direction !== ccui.ScrollView.DIR_VERTICAL, "Scroll view doesn't have a horizontal scroll bar!"), this._horizontalScrollBar.getPositionFromCorner();
  },
  setScrollBarWidth: function(t) {
    cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar && this._verticalScrollBar.setWidth(t), this._horizontalScrollBar && this._horizontalScrollBar.setWidth(t);
  },
  getScrollBarWidth: function() {
    return cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar ? this._verticalScrollBar.getWidth() : this._horizontalScrollBar ? this._horizontalScrollBar.getWidth() : 0;
  },
  setScrollBarColor: function(t) {
    cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar && this._verticalScrollBar.setColor(t), this._horizontalScrollBar && this._horizontalScrollBar.setColor(t);
  },
  getScrollBarColor: function() {
    return cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar && this._verticalScrollBar.getColor(), this._horizontalScrollBar && this._horizontalScrollBar.getColor(), cc.color.WHITE;
  },
  setScrollBarOpacity: function(t) {
    cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar && (this._verticalScrollBar.opacity = t), this._horizontalScrollBar && (this._horizontalScrollBar.opacity = t);
  },
  getScrollBarOpacity: function() {
    return cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar ? this._verticalScrollBar.opacity : this._horizontalScrollBar ? this._horizontalScrollBar.opacity : -1;
  },
  setScrollBarAutoHideEnabled: function(t) {
    cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar && (this._verticalScrollBar.autoHideEnabled = t), this._horizontalScrollBar && (this._horizontalScrollBar.autoHideEnabled = t);
  },
  isScrollBarAutoHideEnabled: function() {
    return cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar ? this._verticalScrollBar.autoHideEnabled : this._horizontalScrollBar ? this._horizontalScrollBar.autoHideEnabled : !1;
  },
  setScrollBarAutoHideTime: function(t) {
    cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar && (this._verticalScrollBar.autoHideTime = t), this._horizontalScrollBar && (this._horizontalScrollBar.autoHideTime = t);
  },
  getScrollBarAutoHideTime: function() {
    return cc.assert(this._scrollBarEnabled, "Scroll bar should be enabled!"), this._verticalScrollBar ? this._verticalScrollBar.autoHideTime : this._horizontalScrollBar ? this._horizontalScrollBar.autoHideTime : 0;
  },
  getInnerContainer: function() {
    return this._innerContainer;
  },
  setLayoutType: function(t) {
    this._innerContainer.setLayoutType(t);
  },
  getLayoutType: function() {
    return this._innerContainer.getLayoutType();
  },
  _doLayout: function() {
    this._doLayoutDirty && (this._doLayoutDirty = !1);
  },
  getDescription: function() {
    return "ScrollView";
  },
  _createCloneInstance: function() {
    return new ccui.ScrollView();
  },
  _copyClonedWidgetChildren: function(t) {
    ccui.Layout.prototype._copyClonedWidgetChildren.call(this, t);
  },
  _copySpecialProperties: function(t) {
    t instanceof ccui.ScrollView && (ccui.Layout.prototype._copySpecialProperties.call(this, t), this.setInnerContainerSize(t.getInnerContainerSize()), this.setInnerContainerPosition(t.getInnerContainerPosition()), this.setDirection(t._direction), this._topBoundary = t._topBoundary, this._bottomBoundary = t._bottomBoundary, this._leftBoundary = t._leftBoundary, this._rightBoundary = t._rightBoundary, this._bePressed = t._bePressed, this._childFocusCancelOffset = t._childFocusCancelOffset, this._touchMoveDisplacements = t._touchMoveDisplacements, this._touchMoveTimeDeltas = t._touchMoveTimeDeltas, this._touchMovePreviousTimestamp = t._touchMovePreviousTimestamp, this._autoScrolling = t._autoScrolling, this._autoScrollAttenuate = t._autoScrollAttenuate, this._autoScrollStartPosition = t._autoScrollStartPosition, this._autoScrollTargetDelta = t._autoScrollTargetDelta, this._autoScrollTotalTime = t._autoScrollTotalTime, this._autoScrollAccumulatedTime = t._autoScrollAccumulatedTime, this._autoScrollCurrentlyOutOfBoundary = t._autoScrollCurrentlyOutOfBoundary, this._autoScrollBraking = t._autoScrollBraking, this._autoScrollBrakingStartPosition = t._autoScrollBrakingStartPosition, this.setBounceEnabled(t.bounceEnabled), this.setInertiaScrollEnabled(t.inertiaScrollEnabled), this._scrollViewEventListener = t._scrollViewEventListener, this._scrollViewEventSelector = t._scrollViewEventSelector, this._ccEventCallback = t._ccEventCallback, this.setScrollBarEnabled(t.isScrollBarEnabled()), this.isScrollBarEnabled() && (this._direction !== ccui.ScrollView.DIR_HORIZONTAL && this.setScrollBarPositionFromCornerForVertical(t.getScrollBarPositionFromCornerForVertical()), this._direction !== ccui.ScrollView.DIR_VERTICAL && this.setScrollBarPositionFromCornerForHorizontal(t.getScrollBarPositionFromCornerForHorizontal()), this.setScrollBarWidth(t.getScrollBarWidth()), this.setScrollBarColor(t.getScrollBarColor()), this.setScrollBarAutoHideEnabled(t.isScrollBarAutoHideEnabled()), this.setScrollBarAutoHideTime(t.getScrollBarAutoHideTime())));
  },
  _initScrollBar: function() {
    this._direction !== ccui.ScrollView.DIR_HORIZONTAL && !this._verticalScrollBar && (this._verticalScrollBar = new ccui.ScrollViewBar(this, ccui.ScrollView.DIR_VERTICAL), this.addProtectedChild(this._verticalScrollBar, 2)), this._direction !== ccui.ScrollView.DIR_VERTICAL && !this._horizontalScrollBar && (this._horizontalScrollBar = new ccui.ScrollViewBar(this, ccui.ScrollView.DIR_HORIZONTAL), this.addProtectedChild(this._horizontalScrollBar, 2));
  },
  _removeScrollBar: function() {
    this._verticalScrollBar && (this.removeProtectedChild(this._verticalScrollBar), this._verticalScrollBar = null), this._horizontalScrollBar && (this.removeProtectedChild(this._horizontalScrollBar), this._horizontalScrollBar = null);
  },
  getNodeByTag: function(t) {
    return this._innerContainer.getNodeByTag(t);
  },
  getNodes: function() {
    return this._innerContainer.getNodes();
  },
  removeNode: function(t) {
    this._innerContainer.removeNode(t);
  },
  removeNodeByTag: function(t) {
    this._innerContainer.removeNodeByTag(t);
  },
  removeAllNodes: function() {
    this._innerContainer.removeAllNodes();
  },
  addNode: function(t, e, n) {
    this._innerContainer.addNode(t, e, n);
  }
});
var _p = ccui.ScrollView.prototype;
_p.innerWidth;
cc.defineGetterSetter(_p, "innerWidth", _p._getInnerWidth, _p._setInnerWidth);
_p.innerHeight;
cc.defineGetterSetter(_p, "innerHeight", _p._getInnerHeight, _p._setInnerHeight);
_p.direction;
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
_p.touchTotalTimeThreshold;
cc.defineGetterSetter(_p, "touchTotalTimeThreshold", _p.getTouchTotalTimeThreshold, _p.setTouchTotalTimeThreshold);
_p = null;
ccui.ScrollView.create = function() {
  return new ccui.ScrollView();
};
ccui.ScrollView.DIR_NONE = 0;
ccui.ScrollView.DIR_VERTICAL = 1;
ccui.ScrollView.DIR_HORIZONTAL = 2;
ccui.ScrollView.DIR_BOTH = 3;
ccui.ScrollView.EVENT_SCROLL_TO_TOP = 0;
ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM = 1;
ccui.ScrollView.EVENT_SCROLL_TO_LEFT = 2;
ccui.ScrollView.EVENT_SCROLL_TO_RIGHT = 3;
ccui.ScrollView.EVENT_SCROLLING = 4;
ccui.ScrollView.EVENT_BOUNCE_TOP = 5;
ccui.ScrollView.EVENT_BOUNCE_BOTTOM = 6;
ccui.ScrollView.EVENT_BOUNCE_LEFT = 7;
ccui.ScrollView.EVENT_BOUNCE_RIGHT = 8;
ccui.ScrollView.EVENT_CONTAINER_MOVED = 9;
ccui.ScrollView.EVENT_AUTOSCROLL_ENDED = 10;
ccui.ScrollView.MOVEDIR_TOP = 0;
ccui.ScrollView.MOVEDIR_BOTTOM = 1;
ccui.ScrollView.MOVEDIR_LEFT = 2;
ccui.ScrollView.MOVEDIR_RIGHT = 3;
(function() {
  if (ccui.ProtectedNode.CanvasRenderCmd) {
    ccui.ScrollView.CanvasRenderCmd = function(e) {
      ccui.Layout.CanvasRenderCmd.call(this, e), this._dirty = !1;
    };
    var t = ccui.ScrollView.CanvasRenderCmd.prototype = Object.create(ccui.Layout.CanvasRenderCmd.prototype);
    t.constructor = ccui.ScrollView.CanvasRenderCmd, t.visit = function(e) {
      var n = (this || window)._node;
      n._visible && (n.__instanceId, cc.renderer.pushRenderCommand(this), this.layoutVisit(e), this._dirtyFlag = 0);
    }, t.rendering = function(e) {
      var n = (this || window)._node.__instanceId, r = cc.renderer._cacheToCanvasCmds[n], s, o, a = cc.view.getScaleX(), c = cc.view.getScaleY(), l = e || cc._renderContext;
      for (l.computeRealOffsetY(), this._node.updateChildren(), s = 0, o = r.length; s < o; s++) {
        var h = r[s]._node;
        h instanceof ccui.ScrollView || h && h._parent && h._parent._inViewRect === !1 || r[s].rendering(l, a, c);
      }
    };
  }
})();
(function() {
  if (ccui.ProtectedNode.WebGLRenderCmd) {
    ccui.ScrollView.WebGLRenderCmd = function(e) {
      ccui.Layout.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._dirty = !1;
    };
    var t = ccui.ScrollView.WebGLRenderCmd.prototype = Object.create(ccui.Layout.WebGLRenderCmd.prototype);
    t.constructor = ccui.ScrollView.WebGLRenderCmd, t.visit = function(e) {
      var n = (this || window)._node;
      if (n._visible) {
        var r = (this || window)._node.__instanceId;
        cc.renderer.pushRenderCommand(this), cc.renderer._turnToCacheMode(r), this.layoutVisit(e), n.updateChildren(), this._dirtyFlag = 0, cc.renderer._turnToNormalMode();
      }
    }, t.rendering = function(e) {
      var n = (this || window)._node.__instanceId, r = cc.renderer._cacheToBufferCmds[n], s, o, a, c, l = e || cc._renderContext;
      if (r)
        for (this._node.updateChildren(), l.bindBuffer(gl.ARRAY_BUFFER, null), s = 0, o = r.length; s < o; s++)
          c = r[s], a = c._node, !(a instanceof ccui.ScrollView) && (a && a._parent && a._parent._inViewRect === !1 || (c.uploadData ? cc.renderer._uploadBufferData(c) : (c._batchingSize > 0 && cc.renderer._batchRendering(), c.rendering(l)), cc.renderer._batchRendering()));
    };
  }
})();
ccui.ListView = ccui.ScrollView.extend({
  _model: null,
  _items: null,
  _gravity: null,
  _itemsMargin: 0,
  _curSelectedIndex: 0,
  _refreshViewDirty: !0,
  _listViewEventListener: null,
  _listViewEventSelector: null,
  _ccListViewEventCallback: null,
  _magneticAllowedOutOfBoundary: !0,
  _magneticType: 0,
  _className: "ListView",
  ctor: function() {
    this._items = [], ccui.ScrollView.prototype.ctor.call(this), this._gravity = ccui.ListView.GRAVITY_CENTER_VERTICAL, this.setTouchEnabled(!0), this.setDirection(ccui.ScrollView.DIR_VERTICAL);
  },
  setItemModel: function(t) {
    if (!t) {
      cc.log("Can't set a null to item model!");
      return;
    }
    this._model = t;
  },
  _handleReleaseLogic: function(t) {
    ccui.ScrollView.prototype._handleReleaseLogic.call(this, t), this._autoScrolling || this._startMagneticScroll();
  },
  _onItemListChanged: function() {
    this._outOfBoundaryAmountDirty = !0;
  },
  _updateInnerContainerSize: function() {
    var t = (this || window)._items, e, n;
    switch (this.direction) {
      case ccui.ScrollView.DIR_VERTICAL:
        e = t.length;
        var r = (e - 1) * this._itemsMargin;
        for (n = 0; n < e; n++)
          r += t[n].getContentSize().height;
        this.setInnerContainerSize(cc.size(this._contentSize.width, r));
        break;
      case ccui.ScrollView.DIR_HORIZONTAL:
        e = t.length;
        var s = (e - 1) * this._itemsMargin;
        for (n = 0; n < e; n++)
          s += t[n].getContentSize().width;
        this.setInnerContainerSize(cc.size(s, this._contentSize.height));
        break;
    }
  },
  _remedyLayoutParameter: function(t) {
    cc.assert(t != null, "ListView Item can't be nil!");
    var e = t.getLayoutParameter(ccui.LayoutParameter.LINEAR), n = !0;
    e || (e = new ccui.LinearLayoutParameter(), n = !1);
    var r = (this || window).getIndex(t);
    switch (this.direction) {
      case ccui.ScrollView.DIR_VERTICAL:
        this._remedyVerticalLayoutParameter(e, r);
        break;
      case ccui.ScrollView.DIR_HORIZONTAL:
        this._remedyHorizontalLayoutParameter(e, r);
        break;
    }
    n || t.setLayoutParameter(e);
  },
  _remedyVerticalLayoutParameter: function(t, e) {
    switch (cc.assert(t != null, "Layout parameter can't be nil!"), this._gravity) {
      case ccui.ListView.GRAVITY_LEFT:
        t.setGravity(ccui.LinearLayoutParameter.LEFT);
        break;
      case ccui.ListView.GRAVITY_RIGHT:
        t.setGravity(ccui.LinearLayoutParameter.RIGHT);
        break;
      case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
        t.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL);
        break;
    }
    e === 0 ? t.setMargin(ccui.MarginZero()) : t.setMargin(new ccui.Margin(0, this._itemsMargin, 0, 0));
  },
  _remedyHorizontalLayoutParameter: function(t, e) {
    switch (cc.assert(t != null, "Layout parameter can't be nil!"), this._gravity) {
      case ccui.ListView.GRAVITY_TOP:
        t.setGravity(ccui.LinearLayoutParameter.TOP);
        break;
      case ccui.ListView.GRAVITY_BOTTOM:
        t.setGravity(ccui.LinearLayoutParameter.BOTTOM);
        break;
      case ccui.ListView.GRAVITY_CENTER_VERTICAL:
        t.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL);
        break;
    }
    e === 0 ? t.setMargin(ccui.MarginZero()) : t.setMargin(new ccui.Margin(this._itemsMargin, 0, 0, 0));
  },
  pushBackDefaultItem: function() {
    if (this._model != null) {
      var t = (this || window)._model.clone();
      this._remedyLayoutParameter(t), this.addChild(t), this._refreshViewDirty = !0;
    }
  },
  insertDefaultItem: function(t) {
    if (this._model != null) {
      var e = (this || window)._model.clone();
      this._items.splice(t, 0, e), ccui.ScrollView.prototype.addChild.call(this, e), this._remedyLayoutParameter(e), this._refreshViewDirty = !0;
    }
  },
  pushBackCustomItem: function(t) {
    this._remedyLayoutParameter(t), this.addChild(t), this._refreshViewDirty = !0;
  },
  addChild: function(t, e, n) {
    t && (e = e || t.getLocalZOrder(), n = n || t.getName(), ccui.ScrollView.prototype.addChild.call(this, t, e, n), t instanceof ccui.Widget && (this._items.push(t), this._onItemListChanged()));
  },
  removeChild: function(t, e) {
    if (t) {
      var n = (this || window)._items.indexOf(t);
      n > -1 && this._items.splice(n, 1), this._onItemListChanged(), ccui.ScrollView.prototype.removeChild.call(this, t, e);
    }
  },
  removeAllChildren: function() {
    this.removeAllChildrenWithCleanup(!0);
  },
  removeAllChildrenWithCleanup: function(t) {
    ccui.ScrollView.prototype.removeAllChildrenWithCleanup.call(this, t), this._items = [], this._onItemListChanged();
  },
  insertCustomItem: function(t, e) {
    this._items.splice(e, 0, t), this._onItemListChanged(), ccui.ScrollView.prototype.addChild.call(this, t), this._remedyLayoutParameter(t), this._refreshViewDirty = !0;
  },
  removeItem: function(t) {
    var e = (this || window).getItem(t);
    e != null && (this.removeChild(e, !0), this._refreshViewDirty = !0);
  },
  removeLastItem: function() {
    this.removeItem(this._items.length - 1);
  },
  removeAllItems: function() {
    this.removeAllChildren();
  },
  getItem: function(t) {
    return t < 0 || t >= (this || window)._items.length ? null : this._items[t];
  },
  getItems: function() {
    return this._items;
  },
  getIndex: function(t) {
    return t == null ? -1 : this._items.indexOf(t);
  },
  setGravity: function(t) {
    this._gravity !== t && (this._gravity = t, this._refreshViewDirty = !0);
  },
  setMagneticType: function(t) {
    this._magneticType = t, this._onItemListChanged(), this._startMagneticScroll();
  },
  getMagneticType: function() {
    return this._magneticType;
  },
  setMagneticAllowedOutOfBoundary: function(t) {
    this._magneticAllowedOutOfBoundary = t;
  },
  getMagneticAllowedOutOfBoundary: function() {
    return this._magneticAllowedOutOfBoundary;
  },
  setItemsMargin: function(t) {
    this._itemsMargin !== t && (this._itemsMargin = t, this._refreshViewDirty = !0);
  },
  getItemsMargin: function() {
    return this._itemsMargin;
  },
  setDirection: function(t) {
    switch (t) {
      case ccui.ScrollView.DIR_VERTICAL:
        this.setLayoutType(ccui.Layout.LINEAR_VERTICAL);
        break;
      case ccui.ScrollView.DIR_HORIZONTAL:
        this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL);
        break;
      case ccui.ScrollView.DIR_BOTH:
        return;
      default:
        return;
    }
    ccui.ScrollView.prototype.setDirection.call(this, t);
  },
  _getHowMuchOutOfBoundary: function(t) {
    if (t === void 0 && (t = cc.p(0, 0)), !this._magneticAllowedOutOfBoundary || this._items.length === 0)
      return ccui.ScrollView.prototype._getHowMuchOutOfBoundary.call(this, t);
    if (this._magneticType === ccui.ListView.MAGNETIC_NONE || this._magneticType === ccui.ListView.MAGNETIC_BOTH_END)
      return ccui.ScrollView.prototype._getHowMuchOutOfBoundary.call(this, t);
    if (t.x === 0 && t.y === 0 && !this._outOfBoundaryAmountDirty)
      return this._outOfBoundaryAmount;
    var e = (this || window)._leftBoundary, n = (this || window)._rightBoundary, r = (this || window)._topBoundary, s = (this || window)._bottomBoundary, o = (this || window)._items.length - 1, a = (this || window).getContentSize(), c = cc.p(0, 0), l = cc.p(0, 0);
    switch (this._magneticType) {
      case ccui.ListView.MAGNETIC_CENTER:
        c.x = (a.width - this._items[0].width) / 2, c.y = (a.height - this._items[0].height) / 2, l.x = (a.width - this._items[o].width) / 2, l.y = (a.height - this._items[o].height) / 2;
        break;
      case ccui.ListView.MAGNETIC_LEFT:
      case ccui.ListView.MAGNETIC_TOP:
        l.x = a.width - this._items[o].width, l.y = a.height - this._items[o].height;
        break;
      case ccui.ListView.MAGNETIC_RIGHT:
      case ccui.ListView.MAGNETIC_BOTTOM:
        c.x = a.width - this._items[0].width, c.y = a.height - this._items[0].height;
        break;
    }
    e += c.x, n -= l.x, r -= c.y, s += l.y;
    var h = cc.p(0, 0);
    return this._innerContainer.getLeftBoundary() + t.x > e ? h.x = e - (this._innerContainer.getLeftBoundary() + t.x) : this._innerContainer.getRightBoundary() + t.x < n && (h.x = n - (this._innerContainer.getRightBoundary() + t.x)), this._innerContainer.getTopBoundary() + t.y < r ? h.y = r - (this._innerContainer.getTopBoundary() + t.y) : this._innerContainer.getBottomBoundary() + t.y > s && (h.y = s - (this._innerContainer.getBottomBoundary() + t.y)), t.x === 0 && t.y === 0 && (this._outOfBoundaryAmount = h, this._outOfBoundaryAmountDirty = !1), h;
  },
  _calculateItemPositionWithAnchor: function(t, e) {
    var n = cc.p(t.getLeftBoundary(), t.getBottomBoundary()), r = t.getContentSize();
    return cc.p(n.x + r.width * e.x, n.y + r.height * e.y);
  },
  _findClosestItem: function(t, e, n, r, s, o, a) {
    if (cc.assert(r >= 0 && o < e.length && r <= o, ""), r === o)
      return e[r];
    if (o - r === 1)
      return s <= a ? e[r] : e[o];
    var c = Math.floor((r + o) / 2), l = (this || window)._calculateItemPositionWithAnchor(e[c], n), h = cc.pLength(cc.pSub(t, l));
    return s <= a ? this._findClosestItem(t, e, n, r, s, c, h) : this._findClosestItem(t, e, n, c, h, o, a);
  },
  getClosestItemToPosition: function(t, e) {
    if (this._items.length === 0)
      return null;
    var n = 0, r = (this || window)._calculateItemPositionWithAnchor(this._items[n], e), s = cc.pLength(cc.pSub(t, r)), o = (this || window)._items.length - 1, a = (this || window)._calculateItemPositionWithAnchor(this._items[o], e), c = cc.pLength(cc.pSub(t, a));
    return this._findClosestItem(t, this._items, e, n, s, o, c);
  },
  getClosestItemToPositionInCurrentView: function(t, e) {
    var n = (this || window).getContentSize(), r = cc.pMult(this._innerContainer.getPosition(), -1);
    return r.x += n.width * t.x, r.y += n.height * t.y, this.getClosestItemToPosition(r, e);
  },
  getCenterItemInCurrentView: function() {
    return this.getClosestItemToPositionInCurrentView(cc.p(0.5, 0.5), cc.p(0.5, 0.5));
  },
  getLeftmostItemInCurrentView: function() {
    return this._direction === ccui.ScrollView.DIR_HORIZONTAL ? this.getClosestItemToPositionInCurrentView(cc.p(0, 0.5), cc.p(0.5, 0.5)) : null;
  },
  getRightmostItemInCurrentView: function() {
    return this._direction === ccui.ScrollView.DIR_HORIZONTAL ? this.getClosestItemToPositionInCurrentView(cc.p(1, 0.5), cc.p(0.5, 0.5)) : null;
  },
  getTopmostItemInCurrentView: function() {
    return this._direction === ccui.ScrollView.DIR_VERTICAL ? this.getClosestItemToPositionInCurrentView(cc.p(0.5, 1), cc.p(0.5, 0.5)) : null;
  },
  getBottommostItemInCurrentView: function() {
    return this._direction === ccui.ScrollView.DIR_VERTICAL ? this.getClosestItemToPositionInCurrentView(cc.p(0.5, 0), cc.p(0.5, 0.5)) : null;
  },
  _calculateItemDestination: function(t, e, n) {
    var r = (this || window).getContentSize(), s = cc.p(0, 0);
    s.x += r.width * t.x, s.y += r.height * t.y;
    var o = (this || window)._calculateItemPositionWithAnchor(e, n);
    return cc.pMult(cc.pSub(o, s), -1);
  },
  jumpToBottom: function() {
    this.doLayout(), ccui.ScrollView.prototype.jumpToBottom.call(this);
  },
  jumpToTop: function() {
    this.doLayout(), ccui.ScrollView.prototype.jumpToTop.call(this);
  },
  jumpToLeft: function() {
    this.doLayout(), ccui.ScrollView.prototype.jumpToLeft.call(this);
  },
  jumpToRight: function() {
    this.doLayout(), ccui.ScrollView.prototype.jumpToRight.call(this);
  },
  jumpToTopLeft: function() {
    this.doLayout(), ccui.ScrollView.prototype.jumpToTopLeft.call(this);
  },
  jumpToTopRight: function() {
    this.doLayout(), ccui.ScrollView.prototype.jumpToTopRight.call(this);
  },
  jumpToBottomLeft: function() {
    this.doLayout(), ccui.ScrollView.prototype.jumpToBottomLeft.call(this);
  },
  jumpToBottomRight: function() {
    this.doLayout(), ccui.ScrollView.prototype.jumpToBottomRight.call(this);
  },
  jumpToPercentVertical: function(t) {
    this.doLayout(), ccui.ScrollView.prototype.jumpToPercentVertical.call(this, t);
  },
  jumpToPercentHorizontal: function(t) {
    this.doLayout(), ccui.ScrollView.prototype.jumpToPercentHorizontal.call(this, t);
  },
  jumpToPercentBothDirection: function(t) {
    this.doLayout(), ccui.ScrollView.prototype.jumpToPercentBothDirection.call(this, t);
  },
  jumpToItem: function(t, e, n) {
    var r = (this || window).getItem(t);
    if (r) {
      this.doLayout();
      var s = (this || window)._calculateItemDestination(e, r, n);
      if (!this.bounceEnabled) {
        var o = cc.pSub(s, this._innerContainer.getPosition()), a = (this || window)._getHowMuchOutOfBoundary(o);
        s.x += a.x, s.y += a.y;
      }
      this._jumpToDestination(s);
    }
  },
  scrollToItem: function(t, e, n, r) {
    r === void 0 && (r = 1);
    var s = (this || window).getItem(t);
    if (s) {
      var o = (this || window)._calculateItemDestination(e, s, n);
      this._startAutoScrollToDestination(o, r, !0);
    }
  },
  requestRefreshView: function() {
    this._refreshViewDirty = !0;
  },
  refreshView: function() {
    this.forceDoLayout();
  },
  doLayout: function() {
    this._doLayout();
  },
  requestDoLayout: function() {
    this._refreshViewDirty = !0;
  },
  _doLayout: function() {
    if (this._refreshViewDirty) {
      for (var t = (this || window)._items, e = 0; e < t.length; e++) {
        var n = t[e];
        n.setLocalZOrder(e), this._remedyLayoutParameter(n);
      }
      this._updateInnerContainerSize(), this._innerContainer.forceDoLayout(), this._refreshViewDirty = !1;
    }
  },
  addEventListenerListView: function(t, e) {
    this._listViewEventListener = e, this._listViewEventSelector = t;
  },
  addEventListener: function(t) {
    this._ccListViewEventCallback = t;
  },
  _selectedItemEvent: function(t) {
    var e = t === ccui.Widget.TOUCH_BEGAN ? ccui.ListView.ON_SELECTED_ITEM_START : ccui.ListView.ON_SELECTED_ITEM_END;
    this._listViewEventSelector && (this._listViewEventListener ? this._listViewEventSelector.call(this._listViewEventListener, this, e) : this._listViewEventSelector(this, e)), this._ccListViewEventCallback && this._ccListViewEventCallback(this, e);
  },
  interceptTouchEvent: function(t, e, n) {
    if (ccui.ScrollView.prototype.interceptTouchEvent.call(this, t, e, n), !!this._touchEnabled && t !== ccui.Widget.TOUCH_MOVED) {
      for (var r = e; r; ) {
        if (r && r.getParent() === (this || window)._innerContainer) {
          this._curSelectedIndex = (this || window).getIndex(r);
          break;
        }
        r = r.getParent();
      }
      e.isHighlighted() && this._selectedItemEvent(t);
    }
  },
  getCurSelectedIndex: function() {
    return this._curSelectedIndex;
  },
  _onSizeChanged: function() {
    ccui.ScrollView.prototype._onSizeChanged.call(this), this._refreshViewDirty = !0;
  },
  getDescription: function() {
    return "ListView";
  },
  _createCloneInstance: function() {
    return new ccui.ListView();
  },
  _copyClonedWidgetChildren: function(t) {
    for (var e = t.getItems(), n = 0; n < e.length; n++) {
      var r = e[n];
      this.pushBackCustomItem(r.clone());
    }
  },
  _copySpecialProperties: function(t) {
    t instanceof ccui.ListView && (ccui.ScrollView.prototype._copySpecialProperties.call(this, t), this.setItemModel(t._model), this.setItemsMargin(t._itemsMargin), this.setGravity(t._gravity), this._listViewEventListener = t._listViewEventListener, this._listViewEventSelector = t._listViewEventSelector);
  },
  _startAttenuatingAutoScroll: function(t, e) {
    var n = t;
    if (this._items.length !== 0 && this._magneticType !== ccui.ListView.MAGNETIC_NONE) {
      n = (this || window)._flattenVectorByDirection(n);
      var r = (this || window)._getHowMuchOutOfBoundary(n);
      if (r.x === 0 && r.y === 0) {
        var s = (this || window)._magneticType;
        s === ccui.ListView.MAGNETIC_BOTH_END && (this._direction === ccui.ScrollView.DIR_HORIZONTAL ? s = n.x > 0 ? ccui.ListView.MAGNETIC_LEFT : ccui.ListView.MAGNETIC_RIGHT : this._direction === ccui.ScrollView.DIR_VERTICAL && (s = n.y > 0 ? ccui.ListView.MAGNETIC_BOTTOM : ccui.ListView.MAGNETIC_TOP));
        var o = (this || window)._getAnchorPointByMagneticType(s), a = cc.pMult(this._innerContainer.getPosition(), -1);
        a.x += (this || window).width * o.x, a.y += (this || window).height * o.y;
        var c = (this || window).getClosestItemToPosition(cc.pSub(a, n), o), l = (this || window)._calculateItemPositionWithAnchor(c, o);
        n = cc.pSub(a, l);
      }
    }
    ccui.ScrollView.prototype._startAttenuatingAutoScroll.call(this, n, e);
  },
  _getAnchorPointByMagneticType: function(t) {
    switch (t) {
      case ccui.ListView.MAGNETIC_NONE:
        return cc.p(0, 0);
      case ccui.ListView.MAGNETIC_BOTH_END:
        return cc.p(0, 1);
      case ccui.ListView.MAGNETIC_CENTER:
        return cc.p(0.5, 0.5);
      case ccui.ListView.MAGNETIC_LEFT:
        return cc.p(0, 0.5);
      case ccui.ListView.MAGNETIC_RIGHT:
        return cc.p(1, 0.5);
      case ccui.ListView.MAGNETIC_TOP:
        return cc.p(0.5, 1);
      case ccui.ListView.MAGNETIC_BOTTOM:
        return cc.p(0.5, 0);
    }
    return cc.p(0, 0);
  },
  _startMagneticScroll: function() {
    if (!(this._items.length === 0 || this._magneticType === ccui.ListView.MAGNETIC_NONE)) {
      var t = (this || window)._getAnchorPointByMagneticType(this._magneticType), e = cc.pMult(this._innerContainer.getPosition(), -1);
      e.x += (this || window).width * t.x, e.y += (this || window).height * t.y;
      var n = (this || window).getClosestItemToPosition(e, t);
      this.scrollToItem(this.getIndex(n), t, t);
    }
  }
});
ccui.ListView.create = function() {
  return new ccui.ListView();
};
ccui.ListView.EVENT_SELECTED_ITEM = 0;
ccui.ListView.ON_SELECTED_ITEM_START = 0;
ccui.ListView.ON_SELECTED_ITEM_END = 1;
ccui.ListView.GRAVITY_LEFT = 0;
ccui.ListView.GRAVITY_RIGHT = 1;
ccui.ListView.GRAVITY_CENTER_HORIZONTAL = 2;
ccui.ListView.GRAVITY_TOP = 3;
ccui.ListView.GRAVITY_BOTTOM = 4;
ccui.ListView.GRAVITY_CENTER_VERTICAL = 5;
ccui.ListView.MAGNETIC_NONE = 0;
ccui.ListView.MAGNETIC_CENTER = 1;
ccui.ListView.MAGNETIC_BOTH_END = 2;
ccui.ListView.MAGNETIC_LEFT = 3;
ccui.ListView.MAGNETIC_RIGHT = 4;
ccui.ListView.MAGNETIC_TOP = 5;
ccui.ListView.MAGNETIC_BOTTOM = 6;
ccui.PageView = ccui.ListView.extend({
  _curPageIdx: 0,
  _childFocusCancelOffset: 0,
  _pageViewEventListener: null,
  _pageViewEventSelector: null,
  _className: "PageView",
  _indicator: null,
  _indicatorPositionAsAnchorPoint: null,
  /**
       * Allocates and initializes a UIPageView.
       * Constructor of ccui.PageView. please do not call this function by yourself, you should pass the parameters to constructor to initialize it
  .
       * @example
       *
       * var uiPageView = new ccui.PageView();
       */
  ctor: function() {
    ccui.ListView.prototype.ctor.call(this), this._childFocusCancelOffset = 5, this._indicatorPositionAsAnchorPoint = cc.p(0.5, 0.1), this._pageViewEventListener = null, this._pageViewEventSelector = null, this.setDirection(ccui.ScrollView.DIR_HORIZONTAL), this.setMagneticType(ccui.ListView.MAGNETIC_CENTER), this.setScrollBarEnabled(!1);
  },
  addWidgetToPage: function(t, e, n) {
    this.insertCustomItem(t, e);
  },
  addPage: function(t) {
    this.pushBackCustomItem(t);
  },
  insertPage: function(t, e) {
    this.insertCustomItem(t, e);
  },
  removePage: function(t) {
    this.removeItem(this.getIndex(t));
  },
  removePageAtIndex: function(t) {
    this.removeItem(t);
  },
  removeAllPages: function() {
    this.removeAllItems();
  },
  scrollToItem: function(t) {
    ccui.ListView.prototype.scrollToItem.call(this, t, cc.p(0.5, 0.5), cc.p(0.5, 0.5));
  },
  scrollToPage: function(t) {
    this.scrollToItem(t);
  },
  _doLayout: function() {
    if (this._refreshViewDirty) {
      if (ccui.ListView.prototype._doLayout.call(this), this._indicator) {
        var t = (this || window).getIndex(this.getCenterItemInCurrentView());
        this._indicator.indicate(t);
      }
      this._refreshViewDirty = !1;
    }
  },
  setDirection: function(t) {
    ccui.ListView.prototype.setDirection.call(this, t), t === ccui.ScrollView.DIR_HORIZONTAL ? this._indicatorPositionAsAnchorPoint = cc.p(0.5, 0.1) : t === ccui.ScrollView.DIR_VERTICAL && (this._indicatorPositionAsAnchorPoint = cc.p(0.1, 0.5)), this._indicator && (this._indicator.setDirection(t), this._refreshIndicatorPosition());
  },
  setCustomScrollThreshold: function(t) {
  },
  getCustomScrollThreshold: function() {
    return 0;
  },
  setUsingCustomScrollThreshold: function(t) {
  },
  isUsingCustomScrollThreshold: function() {
    return !1;
  },
  _moveInnerContainer: function(t, e) {
    ccui.ListView.prototype._moveInnerContainer.call(this, t, e), this._curPageIdx = (this || window).getIndex(this.getCenterItemInCurrentView()), this._indicator && this._indicator.indicate(this._curPageIdx);
  },
  _onItemListChanged: function() {
    ccui.ListView.prototype._onItemListChanged.call(this), this._indicator && this._indicator.reset(this._items.length);
  },
  _onSizeChanged: function() {
    ccui.ListView.prototype._onSizeChanged.call(this), this._refreshIndicatorPosition();
  },
  _remedyLayoutParameter: function(t) {
    t.setContentSize(this.getContentSize()), ccui.ListView.prototype._remedyLayoutParameter.call(this, t);
  },
  _refreshIndicatorPosition: function() {
    if (this._indicator) {
      var t = (this || window).getContentSize(), e = t.width * this._indicatorPositionAsAnchorPoint.x, n = t.height * this._indicatorPositionAsAnchorPoint.y;
      this._indicator.setPosition(cc.p(e, n));
    }
  },
  _handleReleaseLogic: function(t) {
    if (ccui.ScrollView.prototype._handleReleaseLogic.call(this, t), !(this._items.length <= 0)) {
      var e = (this || window)._flattenVectorByDirection(this._calculateTouchMoveVelocity()), n = 500;
      if (cc.pLength(e) < n)
        this._startMagneticScroll();
      else {
        var r = (this || window).getItem(this._curPageIdx), s = (this || window)._calculateItemDestination(cc.p(0.5, 0.5), r, cc.p(0.5, 0.5)), o = cc.pSub(s, this.getInnerContainerPosition());
        o = (this || window)._flattenVectorByDirection(o), e.x * o.x > 0 || e.y * o.y > 0 ? this._startMagneticScroll() : (e.x < 0 || e.y > 0 ? ++this._curPageIdx : --this._curPageIdx, this._curPageIdx = Math.min(this._curPageIdx, this._items.length), this._curPageIdx = Math.max(this._curPageIdx, 0), this.scrollToItem(this._curPageIdx));
      }
    }
  },
  _getAutoScrollStopEpsilon: function() {
    return 1e-3;
  },
  _pageTurningEvent: function() {
    this._pageViewEventSelector && (this._pageViewEventListener ? this._pageViewEventSelector.call(this._pageViewEventListener, this, ccui.PageView.EVENT_TURNING) : this._pageViewEventSelector(this, ccui.PageView.EVENT_TURNING)), this._ccEventCallback && this._ccEventCallback(this, ccui.PageView.EVENT_TURNING);
  },
  addEventListenerPageView: function(t, e) {
    this._pageViewEventSelector = t, this._pageViewEventListener = e;
  },
  addEventListener: function(t) {
    this._ccEventCallback = function(e, n) {
      n == ccui.ScrollView.EVENT_AUTOSCROLL_ENDED && t(this, n);
    };
  },
  setCurrentPageIndex: function(t) {
    this.jumpToItem(t, cc.p(0.5, 0.5), cc.p(0.5, 0.5));
  },
  setCurPageIndex: function(t) {
    this.setCurrentPageIndex(t);
  },
  getCurrentPageIndex: function() {
    return this._curPageIdx;
  },
  getCurPageIndex: function() {
    var t = (this || window).getCenterItemInCurrentView();
    return this.getIndex(t);
  },
  getPages: function() {
    return this.getItems();
  },
  getPage: function(t) {
    return this.getItem(t);
  },
  getDescription: function() {
    return "PageView";
  },
  _createCloneInstance: function() {
    return new ccui.PageView();
  },
  _copyClonedWidgetChildren: function(t) {
    for (var e = t.getPages(), n = 0; n < e.length; n++) {
      var r = e[n];
      this.addPage(r.clone());
    }
  },
  _copySpecialProperties: function(t) {
    ccui.ListView.prototype._copySpecialProperties.call(this, t), this._ccEventCallback = t._ccEventCallback, this._pageViewEventListener = t._pageViewEventListener, this._pageViewEventSelector = t._pageViewEventSelector, this._customScrollThreshold = t._customScrollThreshold;
  },
  setIndicatorEnabled: function(t) {
    t != (this._indicator !== null) && (t ? (this._indicator = new ccui.PageViewIndicator(), this._indicator.setDirection(this.getDirection()), this.addProtectedChild(this._indicator, 1e4), this.setIndicatorSelectedIndexColor(cc.color(100, 100, 255)), this._refreshIndicatorPosition()) : (this.removeProtectedChild(this._indicator), this._indicator = null));
  },
  getIndicatorEnabled: function() {
    return this._indicator !== null;
  },
  setIndicatorPositionAsAnchorPoint: function(t) {
    this._indicatorPositionAsAnchorPoint = t, this._refreshIndicatorPosition();
  },
  getIndicatorPositionAsAnchorPoint: function() {
    return this._indicatorPositionAsAnchorPoint;
  },
  setIndicatorPosition: function(t) {
    if (this._indicator) {
      var e = (this || window).getContentSize();
      this._indicatorPositionAsAnchorPoint.x = t.x / e.width, this._indicatorPositionAsAnchorPoint.y = t.y / e.height, this._indicator.setPosition(t);
    }
  },
  getIndicatorPosition: function() {
    return cc.assert(this._indicator !== null, ""), this._indicator.getPosition();
  },
  setIndicatorSpaceBetweenIndexNodes: function(t) {
    this._indicator && this._indicator.setSpaceBetweenIndexNodes(t);
  },
  getIndicatorSpaceBetweenIndexNodes: function() {
    return cc.assert(this._indicator !== null, ""), this._indicator.getSpaceBetweenIndexNodes();
  },
  setIndicatorSelectedIndexColor: function(t) {
    this._indicator && this._indicator.setSelectedIndexColor(t);
  },
  getIndicatorSelectedIndexColor: function() {
    return cc.assert(this._indicator !== null, ""), this._indicator.getSelectedIndexColor();
  },
  setIndicatorIndexNodesColor: function(t) {
    this._indicator && this._indicator.setIndexNodesColor(t);
  },
  getIndicatorIndexNodesColor: function() {
    return cc.assert(this._indicator !== null, ""), this._indicator.getIndexNodesColor();
  },
  setIndicatorIndexNodesScale: function(t) {
    this._indicator && (this._indicator.setIndexNodesScale(t), this._indicator.indicate(this._curPageIdx));
  },
  getIndicatorIndexNodesScale: function() {
    return cc.assert(this._indicator !== null, ""), this._indicator.getIndexNodesScale();
  },
  setIndicatorIndexNodesTexture: function(t, e) {
    this._indicator && (this._indicator.setIndexNodesTexture(t, e), this._indicator.indicate(this._curPageIdx));
  }
});
ccui.PageView.create = function() {
  return new ccui.PageView();
};
ccui.PageView.EVENT_TURNING = 0;
ccui.PageView.TOUCH_DIR_LEFT = 0;
ccui.PageView.TOUCH_DIR_RIGHT = 1;
ccui.PageView.DIRECTION_LEFT = 0;
ccui.PageView.DIRECTION_RIGHT = 1;
ccui.PageViewIndicator = ccui.ProtectedNode.extend({
  _direction: null,
  _indexNodes: null,
  _currentIndexNode: null,
  _spaceBetweenIndexNodes: 0,
  _indexNodesScale: 1,
  _indexNodesColor: null,
  _useDefaultTexture: !0,
  _indexNodesTextureFile: "",
  _indexNodesTexType: ccui.Widget.LOCAL_TEXTURE,
  _className: "PageViewIndicator",
  ctor: function() {
    cc.ProtectedNode.prototype.ctor.call(this), this._direction = ccui.ScrollView.DIR_HORIZONTAL, this._indexNodes = [], this._spaceBetweenIndexNodes = ccui.PageViewIndicator.SPACE_BETWEEN_INDEX_NODES_DEFAULT, this._indexNodesColor = cc.color.WHITE, this._currentIndexNode = ccui.helper._createSpriteFromBase64(ccui.PageViewIndicator.CIRCLE_IMAGE, ccui.PageViewIndicator.CIRCLE_IMAGE_KEY), this._currentIndexNode.setVisible(!1), this.addProtectedChild(this._currentIndexNode, 1);
  },
  setDirection: function(t) {
    this._direction = t, this._rearrange();
  },
  reset: function(t) {
    for (; this._indexNodes.length < t; )
      this._increaseNumberOfPages();
    for (; this._indexNodes.length > t; )
      this._decreaseNumberOfPages();
    this._rearrange(), this._currentIndexNode.setVisible(this._indexNodes.length > 0);
  },
  indicate: function(t) {
    t < 0 || t >= (this || window)._indexNodes.length || this._currentIndexNode.setPosition(this._indexNodes[t].getPosition());
  },
  _rearrange: function() {
    if (this._indexNodes.length !== 0)
      for (var t = (this || window)._direction === ccui.ScrollView.DIR_HORIZONTAL, e = (this || window)._indexNodes[0].getContentSize(), n = t ? e.width : e.height, r = (this || window)._indexNodes.length, s = n * r + this._spaceBetweenIndexNodes * (r - 1), o = -(s / 2) + n / 2, a = 0; a < this._indexNodes.length; ++a) {
        var c;
        t ? c = cc.p(o, e.height / 2) : c = cc.p(e.width / 2, -o), this._indexNodes[a].setPosition(c), o += n + this._spaceBetweenIndexNodes;
      }
  },
  setSpaceBetweenIndexNodes: function(t) {
    this._spaceBetweenIndexNodes !== t && (this._spaceBetweenIndexNodes = t, this._rearrange());
  },
  getSpaceBetweenIndexNodes: function() {
    return this._spaceBetweenIndexNodes;
  },
  setSelectedIndexColor: function(t) {
    this._currentIndexNode.setColor(t);
  },
  getSelectedIndexColor: function() {
    return this._currentIndexNode.getColor();
  },
  setIndexNodesColor: function(t) {
    this._indexNodesColor = t;
    for (var e = 0; e < this._indexNodes.length; ++e)
      this._indexNodes[e].setColor(t);
  },
  getIndexNodesColor: function() {
    var t = (this || window)._indexNodesColor;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  setIndexNodesScale: function(t) {
    if (this._indexNodesScale !== t) {
      this._indexNodesScale = t, this._currentIndexNode.setScale(t);
      for (var e = 0; e < this._indexNodes.length; ++e)
        this._indexNodes[e].setScale(this, _indexNodesScale);
      this._rearrange();
    }
  },
  getIndexNodesScale: function() {
    return this._indexNodesScale;
  },
  setIndexNodesTexture: function(t, e) {
    switch (e === void 0 && (e = ccui.Widget.LOCAL_TEXTURE), this._useDefaultTexture = !1, this._indexNodesTextureFile = t, this._indexNodesTexType = e, e) {
      case ccui.Widget.LOCAL_TEXTURE:
        this._currentIndexNode.setTexture(t);
        for (var n = 0; n < this._indexNodes.length; ++n)
          this._indexNodes[n].setTexture(t);
        break;
      case ccui.Widget.PLIST_TEXTURE:
        this._currentIndexNode.setSpriteFrame(t);
        for (var n = 0; n < this._indexNodes.length; ++n)
          this._indexNodes[n].setSpriteFrame(t);
        break;
    }
    this._rearrange();
  },
  _increaseNumberOfPages: function() {
    var t;
    if (this._useDefaultTexture)
      t = ccui.helper._createSpriteFromBase64(ccui.PageViewIndicator.CIRCLE_IMAGE, ccui.PageViewIndicator.CIRCLE_IMAGE_KEY);
    else
      switch (t = new cc.Sprite(), this._indexNodesTexType) {
        case ccui.Widget.LOCAL_TEXTURE:
          t.initWithFile(this._indexNodesTextureFile);
          break;
        case ccui.Widget.PLIST_TEXTURE:
          t.initWithSpriteFrameName(this._indexNodesTextureFile);
          break;
      }
    t.setColor(this._indexNodesColor), t.setScale(this._indexNodesScale), this.addProtectedChild(t), this._indexNodes.push(t);
  },
  _decreaseNumberOfPages: function() {
    this._indexNodes.length !== 0 && (this.removeProtectedChild(this._indexNodes[0]), this._indexNodes.splice(0, 1));
  },
  clear: function() {
    for (var t = 0; t < this._indexNodes.length; ++t)
      this.removeProtectedChild(this._indexNodes[t]);
    this._indexNodes.length = 0, this._currentIndexNode.setVisible(!1);
  }
});
var _p = ccui.PageViewIndicator.prototype;
_p.spaceBetweenIndexNodes;
cc.defineGetterSetter(_p, "spaceBetweenIndexNodes", _p.getSpaceBetweenIndexNodes, _p.setSpaceBetweenIndexNodes);
ccui.PageViewIndicator.SPACE_BETWEEN_INDEX_NODES_DEFAULT = 23;
ccui.PageViewIndicator.CIRCLE_IMAGE_KEY = "/__circle_image";
ccui.PageViewIndicator.CIRCLE_IMAGE = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAA8ElEQVRIx62VyRGCQBBF+6gWRCEmYDIQkhiBCgHhSclC8YqWzOV5oVzKAYZp3r1/9fpbxAIBMTsKrjx5cqVgR0wgLhCRUWOjJiPqD56xoaGPhpRZV/iSEy6crHmw5oIrF9b/lVeMofrJgjlnxlIy/wik+JB+mme8BExbBhm+5CJC2LE2LtSEQoyGWDioBA5CoRIohJtK4CYDxzNEM4GAugR1E9VjVC+SZpXvhCJCrjomESLvc17pDGX7bWmlh6UtpjPVCWy9zaJ0TD7qfm3pwERMz2trRVZk3K3BD/L34AY+dEDCniMVBkPFkT2J/b2/AIV+dRpFLOYoAAAAAElFTkSuQmCC";
ccui.VideoPlayer = ccui.Widget.extend({
  _played: !1,
  _playing: !1,
  _stopped: !0,
  ctor: function(t) {
    ccui.Widget.prototype.ctor.call(this), this._EventList = {}, t && this.setURL(t);
  },
  _createRenderCmd: function() {
    return new ccui.VideoPlayer.RenderCmd(this);
  },
  setURL: function(t) {
    this._renderCmd.updateURL(t);
  },
  getURL: function() {
    return this._renderCmd._url;
  },
  play: function() {
    var t = (this || window), e = (this || window)._renderCmd._video;
    e && (this._played = !0, e.pause(), (this._stopped !== !1 || this._playing !== !1 || this._played !== !0) && (e.currentTime = 0), ccui.VideoPlayer._polyfill.autoplayAfterOperation ? setTimeout(function() {
      e.play(), t._playing = !0, t._stopped = !1;
    }, 20) : (e.play(), this._playing = !0, this._stopped = !1));
  },
  pause: function() {
    var t = (this || window)._renderCmd._video;
    t && this._playing === !0 && this._stopped === !1 && (t.pause(), this._playing = !1);
  },
  resume: function() {
    this._stopped === !1 && this._playing === !1 && this._played === !0 && this.play();
  },
  stop: function() {
    var t = (this || window), e = (this || window)._renderCmd._video;
    e && (e.pause(), e.currentTime = 0, this._playing = !1, this._stopped = !0), setTimeout(function() {
      t._dispatchEvent(ccui.VideoPlayer.EventType.STOPPED);
    }, 0);
  },
  seekTo: function(t) {
    var e = (this || window)._renderCmd._video;
    e && (e.currentTime = t, ccui.VideoPlayer._polyfill.autoplayAfterOperation && this.isPlaying() && setTimeout(function() {
      e.play();
    }, 20));
  },
  isPlaying: function() {
    return ccui.VideoPlayer._polyfill.autoplayAfterOperation && this._playing && setTimeout(function() {
      video.play();
    }, 20), this._playing;
  },
  setKeepAspectRatioEnabled: function(t) {
    cc.log("On the web is always keep the aspect ratio");
  },
  isKeepAspectRatioEnabled: function() {
    return !1;
  },
  setFullScreenEnabled: function(t) {
    var e = (this || window)._renderCmd._video;
    e && (t ? cc.screen.requestFullScreen(e) : cc.screen.exitFullScreen(e));
  },
  isFullScreenEnabled: function() {
    cc.log("Can't know status");
  },
  setEventListener: function(t, e) {
    this._EventList[t] = e;
  },
  removeEventListener: function(t) {
    this._EventList[t] = null;
  },
  _dispatchEvent: function(t) {
    var e = (this || window)._EventList[t];
    e && e.call(this, this, this._renderCmd._video.src);
  },
  onPlayEvent: function() {
    var t = (this || window)._EventList[ccui.VideoPlayer.EventType.PLAYING];
    if (t)
      for (var e = 0; e < t.length; e++)
        t[e].call(this, this, this._renderCmd._video.src);
  },
  setContentSize: function(t, e) {
    ccui.Widget.prototype.setContentSize.call(this, t, e), e === void 0 && (e = t.height, t = t.width), this._renderCmd.changeSize(t, e);
  },
  cleanup: function() {
    this._renderCmd.removeDom(), this.stopAllActions(), this.unscheduleAllCallbacks();
  },
  onEnter: function() {
    ccui.Widget.prototype.onEnter.call(this);
    var t = ccui.VideoPlayer.elements;
    t.indexOf(this) === -1 && t.push(this);
  },
  onExit: function() {
    ccui.Widget.prototype.onExit.call(this);
    var t = ccui.VideoPlayer.elements, e = t.indexOf(this);
    e !== -1 && t.splice(e, 1);
  }
});
ccui.VideoPlayer.elements = [];
ccui.VideoPlayer.pauseElements = [];
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
  for (var t = ccui.VideoPlayer.elements, e, n = 0; n < t.length; n++)
    e = t[n], t[n]._playing && (e.pause(), ccui.VideoPlayer.pauseElements.push(e));
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
  for (var t = ccui.VideoPlayer.pauseElements, e = t.pop(); e; )
    e.play(), e = t.pop();
});
ccui.VideoPlayer.EventType = {
  PLAYING: "play",
  PAUSED: "pause",
  STOPPED: "stop",
  COMPLETED: "complete"
};
(function(t) {
  t._polyfill = {
    devicePixelRatio: !1,
    event: "canplay",
    canPlayType: []
  }, function() {
    var n = document.createElement("video");
    n.canPlayType("video/ogg") && (t._polyfill.canPlayType.push(".ogg"), t._polyfill.canPlayType.push(".ogv")), n.canPlayType("video/mp4") && t._polyfill.canPlayType.push(".mp4"), n.canPlayType("video/webm") && t._polyfill.canPlayType.push(".webm");
  }(), cc.sys.OS_IOS === cc.sys.os && (t._polyfill.devicePixelRatio = !0, t._polyfill.event = "progress"), cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX && (t._polyfill.autoplayAfterOperation = !0);
  var e = document.createElement("style");
  e.innerHTML = ".cocosVideo:-moz-full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:-webkit-full-screen{transform:matrix(1,0,0,1,0,0) !important;}", document.head.appendChild(e);
})(ccui.VideoPlayer);
(function(t) {
  var e = null;
  cc._renderType === cc.game.RENDER_TYPE_WEBGL ? e = cc.Node.WebGLRenderCmd : e = cc.Node.CanvasRenderCmd, ccui.VideoPlayer.RenderCmd = function(r) {
    e.call(this, r), this._listener = null, this._url = "", this.initStyle();
  };
  var n = ccui.VideoPlayer.RenderCmd.prototype = Object.create(e.prototype);
  n.constructor = ccui.VideoPlayer.RenderCmd, n.visit = function() {
    var r = (this || window), s = cc.container, o = cc.eventManager;
    if (this._node._visible)
      s.appendChild(this._video), this._listener === null && (this._listener = cc.eventManager.addCustomListener(cc.game.EVENT_RESIZE, function() {
        r.resize();
      }));
    else {
      var a = !1;
      "contains" in s ? a = s.contains(this._video) : a = s.compareDocumentPosition(this._video) % 16, a && s.removeChild(this._video), o.removeListener(this._listener), this._listener = null;
    }
    this.updateStatus();
  }, n.transform = function(r, s) {
    this.originTransform(r, s), this.updateMatrix(this._worldTransform, cc.view._scaleX, cc.view._scaleY);
  }, n.updateStatus = function() {
    t.devicePixelRatio = cc.view.isRetinaEnabled();
    var r = cc.Node._dirtyFlags, s = (this || window)._dirtyFlag;
    s & r.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this.updateMatrix(this._worldTransform, cc.view._scaleX, cc.view._scaleY), this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag), s & r.orderDirty && (this._dirtyFlag = (this || window)._dirtyFlag & r.orderDirty ^ this._dirtyFlag);
  }, n.resize = function(r) {
    r = r || cc.view;
    var s = (this || window)._node, o = cc.eventManager;
    s._parent && s._visible ? this.updateMatrix(this._worldTransform, r._scaleX, r._scaleY) : (o.removeListener(this._listener), this._listener = null);
  }, n.updateMatrix = function(r, s, o) {
    var a = (this || window)._node;
    if (t.devicePixelRatio) {
      var c = cc.view.getDevicePixelRatio();
      s = s / c, o = o / c;
    }
    if (this._loaded !== !1) {
      var l = a._contentSize.width, h = a._contentSize.height, u = r.a * s, _ = r.b, d = r.c, f = r.d * o, C = r.tx * s - l / 2 + l * a._scaleX / 2 * s, m = r.ty * o - h / 2 + h * a._scaleY / 2 * o, g = "matrix(" + u + "," + _ + "," + d + "," + f + "," + C + "," + -m + ")";
      this._video.style.transform = g, this._video.style["-webkit-transform"] = g;
    }
  }, n.updateURL = function(r) {
    var s, o, a, c, l, h = (this || window)._node;
    if (this._url != r) {
      this._url = r, cc.loader.resPath && !/^http/.test(r) && (r = cc.path.join(cc.loader.resPath, r)), a = !1, c = cc.container, "contains" in c ? a = c.contains(this._video) : a = c.compareDocumentPosition(this._video) % 16, a && c.removeChild(this._video), this._video = document.createElement("video"), o = (this || window)._video, this.bindEvent();
      var u = (this || window), _ = /* @__PURE__ */ H(function() {
        u._loaded != !0 && (u._loaded = !0, u.changeSize(), u.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), o.removeEventListener(t.event, _), o.currentTime = 0, o.style.visibility = "visible", o.play(), h._played || (o.pause(), o.currentTime = 0));
      }, "cb");
      o.addEventListener(t.event, _), o.preload = "metadata", o.style.visibility = "hidden", this._loaded = !1, h._played = !1, h._playing = !1, h._stopped = !0, this.initStyle(), this.visit(), s = document.createElement("source"), s.src = r, o.appendChild(s), l = cc.path.extname(r);
      for (var d = 0; d < t.canPlayType.length; d++)
        l !== t.canPlayType[d] && (s = document.createElement("source"), s.src = r.replace(l, t.canPlayType[d]), o.appendChild(s));
    }
  }, n.bindEvent = function() {
    var r = (this || window), s = (this || window)._node, o = (this || window)._video;
    o.addEventListener("ended", function() {
      s._renderCmd.updateMatrix(r._worldTransform, cc.view._scaleX, cc.view._scaleY), s._playing = !1, s._dispatchEvent(ccui.VideoPlayer.EventType.COMPLETED);
    }), o.addEventListener("play", function() {
      s._dispatchEvent(ccui.VideoPlayer.EventType.PLAYING);
    }), o.addEventListener("pause", function() {
      s._dispatchEvent(ccui.VideoPlayer.EventType.PAUSED);
    });
  }, n.initStyle = function() {
    if (this._video) {
      var r = (this || window)._video;
      r.style.position = "absolute", r.style.bottom = "0px", r.style.left = "0px", r.className = "cocosVideo";
    }
  }, n.changeSize = function(r, s) {
    var o = (this || window)._node._contentSize;
    r = r || o.width, s = s || o.height;
    var a = (this || window)._video;
    a && (r !== 0 && (a.width = r), s !== 0 && (a.height = s));
  }, n.removeDom = function() {
    var r = (this || window)._video;
    if (r) {
      var s = !1;
      "contains" in cc.container ? s = cc.container.contains(r) : s = cc.container.compareDocumentPosition(r) % 16, s && cc.container.removeChild(r);
    }
  };
})(ccui.VideoPlayer._polyfill);
ccui.WebView = ccui.Widget.extend({
  ctor: function(t) {
    ccui.Widget.prototype.ctor.call(this), this._EventList = {}, t && this.loadURL(t);
  },
  setJavascriptInterfaceScheme: function(t) {
  },
  loadData: function(t, e, n, r) {
  },
  loadHTMLString: function(t, e) {
  },
  loadURL: function(t) {
    this._renderCmd.updateURL(t), this._dispatchEvent(ccui.WebView.EventType.LOADING);
  },
  stopLoading: function() {
    cc.log("Web does not support loading");
  },
  reload: function() {
    var t = (this || window)._renderCmd._iframe;
    if (t) {
      var e = t.contentWindow;
      e && e.location && e.location.reload();
    }
  },
  canGoBack: function() {
    return cc.log("Web does not support query history"), !0;
  },
  canGoForward: function() {
    return cc.log("Web does not support query history"), !0;
  },
  goBack: function() {
    try {
      if (ccui.WebView._polyfill.closeHistory)
        return cc.log("The current browser does not support the GoBack");
      var t = (this || window)._renderCmd._iframe;
      if (t) {
        var e = t.contentWindow;
        if (e && e.location)
          try {
            e.history.back.call(e);
          } catch (n) {
            e.history.back();
          }
      }
    } catch (n) {
      cc.log(n);
    }
  },
  goForward: function() {
    try {
      if (ccui.WebView._polyfill.closeHistory)
        return cc.log("The current browser does not support the GoForward");
      var t = (this || window)._renderCmd._iframe;
      if (t) {
        var e = t.contentWindow;
        if (e && e.location)
          try {
            e.history.forward.call(e);
          } catch (n) {
            e.history.forward();
          }
      }
    } catch (n) {
      cc.log(n);
    }
  },
  evaluateJS: function(t) {
    var e = (this || window)._renderCmd._iframe;
    if (e) {
      var n = e.contentWindow;
      try {
        n.eval(t), this._dispatchEvent(ccui.WebView.EventType.JS_EVALUATED);
      } catch (r) {
        console.error(r);
      }
    }
  },
  setScalesPageToFit: function() {
    cc.log("Web does not support zoom");
  },
  setEventListener: function(t, e) {
    this._EventList[t] = e;
  },
  removeEventListener: function(t) {
    this._EventList[t] = null;
  },
  _dispatchEvent: function(t) {
    var e = (this || window)._EventList[t];
    e && e.call(this, this, this._renderCmd._iframe.src);
  },
  _createRenderCmd: function() {
    return new ccui.WebView.RenderCmd(this);
  },
  setContentSize: function(t, e) {
    ccui.Widget.prototype.setContentSize.call(this, t, e), e === void 0 && (e = t.height, t = t.width), this._renderCmd.changeSize(t, e);
  },
  cleanup: function() {
    this._renderCmd.removeDom(), this.stopAllActions(), this.unscheduleAllCallbacks();
  }
});
ccui.WebView.EventType = {
  LOADING: "loading",
  LOADED: "load",
  ERROR: "error",
  JS_EVALUATED: "js"
};
(function() {
  var t = ccui.WebView._polyfill = {
    devicePixelRatio: !1,
    enableDiv: !1
  };
  cc.sys.os === cc.sys.OS_IOS && (t.enableDiv = !0), cc.sys.isMobile ? cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX && (t.enableBG = !0) : cc.sys.browserType === cc.sys.BROWSER_TYPE_IE && (t.closeHistory = !0);
})();
(function(t) {
  var e = null;
  cc._renderType === cc.game.RENDER_TYPE_WEBGL ? e = cc.Node.WebGLRenderCmd : e = cc.Node.CanvasRenderCmd, ccui.WebView.RenderCmd = function(r) {
    e.call(this, r), this._div = null, this._iframe = null, t.enableDiv ? (this._div = document.createElement("div"), this._div.style["-webkit-overflow"] = "auto", this._div.style["-webkit-overflow-scrolling"] = "touch", this._iframe = document.createElement("iframe"), this._iframe.style.width = "100%", this._iframe.style.height = "100%", this._div.appendChild(this._iframe)) : this._div = (this || window)._iframe = document.createElement("iframe"), t.enableBG && (this._div.style.background = "#FFF"), this._iframe.addEventListener("load", function() {
      r._dispatchEvent(ccui.WebView.EventType.LOADED);
    }), this._iframe.addEventListener("error", function() {
      r._dispatchEvent(ccui.WebView.EventType.ERROR);
    }), this._div.style.background = "#FFF", this._div.style.height = "200px", this._div.style.width = "300px", this._div.style.overflow = "scroll", this._listener = null, this.initStyle();
  };
  var n = ccui.WebView.RenderCmd.prototype = Object.create(e.prototype);
  n.constructor = ccui.WebView.RenderCmd, n.transform = function(r, s) {
    this.originTransform(r, s), this.updateMatrix(this._worldTransform, cc.view._scaleX, cc.view._scaleY);
  }, n.updateStatus = function() {
    t.devicePixelRatio = cc.view.isRetinaEnabled();
    var r = cc.Node._dirtyFlags, s = (this || window)._dirtyFlag;
    s & r.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this.updateMatrix(this._worldTransform, cc.view._scaleX, cc.view._scaleY), this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag), s & r.orderDirty && (this._dirtyFlag = (this || window)._dirtyFlag & r.orderDirty ^ this._dirtyFlag);
  }, n.visit = function() {
    var r = (this || window), s = cc.container, o = cc.eventManager;
    if (this._node._visible)
      s.appendChild(this._div), this._listener === null && (this._listener = o.addCustomListener(cc.game.EVENT_RESIZE, function() {
        r.resize();
      }));
    else {
      var a = !1;
      "contains" in s ? a = s.contains(this._div) : a = s.compareDocumentPosition(this._div) % 16, a && s.removeChild(this._div);
      var c = o._listenersMap[cc.game.EVENT_RESIZE].getFixedPriorityListeners();
      o._removeListenerInVector(c, this._listener), this._listener = null;
    }
    this.updateStatus(), this.resize(cc.view);
  }, n.resize = function(r) {
    r = r || cc.view;
    var s = (this || window)._node, o = cc.eventManager;
    if (s._parent && s._visible)
      this.updateMatrix(this._worldTransform, r._scaleX, r._scaleY);
    else {
      var a = o._listenersMap[cc.game.EVENT_RESIZE].getFixedPriorityListeners();
      o._removeListenerInVector(a, this._listener), this._listener = null;
    }
  }, n.updateMatrix = function(r, s, o) {
    var a = (this || window)._node;
    if (t.devicePixelRatio && s !== 1 && s !== 1) {
      var c = cc.view.getDevicePixelRatio();
      s = s / c, o = o / c;
    }
    if (this._loaded !== !1) {
      var l = a._contentSize.width, h = a._contentSize.height, u = r.a * s, _ = r.b, d = r.c, f = r.d * o, C = r.tx * s - l / 2 + l * a._scaleX / 2 * s, m = r.ty * o - h / 2 + h * a._scaleY / 2 * o, g = "matrix(" + u + "," + _ + "," + d + "," + f + "," + C + "," + -m + ")";
      this._div.style.transform = g, this._div.style["-webkit-transform"] = g;
    }
  }, n.initStyle = function() {
    if (this._div) {
      var r = (this || window)._div;
      r.style.position = "absolute", r.style.bottom = "0px", r.style.left = "0px";
    }
  }, n.updateURL = function(r) {
    var s = (this || window)._iframe;
    s.src = r;
    var o = (this || window), a = /* @__PURE__ */ H(function() {
      o._loaded = !0, s.removeEventListener("load", a);
    }, "cb");
    s.addEventListener("load", a);
  }, n.changeSize = function(r, s) {
    var o = (this || window)._div;
    o && (o.style.width = r + "px", o.style.height = s + "px");
  }, n.removeDom = function() {
    var r = (this || window)._div;
    if (r) {
      var s = !1;
      "contains" in cc.container ? s = cc.container.contains(r) : s = cc.container.compareDocumentPosition(r) % 16, s && cc.container.removeChild(r);
    }
  };
})(ccui.WebView._polyfill);
cc.Component = cc.Class.extend({
  _owner: null,
  _name: "",
  _enabled: !0,
  ctor: function() {
    this._owner = null, this._name = "", this._enabled = !0;
  },
  init: function() {
    return !0;
  },
  onEnter: function() {
  },
  onExit: function() {
  },
  update: function(t) {
  },
  serialize: function(t) {
  },
  isEnabled: function() {
    return this._enabled;
  },
  setEnabled: function(t) {
    this._enabled = t;
  },
  getName: function() {
    return this._name;
  },
  setName: function(t) {
    this._name = t;
  },
  setOwner: function(t) {
    this._owner = t;
  },
  getOwner: function() {
    return this._owner;
  }
});
cc.Component.create = function() {
  return new cc.Component();
};
ccui.LayoutComponent_ReferencePoint = {
  BOTTOM_LEFT: 0,
  TOP_LEFT: 1,
  BOTTOM_RIGHT: 2,
  TOP_RIGHT: 3
};
ccui.LayoutComponent_PositionType = {
  Position: 0,
  RelativePosition: 1,
  PreRelativePosition: 2,
  PreRelativePositionEnable: 3
};
ccui.LayoutComponent_SizeType = {
  Size: 0,
  PreSize: 1,
  PreSizeEnable: 2
};
ccui.LayoutComponent = cc.Component.extend({
  _horizontalEdge: 0,
  _verticalEdge: 0,
  _leftMargin: 0,
  _rightMargin: 0,
  _bottomMargin: 0,
  _topMargin: 0,
  _usingPositionPercentX: !1,
  _positionPercentX: 0,
  _usingPositionPercentY: !1,
  _positionPercentY: 0,
  _usingStretchWidth: !1,
  _usingStretchHeight: !1,
  _percentWidth: 0,
  _usingPercentWidth: !1,
  _percentHeight: 0,
  _usingPercentHeight: !1,
  _actived: !0,
  _isPercentOnly: !1,
  ctor: function() {
    this._name = ccui.LayoutComponent.NAME;
  },
  init: function() {
    var t = !0;
    return cc.Component.prototype.init.call(this) ? t : !1;
  },
  getPercentContentSize: function() {
    return cc.p(this._percentWidth, this._percentHeight);
  },
  setPercentContentSize: function(t) {
    this.setPercentWidth(t.x), this.setPercentHeight(t.y);
  },
  setUsingPercentContentSize: function(t) {
    this._usingPercentWidth = (this || window)._usingPercentHeight = t;
  },
  SetActiveEnable: function(t) {
    this._actived = t;
  },
  getUsingPercentContentSize: function() {
    return this._usingPercentWidth && this._usingPercentHeight;
  },
  getAnchorPosition: function() {
    return this._owner.getAnchorPoint();
  },
  setAnchorPosition: function(t, e) {
    var n = (this || window)._owner.getBoundingBox();
    this._owner.setAnchorPoint(t, e);
    var r = (this || window)._owner.getBoundingBox(), s = n.x - r.x, o = n.y - r.y, a = (this || window)._owner.getPosition();
    a.x += s, a.y += o, this.setPosition(a);
  },
  getPosition: function() {
    return this._owner.getPosition();
  },
  setPosition: function(t, e) {
    var n = (this || window)._getOwnerParent(), r;
    if (n != null) {
      e === void 0 ? (r = t.x, e = t.y) : r = t;
      var s = n.getContentSize();
      s.width !== 0 ? this._positionPercentX = r / s.width : (this._positionPercentX = 0, this._usingPositionPercentX && (r = 0)), s.height !== 0 ? this._positionPercentY = e / s.height : (this._positionPercentY = 0, this._usingPositionPercentY && (e = 0)), this._owner.setPosition(r, e), this._refreshHorizontalMargin(), this._refreshVerticalMargin();
    } else
      this._owner.setPosition(t, e);
  },
  isPositionPercentXEnabled: function() {
    return this._usingPositionPercentX;
  },
  setPositionPercentXEnabled: function(t) {
    this._usingPositionPercentX = t, this._usingPositionPercentX && (this._horizontalEdge = ccui.LayoutComponent.horizontalEdge.NONE);
  },
  getPositionPercentX: function() {
    return this._positionPercentX;
  },
  setPositionPercentX: function(t) {
    this._positionPercentX = t;
    var e = (this || window)._getOwnerParent();
    e !== null && (this._owner.setPositionX(e.width * this._positionPercentX), this._refreshHorizontalMargin());
  },
  isPositionPercentYEnabled: function() {
    return this._usingPositionPercentY;
  },
  setPositionPercentYEnabled: function(t) {
    this._usingPositionPercentY = t, this._usingPositionPercentY && (this._verticalEdge = ccui.LayoutComponent.verticalEdge.NONE);
  },
  getPositionPercentY: function() {
    return this._positionPercentY;
  },
  setPositionPercentY: function(t) {
    this._positionPercentY = t;
    var e = (this || window)._getOwnerParent();
    e !== null && (this._owner.setPositionY(e.height * this._positionPercentY), this._refreshVerticalMargin());
  },
  getHorizontalEdge: function() {
    return this._horizontalEdge;
  },
  setHorizontalEdge: function(t) {
    this._horizontalEdge = t, this._horizontalEdge !== ccui.LayoutComponent.horizontalEdge.NONE && (this._usingPositionPercentX = !1);
    var e = (this || window)._getOwnerParent();
    if (e !== null) {
      var n = (this || window)._owner.getPosition(), r = e.getContentSize();
      r.width !== 0 ? this._positionPercentX = n.x / r.width : (this._positionPercentX = 0, n.x = 0, this._usingPositionPercentX && this._owner.setPosition(n)), this._refreshHorizontalMargin();
    }
  },
  getVerticalEdge: function() {
    return this._verticalEdge;
  },
  setVerticalEdge: function(t) {
    this._verticalEdge = t, this._verticalEdge !== ccui.LayoutComponent.verticalEdge.NONE && (this._usingPositionPercentY = !1);
    var e = (this || window)._getOwnerParent();
    if (e !== null) {
      var n = (this || window)._owner.getPosition(), r = e.getContentSize();
      r.height !== 0 ? this._positionPercentY = n.y / r.height : (this._positionPercentY = 0, n.y = 0, this._usingPositionPercentY && this._owner.setPosition(n)), this._refreshVerticalMargin();
    }
  },
  getLeftMargin: function() {
    return this._leftMargin;
  },
  setLeftMargin: function(t) {
    this._leftMargin = t;
  },
  getRightMargin: function() {
    return this._rightMargin;
  },
  setRightMargin: function(t) {
    this._rightMargin = t;
  },
  getTopMargin: function() {
    return this._topMargin;
  },
  setTopMargin: function(t) {
    this._topMargin = t;
  },
  getBottomMargin: function() {
    return this._bottomMargin;
  },
  setBottomMargin: function(t) {
    this._bottomMargin = t;
  },
  getSize: function() {
    return this.getOwner().getContentSize();
  },
  setSize: function(t) {
    var e = (this || window)._getOwnerParent();
    if (e !== null) {
      var n = t, r = e.getContentSize();
      r.width !== 0 ? this._percentWidth = n.width / r.width : (this._percentWidth = 0, this._usingPercentWidth && (n.width = 0)), r.height !== 0 ? this._percentHeight = n.height / r.height : (this._percentHeight = 0, this._usingPercentHeight && (n.height = 0)), this._owner.setContentSize(n), this._refreshHorizontalMargin(), this._refreshVerticalMargin();
    } else
      this._owner.setContentSize(t);
  },
  isPercentWidthEnabled: function() {
    return this._usingPercentWidth;
  },
  setPercentWidthEnabled: function(t) {
    this._usingPercentWidth = t, this._usingPercentWidth && (this._usingStretchWidth = !1);
  },
  getSizeWidth: function() {
    return this._owner.width;
  },
  setSizeWidth: function(t) {
    var e = (this || window)._owner.getContentSize();
    e.width = t;
    var n = (this || window)._getOwnerParent();
    if (n !== null) {
      var r = n.getContentSize();
      r.width !== 0 ? this._percentWidth = e.width / r.width : (this._percentWidth = 0, this._usingPercentWidth && (e.width = 0)), this._owner.setContentSize(e), this._refreshHorizontalMargin();
    } else
      this._owner.setContentSize(e);
  },
  getPercentWidth: function() {
    return this._percentWidth;
  },
  setPercentWidth: function(t) {
    this._percentWidth = t;
    var e = (this || window)._getOwnerParent();
    if (e !== null) {
      var n = (this || window)._owner.getContentSize();
      n.width = e.width * this._percentWidth, this._owner.setContentSize(n), this._refreshHorizontalMargin();
    }
  },
  isPercentHeightEnabled: function() {
    return this._usingPercentHeight;
  },
  setPercentHeightEnabled: function(t) {
    this._usingPercentHeight = t, this._usingPercentHeight && (this._usingStretchHeight = !1);
  },
  getSizeHeight: function() {
    return this._owner.height;
  },
  setSizeHeight: function(t) {
    var e = (this || window)._owner.getContentSize();
    e.height = t;
    var n = (this || window)._getOwnerParent();
    if (n !== null) {
      var r = n.getContentSize();
      r.height !== 0 ? this._percentHeight = e.height / r.height : (this._percentHeight = 0, this._usingPercentHeight && (e.height = 0)), this._owner.setContentSize(e), this._refreshVerticalMargin();
    } else
      this._owner.setContentSize(e);
  },
  getPercentHeight: function() {
    return this._percentHeight;
  },
  setPercentHeight: function(t) {
    this._percentHeight = t;
    var e = (this || window)._getOwnerParent();
    if (e !== null) {
      var n = (this || window)._owner.getContentSize();
      n.height = e.height * this._percentHeight, this._owner.setContentSize(n), this._refreshVerticalMargin();
    }
  },
  isStretchWidthEnabled: function() {
    return this._usingStretchWidth;
  },
  setStretchWidthEnabled: function(t) {
    this._usingStretchWidth = t, this._usingStretchWidth && (this._usingPercentWidth = !1);
  },
  isStretchHeightEnabled: function() {
    return this._usingStretchHeight;
  },
  setStretchHeightEnabled: function(t) {
    this._usingStretchHeight = t, this._usingStretchHeight && (this._usingPercentHeight = !1);
  },
  setPercentOnlyEnabled: function(t) {
    this._isPercentOnly = t;
  },
  setActiveEnabled: function(t) {
    this._actived = t;
  },
  refreshLayout: function() {
    if (this._actived) {
      var t = (this || window)._getOwnerParent();
      if (t !== null) {
        var e = t.getContentSize(), n = (this || window)._owner, r = n.getAnchorPoint(), s = n.getContentSize(), o = n.getPosition();
        switch (this._horizontalEdge) {
          case ccui.LayoutComponent.horizontalEdge.NONE:
            this._usingStretchWidth && !this._isPercentOnly ? (s.width = e.width * this._percentWidth, o.x = (this || window)._leftMargin + r.x * s.width) : (this._usingPositionPercentX && (o.x = e.width * this._positionPercentX), this._usingPercentWidth && (s.width = e.width * this._percentWidth));
            break;
          case ccui.LayoutComponent.horizontalEdge.LEFT:
            if (this._isPercentOnly)
              break;
            (this._usingPercentWidth || this._usingStretchWidth) && (s.width = e.width * this._percentWidth), o.x = (this || window)._leftMargin + r.x * s.width;
            break;
          case ccui.LayoutComponent.horizontalEdge.RIGHT:
            if (this._isPercentOnly)
              break;
            (this._usingPercentWidth || this._usingStretchWidth) && (s.width = e.width * this._percentWidth), o.x = e.width - (this._rightMargin + (1 - r.x) * s.width);
            break;
          case ccui.LayoutComponent.horizontalEdge.CENTER:
            if (this._isPercentOnly)
              break;
            this._usingStretchWidth ? (s.width = e.width - this._leftMargin - this._rightMargin, s.width < 0 && (s.width = 0), o.x = (this || window)._leftMargin + r.x * s.width) : (this._usingPercentWidth && (s.width = e.width * this._percentWidth), o.x = e.width * this._positionPercentX);
            break;
        }
        switch (this._verticalEdge) {
          case ccui.LayoutComponent.verticalEdge.NONE:
            this._usingStretchHeight && !this._isPercentOnly ? (s.height = e.height * this._percentHeight, o.y = (this || window)._bottomMargin + r.y * s.height) : (this._usingPositionPercentY && (o.y = e.height * this._positionPercentY), this._usingPercentHeight && (s.height = e.height * this._percentHeight));
            break;
          case ccui.LayoutComponent.verticalEdge.BOTTOM:
            if (this._isPercentOnly)
              break;
            (this._usingPercentHeight || this._usingStretchHeight) && (s.height = e.height * this._percentHeight), o.y = (this || window)._bottomMargin + r.y * s.height;
            break;
          case ccui.LayoutComponent.verticalEdge.TOP:
            if (this._isPercentOnly)
              break;
            (this._usingPercentHeight || this._usingStretchHeight) && (s.height = e.height * this._percentHeight), o.y = e.height - (this._topMargin + (1 - r.y) * s.height);
            break;
          case ccui.LayoutComponent.verticalEdge.CENTER:
            if (this._isPercentOnly)
              break;
            this._usingStretchHeight ? (s.height = e.height - this._topMargin - this._bottomMargin, s.height < 0 && (s.height = 0), o.y = (this || window)._bottomMargin + r.y * s.height) : (this._usingPercentHeight && (s.height = e.height * this._percentHeight), o.y = e.height * this._positionPercentY);
            break;
        }
        if (n.setPosition(o), n.setContentSize(s), n instanceof ccui.PageView) {
          n.forceDoLayout();
          for (var a = n.getPages(), c = 0; c < a.length; c++)
            ccui.helper.doLayout(a[c]);
        } else
          ccui.helper.doLayout(n);
      }
    }
  },
  _getOwnerParent: function() {
    return this._owner ? this._owner.getParent() : null;
  },
  _refreshHorizontalMargin: function() {
    var t = (this || window)._getOwnerParent();
    if (t !== null) {
      var e = (this || window)._owner.getPosition(), n = (this || window)._owner.getAnchorPoint(), r = (this || window)._owner.getContentSize(), s = t.getContentSize();
      this._leftMargin = e.x - n.x * r.width, this._rightMargin = s.width - (e.x + (1 - n.x) * r.width);
    }
  },
  _refreshVerticalMargin: function() {
    var t = (this || window)._getOwnerParent();
    if (t !== null) {
      var e = (this || window)._owner.getPosition(), n = (this || window)._owner.getAnchorPoint(), r = (this || window)._owner.getContentSize(), s = t.getContentSize();
      this._bottomMargin = e.y - n.y * r.height, this._topMargin = s.height - (e.y + (1 - n.y) * r.height);
    }
  }
});
ccui.LayoutComponent.horizontalEdge = { NONE: 0, LEFT: 1, RIGHT: 2, CENTER: 3 };
ccui.LayoutComponent.verticalEdge = { NONE: 0, BOTTOM: 1, TOP: 2, CENTER: 3 };
ccui.LayoutComponent.NAME = "__ui_layout";
ccui.LayoutComponent.bindLayoutComponent = function(t) {
  var e = t.getComponent(ccui.LayoutComponent.NAME);
  return e !== void 0 || (e = new ccui.LayoutComponent(), e.init(), t.addComponent(e), t instanceof ccui.Widget || t.addEventListener && t.addEventListener("load", function() {
    e.refreshLayout();
  }, this)), e;
};
cc.ComponentContainer = cc.Class.extend({
  _components: null,
  _owner: null,
  ctor: function(t) {
    this._components = null, this._owner = t;
  },
  getComponent: function(t) {
    if (!t)
      throw new Error("cc.ComponentContainer.getComponent(): name should be non-null");
    return t = t.trim(), this._components || (this._components = {}), this._components[t];
  },
  add: function(t) {
    if (!t)
      throw new Error("cc.ComponentContainer.add(): component should be non-null");
    if (t.getOwner())
      return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1;
    this._components == null && (this._components = {}, this._owner.scheduleUpdate());
    var e = (this || window)._components[t.getName()];
    return e ? (cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1) : (t.setOwner(this._owner), this._components[t.getName()] = t, t.onEnter(), !0);
  },
  remove: function(t) {
    if (!t)
      throw new Error("cc.ComponentContainer.remove(): name should be non-null");
    return this._components ? t instanceof cc.Component ? this._removeByComponent(t) : (t = t.trim(), this._removeByComponent(this._components[t])) : !1;
  },
  _removeByComponent: function(t) {
    return t ? (t.onExit(), t.setOwner(null), delete this._components[t.getName()], !0) : !1;
  },
  removeAll: function() {
    if (this._components) {
      var t = (this || window)._components;
      for (var e in t) {
        var n = t[e];
        n.onExit(), n.setOwner(null), delete t[e];
      }
      this._owner.unscheduleUpdate(), this._components = null;
    }
  },
  _alloc: function() {
    this._components = {};
  },
  visit: function(t) {
    if (this._components) {
      var e = (this || window)._components;
      for (var n in e)
        e[n].update(t);
    }
  },
  isEmpty: function() {
    return this._components ? this._components.length === 0 : !0;
  }
});
var ccs = ccs || {};
ccs.Class = ccs.Class || cc.Class;
ccs.Class.extend = ccs.Class.extend || cc.Class.extend;
ccs.Node = ccs.Node || cc.Node;
ccs.Node.extend = ccs.Node.extend || cc.Node.extend;
ccs.Sprite = ccs.Sprite || cc.Sprite;
ccs.Sprite.extend = ccs.Sprite.extend || cc.Sprite.extend;
ccs.Component = ccs.Component || cc.Component;
ccs.Component.extend = ccs.Component.extend || cc.Component.extend;
ccs.cocostudioVersion = "v1.3.0.0";
ccs.VERSION_COMBINED = 0.3;
ccs.VERSION_CHANGE_ROTATION_RANGE = 1;
ccs.VERSION_COLOR_READING = 1.1;
ccs.MAX_VERTEXZ_VALUE = 5e6;
ccs.ARMATURE_MAX_CHILD = 50;
ccs.ARMATURE_MAX_ZORDER = 100;
ccs.ARMATURE_MAX_COUNT = ccs.MAX_VERTEXZ_VALUE / ccs.ARMATURE_MAX_CHILD / ccs.ARMATURE_MAX_ZORDER;
ccs.AUTO_ADD_SPRITE_FRAME_NAME_PREFIX = !1;
ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT = !1;
ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX = !1;
ccs.armatureVersion = function() {
  return "v1.1.0.0";
};
ccs.CONST_VERSION = "version";
ccs.CONST_VERSION_2_0 = 2;
ccs.CONST_VERSION_COMBINED = 0.3;
ccs.CONST_ARMATURES = "armatures";
ccs.CONST_ARMATURE = "armature";
ccs.CONST_BONE = "b";
ccs.CONST_DISPLAY = "d";
ccs.CONST_ANIMATIONS = "animations";
ccs.CONST_ANIMATION = "animation";
ccs.CONST_MOVEMENT = "mov";
ccs.CONST_FRAME = "f";
ccs.CONST_TEXTURE_ATLAS = "TextureAtlas";
ccs.CONST_SUB_TEXTURE = "SubTexture";
ccs.CONST_SKELETON = "skeleton";
ccs.CONST_A_NAME = "name";
ccs.CONST_A_DURATION = "dr";
ccs.CONST_A_FRAME_INDEX = "fi";
ccs.CONST_A_DURATION_TO = "to";
ccs.CONST_A_DURATION_TWEEN = "drTW";
ccs.CONST_A_LOOP = "lp";
ccs.CONST_A_MOVEMENT_SCALE = "sc";
ccs.CONST_A_MOVEMENT_DELAY = "dl";
ccs.CONST_A_DISPLAY_INDEX = "dI";
ccs.CONST_A_PLIST = "plist";
ccs.CONST_A_PARENT = "parent";
ccs.CONST_A_SKEW_X = "kX";
ccs.CONST_A_SKEW_Y = "kY";
ccs.CONST_A_SCALE_X = "cX";
ccs.CONST_A_SCALE_Y = "cY";
ccs.CONST_A_Z = "z";
ccs.CONST_A_EVENT = "evt";
ccs.CONST_A_SOUND = "sd";
ccs.CONST_A_SOUND_EFFECT = "sdE";
ccs.CONST_A_TWEEN_EASING = "twE";
ccs.CONST_A_EASING_PARAM = "twEP";
ccs.CONST_A_TWEEN_ROTATE = "twR";
ccs.CONST_A_IS_ARMATURE = "isArmature";
ccs.CONST_A_DISPLAY_TYPE = "displayType";
ccs.CONST_A_MOVEMENT = "mov";
ccs.CONST_A_X = "x";
ccs.CONST_A_Y = "y";
ccs.CONST_A_COCOS2DX_X = "cocos2d_x";
ccs.CONST_A_COCOS2DX_Y = "cocos2d_y";
ccs.CONST_A_WIDTH = "width";
ccs.CONST_A_HEIGHT = "height";
ccs.CONST_A_PIVOT_X = "pX";
ccs.CONST_A_PIVOT_Y = "pY";
ccs.CONST_A_COCOS2D_PIVOT_X = "cocos2d_pX";
ccs.CONST_A_COCOS2D_PIVOT_Y = "cocos2d_pY";
ccs.CONST_A_BLEND_TYPE = "bd";
ccs.CONST_A_BLEND_SRC = "bd_src";
ccs.CONST_A_BLEND_DST = "bd_dst";
ccs.CONST_A_ALPHA = "a";
ccs.CONST_A_RED = "r";
ccs.CONST_A_GREEN = "g";
ccs.CONST_A_BLUE = "b";
ccs.CONST_A_ALPHA_OFFSET = "aM";
ccs.CONST_A_RED_OFFSET = "rM";
ccs.CONST_A_GREEN_OFFSET = "gM";
ccs.CONST_A_BLUE_OFFSET = "bM";
ccs.CONST_A_COLOR_TRANSFORM = "colorTransform";
ccs.CONST_A_TWEEN_FRAME = "tweenFrame";
ccs.CONST_CONTOUR = "con";
ccs.CONST_CONTOUR_VERTEX = "con_vt";
ccs.CONST_FL_NAN = "NaN";
ccs.CONST_FRAME_DATA = "frame_data";
ccs.CONST_MOVEMENT_BONE_DATA = "mov_bone_data";
ccs.CONST_MOVEMENT_DATA = "mov_data";
ccs.CONST_ANIMATION_DATA = "animation_data";
ccs.CONST_DISPLAY_DATA = "display_data";
ccs.CONST_SKIN_DATA = "skin_data";
ccs.CONST_BONE_DATA = "bone_data";
ccs.CONST_ARMATURE_DATA = "armature_data";
ccs.CONST_CONTOUR_DATA = "contour_data";
ccs.CONST_TEXTURE_DATA = "texture_data";
ccs.CONST_VERTEX_POINT = "vertex";
ccs.CONST_COLOR_INFO = "color";
ccs.CONST_CONFIG_FILE_PATH = "config_file_path";
ccs.CONST_CONTENT_SCALE = "content_scale";
ccs.DataInfo = function() {
  this.asyncStruct = null, this.configFileQueue = [], this.contentScale = 1, this.filename = "", this.baseFilePath = "", this.flashToolVersion = 0, this.cocoStudioVersion = 0;
};
ccs.dataReaderHelper = {
  ConfigType: {
    DragonBone_XML: 0,
    CocoStudio_JSON: 1,
    CocoStudio_Binary: 2
  },
  _configFileList: [],
  _flashToolVersion: ccs.CONST_VERSION_2_0,
  _positionReadScale: 1,
  _asyncRefCount: 0,
  _asyncRefTotalCount: 0,
  _dataQueue: null,
  setPositionReadScale: function(t) {
    this._positionReadScale = t;
  },
  getPositionReadScale: function() {
    return this._positionReadScale;
  },
  addDataFromFile: function(t) {
    if (this._configFileList.indexOf(t) === -1) {
      this._configFileList.push(t);
      var e = (this || window)._initBaseFilePath(t), n = cc.path.extname(t).toLowerCase(), r = new ccs.DataInfo();
      r.filename = t, r.basefilePath = e, n === ".xml" ? ccs.dataReaderHelper.addDataFromXML(t, r) : n === ".json" || n === ".exportjson" ? ccs.dataReaderHelper.addDataFromJson(t, r) : n === ".csb" && ccs.dataReaderHelper.addDataFromBinaryCache(t, r);
    }
  },
  addDataFromFileAsync: function(t, e, n, r, s) {
    if (this._configFileList.indexOf(n) !== -1) {
      s && r && (this._asyncRefTotalCount === 0 && this._asyncRefCount === 0 ? this._asyncCallBack(r, s, 1) : this._asyncCallBack(r, s, (this._asyncRefTotalCount - this._asyncRefCount) / this._asyncRefTotalCount));
      return;
    }
    this._asyncRefTotalCount++, this._asyncRefCount++;
    var o = (this || window), a = /* @__PURE__ */ H(function() {
      o.addDataFromFile(n), o._asyncRefCount--, o._asyncCallBack(r, s, (o._asyncRefTotalCount - o._asyncRefCount) / o._asyncRefTotalCount);
    }, "fun");
    cc.director.getScheduler().schedule(a, this, 0.1, !1, 0, !1, "armatrueDataHelper");
  },
  removeConfigFile: function(t) {
    for (var e = (this || window)._configFileList, n = e.length, r = e[n], s = 0; s < n; s++)
      e[s] === t && (r = s);
    r !== e[n] && cc.arrayRemoveObject(e, t);
  },
  addDataFromCache: function(t, e) {
    if (!t) {
      cc.log("XML error  or  XML is empty.");
      return;
    }
    e.flashToolVersion = parseFloat(t.getAttribute(ccs.CONST_VERSION));
    var n = t.querySelectorAll(ccs.CONST_SKELETON + " > " + ccs.CONST_ARMATURES + " >  " + ccs.CONST_ARMATURE), r = ccs.armatureDataManager, s;
    for (s = 0; s < n.length; s++) {
      var o = (this || window).decodeArmature(n[s], e);
      r.addArmatureData(o.name, o, e.filename);
    }
    var a = t.querySelectorAll(ccs.CONST_SKELETON + " > " + ccs.CONST_ANIMATIONS + " >  " + ccs.CONST_ANIMATION);
    for (s = 0; s < a.length; s++) {
      var c = (this || window).decodeAnimation(a[s], e);
      r.addAnimationData(c.name, c, e.filename);
    }
    var l = t.querySelectorAll(ccs.CONST_SKELETON + " > " + ccs.CONST_TEXTURE_ATLAS + " >  " + ccs.CONST_SUB_TEXTURE);
    for (s = 0; s < l.length; s++) {
      var h = (this || window).decodeTexture(l[s], e);
      r.addTextureData(h.name, h, e.filename);
    }
  },
  decodeArmature: function(t, e) {
    var n = new ccs.ArmatureData();
    n.init(), n.name = t.getAttribute(ccs.CONST_A_NAME);
    for (var r = t.querySelectorAll(ccs.CONST_ARMATURE + " > " + ccs.CONST_BONE), s = 0; s < r.length; s++) {
      var o = r[s], a = o.getAttribute(ccs.CONST_A_PARENT), c = null;
      if (a)
        for (var l = 0; l < r.length && (c = r[l], a != r[l].getAttribute(ccs.CONST_A_NAME)); l++)
          ;
      var h = (this || window).decodeBone(o, c, e);
      n.addBoneData(h);
    }
    return n;
  },
  decodeArmatureFromJSON: function(t, e) {
    var n = new ccs.ArmatureData();
    n.init();
    var r = t[ccs.CONST_A_NAME];
    r && (n.name = r), e.cocoStudioVersion = n.dataVersion = t[ccs.CONST_VERSION] || 0.1;
    for (var s = t[ccs.CONST_BONE_DATA], o = 0; o < s.length; o++) {
      var a = (this || window).decodeBoneFromJson(s[o], e);
      n.addBoneData(a);
    }
    return n;
  },
  decodeBone: function(t, e, n) {
    var r = new ccs.BoneData();
    r.init(), r.name = t.getAttribute(ccs.CONST_A_NAME), r.parentName = t.getAttribute(ccs.CONST_A_PARENT) || "", r.zOrder = parseInt(t.getAttribute(ccs.CONST_A_Z)) || 0;
    for (var s = t.querySelectorAll(ccs.CONST_BONE + " > " + ccs.CONST_DISPLAY), o = 0; o < s.length; o++) {
      var a = s[o], c = (this || window).decodeBoneDisplay(a, n);
      r.addDisplayData(c);
    }
    return r;
  },
  decodeBoneFromJson: function(t, e) {
    var n = new ccs.BoneData();
    n.init(), this.decodeNodeFromJson(n, t, e), n.name = t[ccs.CONST_A_NAME] || "", n.parentName = t[ccs.CONST_A_PARENT] || "";
    for (var r = t[ccs.CONST_DISPLAY_DATA] || [], s = 0; s < r.length; s++) {
      var o = (this || window).decodeBoneDisplayFromJson(r[s], e);
      n.addDisplayData(o);
    }
    return n;
  },
  decodeBoneDisplay: function(t, e) {
    var n = parseFloat(t.getAttribute(ccs.CONST_A_IS_ARMATURE)) || 0, r = null;
    n === 1 ? (r = new ccs.ArmatureDisplayData(), r.displayType = ccs.DISPLAY_TYPE_ARMATURE) : (r = new ccs.SpriteDisplayData(), r.displayType = ccs.DISPLAY_TYPE_SPRITE);
    var s = t.getAttribute(ccs.CONST_A_NAME) || "";
    return s && (r.displayName = s), r;
  },
  decodeBoneDisplayFromJson: function(t, e) {
    var n = t[ccs.CONST_A_DISPLAY_TYPE] || ccs.DISPLAY_TYPE_SPRITE, r = null;
    switch (n) {
      case ccs.DISPLAY_TYPE_SPRITE:
        r = new ccs.SpriteDisplayData();
        var c = t[ccs.CONST_A_NAME];
        c != null && (r.displayName = c);
        var s = t[ccs.CONST_SKIN_DATA] || [], o = s[0];
        if (o) {
          var a = r.skinData;
          a.x = o[ccs.CONST_A_X] * this._positionReadScale, a.y = o[ccs.CONST_A_Y] * this._positionReadScale, a.scaleX = o[ccs.CONST_A_SCALE_X] == null ? 1 : o[ccs.CONST_A_SCALE_X], a.scaleY = o[ccs.CONST_A_SCALE_Y] == null ? 1 : o[ccs.CONST_A_SCALE_Y], a.skewX = o[ccs.CONST_A_SKEW_X] == null ? 1 : o[ccs.CONST_A_SKEW_X], a.skewY = o[ccs.CONST_A_SKEW_Y] == null ? 1 : o[ccs.CONST_A_SKEW_Y], a.x *= e.contentScale, a.y *= e.contentScale;
        }
        break;
      case ccs.DISPLAY_TYPE_ARMATURE:
        r = new ccs.ArmatureDisplayData();
        var c = t[ccs.CONST_A_NAME];
        c != null && (r.displayName = t[ccs.CONST_A_NAME]);
        break;
      case ccs.DISPLAY_TYPE_PARTICLE:
        r = new ccs.ParticleDisplayData();
        var l = t[ccs.CONST_A_PLIST];
        l != null && (e.asyncStruct ? r.displayName = e.asyncStruct.basefilePath + l : r.displayName = e.basefilePath + l);
        break;
      default:
        r = new ccs.SpriteDisplayData();
        break;
    }
    return r.displayType = n, r;
  },
  decodeAnimation: function(t, e) {
    var n = new ccs.AnimationData(), r = t.getAttribute(ccs.CONST_A_NAME), s = ccs.armatureDataManager.getArmatureData(r);
    n.name = r;
    for (var o = t.querySelectorAll(ccs.CONST_ANIMATION + " > " + ccs.CONST_MOVEMENT), a = null, c = 0; c < o.length; c++) {
      a = o[c];
      var l = (this || window).decodeMovement(a, s, e);
      n.addMovement(l);
    }
    return n;
  },
  decodeAnimationFromJson: function(t, e) {
    var n = new ccs.AnimationData(), r = t[ccs.CONST_A_NAME];
    r && (n.name = t[ccs.CONST_A_NAME]);
    for (var s = t[ccs.CONST_MOVEMENT_DATA] || [], o = 0; o < s.length; o++) {
      var a = (this || window).decodeMovementFromJson(s[o], e);
      n.addMovement(a);
    }
    return n;
  },
  decodeMovement: function(t, e, n) {
    var r = new ccs.MovementData();
    r.name = t.getAttribute(ccs.CONST_A_NAME);
    var s, o, a, c, l = 0;
    s = t.getAttribute(ccs.CONST_A_DURATION), r.duration = s == null ? 0 : parseFloat(s), o = t.getAttribute(ccs.CONST_A_DURATION_TO), r.durationTo = o == null ? 0 : parseFloat(o), a = t.getAttribute(ccs.CONST_A_DURATION_TWEEN), r.durationTween = a == null ? 0 : parseFloat(a), c = t.getAttribute(ccs.CONST_A_LOOP), r.loop = c ? !!parseFloat(c) : !0;
    var h = t.getAttribute(ccs.CONST_A_TWEEN_EASING);
    h && (h != ccs.CONST_FL_NAN ? (l = h == null ? 0 : parseFloat(h), r.tweenEasing = l === 2 ? ccs.TweenType.SINE_EASEINOUT : l) : r.tweenEasing = ccs.TweenType.LINEAR);
    for (var u = t.querySelectorAll(ccs.CONST_MOVEMENT + " > " + ccs.CONST_BONE), _ = null, d = 0; d < u.length; d++) {
      _ = u[d];
      var f = _.getAttribute(ccs.CONST_A_NAME);
      if (!r.getMovementBoneData(f)) {
        var C = e.getBoneData(f), m = C.parentName, g = null;
        if (m !== "")
          for (var y = 0; y < u.length && (g = u[y], m !== g.getAttribute(ccs.CONST_A_NAME)); y++)
            ;
        var A = (this || window).decodeMovementBone(_, g, C, n);
        r.addMovementBoneData(A);
      }
    }
    return r;
  },
  decodeMovementFromJson: function(t, e) {
    var n = new ccs.MovementData();
    n.loop = t[ccs.CONST_A_LOOP] == null ? !1 : t[ccs.CONST_A_LOOP], n.durationTween = t[ccs.CONST_A_DURATION_TWEEN] || 0, n.durationTo = t[ccs.CONST_A_DURATION_TO] || 0, n.duration = t[ccs.CONST_A_DURATION] || 0, t[ccs.CONST_A_DURATION] == null ? n.scale = 1 : n.scale = t[ccs.CONST_A_MOVEMENT_SCALE] == null ? 1 : t[ccs.CONST_A_MOVEMENT_SCALE], n.tweenEasing = t[ccs.CONST_A_TWEEN_EASING] == null ? ccs.TweenType.LINEAR : t[ccs.CONST_A_TWEEN_EASING];
    var r = t[ccs.CONST_A_NAME];
    r && (n.name = r);
    for (var s = t[ccs.CONST_MOVEMENT_BONE_DATA] || [], o = 0; o < s.length; o++) {
      var a = (this || window).decodeMovementBoneFromJson(s[o], e);
      n.addMovementBoneData(a);
    }
    return n;
  },
  decodeMovementBone: function(t, e, n, r) {
    var s = new ccs.MovementBoneData();
    s.init();
    var o, a;
    t && (o = parseFloat(t.getAttribute(ccs.CONST_A_MOVEMENT_SCALE)) || 0, s.scale = o, a = parseFloat(t.getAttribute(ccs.CONST_A_MOVEMENT_DELAY)) || 0, a > 0 && (a -= 1), s.delay = a);
    var c = 0, l = 0, h = 0, u = null, _ = [];
    if (e != null) {
      for (var d = e.querySelectorAll(ccs.CONST_BONE + " > " + ccs.CONST_FRAME), f = 0; f < d.length; f++)
        _.push(d[f]);
      c = _.length;
    }
    s.name = t.getAttribute(ccs.CONST_A_NAME);
    for (var C = t.querySelectorAll(ccs.CONST_BONE + " > " + ccs.CONST_FRAME), m = 0, g = 0, y = 0; y < C.length; y++) {
      var A = C[y];
      if (e)
        for (; m < c && (!u || g < l || g >= l + h); )
          u = _[m], l += h, h = parseFloat(u.getAttribute(ccs.CONST_A_DURATION)), m++;
      var D = (this || window).decodeFrame(A, u, n, r);
      s.addFrameData(D), D.frameID = g, g += D.duration, s.duration = g;
    }
    for (var N = s.frameList, z = Math.PI, f = N.length - 1; f >= 0; f--)
      if (f > 0) {
        var M = N[f].skewX - N[f - 1].skewX, Z = N[f].skewY - N[f - 1].skewY;
        (M < -z || M > z) && (N[f - 1].skewX = M < 0 ? N[f - 1].skewX - 2 * z : N[f - 1].skewX + 2 * z), (Z < -z || Z > z) && (N[f - 1].skewY = Z < 0 ? N[f - 1].skewY - 2 * z : N[f - 1].skewY + 2 * z);
      }
    var U = new ccs.FrameData();
    return U.copy(s.frameList[s.frameList.length - 1]), U.frameID = s.duration, s.addFrameData(U), s;
  },
  decodeMovementBoneFromJson: function(t, e) {
    var n = new ccs.MovementBoneData();
    n.init(), n.delay = t[ccs.CONST_A_MOVEMENT_DELAY] || 0;
    var r = t[ccs.CONST_A_NAME];
    r && (n.name = r);
    for (var s = t[ccs.CONST_FRAME_DATA] || [], o = s.length, a = 0; a < o; a++) {
      var c = t[ccs.CONST_FRAME_DATA][a], l = (this || window).decodeFrameFromJson(c, e);
      n.addFrameData(l), e.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && (l.frameID = n.duration, n.duration += l.duration);
    }
    if (e.cocoStudioVersion < ccs.VERSION_CHANGE_ROTATION_RANGE) {
      for (var h = n.frameList, u = Math.PI, a = h.length - 1; a >= 0; a--)
        if (a > 0) {
          var _ = h[a].skewX - h[a - 1].skewX, d = h[a].skewY - h[a - 1].skewY;
          (_ < -u || _ > u) && (h[a - 1].skewX = _ < 0 ? h[a - 1].skewX - 2 * u : h[a - 1].skewX + 2 * u), (d < -u || d > u) && (h[a - 1].skewY = d < 0 ? h[a - 1].skewY - 2 * u : h[a - 1].skewY + 2 * u);
        }
    }
    if (e.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && n.frameList.length > 0) {
      var l = new ccs.FrameData();
      l.copy(n.frameList[n.frameList.length - 1]), n.addFrameData(l), l.frameID = n.duration;
    }
    return n;
  },
  decodeFrame: function(t, e, n, r) {
    var s = 0, o = 0, a = 0, c = 0, l = 0, h = 0, u = 0, _ = 0, d = 0, f = 0, C = 0, m = 0, g = new ccs.FrameData();
    g.strMovement = t.getAttribute(ccs.CONST_A_MOVEMENT) || "", g.movement = g.strMovement, g.strEvent = t.getAttribute(ccs.CONST_A_EVENT) || "", g.event = g.strEvent, g.strSound = t.getAttribute(ccs.CONST_A_SOUND) || "", g.sound = g.strSound, g.strSoundEffect = t.getAttribute(ccs.CONST_A_SOUND_EFFECT) || "", g.soundEffect = g.strSoundEffect;
    var y = t.getAttribute(ccs.CONST_A_TWEEN_FRAME);
    if (g.isTween = !(y !== void 0 && (y === "false" || y === "0")), r.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (s = t.getAttribute(ccs.CONST_A_COCOS2DX_X), s && (g.x = parseFloat(s), g.x *= (this || window)._positionReadScale), o = t.getAttribute(ccs.CONST_A_COCOS2DX_Y), o && (g.y = -parseFloat(o), g.y *= (this || window)._positionReadScale)) : (s = t.getAttribute(ccs.CONST_A_X), s && (g.x = parseFloat(s), g.x *= (this || window)._positionReadScale), o = t.getAttribute(ccs.CONST_A_Y), o && (g.y = -parseFloat(o), g.y *= (this || window)._positionReadScale)), a = t.getAttribute(ccs.CONST_A_SCALE_X), a != null && (g.scaleX = parseFloat(a)), c = t.getAttribute(ccs.CONST_A_SCALE_Y), c != null && (g.scaleY = parseFloat(c)), l = t.getAttribute(ccs.CONST_A_SKEW_X), l != null && (g.skewX = cc.degreesToRadians(parseFloat(l))), h = t.getAttribute(ccs.CONST_A_SKEW_Y), h != null && (g.skewY = cc.degreesToRadians(-parseFloat(h))), _ = t.getAttribute(ccs.CONST_A_DURATION), _ != null && (g.duration = parseFloat(_)), d = t.getAttribute(ccs.CONST_A_DISPLAY_INDEX), d != null && (g.displayIndex = parseFloat(d)), f = t.getAttribute(ccs.CONST_A_Z), f != null && (g.zOrder = parseInt(f)), u = t.getAttribute(ccs.CONST_A_TWEEN_ROTATE), u != null && (g.tweenRotate = parseFloat(u)), m = t.getAttribute(ccs.CONST_A_BLEND_TYPE), m != null) {
      var A = g.blendFunc;
      switch (m) {
        case ccs.BLEND_TYPE_NORMAL:
          A.src = cc.BLEND_SRC, A.dst = cc.BLEND_DST;
          break;
        case ccs.BLEND_TYPE_ADD:
          A.src = cc.SRC_ALPHA, A.dst = cc.ONE;
          break;
        case ccs.BLEND_TYPE_MULTIPLY:
          A.src = cc.DST_COLOR, A.dst = cc.ONE_MINUS_SRC_ALPHA;
          break;
        case ccs.BLEND_TYPE_SCREEN:
          A.src = cc.ONE, A.dst = cc.ONE_MINUS_DST_COLOR;
          break;
        default:
          g.blendFunc.src = cc.BLEND_SRC, g.blendFunc.dst = cc.BLEND_DST;
          break;
      }
    }
    var D = t.querySelectorAll(ccs.CONST_FRAME + " > " + ccs.CONST_A_COLOR_TRANSFORM);
    if (D && D.length > 0) {
      D = D[0];
      var N, z, M, Z, U, Q, et, rt;
      N = parseFloat(D.getAttribute(ccs.CONST_A_ALPHA)) || 0, z = parseFloat(D.getAttribute(ccs.CONST_A_RED)) || 0, M = parseFloat(D.getAttribute(ccs.CONST_A_GREEN)) || 0, Z = parseFloat(D.getAttribute(ccs.CONST_A_BLUE)) || 0, U = parseFloat(D.getAttribute(ccs.CONST_A_ALPHA_OFFSET)) || 0, Q = parseFloat(D.getAttribute(ccs.CONST_A_RED_OFFSET)) || 0, et = parseFloat(D.getAttribute(ccs.CONST_A_GREEN_OFFSET)) || 0, rt = parseFloat(D.getAttribute(ccs.CONST_A_BLUE_OFFSET)) || 0, g.a = 2.55 * U + N, g.r = 2.55 * Q + z, g.g = 2.55 * et + M, g.b = 2.55 * rt + Z, g.isUseColorInfo = !0;
    }
    var w = t.getAttribute(ccs.CONST_A_TWEEN_EASING);
    if (w != null && (w != ccs.CONST_FL_NAN ? (C = t.getAttribute(ccs.CONST_A_TWEEN_EASING), C && (g.tweenEasing = C === 2 ? ccs.TweenType.SINE_EASEINOUT : C)) : g.tweenEasing = ccs.TweenType.LINEAR), e) {
      var L = new ccs.BaseData();
      r.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (L.x = parseFloat(e.getAttribute(ccs.CONST_A_COCOS2DX_X)), L.y = parseFloat(e.getAttribute(ccs.CONST_A_COCOS2DX_Y))) : (L.x = parseFloat(e.getAttribute(ccs.CONST_A_X)), L.y = parseFloat(e.getAttribute(ccs.CONST_A_Y))), L.skewX = parseFloat(e.getAttribute(ccs.CONST_A_SKEW_X)), L.skewY = parseFloat(e.getAttribute(ccs.CONST_A_SKEW_Y)), L.y = -L.y, L.skewX = cc.degreesToRadians(L.skewX), L.skewY = cc.degreesToRadians(-L.skewY), ccs.TransformHelp.transformFromParent(g, L);
    }
    return g;
  },
  decodeFrameFromJson: function(t, e) {
    var n = new ccs.FrameData();
    this.decodeNodeFromJson(n, t, e), n.tweenEasing = t[ccs.CONST_A_TWEEN_EASING] || ccs.TweenType.LINEAR, n.displayIndex = t[ccs.CONST_A_DISPLAY_INDEX];
    var r = t[ccs.CONST_A_BLEND_SRC] == null ? cc.BLEND_SRC : t[ccs.CONST_A_BLEND_SRC], s = t[ccs.CONST_A_BLEND_DST] == null ? cc.BLEND_DST : t[ccs.CONST_A_BLEND_DST];
    n.blendFunc.src = r, n.blendFunc.dst = s, n.isTween = t[ccs.CONST_A_TWEEN_FRAME] == null ? !0 : t[ccs.CONST_A_TWEEN_FRAME];
    var o = t[ccs.CONST_A_EVENT];
    o != null && (n.strEvent = o, n.event = o), e.cocoStudioVersion < ccs.CONST_VERSION_COMBINED ? n.duration = t[ccs.CONST_A_DURATION] == null ? 1 : t[ccs.CONST_A_DURATION] : n.frameID = t[ccs.CONST_A_FRAME_INDEX];
    for (var a = t[ccs.CONST_A_EASING_PARAM] || [], c = 0; c < a.length; c++)
      n.easingParams[c] = a[c];
    return n;
  },
  decodeTexture: function(t, e) {
    var n = new ccs.TextureData();
    n.init(), t.getAttribute(ccs.CONST_A_NAME) && (n.name = t.getAttribute(ccs.CONST_A_NAME));
    var r, s;
    e.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (r = parseFloat(t.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_X)) || 0, s = parseFloat(t.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_Y)) || 0) : (r = parseFloat(t.getAttribute(ccs.CONST_A_PIVOT_X)) || 0, s = parseFloat(t.getAttribute(ccs.CONST_A_PIVOT_Y)) || 0);
    var o = parseFloat(t.getAttribute(ccs.CONST_A_WIDTH)) || 0, a = parseFloat(t.getAttribute(ccs.CONST_A_HEIGHT)) || 0, c = r / o, l = (a - s) / a;
    n.pivotX = c, n.pivotY = l;
    for (var h = t.querySelectorAll(ccs.CONST_SUB_TEXTURE + " > " + ccs.CONST_CONTOUR), u = 0; u < h.length; u++)
      n.addContourData(this.decodeContour(h[u], e));
    return n;
  },
  decodeTextureFromJson: function(t) {
    var e = new ccs.TextureData();
    e.init();
    var n = t[ccs.CONST_A_NAME];
    n != null && (e.name = n), e.width = t[ccs.CONST_A_WIDTH] || 0, e.height = t[ccs.CONST_A_HEIGHT] || 0, e.pivotX = t[ccs.CONST_A_PIVOT_X] || 0, e.pivotY = t[ccs.CONST_A_PIVOT_Y] || 0;
    for (var r = t[ccs.CONST_CONTOUR_DATA] || [], s = 0; s < r.length; s++)
      e.contourDataList.push(this.decodeContourFromJson(r[s]));
    return e;
  },
  decodeContour: function(t, e) {
    var n = new ccs.ContourData();
    n.init();
    for (var r = t.querySelectorAll(ccs.CONST_CONTOUR + " > " + ccs.CONST_CONTOUR_VERTEX), s, o = 0; o < r.length; o++) {
      s = r[o];
      var a = cc.p(0, 0);
      a.x = parseFloat(s.getAttribute(ccs.CONST_A_X)) || 0, a.y = parseFloat(s.getAttribute(ccs.CONST_A_Y)) || 0, a.y = -a.y, n.vertexList.push(a);
    }
    return n;
  },
  decodeContourFromJson: function(t) {
    var e = new ccs.ContourData();
    e.init();
    for (var n = t[ccs.CONST_VERTEX_POINT] || [], r = n.length, s = 0; s < r; s++) {
      var o = n[s], a = cc.p(0, 0);
      a.x = o[ccs.CONST_A_X] || 0, a.y = o[ccs.CONST_A_Y] || 0, e.vertexList.push(a);
    }
    return e;
  },
  addDataFromJsonCache: function(t, e) {
    e.contentScale = t[ccs.CONST_CONTENT_SCALE] == null ? 1 : t[ccs.CONST_CONTENT_SCALE];
    var n = t[ccs.CONST_ARMATURE_DATA] || [], r, s;
    for (r = 0; r < n.length; r++)
      s = (this || window).decodeArmatureFromJSON(n[r], e), ccs.armatureDataManager.addArmatureData(s.name, s, e.filename);
    var o = t[ccs.CONST_ANIMATION_DATA] || [], a;
    for (r = 0; r < o.length; r++)
      a = (this || window).decodeAnimationFromJson(o[r], e), ccs.armatureDataManager.addAnimationData(a.name, a, e.filename);
    var c = t[ccs.CONST_TEXTURE_DATA] || [], l;
    for (r = 0; r < c.length; r++)
      l = (this || window).decodeTextureFromJson(c[r], e), ccs.armatureDataManager.addTextureData(l.name, l, e.filename);
    var h = e.asyncStruct == null ? ccs.armatureDataManager.isAutoLoadSpriteFile() : e.asyncStruct.autoLoadSpriteFile;
    if (h) {
      var u = t[ccs.CONST_CONFIG_FILE_PATH] || [], _, d, f, C;
      for (r = 0; r < u.length; r++)
        _ = u[r], d = _.lastIndexOf("."), _ = _.substring(0, d), f = e.basefilePath + _ + ".plist", C = e.basefilePath + _ + ".png", ccs.armatureDataManager.addSpriteFrameFromFile(f, C, e.filename);
    }
    s = null, a = null;
  },
  decodeNodeFromJson: function(t, e, n) {
    t.x = e[ccs.CONST_A_X] * this._positionReadScale, t.y = e[ccs.CONST_A_Y] * this._positionReadScale, t.x *= n.contentScale, t.y *= n.contentScale, t.zOrder = e[ccs.CONST_A_Z], t.skewX = e[ccs.CONST_A_SKEW_X] || 0, t.skewY = e[ccs.CONST_A_SKEW_Y] || 0, t.scaleX = e[ccs.CONST_A_SCALE_X] == null ? 1 : e[ccs.CONST_A_SCALE_X], t.scaleY = e[ccs.CONST_A_SCALE_Y] == null ? 1 : e[ccs.CONST_A_SCALE_Y];
    var r;
    n.cocoStudioVersion < ccs.VERSION_COLOR_READING ? (r = e[0], r && (t.a = r[ccs.CONST_A_ALPHA] == null ? 255 : r[ccs.CONST_A_ALPHA], t.r = r[ccs.CONST_A_RED] == null ? 255 : r[ccs.CONST_A_RED], t.g = r[ccs.CONST_A_GREEN] == null ? 255 : r[ccs.CONST_A_GREEN], t.b = r[ccs.CONST_A_BLUE] == null ? 255 : r[ccs.CONST_A_BLUE], t.isUseColorInfo = !0)) : (r = e[ccs.CONST_COLOR_INFO] || null, r && (t.a = r[ccs.CONST_A_ALPHA] == null ? 255 : r[ccs.CONST_A_ALPHA], t.r = r[ccs.CONST_A_RED] == null ? 255 : r[ccs.CONST_A_RED], t.g = r[ccs.CONST_A_GREEN] == null ? 255 : r[ccs.CONST_A_GREEN], t.b = r[ccs.CONST_A_BLUE] == null ? 255 : r[ccs.CONST_A_BLUE], t.isUseColorInfo = !0));
  },
  clear: function() {
    this._configFileList = [], this._asyncRefCount = 0, this._asyncRefTotalCount = 0;
  },
  _asyncCallBack: function(t, e, n) {
    t && cc.isFunction(t) && t.call(e, n), e && t && typeof t == "string" && e[t](n);
  },
  _initBaseFilePath: function(t) {
    var e = t, n = e.lastIndexOf("/");
    return n > -1 ? e = e.substr(0, n + 1) : e = "", e;
  },
  addDataFromXML: function(t, e) {
    var n = cc.loader.getRes(t);
    if (!n)
      throw new Error("Please load the resource first : " + t);
    var r = cc.saxParser.parse(n), s = r.documentElement;
    s && this.addDataFromCache(s, e);
  },
  addDataFromJson: function(t, e) {
    var n = cc.loader.getRes(t);
    this.addDataFromJsonCache(n, e);
  }
};
ccs.spriteFrameCacheHelper = {
  _textureAtlasDic: {},
  _imagePaths: [],
  addSpriteFrameFromFile: function(t, e) {
    cc.spriteFrameCache.addSpriteFrames(t, e);
  },
  getTextureAtlasWithTexture: function(t) {
    return null;
  },
  clear: function() {
    this._textureAtlasDic = {}, this._imagePaths = [];
  }
};
ccs.TransformHelp = ccs.TransformHelp || ccs.Class.extend({});
ccs.TransformHelp.helpMatrix1 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpMatrix2 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpPoint1 = cc.p(0, 0);
ccs.TransformHelp.helpPoint2 = cc.p(0, 0);
ccs.TransformHelp.helpParentNode = {};
ccs.TransformHelp.transformFromParent = function(t, e) {
  this.nodeToMatrix(t, this.helpMatrix1), this.nodeToMatrix(e, this.helpMatrix2), this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, t);
};
ccs.TransformHelp.transformToParent = function(t, e) {
  this.nodeToMatrix(t, this.helpMatrix1), this.nodeToMatrix(e, this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, t);
};
ccs.TransformHelp.transformFromParentWithoutScale = function(t, e) {
  for (var n in e)
    this.helpParentNode[n] = e[n];
  this.helpParentNode.scaleX = 1, this.helpParentNode.scaleY = 1, this.nodeToMatrix(t, this.helpMatrix1), this.nodeToMatrix(this.helpParentNode, this.helpMatrix2), this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, t);
};
ccs.TransformHelp.transformToParentWithoutScale = function(t, e) {
  for (var n in e)
    this.helpParentNode[n] = e[n];
  this.helpParentNode.scaleX = 1, this.helpParentNode.scaleY = 1, this.nodeToMatrix(t, this.helpMatrix1), this.nodeToMatrix(this.helpParentNode, this.helpMatrix2), this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2), this.matrixToNode(this.helpMatrix1, t);
};
ccs.TransformHelp.nodeToMatrix = function(t, e) {
  if (t.skewX === -t.skewY) {
    var n = Math.sin(t.skewX), r = Math.cos(t.skewX);
    e.a = t.scaleX * r, e.b = t.scaleX * -n, e.c = t.scaleY * n, e.d = t.scaleY * r;
  } else
    e.a = t.scaleX * Math.cos(t.skewY), e.b = t.scaleX * Math.sin(t.skewY), e.c = t.scaleY * Math.sin(t.skewX), e.d = t.scaleY * Math.cos(t.skewX);
  e.tx = t.x, e.ty = t.y;
};
ccs.TransformHelp.matrixToNode = function(t, e) {
  this.helpPoint1.x = 0, this.helpPoint1.y = 1, this.helpPoint1 = cc.pointApplyAffineTransform(this.helpPoint1, t), this.helpPoint1.x -= t.tx, this.helpPoint1.y -= t.ty, this.helpPoint2.x = 1, this.helpPoint2.y = 0, this.helpPoint2 = cc.pointApplyAffineTransform(this.helpPoint2, t), this.helpPoint2.x -= t.tx, this.helpPoint2.y -= t.ty, e.skewX = -(Math.atan2(this.helpPoint1.y, this.helpPoint1.x) - 1.5707964), e.skewY = Math.atan2(this.helpPoint2.y, this.helpPoint2.x), e.scaleX = Math.sqrt(t.a * t.a + t.b * t.b), e.scaleY = Math.sqrt(t.c * t.c + t.d * t.d), e.x = t.tx, e.y = t.ty;
};
ccs.TransformHelp.nodeConcat = function(t, e) {
  t.x += e.x, t.y += e.y, t.skewX += e.skewX, t.skewY += e.skewY, t.scaleX += e.scaleX, t.scaleY += e.scaleY;
};
ccs.TransformHelp.nodeSub = function(t, e) {
  t.x -= e.x, t.y -= e.y, t.skewX -= e.skewX, t.skewY -= e.skewY, t.scaleX -= e.scaleX, t.scaleY -= e.scaleY;
};
ccs.TweenType = {
  CUSTOM_EASING: -1,
  LINEAR: 0,
  SINE_EASEIN: 1,
  SINE_EASEOUT: 2,
  SINE_EASEINOUT: 3,
  QUAD_EASEIN: 4,
  QUAD_EASEOUT: 5,
  QUAD_EASEINOUT: 6,
  CUBIC_EASEIN: 7,
  CUBIC_EASEOUT: 8,
  CUBIC_EASEINOUT: 9,
  QUART_EASEIN: 10,
  QUART_EASEOUT: 11,
  QUART_EASEINOUT: 12,
  QUINT_EASEIN: 13,
  QUINT_EASEOUT: 14,
  QUINT_EASEINOUT: 15,
  EXPO_EASEIN: 16,
  EXPO_EASEOUT: 17,
  EXPO_EASEINOUT: 18,
  CIRC_EASEIN: 19,
  CIRC_EASEOUT: 20,
  CIRC_EASEINOUT: 21,
  ELASTIC_EASEIN: 22,
  ELASTIC_EASEOUT: 23,
  ELASTIC_EASEINOUT: 24,
  BACK_EASEIN: 25,
  BACK_EASEOUT: 26,
  BACK_EASEINOUT: 27,
  BOUNCE_EASEIN: 28,
  BOUNCE_EASEOUT: 29,
  BOUNCE_EASEINOUT: 30,
  TWEEN_EASING_MAX: 1e4
};
ccs.TweenFunction = ccs.TweenFunction || ccs.Class.extend({});
ccs.DOUBLE_PI = ccs.M_PI_X_2 = Math.PI * 2;
ccs.HALF_PI = ccs.M_PI_2 = Math.PI / 2;
ccs.M_PI = Math.PI;
ccs.TweenFunction.tweenTo = function(t, e, n) {
  var r = 0;
  switch (e) {
    case ccs.TweenType.CUSTOM_EASING:
      r = (this || window).customEase(t, n);
      break;
    case ccs.TweenType.LINEAR:
      r = (this || window).linear(t);
      break;
    case ccs.TweenType.SINE_EASEIN:
      r = (this || window).sineEaseIn(t);
      break;
    case ccs.TweenType.SINE_EASEOUT:
      r = (this || window).sineEaseOut(t);
      break;
    case ccs.TweenType.SINE_EASEINOUT:
      r = (this || window).sineEaseInOut(t);
      break;
    case ccs.TweenType.QUAD_EASEIN:
      r = (this || window).quadEaseIn(t);
      break;
    case ccs.TweenType.QUAD_EASEOUT:
      r = (this || window).quadEaseOut(t);
      break;
    case ccs.TweenType.QUAD_EASEINOUT:
      r = (this || window).quadEaseInOut(t);
      break;
    case ccs.TweenType.CUBIC_EASEIN:
      r = (this || window).cubicEaseIn(t);
      break;
    case ccs.TweenType.CUBIC_EASEOUT:
      r = (this || window).cubicEaseOut(t);
      break;
    case ccs.TweenType.CUBIC_EASEINOUT:
      r = (this || window).cubicEaseInOut(t);
      break;
    case ccs.TweenType.QUART_EASEIN:
      r = (this || window).quartEaseIn(t);
      break;
    case ccs.TweenType.QUART_EASEOUT:
      r = (this || window).quartEaseOut(t);
      break;
    case ccs.TweenType.QUART_EASEINOUT:
      r = (this || window).quartEaseInOut(t);
      break;
    case ccs.TweenType.QUINT_EASEIN:
      r = (this || window).quintEaseIn(t);
      break;
    case ccs.TweenType.QUINT_EASEOUT:
      r = (this || window).quintEaseOut(t);
      break;
    case ccs.TweenType.QUINT_EASEINOUT:
      r = (this || window).quintEaseInOut(t);
      break;
    case ccs.TweenType.EXPO_EASEIN:
      r = (this || window).expoEaseIn(t);
      break;
    case ccs.TweenType.EXPO_EASEOUT:
      r = (this || window).expoEaseOut(t);
      break;
    case ccs.TweenType.EXPO_EASEINOUT:
      r = (this || window).expoEaseInOut(t);
      break;
    case ccs.TweenType.CIRC_EASEIN:
      r = (this || window).circEaseIn(t);
      break;
    case ccs.TweenType.CIRC_EASEOUT:
      r = (this || window).circEaseOut(t);
      break;
    case ccs.TweenType.CIRC_EASEINOUT:
      r = (this || window).circEaseInOut(t);
      break;
    case ccs.TweenType.ELASTIC_EASEIN:
      var s = 0.3;
      n != null && n.length > 0 && (s = n[0]), r = (this || window).elasticEaseIn(t, s);
      break;
    case ccs.TweenType.ELASTIC_EASEOUT:
      var s = 0.3;
      n != null && n.length > 0 && (s = n[0]), r = (this || window).elasticEaseOut(t, s);
      break;
    case ccs.TweenType.ELASTIC_EASEINOUT:
      var s = 0.3;
      n != null && n.length > 0 && (s = n[0]), r = (this || window).elasticEaseInOut(t, s);
      break;
    case ccs.TweenType.BACK_EASEIN:
      r = (this || window).backEaseIn(t);
      break;
    case ccs.TweenType.BACK_EASEOUT:
      r = (this || window).backEaseOut(t);
      break;
    case ccs.TweenType.BACK_EASEINOUT:
      r = (this || window).backEaseInOut(t);
      break;
    case ccs.TweenType.BOUNCE_EASEIN:
      r = (this || window).bounceEaseIn(t);
      break;
    case ccs.TweenType.BOUNCE_EASEOUT:
      r = (this || window).bounceEaseOut(t);
      break;
    case ccs.TweenType.BOUNCE_EASEINOUT:
      r = (this || window).bounceEaseInOut(t);
      break;
    default:
      r = (this || window).sineEaseInOut(t);
      break;
  }
  return r;
};
ccs.TweenFunction.linear = function(t) {
  return t;
};
ccs.TweenFunction.sineEaseIn = function(t) {
  return -1 * Math.cos(t * ccs.HALF_PI) + 1;
};
ccs.TweenFunction.sineEaseOut = function(t) {
  return Math.sin(t * ccs.HALF_PI);
};
ccs.TweenFunction.sineEaseInOut = function(t) {
  return -0.5 * (Math.cos(ccs.M_PI * t) - 1);
};
ccs.TweenFunction.quadEaseIn = function(t) {
  return t * t;
};
ccs.TweenFunction.quadEaseOut = function(t) {
  return -1 * t * (t - 2);
};
ccs.TweenFunction.quadEaseInOut = function(t) {
  return t = t * 2, t < 1 ? 0.5 * t * t : (--t, -0.5 * (t * (t - 2) - 1));
};
ccs.TweenFunction.cubicEaseIn = function(t) {
  return t * t * t;
};
ccs.TweenFunction.cubicEaseOut = function(t) {
  return t -= 1, t * t * t + 1;
};
ccs.TweenFunction.cubicEaseInOut = function(t) {
  return t = t * 2, t < 1 ? 0.5 * t * t * t : (t -= 2, 0.5 * (t * t * t + 2));
};
ccs.TweenFunction.quartEaseIn = function(t) {
  return t * t * t * t;
};
ccs.TweenFunction.quartEaseOut = function(t) {
  return t -= 1, -(t * t * t * t - 1);
};
ccs.TweenFunction.quartEaseInOut = function(t) {
  return t = t * 2, t < 1 ? 0.5 * t * t * t * t : (t -= 2, -0.5 * (t * t * t * t - 2));
};
ccs.TweenFunction.quintEaseIn = function(t) {
  return t * t * t * t * t;
};
ccs.TweenFunction.quintEaseOut = function(t) {
  return t -= 1, t * t * t * t * t + 1;
};
ccs.TweenFunction.quintEaseInOut = function(t) {
  return t = t * 2, t < 1 ? 0.5 * t * t * t * t * t : (t -= 2, 0.5 * (t * t * t * t * t + 2));
};
ccs.TweenFunction.expoEaseIn = function(t) {
  return t === 0 ? 0 : Math.pow(2, 10 * (t - 1)) - 1e-3;
};
ccs.TweenFunction.expoEaseOut = function(t) {
  return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
};
ccs.TweenFunction.expoEaseInOut = function(t) {
  return t /= 0.5, t < 1 ? t = 0.5 * Math.pow(2, 10 * (t - 1)) : t = 0.5 * (-Math.pow(2, -10 * (t - 1)) + 2), t;
};
ccs.TweenFunction.circEaseIn = function(t) {
  return -1 * (Math.sqrt(1 - t * t) - 1);
};
ccs.TweenFunction.circEaseOut = function(t) {
  return t = t - 1, Math.sqrt(1 - t * t);
};
ccs.TweenFunction.circEaseInOut = function(t) {
  return t = t * 2, t < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : (t -= 2, 0.5 * (Math.sqrt(1 - t * t) + 1));
};
ccs.TweenFunction.elasticEaseIn = function(t, e) {
  var n = 0.3;
  e.length > 0 && (n = e[0]);
  var r = 0;
  if (t === 0 || t === 1)
    r = t;
  else {
    var s = n / 4;
    t = t - 1, r = -Math.pow(2, 10 * t) * Math.sin((t - s) * ccs.DOUBLE_PI / n);
  }
  return r;
};
ccs.TweenFunction.elasticEaseOut = function(t, e) {
  var n = 0.3;
  e.length > 0 && (n = e[0]);
  var r = 0;
  if (t === 0 || t === 1)
    r = t;
  else {
    var s = n / 4;
    r = Math.pow(2, -10 * t) * Math.sin((t - s) * ccs.DOUBLE_PI / n) + 1;
  }
  return r;
};
ccs.TweenFunction.elasticEaseInOut = function(t, e) {
  var n = 0.3;
  e.length > 0 && (n = e[0]);
  var r = 0;
  if (t === 0 || t === 1)
    r = t;
  else {
    t = t * 2, n || (n = 0.3 * 1.5);
    var s = n / 4;
    t = t - 1, t < 0 ? r = -0.5 * Math.pow(2, 10 * t) * Math.sin((t - s) * ccs.DOUBLE_PI / n) : r = Math.pow(2, -10 * t) * Math.sin((t - s) * ccs.DOUBLE_PI / n) * 0.5 + 1;
  }
  return r;
};
ccs.TweenFunction.backEaseIn = function(t) {
  var e = 1.70158;
  return t * t * ((e + 1) * t - e);
};
ccs.TweenFunction.backEaseOut = function(t) {
  var e = 1.70158;
  return t = t - 1, t * t * ((e + 1) * t + e) + 1;
};
ccs.TweenFunction.backEaseInOut = function(t) {
  var e = 2.5949095;
  return t = t * 2, t < 1 ? t * t * ((e + 1) * t - e) / 2 : (t = t - 2, t * t * ((e + 1) * t + e) / 2 + 1);
};
ccs.bounceTime = function(t) {
  return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? (t -= 1.5 / 2.75, 7.5625 * t * t + 0.75) : t < 2.5 / 2.75 ? (t -= 2.25 / 2.75, 7.5625 * t * t + 0.9375) : (t -= 2.625 / 2.75, 7.5625 * t * t + 0.984375);
};
ccs.TweenFunction.bounceEaseIn = function(t) {
  return 1 - ccs.bounceTime(1 - t);
};
ccs.TweenFunction.bounceEaseOut = function(t) {
  return ccs.bounceTime(t);
};
ccs.TweenFunction.bounceEaseInOut = function(t) {
  var e = 0;
  return t < 0.5 ? (t = t * 2, e = (1 - ccs.bounceTime(1 - t)) * 0.5) : e = ccs.bounceTime(t * 2 - 1) * 0.5 + 0.5, e;
};
ccs.TweenFunction.customEase = function(t, e) {
  if (e.length > 0) {
    var n = 1 - t;
    return e[1] * n * n * n + 3 * e[3] * t * n * n + 3 * e[5] * t * t * n + e[7] * t * t * t;
  }
  return t;
};
ccs.TweenFunction.easeIn = function(t, e) {
  return Math.pow(t, e);
};
ccs.TweenFunction.easeOut = function(t, e) {
  return Math.pow(t, 1 / e);
};
ccs.TweenFunction.easeInOut = function(t, e) {
  return t *= 2, t < 1 ? 0.5 * Math.pow(t, e) : 1 - 0.5 * Math.pow(2 - t, e);
};
ccs.TweenFunction.quadraticIn = function(t) {
  return Math.pow(t, 2);
};
ccs.TweenFunction.quadraticOut = function(t) {
  return -t * (t - 2);
};
ccs.TweenFunction.bezieratFunction = function(t, e, n, r, s) {
  return Math.pow(1 - s, 3) * t + 3 * s * Math.pow(1 - s, 2) * e + 3 * Math.pow(s, 2) * (1 - s) * n + Math.pow(s, 3) * r;
};
ccs.fmodf = function(t, e) {
  for (; t > e; )
    t -= e;
  return t;
};
ccs.isSpriteContainPoint = function(t, e, n) {
  var r = t.convertToNodeSpace(e);
  n && (n.x = r.x, n.y = r.y);
  var s = t.getContentSize();
  return cc.rectContainsPoint(cc.rect(0, 0, s.width, s.height), r);
};
ccs.SPRITE_CONTAIN_POINT = ccs.isSpriteContainPoint;
ccs.SPRITE_CONTAIN_POINT_WITH_RETURN = ccs.isSpriteContainPoint;
ccs.extBezierTo = function(t, e, n, r, s) {
  var o = cc.p(0, 0);
  return r && !s && (o.x = Math.pow(1 - t, 2) * e.x + 2 * t * (1 - t) * n.x + Math.pow(t, 2) * r.x, o.y = Math.pow(1 - t, 2) * e.y + 2 * t * (1 - t) * n.y + Math.pow(t, 2) * r.y), s && (o.x = e.x * Math.pow(1 - t, 3) + 3 * t * n.x * Math.pow(1 - t, 2) + 3 * r.x * Math.pow(t, 2) * (1 - t) + s.x * Math.pow(t, 3), o.y = e.y * Math.pow(1 - t, 3) + 3 * t * n.y * Math.pow(1 - t, 2) + 3 * r.y * Math.pow(t, 2) * (1 - t) + s.y * Math.pow(t, 3)), o;
};
ccs.extCircleTo = function(t, e, n, r, s) {
  var o = cc.p(0, 0);
  return o.x = e.x + n * Math.cos(r + s * t), o.y = e.y + n * Math.sin(r + s * t), o;
};
ccs.RelativeData = function() {
  this.plistFiles = [], this.armatures = [], this.animations = [], this.textures = [];
};
ccs.armatureDataManager = {
  _animationDatas: {},
  _armatureDatas: {},
  _textureDatas: {},
  _autoLoadSpriteFile: !1,
  _relativeDatas: {},
  s_sharedArmatureDataManager: null,
  removeArmatureFileInfo: function(t) {
    var e = (this || window).getRelativeData(t);
    if (e) {
      var n, r;
      for (n = 0; n < e.armatures.length; n++)
        r = e.armatures[n], this.removeArmatureData(r);
      for (n = 0; n < e.animations.length; n++)
        r = e.animations[n], this.removeAnimationData(r);
      for (n = 0; n < e.textures.length; n++)
        r = e.textures[n], this.removeTextureData(r);
      for (n = 0; n < e.plistFiles.length; n++)
        r = e.plistFiles[n], cc.spriteFrameCache.removeSpriteFramesFromFile(r);
      delete this._relativeDatas[t], ccs.dataReaderHelper.removeConfigFile(t);
    }
  },
  addArmatureData: function(t, e, n) {
    var r = (this || window).getRelativeData(n);
    r && r.armatures.push(t), this._armatureDatas[t] = e;
  },
  getArmatureData: function(t) {
    var e = null;
    return this._armatureDatas && (e = (this || window)._armatureDatas[t]), e;
  },
  removeArmatureData: function(t) {
    this._armatureDatas[t] && delete this._armatureDatas[t];
  },
  addAnimationData: function(t, e, n) {
    var r = (this || window).getRelativeData(n);
    r && r.animations.push(t), this._animationDatas[t] = e;
  },
  getAnimationData: function(t) {
    var e = null;
    return this._animationDatas[t] && (e = (this || window)._animationDatas[t]), e;
  },
  removeAnimationData: function(t) {
    this._animationDatas[t] && delete this._animationDatas[t];
  },
  addTextureData: function(t, e, n) {
    var r = (this || window).getRelativeData(n);
    r && r.textures.push(t), this._textureDatas[t] = e;
  },
  getTextureData: function(t) {
    var e = null;
    return this._textureDatas && (e = (this || window)._textureDatas[t]), e;
  },
  removeTextureData: function(t) {
    this._textureDatas[t] && delete this._textureDatas[t];
  },
  addArmatureFileInfo: function() {
    var t, e, n;
    switch (arguments.length) {
      case 1:
        n = arguments[0], this.addRelativeData(n), this._autoLoadSpriteFile = !0, ccs.dataReaderHelper.addDataFromFile(n);
        break;
      case 3:
        t = arguments[0], e = arguments[1], n = arguments[2], this.addRelativeData(n), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFile(n), this.addSpriteFrameFromFile(e, t);
    }
  },
  addArmatureFileInfoAsync: function() {
    var t, e, n, r, s;
    switch (arguments.length) {
      case 3:
        n = arguments[0], r = arguments[2], s = arguments[1], this.addRelativeData(n), this._autoLoadSpriteFile = !0, ccs.dataReaderHelper.addDataFromFileAsync("", "", n, s, r);
        break;
      case 5:
        t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[4], s = arguments[3], this.addRelativeData(n), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFileAsync(t, e, n, s, r), this.addSpriteFrameFromFile(e, t);
    }
  },
  addSpriteFrameFromFile: function(t, e, n) {
    var r = (this || window).getRelativeData(n);
    r && r.plistFiles.push(t), ccs.spriteFrameCacheHelper.addSpriteFrameFromFile(t, e);
  },
  isAutoLoadSpriteFile: function() {
    return this._autoLoadSpriteFile;
  },
  getArmatureDatas: function() {
    return this._armatureDatas;
  },
  getAnimationDatas: function() {
    return this._animationDatas;
  },
  getTextureDatas: function() {
    return this._textureDatas;
  },
  addRelativeData: function(t) {
    this._relativeDatas[t] || (this._relativeDatas[t] = new ccs.RelativeData());
  },
  getRelativeData: function(t) {
    return this._relativeDatas[t];
  },
  clear: function() {
    for (var t in this._relativeDatas)
      this.removeArmatureFileInfo(t);
    this._animationDatas = {}, this._armatureDatas = {}, this._textureDatas = {}, this._relativeDatas = {}, ccs.spriteFrameCacheHelper.clear(), ccs.dataReaderHelper.clear();
  }
};
ccs.BLEND_TYPE_NORMAL = 0;
ccs.BLEND_TYPE_LAYER = 1;
ccs.BLEND_TYPE_DARKEN = 2;
ccs.BLEND_TYPE_MULTIPLY = 3;
ccs.BLEND_TYPE_LIGHTEN = 4;
ccs.BLEND_TYPE_SCREEN = 5;
ccs.BLEND_TYPE_OVERLAY = 6;
ccs.BLEND_TYPE_HIGHLIGHT = 7;
ccs.BLEND_TYPE_ADD = 8;
ccs.BLEND_TYPE_SUBTRACT = 9;
ccs.BLEND_TYPE_DIFFERENCE = 10;
ccs.BLEND_TYPE_INVERT = 11;
ccs.BLEND_TYPE_ALPHA = 12;
ccs.BLEND_TYPE_ERASE = 13;
ccs.DISPLAY_TYPE_SPRITE = 0;
ccs.DISPLAY_TYPE_ARMATURE = 1;
ccs.DISPLAY_TYPE_PARTICLE = 2;
ccs.DISPLAY_TYPE_MAX = 3;
ccs.BaseData = ccs.Class.extend({
  x: 0,
  y: 0,
  zOrder: 0,
  skewX: 0,
  skewY: 0,
  scaleX: 1,
  scaleY: 1,
  tweenRotate: 0,
  isUseColorInfo: !1,
  r: 255,
  g: 255,
  b: 255,
  a: 255,
  ctor: function() {
    this.x = 0, this.y = 0, this.zOrder = 0, this.skewX = 0, this.skewY = 0, this.scaleX = 1, this.scaleY = 1, this.tweenRotate = 0, this.isUseColorInfo = !1, this.r = 255, this.g = 255, this.b = 255, this.a = 255;
  },
  copy: function(t) {
    this.x = t.x, this.y = t.y, this.zOrder = t.zOrder, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.skewX = t.skewX, this.skewY = t.skewY, this.tweenRotate = t.tweenRotate, this.isUseColorInfo = t.isUseColorInfo, this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a;
  },
  setColor: function(t) {
    this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a;
  },
  getColor: function() {
    return cc.color(this.r, this.g, this.b, this.a);
  },
  subtract: function(t, e, n) {
    this.x = e.x - t.x, this.y = e.y - t.y, this.scaleX = e.scaleX - t.scaleX, this.scaleY = e.scaleY - t.scaleY, this.skewX = e.skewX - t.skewX, this.skewY = e.skewY - t.skewY, this.isUseColorInfo || t.isUseColorInfo || e.isUseColorInfo ? (this.a = e.a - t.a, this.r = e.r - t.r, this.g = e.g - t.g, this.b = e.b - t.b, this.isUseColorInfo = !0) : (this.a = (this || window).r = (this || window).g = (this || window).b = 0, this.isUseColorInfo = !1), n && (this.skewX > ccs.M_PI && (this.skewX -= ccs.DOUBLE_PI), this.skewX < -ccs.M_PI && (this.skewX += ccs.DOUBLE_PI), this.skewY > ccs.M_PI && (this.skewY -= ccs.DOUBLE_PI), this.skewY < -ccs.M_PI && (this.skewY += ccs.DOUBLE_PI)), e.tweenRotate && (this.skewX += e.tweenRotate * ccs.PI * 2, this.skewY -= e.tweenRotate * ccs.PI * 2);
  }
});
ccs.DisplayData = ccs.Class.extend({
  displayType: ccs.DISPLAY_TYPE_MAX,
  displayName: "",
  ctor: function() {
    this.displayType = ccs.DISPLAY_TYPE_MAX;
  },
  changeDisplayToTexture: function(t) {
    var e = t, n = e.lastIndexOf(".");
    return n !== -1 && (e = e.substring(0, n)), e;
  },
  copy: function(t) {
    this.displayName = t.displayName, this.displayType = t.displayType;
  }
});
ccs.SpriteDisplayData = ccs.DisplayData.extend({
  skinData: null,
  ctor: function() {
    this.skinData = new ccs.BaseData(), this.displayType = ccs.DISPLAY_TYPE_SPRITE;
  },
  copy: function(t) {
    ccs.DisplayData.prototype.copy.call(this, t), this.skinData = t.skinData;
  }
});
ccs.ArmatureDisplayData = ccs.DisplayData.extend({
  ctor: function() {
    this.displayName = "", this.displayType = ccs.DISPLAY_TYPE_ARMATURE;
  }
});
ccs.ParticleDisplayData = ccs.DisplayData.extend({
  ctor: function() {
    this.displayType = ccs.DISPLAY_TYPE_PARTICLE;
  }
});
ccs.BoneData = ccs.BaseData.extend({
  displayDataList: null,
  name: "",
  parentName: "",
  boneDataTransform: null,
  ctor: function() {
    this.displayDataList = [], this.name = "", this.parentName = "", this.boneDataTransform = null;
  },
  init: function() {
    return this.displayDataList.length = 0, !0;
  },
  addDisplayData: function(t) {
    this.displayDataList.push(t);
  },
  getDisplayData: function(t) {
    return this.displayDataList[t];
  }
});
ccs.ArmatureData = ccs.Class.extend({
  boneDataDic: null,
  name: "",
  dataVersion: 0.1,
  ctor: function() {
    this.boneDataDic = {}, this.name = "", this.dataVersion = 0.1;
  },
  init: function() {
    return !0;
  },
  addBoneData: function(t) {
    this.boneDataDic[t.name] = t;
  },
  getBoneDataDic: function() {
    return this.boneDataDic;
  },
  getBoneData: function(t) {
    return this.boneDataDic[t];
  }
});
ccs.FrameData = ccs.BaseData.extend(
  {
    duration: 0,
    tweenEasing: 0,
    easingParamNumber: 0,
    easingParams: null,
    displayIndex: -1,
    movement: "",
    event: "",
    sound: "",
    soundEffect: "",
    blendFunc: null,
    frameID: 0,
    isTween: !0,
    ctor: function() {
      ccs.BaseData.prototype.ctor.call(this), this.duration = 1, this.tweenEasing = ccs.TweenType.LINEAR, this.easingParamNumber = 0, this.easingParams = [], this.displayIndex = 0, this.movement = "", this.event = "", this.sound = "", this.soundEffect = "", this.blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this.frameID = 0, this.isTween = !0;
    },
    copy: function(t) {
      if (ccs.BaseData.prototype.copy.call(this, t), this.duration = t.duration, this.displayIndex = t.displayIndex, this.tweenEasing = t.tweenEasing, this.easingParamNumber = t.easingParamNumber, this.easingParamNumber !== 0) {
        this.easingParams.length = 0;
        for (var e = 0; e < this.easingParamNumber; e++)
          this.easingParams[e] = t.easingParams[e];
      }
      this.blendFunc = t.blendFunc, this.isTween = t.isTween;
    }
  }
);
ccs.MovementBoneData = ccs.Class.extend({
  delay: 0,
  scale: 1,
  duration: 0,
  frameList: null,
  name: "",
  ctor: function() {
    this.delay = 0, this.scale = 1, this.duration = 0, this.frameList = [], this.name = "";
  },
  init: function() {
    return !0;
  },
  addFrameData: function(t) {
    this.frameList.push(t);
  },
  getFrameData: function(t) {
    return this.frameList[t];
  }
});
ccs.MovementData = function() {
  this.name = "", this.duration = 0, this.scale = 1, this.durationTo = 0, this.durationTween = 0, this.loop = !0, this.tweenEasing = ccs.TweenType.LINEAR, this.movBoneDataDic = {};
};
ccs.MovementData.prototype.addMovementBoneData = function(t) {
  this.movBoneDataDic[t.name] = t;
};
ccs.MovementData.prototype.getMovementBoneData = function(t) {
  return this.movBoneDataDic[t];
};
ccs.AnimationData = function() {
  this.movementDataDic = {}, this.movementNames = [], this.name = "";
};
ccs.AnimationData.prototype.addMovement = function(t) {
  this.movementDataDic[t.name] = t, this.movementNames.push(t.name);
};
ccs.AnimationData.prototype.getMovement = function(t) {
  return this.movementDataDic[t];
};
ccs.AnimationData.prototype.getMovementCount = function() {
  return Object.keys(this.movementDataDic).length;
};
ccs.ContourVertex2 = function(t, e) {
  this.x = t || 0, this.y = e || 0;
};
ccs.ContourData = function() {
  this.vertexList = [];
};
ccs.ContourData.prototype.init = function() {
  return this.vertexList.length = 0, !0;
};
ccs.ContourData.prototype.addVertex = function(t) {
  this.vertexList.push(t);
};
ccs.TextureData = function() {
  this.height = 0, this.width = 0, this.pivotX = 0.5, this.pivotY = 0.5, this.name = "", this.contourDataList = [];
};
ccs.TextureData.prototype.init = function() {
  this.contourDataList.length = 0;
};
ccs.TextureData.prototype.addContourData = function(t) {
  this.contourDataList.push(t);
};
ccs.TextureData.prototype.getContourData = function(t) {
  return this.contourDataList[t];
};
ccs.DecorativeDisplay = ccs.Class.extend({
  _display: null,
  _colliderDetector: null,
  _displayData: null,
  ctor: function() {
    this._display = null, this._colliderDetector = null, this._displayData = null;
  },
  init: function() {
    return !0;
  },
  setDisplay: function(t) {
    t._parent && (t._parent.removeChild(t), delete t._parent), this._display = t;
  },
  getDisplay: function() {
    return this._display;
  },
  setColliderDetector: function(t) {
    this._colliderDetector = t;
  },
  getColliderDetector: function() {
    return this._colliderDetector;
  },
  setDisplayData: function(t) {
    this._displayData = t;
  },
  getDisplayData: function() {
    return this._displayData;
  },
  release: function() {
    this._display = null, this._displayData = null, this._colliderDetector = null;
  }
});
ccs.DecorativeDisplay.create = function() {
  return new ccs.DecorativeDisplay();
};
ccs.displayFactory = {
  addDisplay: function(t, e, n) {
    switch (n.displayType) {
      case ccs.DISPLAY_TYPE_SPRITE:
        this.addSpriteDisplay(t, e, n);
        break;
      case ccs.DISPLAY_TYPE_PARTICLE:
        this.addParticleDisplay(t, e, n);
        break;
      case ccs.DISPLAY_TYPE_ARMATURE:
        this.addArmatureDisplay(t, e, n);
        break;
    }
  },
  createDisplay: function(t, e) {
    switch (e.getDisplayData().displayType) {
      case ccs.DISPLAY_TYPE_SPRITE:
        this.createSpriteDisplay(t, e);
        break;
      case ccs.DISPLAY_TYPE_PARTICLE:
        this.createParticleDisplay(t, e);
        break;
      case ccs.DISPLAY_TYPE_ARMATURE:
        this.createArmatureDisplay(t, e);
        break;
    }
  },
  _helpTransform: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 },
  updateDisplay: function(t, e, n) {
    var r = t.getDisplayRenderNode();
    if (r) {
      switch (t.getDisplayRenderNodeType()) {
        case ccs.DISPLAY_TYPE_SPRITE:
          n && (r._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), r.updateArmatureTransform());
          break;
        case ccs.DISPLAY_TYPE_PARTICLE:
          this.updateParticleDisplay(t, r, e);
          break;
        case ccs.DISPLAY_TYPE_ARMATURE:
          this.updateArmatureDisplay(t, r, e);
          break;
        default:
          var s = t.getNodeToArmatureTransform();
          r.setAdditionalTransform(s);
          break;
      }
      if ((ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && n) {
        var o = t.getDisplayManager().getCurrentDecorativeDisplay(), a = o.getColliderDetector();
        if (a) {
          var c = o.getDisplay(), l = c.getNodeToParentTransform(), h = (this || window)._helpTransform;
          h.a = l.a, h.b = l.b, h.c = l.c, h.d = l.d, h.tx = l.tx, h.ty = l.ty;
          var u = cc.pointApplyAffineTransform(c.getAnchorPointInPoints(), h);
          h.tx = u.x, h.ty = u.y;
          var _ = cc.affineTransformConcat(h, t.getArmature().getNodeToParentTransform());
          a.updateTransform(_);
        }
      }
    }
  },
  addSpriteDisplay: function(t, e, n) {
    var r = new ccs.SpriteDisplayData();
    r.copy(n), e.setDisplayData(r), this.createSpriteDisplay(t, e);
  },
  createSpriteDisplay: function(t, e) {
    var n = null, r = e.getDisplayData(), s = r.displayName, o = s.lastIndexOf(".");
    o !== -1 && (s = s.substring(0, o)), s === "" ? n = new ccs.Skin() : n = new ccs.Skin("#" + s + ".png"), e.setDisplay(n), n.setBone(t), this.initSpriteDisplay(t, e, r.displayName, n);
    var a = t.getArmature();
    a && (a.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? n.setSkinData(r.skinData) : n.setSkinData(t.boneData));
  },
  initSpriteDisplay: function(t, e, n, r) {
    var s = n, o = s.lastIndexOf(".");
    o !== -1 && (s = s.substring(0, o));
    var a = ccs.armatureDataManager.getTextureData(s);
    if (a && r.setAnchorPoint(cc.p(a.pivotX, a.pivotY)), (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && a && a.contourDataList.length > 0) {
      var c = new ccs.ColliderDetector(t);
      c.addContourDataList(a.contourDataList), e.setColliderDetector(c);
    }
  },
  addArmatureDisplay: function(t, e, n) {
    var r = new ccs.ArmatureDisplayData();
    r.copy(n), e.setDisplayData(r), this.createArmatureDisplay(t, e);
  },
  createArmatureDisplay: function(t, e) {
    var n = e.getDisplayData(), r = new ccs.Armature(n.displayName, t);
    e.setDisplay(r);
  },
  updateArmatureDisplay: function(t, e, n) {
    e && (e.sortAllChildren(), e.update(n));
  },
  addParticleDisplay: function(t, e, n) {
    var r = new ccs.ParticleDisplayData();
    r.copy(n), e.setDisplayData(r), this.createParticleDisplay(t, e);
  },
  createParticleDisplay: function(t, e) {
    var n = e.getDisplayData(), r = new cc.ParticleSystem(n.displayName);
    r.removeFromParent(), r.cleanup();
    var s = t.getArmature();
    s && r.setParent(t.getArmature()), e.setDisplay(r);
  },
  updateParticleDisplay: function(t, e, n) {
    var r = new ccs.BaseData();
    ccs.TransformHelp.matrixToNode(t.nodeToArmatureTransform(), r), e.setPosition(r.x, r.y), e.setScaleX(r.scaleX), e.setScaleY(r.scaleY), e.update(n);
  }
};
ccs.DisplayManager = ccs.Class.extend({
  _decoDisplayList: null,
  _currentDecoDisplay: null,
  _displayRenderNode: null,
  _displayIndex: null,
  _forceChangeDisplay: !1,
  _bone: null,
  _visible: !0,
  _displayType: null,
  ctor: function(t) {
    this._decoDisplayList = [], this._currentDecoDisplay = null, this._displayRenderNode = null, this._displayIndex = null, this._forceChangeDisplay = !1, this._bone = null, this._visible = !0, this._displayType = ccs.DISPLAY_TYPE_MAX, t && ccs.DisplayManager.prototype.init.call(this, t);
  },
  init: function(t) {
    return this._bone = t, this.initDisplayList(t.getBoneData()), !0;
  },
  addDisplay: function(t, e) {
    var n, r = (this || window)._decoDisplayList;
    if (e >= 0 && e < r.length ? n = r[e] : (n = new ccs.DecorativeDisplay(), r.push(n)), t instanceof ccs.DisplayData) {
      ccs.displayFactory.addDisplay(this._bone, n, t), e === (this || window)._displayIndex && (this._displayIndex = -1, this.changeDisplayWithIndex(e, !1));
      return;
    }
    var s = null;
    if (t instanceof ccs.Skin) {
      t.setBone(this._bone), s = new ccs.SpriteDisplayData(), ccs.displayFactory.initSpriteDisplay(this._bone, n, t.getDisplayName(), t);
      var o = n.getDisplayData();
      if (o instanceof ccs.SpriteDisplayData)
        t.setSkinData(o.skinData), s.skinData = o.skinData;
      else {
        for (var a = !1, c = r.length - 2; c >= 0; c--) {
          var l = r[c], h = l.getDisplayData();
          if (h instanceof ccs.SpriteDisplayData) {
            a = !0, t.setSkinData(h.skinData), s.skinData = h.skinData;
            break;
          }
        }
        a || t.setSkinData(new ccs.BaseData());
      }
    } else if (t instanceof cc.ParticleSystem) {
      s = new ccs.ParticleDisplayData(), t.removeFromParent(), t.cleanup();
      var u = (this || window)._bone.getArmature();
      u && t.setParent(u);
    } else
      t instanceof ccs.Armature ? (s = new ccs.ArmatureDisplayData(), s.displayName = t.getName(), t.setParentBone(this._bone)) : s = new ccs.DisplayData();
    n.setDisplay(t), n.setDisplayData(s), e === (this || window)._displayIndex && (this._displayIndex = -1, this.changeDisplayWithIndex(e, !1));
  },
  _addDisplayOther: function(t, e) {
    var n = null;
    if (e instanceof ccs.Skin) {
      var r = e;
      r.setBone(this._bone), n = new ccs.SpriteDisplayData(), n.displayName = r.getDisplayName(), ccs.displayFactory.initSpriteDisplay(this._bone, t, r.getDisplayName(), r);
      var s = t.getDisplayData();
      if (s instanceof ccs.SpriteDisplayData)
        r.setSkinData(s.skinData);
      else {
        for (var o = !1, a = (this || window)._decoDisplayList.length - 2; a >= 0; a--) {
          var c = (this || window)._decoDisplayList[a], l = c.getDisplayData();
          if (l) {
            o = !0, r.setSkinData(l.skinData), n.skinData = l.skinData;
            break;
          }
        }
        o || r.setSkinData(new ccs.BaseData()), r.setSkinData(new ccs.BaseData());
      }
    } else
      e instanceof cc.ParticleSystem ? (n = new ccs.ParticleDisplayData(), n.displayName = e._plistFile) : e instanceof ccs.Armature ? (n = new ccs.ArmatureDisplayData(), n.displayName = e.getName(), e.setParentBone(this._bone)) : n = new ccs.DisplayData();
    t.setDisplay(e), t.setDisplayData(n);
  },
  removeDisplay: function(t) {
    this._decoDisplayList.splice(t, 1), t === (this || window)._displayIndex && (this.setCurrentDecorativeDisplay(null), this._displayIndex = -1);
  },
  getDecorativeDisplayList: function() {
    return this._decoDisplayList;
  },
  changeDisplayWithIndex: function(t, e) {
    if (t >= (this || window)._decoDisplayList.length) {
      cc.log("the index value is out of range");
      return;
    }
    if (this._forceChangeDisplay = e, this._displayIndex !== t) {
      if (this._displayIndex = t, t < 0) {
        this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this.setCurrentDecorativeDisplay(null));
        return;
      }
      this.setCurrentDecorativeDisplay(this._decoDisplayList[t]);
    }
  },
  changeDisplayWithName: function(t, e) {
    for (var n = (this || window)._decoDisplayList, r = 0; r < n.length; r++)
      if (n[r].getDisplayData().displayName === t) {
        this.changeDisplayWithIndex(r, e);
        break;
      }
  },
  setCurrentDecorativeDisplay: function(t) {
    var e = (this || window)._currentDecoDisplay;
    (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && e && e.getColliderDetector() && e.getColliderDetector().setActive(!1), this._currentDecoDisplay = t, e = (this || window)._currentDecoDisplay, (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && e && e.getColliderDetector() && e.getColliderDetector().setActive(!0);
    var n = e ? e.getDisplay() : null, r = (this || window)._displayRenderNode, s = (this || window)._bone;
    r && (r instanceof ccs.Armature && s.setChildArmature(null), r.removeFromParent(!0)), this._displayRenderNode = n, n ? (n instanceof ccs.Armature ? (this._bone.setChildArmature(n), n.setParentBone(this._bone)) : n instanceof cc.ParticleSystem && (n instanceof ccs.Armature ? (s.setChildArmature(n), n.setParentBone(s)) : n instanceof cc.ParticleSystem && n.resetSystem()), n.setColor(s.getDisplayedColor()), n.setOpacity(s.getDisplayedOpacity()), this._displayRenderNode.setVisible(this._visible), this._displayType = (this || window)._currentDecoDisplay.getDisplayData().displayType) : this._displayType = ccs.DISPLAY_TYPE_MAX, cc.renderer.childrenOrderDirty = !0;
  },
  getDisplayRenderNode: function() {
    return this._displayRenderNode;
  },
  getDisplayRenderNodeType: function() {
    return this._displayType;
  },
  getCurrentDisplayIndex: function() {
    return this._displayIndex;
  },
  getCurrentDecorativeDisplay: function() {
    return this._currentDecoDisplay;
  },
  getDecorativeDisplayByIndex: function(t) {
    return this._decoDisplayList[t];
  },
  initDisplayList: function(t) {
    if (this._decoDisplayList.length = 0, !!t)
      for (var e = t.displayDataList, n = (this || window)._decoDisplayList, r = (this || window)._bone, s = 0; s < e.length; s++) {
        var o = e[s], a = new ccs.DecorativeDisplay();
        a.setDisplayData(o), ccs.displayFactory.createDisplay(r, a), n.push(a);
      }
  },
  containPoint: function(t, e) {
    if (!this._visible || this._displayIndex < 0)
      return !1;
    if (e !== void 0 && (t = cc.p(t, e)), this._currentDecoDisplay.getDisplayData().displayType === ccs.DISPLAY_TYPE_SPRITE) {
      var n = (this || window)._currentDecoDisplay.getDisplay();
      return n = n.getChildByTag(0), ccs.SPRITE_CONTAIN_POINT_WITH_RETURN(n, t);
    }
    return !1;
  },
  setVisible: function(t) {
    this._displayRenderNode && (this._visible = t, this._displayRenderNode.setVisible(t));
  },
  isVisible: function() {
    return this._visible;
  },
  getContentSize: function() {
    return this._displayRenderNode ? this._displayRenderNode.getContentSize() : cc.size(0, 0);
  },
  getBoundingBox: function() {
    return this._displayRenderNode ? this._displayRenderNode.getBoundingBox() : cc.rect(0, 0, 0, 0);
  },
  getAnchorPoint: function() {
    return this._displayRenderNode ? this._displayRenderNode.getAnchorPoint() : cc.p(0, 0);
  },
  getAnchorPointInPoints: function() {
    return this._displayRenderNode ? this._displayRenderNode.getAnchorPointInPoints() : cc.p(0, 0);
  },
  getForceChangeDisplay: function() {
    return this._forceChangeDisplay;
  },
  release: function() {
    this._decoDisplayList = null, this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this._displayRenderNode = null);
  }
});
ccs.DisplayManager.create = function(t) {
  return new ccs.DisplayManager(t);
};
ccs.Skin = ccs.Sprite.extend({
  _skinData: null,
  bone: null,
  _skinTransform: null,
  _displayName: "",
  _armature: null,
  _className: "Skin",
  ctor: function(t, e) {
    cc.Sprite.prototype.ctor.call(this), this._skinData = null, this.bone = null, this._displayName = "", this._skinTransform = cc.affineTransformIdentity(), this._armature = null, t == null || t === "" ? ccs.Skin.prototype.init.call(this) : t[0] === "#" ? ccs.Skin.prototype.initWithSpriteFrameName.call(this, t.substr(1)) : ccs.Skin.prototype.initWithFile.call(this, t, e);
  },
  initWithSpriteFrameName: function(t) {
    if (t === "")
      return !1;
    var e = cc.spriteFrameCache.getSpriteFrame(t), n = !0;
    return e ? this.initWithSpriteFrame(e) : (cc.log("Can't find CCSpriteFrame with %s. Please check your .plist file", t), n = !1), this._displayName = t, n;
  },
  initWithFile: function(t, e) {
    var n = e ? cc.Sprite.prototype.initWithFile.call(this, t, e) : cc.Sprite.prototype.initWithFile.call(this, t);
    return this._displayName = t, n;
  },
  setSkinData: function(t) {
    this._skinData = t, this.setScaleX(t.scaleX), this.setScaleY(t.scaleY), this.setRotationX(cc.radiansToDegrees(t.skewX)), this.setRotationY(cc.radiansToDegrees(-t.skewY)), this.setPosition(t.x, t.y), this._renderCmd.transform();
  },
  getSkinData: function() {
    return this._skinData;
  },
  updateArmatureTransform: function() {
    this._renderCmd.transform();
  },
  getNodeToWorldTransform: function() {
    return this._renderCmd.getNodeToWorldTransform();
  },
  getNodeToWorldTransformAR: function() {
    return this._renderCmd.getNodeToWorldTransformAR();
  },
  setBone: function(t) {
    this.bone = t;
    var e = (this || window).bone.getArmature();
    e && (this._armature = e);
  },
  getBone: function() {
    return this.bone;
  },
  getDisplayName: function() {
    return this._displayName;
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccs.Skin.CanvasRenderCmd(this) : new ccs.Skin.WebGLRenderCmd(this);
  }
});
var _p = ccs.Skin.prototype;
_p.skinData;
cc.defineGetterSetter(_p, "skinData", _p.getSkinData, _p.setSkinData);
_p.displayName;
cc.defineGetterSetter(_p, "displayName", _p.getDisplayName);
_p = null;
ccs.Skin.create = function(t, e) {
  return new ccs.Skin(t, e);
};
ccs.Skin.createWithSpriteFrameName = function(t) {
  return new ccs.Skin("#" + t);
};
(function() {
  ccs.Skin.RenderCmd = {
    _realWorldTM: null,
    transform: function(e, n) {
      var r = (this || window)._node, s = e ? e._worldTransform : null, o = (this || window)._transform, a = (this || window)._worldTransform, c = (this || window)._dirtyFlag & cc.Node._dirtyFlags.transformDirty;
      if ((c || s) && (this.originTransform(), cc.affineTransformConcatIn(o, r.bone.getNodeToArmatureTransform()), this._dirtyFlag = (this || window)._dirtyFlag & cc.Node._dirtyFlags.transformDirty ^ this._dirtyFlag), s) {
        a.a = o.a * s.a + o.b * s.c, a.b = o.a * s.b + o.b * s.d, a.c = o.c * s.a + o.d * s.c, a.d = o.c * s.b + o.d * s.d, a.tx = o.tx * s.a + o.ty * s.c + s.tx, a.ty = o.tx * s.b + o.ty * s.d + s.ty;
        var l = (this || window)._vertices;
        if (l) {
          var h = r._offsetPosition.x, u = h + r._rect.width, _ = r._offsetPosition.y, d = _ + r._rect.height;
          l[0].x = h * a.a + d * a.c + a.tx, l[0].y = h * a.b + d * a.d + a.ty, l[1].x = h * a.a + _ * a.c + a.tx, l[1].y = h * a.b + _ * a.d + a.ty, l[2].x = u * a.a + d * a.c + a.tx, l[2].y = u * a.b + d * a.d + a.ty, l[3].x = u * a.a + _ * a.c + a.tx, l[3].y = u * a.b + _ * a.d + a.ty;
        }
      } else
        a.a = o.a, a.b = o.b, a.c = o.c, a.d = o.d, a.tx = o.tx, a.ty = o.ty;
      var f = (this || window)._realWorldTM;
      f && (f.a = o.a, f.b = o.b, f.c = o.c, f.d = o.d, f.tx = o.tx, f.ty = o.ty, cc.affineTransformConcatIn(f, this._node.bone.getArmature()._renderCmd._worldTransform));
    },
    getNodeToWorldTransform: function() {
      return cc.affineTransformConcat(this._transform, this._node.bone.getArmature().getNodeToWorldTransform());
    },
    getNodeToWorldTransformAR: function() {
      var e = (this || window)._transform, n = (this || window)._node;
      return this._anchorPointInPoints = cc.pointApplyAffineTransform(this._anchorPointInPoints, e), e.tx = (this || window)._anchorPointInPoints.x, e.ty = (this || window)._anchorPointInPoints.y, cc.affineTransformConcat(e, n.bone.getArmature().getNodeToWorldTransform());
    }
  }, ccs.Skin.CanvasRenderCmd = function(e) {
    cc.Sprite.CanvasRenderCmd.call(this, e), this._realWorldTM = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 };
  };
  var t = ccs.Skin.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
  cc.inject(ccs.Skin.RenderCmd, t), t.constructor = ccs.Skin.CanvasRenderCmd, t._updateCurrentRegions = function() {
    var e = (this || window)._currentRegion;
    this._currentRegion = (this || window)._oldRegion, this._oldRegion = e, cc.Node.CanvasRenderCmd.RegionStatus.DirtyDouble === (this || window)._regionFlag && !this._currentRegion.isEmpty() && this._oldRegion.union(this._currentRegion), this._currentRegion.updateRegion(this.getLocalBB(), this._realWorldTM);
  }, ccs.Skin.WebGLRenderCmd = function(e) {
    cc.Sprite.WebGLRenderCmd.call(this, e);
  }, t = ccs.Skin.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype), cc.inject(ccs.Skin.RenderCmd, t), t.constructor = ccs.Skin.WebGLRenderCmd;
})();
ccs.ANIMATION_TYPE_SINGLE_FRAME = -4;
ccs.ANIMATION_TYPE_NO_LOOP = -3;
ccs.ANIMATION_TYPE_TO_LOOP_FRONT = -2;
ccs.ANIMATION_TYPE_TO_LOOP_BACK = -1;
ccs.ANIMATION_TYPE_LOOP_FRONT = 0;
ccs.ANIMATION_TYPE_LOOP_BACK = 1;
ccs.ANIMATION_TYPE_MAX = 2;
ccs.ProcessBase = ccs.Class.extend({
  _processScale: 1,
  _isComplete: !0,
  _isPause: !0,
  _isPlaying: !1,
  _currentPercent: 0,
  _rawDuration: 0,
  _loopType: 0,
  _tweenEasing: 0,
  animationInternal: null,
  _currentFrame: 0,
  _durationTween: 0,
  _nextFrameIndex: 0,
  _curFrameIndex: null,
  _isLoopBack: !1,
  ctor: function() {
    this._processScale = 1, this._isComplete = !0, this._isPause = !0, this._isPlaying = !1, this._currentFrame = 0, this._currentPercent = 0, this._durationTween = 0, this._rawDuration = 0, this._loopType = ccs.ANIMATION_TYPE_LOOP_BACK, this._tweenEasing = ccs.TweenType.LINEAR, this.animationInternal = 1 / 60, this._curFrameIndex = 0, this._durationTween = 0, this._isLoopBack = !1;
  },
  pause: function() {
    this._isPause = !0, this._isPlaying = !1;
  },
  resume: function() {
    this._isPause = !1, this._isPlaying = !0;
  },
  stop: function() {
    this._isComplete = !0, this._isPlaying = !1;
  },
  play: function(t, e, n, r) {
    this._isComplete = !1, this._isPause = !1, this._isPlaying = !0, this._currentFrame = 0, this._nextFrameIndex = t, this._tweenEasing = r;
  },
  update: function(t) {
    if (!(this._isComplete || this._isPause) && !(this._rawDuration <= 0 || t > 1)) {
      var e = (this || window)._nextFrameIndex === void 0 ? 0 : this._nextFrameIndex, n = (this || window)._currentFrame;
      e <= 0 ? (this._currentPercent = 1, n = 0) : (n += (this || window)._processScale * (t / this.animationInternal), this._currentPercent = n / e, n = ccs.fmodf(n, e)), this._currentFrame = n, this.updateHandler();
    }
  },
  gotoFrame: function(t) {
    var e = (this || window)._loopType;
    e === ccs.ANIMATION_TYPE_NO_LOOP ? e = ccs.ANIMATION_TYPE_MAX : e === ccs.ANIMATION_TYPE_TO_LOOP_FRONT && (e = ccs.ANIMATION_TYPE_LOOP_FRONT), this._loopType = e, this._curFrameIndex = t, this._nextFrameIndex = (this || window)._durationTween;
  },
  getCurrentFrameIndex: function() {
    return this._curFrameIndex = (this._rawDuration - 1) * this._currentPercent, this._curFrameIndex;
  },
  updateHandler: function() {
  },
  isPause: function() {
    return this._isPause;
  },
  isComplete: function() {
    return this._isComplete;
  },
  getCurrentPercent: function() {
    return this._currentPercent;
  },
  getRawDuration: function() {
    return this._rawDuration;
  },
  getLoop: function() {
    return this._loopType;
  },
  getTweenEasing: function() {
    return this._tweenEasing;
  },
  getAnimationInternal: function() {
    return this.animationInternal;
  },
  setAnimationInternal: function(t) {
    this.animationInternal = t;
  },
  getProcessScale: function() {
    return this._processScale;
  },
  setProcessScale: function(t) {
    this._processScale = t;
  },
  isPlaying: function() {
    return this._isPlaying;
  }
});
var _p = ccs.ProcessBase.prototype;
_p.currentFrameIndex;
cc.defineGetterSetter(_p, "currentFrameIndex", _p.getCurrentFrameIndex);
_p.paused;
cc.defineGetterSetter(_p, "paused", _p.isPause);
_p.completed;
cc.defineGetterSetter(_p, "completed", _p.isComplete);
_p.currentPercent;
cc.defineGetterSetter(_p, "currentPercent", _p.getCurrentPercent);
_p.rawDuration;
cc.defineGetterSetter(_p, "rawDuration", _p.getRawDuration);
_p.loop;
cc.defineGetterSetter(_p, "loop", _p.getLoop);
_p.tweenEasing;
cc.defineGetterSetter(_p, "tweenEasing", _p.getTweenEasing);
_p.playing;
cc.defineGetterSetter(_p, "playing", _p.isPlaying);
_p = null;
ccs.MovementEventType = {
  start: 0,
  complete: 1,
  loopComplete: 2
};
ccs.AnimationEvent = ccs.Class.extend({
  _arguments: null,
  _callFunc: null,
  _selectorTarget: null,
  ctor: function(t, e, n) {
    this._data = n, this._callFunc = t, this._selectorTarget = e;
  },
  call: function() {
    this._callFunc && this._callFunc.apply(this._selectorTarget, this._arguments);
  },
  setArguments: function(t) {
    this._arguments = t;
  }
});
ccs.MovementEvent = function() {
  this.armature = null, this.movementType = ccs.MovementEventType.start, this.movementID = "";
};
ccs.FrameEvent = function() {
  this.bone = null, this.frameEventName = "", this.originFrameIndex = 0, this.currentFrameIndex = 0;
};
ccs.ArmatureAnimation = ccs.ProcessBase.extend({
  _animationData: null,
  _movementData: null,
  _armature: null,
  _movementID: "",
  _toIndex: 0,
  _tweenList: null,
  _speedScale: 1,
  _ignoreFrameEvent: !1,
  _frameEventQueue: null,
  _movementEventQueue: null,
  _movementList: null,
  _onMovementList: !1,
  _movementListLoop: !1,
  _movementIndex: 0,
  _movementListDurationTo: -1,
  _movementEventCallFunc: null,
  _frameEventCallFunc: null,
  _movementEventTarget: null,
  _frameEventTarget: null,
  _movementEventListener: null,
  _frameEventListener: null,
  ctor: function(t) {
    ccs.ProcessBase.prototype.ctor.call(this), this._tweenList = [], this._movementList = [], this._frameEventQueue = [], this._movementEventQueue = [], this._armature = null, t && ccs.ArmatureAnimation.prototype.init.call(this, t);
  },
  init: function(t) {
    return this._armature = t, this._tweenList.length = 0, !0;
  },
  pause: function() {
    for (var t = (this || window)._tweenList, e = 0; e < t.length; e++)
      t[e].pause();
    ccs.ProcessBase.prototype.pause.call(this);
  },
  resume: function() {
    for (var t = (this || window)._tweenList, e = 0; e < t.length; e++)
      t[e].resume();
    ccs.ProcessBase.prototype.resume.call(this);
  },
  stop: function() {
    for (var t = (this || window)._tweenList, e = 0; e < t.length; e++)
      t[e].stop();
    t.length = 0, ccs.ProcessBase.prototype.stop.call(this);
  },
  setAnimationScale: function(t) {
    this.setSpeedScale(t);
  },
  getAnimationScale: function() {
    return this.getSpeedScale();
  },
  setSpeedScale: function(t) {
    if (t !== (this || window)._speedScale) {
      this._speedScale = t, this._processScale = (this || window)._movementData ? this._speedScale * this._movementData.scale : this._speedScale;
      var e = (this || window)._armature.getBoneDic();
      for (var n in e) {
        var r = e[n];
        r.getTween().setProcessScale(this._processScale), r.getChildArmature() && r.getChildArmature().getAnimation().setSpeedScale(this._processScale);
      }
    }
  },
  getSpeedScale: function() {
    return this._speedScale;
  },
  play: function(t, e, n) {
    cc.assert(this._animationData, "this.animationData can not be null"), this._movementData = (this || window)._animationData.getMovement(t), cc.assert(this._movementData, "this._movementData can not be null"), e = e === void 0 ? -1 : e, n = n === void 0 ? -1 : n, this._rawDuration = (this || window)._movementData.duration, this._movementID = t, this._processScale = (this || window)._speedScale * this._movementData.scale, e = e === -1 ? this._movementData.durationTo : e;
    var r = (this || window)._movementData.durationTween === 0 ? this._rawDuration : this._movementData.durationTween, s = (this || window)._movementData.tweenEasing;
    n = n < 0 ? this._movementData.loop : n, this._onMovementList = !1, ccs.ProcessBase.prototype.play.call(this, e, r, n, s), this._rawDuration === 0 ? this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME : (this._loopType = n ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._durationTween = r), this._tweenList.length = 0;
    var o, a = (this || window)._armature.getBoneDic();
    for (var c in a) {
      var l = a[c];
      o = (this || window)._movementData.movBoneDataDic[l.getName()];
      var h = l.getTween();
      o && o.frameList.length > 0 ? (this._tweenList.push(h), o.duration = (this || window)._movementData.duration, h.play(o, e, r, n, s), h.setProcessScale(this._processScale), l.getChildArmature() && (l.getChildArmature().getAnimation().setSpeedScale(this._processScale), l.getChildArmature().getAnimation().isPlaying() || l.getChildArmature().getAnimation().playWithIndex(0))) : l.isIgnoreMovementBoneData() || (l.getDisplayManager().changeDisplayWithIndex(-1, !1), h.stop());
    }
    this._armature.update(0);
  },
  playByIndex: function(t, e, n, r, s) {
    cc.log("playByIndex is deprecated. Use playWithIndex instead."), this.playWithIndex(t, e, r);
  },
  playWithIndex: function(t, e, n) {
    var r = (this || window)._animationData.movementNames;
    cc.assert(t > -1 && t < r.length);
    var s = r[t];
    this.play(s, e, n);
  },
  playWithNames: function(t, e, n) {
    e = e === void 0 ? -1 : e, n = n === void 0 ? !0 : n, this._movementListLoop = n, this._movementListDurationTo = e, this._onMovementList = !0, this._movementIndex = 0, t instanceof Array ? this._movementList = t : this._movementList.length = 0, this.updateMovementList();
  },
  playWithIndexes: function(t, e, n) {
    e = e === void 0 ? -1 : e, n = n === void 0 ? !0 : n, this._movementList.length = 0, this._movementListLoop = n, this._movementListDurationTo = e, this._onMovementList = !0, this._movementIndex = 0;
    for (var r = (this || window)._animationData.movementNames, s = 0; s < t.length; s++) {
      var o = r[t[s]];
      this._movementList.push(o);
    }
    this.updateMovementList();
  },
  gotoAndPlay: function(t) {
    if (!this._movementData || t < 0 || t >= (this || window)._movementData.duration) {
      cc.log("Please ensure you have played a movement, and the frameIndex is in the range.");
      return;
    }
    var e = (this || window)._ignoreFrameEvent;
    this._ignoreFrameEvent = !0, this._isPlaying = !0, this._isComplete = (this || window)._isPause = !1, ccs.ProcessBase.prototype.gotoFrame.call(this, t), this._currentPercent = (this || window)._curFrameIndex / (this._movementData.duration - 1), this._currentFrame = (this || window)._nextFrameIndex * this._currentPercent;
    for (var n = (this || window)._tweenList, r = 0; r < n.length; r++)
      n[r].gotoAndPlay(t);
    this._armature.update(0), this._ignoreFrameEvent = e;
  },
  gotoAndPause: function(t) {
    this.gotoAndPlay(t), this.pause();
  },
  getMovementCount: function() {
    return this._animationData.getMovementCount();
  },
  update: function(t) {
    ccs.ProcessBase.prototype.update.call(this, t);
    for (var e = (this || window)._tweenList, n = 0; n < e.length; n++)
      e[n].update(t);
    for (var r = (this || window)._frameEventQueue, s; r.length > 0; )
      s = r.shift(), this._ignoreFrameEvent = !0, this._frameEventCallFunc && this._frameEventCallFunc.call(this._frameEventTarget, s.bone, s.frameEventName, s.originFrameIndex, s.currentFrameIndex), this._frameEventListener && this._frameEventListener(s.bone, s.frameEventName, s.originFrameIndex, s.currentFrameIndex), this._ignoreFrameEvent = !1;
    for (var o = (this || window)._movementEventQueue; o.length > 0; )
      s = o.shift(), this._movementEventCallFunc && this._movementEventCallFunc.call(this._movementEventTarget, s.armature, s.movementType, s.movementID), this._movementEventListener && this._movementEventListener(s.armature, s.movementType, s.movementID);
  },
  updateHandler: function() {
    var t = (this || window)._currentPercent;
    if (t >= 1) {
      switch (this._loopType) {
        case ccs.ANIMATION_TYPE_NO_LOOP:
          if (this._loopType = ccs.ANIMATION_TYPE_MAX, this._currentFrame = (t - 1) * this._nextFrameIndex, t = (this || window)._currentFrame / this._durationTween, t < 1) {
            this._nextFrameIndex = (this || window)._durationTween, this.movementEvent(this._armature, ccs.MovementEventType.start, this._movementID);
            break;
          }
          break;
        case ccs.ANIMATION_TYPE_MAX:
        case ccs.ANIMATION_TYPE_SINGLE_FRAME:
          t = 1, this._isComplete = !0, this._isPlaying = !1, this.movementEvent(this._armature, ccs.MovementEventType.complete, this._movementID), this.updateMovementList();
          break;
        case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
          this._loopType = ccs.ANIMATION_TYPE_LOOP_FRONT, t = ccs.fmodf(t, 1), this._currentFrame = (this || window)._nextFrameIndex === 0 ? 0 : ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._nextFrameIndex = (this || window)._durationTween > 0 ? this._durationTween : 1, this.movementEvent(this, ccs.MovementEventType.start, this._movementID);
          break;
        default:
          this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._toIndex = 0, this.movementEvent(this._armature, ccs.MovementEventType.loopComplete, this._movementID);
          break;
      }
      this._currentPercent = t;
    }
  },
  getCurrentMovementID: function() {
    return this._isComplete ? "" : this._movementID;
  },
  setMovementEventCallFunc: function(t, e) {
    arguments.length === 1 ? this._movementEventListener = t : arguments.length === 2 && (this._movementEventTarget = e, this._movementEventCallFunc = t);
  },
  setFrameEventCallFunc: function(t, e) {
    arguments.length === 1 ? this._frameEventListener = t : arguments.length === 2 && (this._frameEventTarget = e, this._frameEventCallFunc = t);
  },
  setUserObject: function(t) {
    this._userObject = t;
  },
  frameEvent: function(t, e, n, r) {
    if (this._frameEventTarget && this._frameEventCallFunc || this._frameEventListener) {
      var s = new ccs.FrameEvent();
      s.bone = t, s.frameEventName = e, s.originFrameIndex = n, s.currentFrameIndex = r, this._frameEventQueue.push(s);
    }
  },
  movementEvent: function(t, e, n) {
    if (this._movementEventTarget && this._movementEventCallFunc || this._movementEventListener) {
      var r = new ccs.MovementEvent();
      r.armature = t, r.movementType = e, r.movementID = n, this._movementEventQueue.push(r);
    }
  },
  updateMovementList: function() {
    if (this._onMovementList) {
      var t, e = (this || window)._movementList;
      this._movementListLoop ? (t = e[this._movementIndex], this.play(t, t.durationTo, 0), this._movementIndex++, this._movementIndex >= e.length && (this._movementIndex = 0)) : this._movementIndex < e.length ? (t = e[this._movementIndex], this.play(t, t.durationTo, 0), this._movementIndex++) : this._onMovementList = !1, this._onMovementList = !0;
    }
  },
  setAnimationData: function(t) {
    this._animationData !== t && (this._animationData = t);
  },
  getAnimationData: function() {
    return this._animationData;
  },
  getUserObject: function() {
    return this._userObject;
  },
  isIgnoreFrameEvent: function() {
    return this._ignoreFrameEvent;
  }
});
var _p = ccs.ArmatureAnimation.prototype;
_p.speedScale;
cc.defineGetterSetter(_p, "speedScale", _p.getSpeedScale, _p.setSpeedScale);
_p.animationScale;
cc.defineGetterSetter(_p, "animationScale", _p.getAnimationScale, _p.setAnimationScale);
_p = null;
ccs.ArmatureAnimation.create = function(t) {
  return new ccs.ArmatureAnimation(t);
};
ccs.Tween = ccs.ProcessBase.extend({
  _tweenData: null,
  _to: null,
  _from: null,
  _between: null,
  _movementBoneData: null,
  _bone: null,
  _frameTweenEasing: 0,
  _betweenDuration: 0,
  _totalDuration: 0,
  _toIndex: 0,
  _fromIndex: 0,
  _animation: null,
  _passLastFrame: !1,
  ctor: function(t) {
    ccs.ProcessBase.prototype.ctor.call(this), this._frameTweenEasing = ccs.TweenType.LINEAR, ccs.Tween.prototype.init.call(this, t);
  },
  init: function(t) {
    return this._from = new ccs.FrameData(), this._between = new ccs.FrameData(), this._bone = t, this._tweenData = (this || window)._bone.getTweenData(), this._tweenData.displayIndex = -1, this._animation = (this || window)._bone !== null && this._bone.getArmature() !== null ? this._bone.getArmature().getAnimation() : null, !0;
  },
  play: function(t, e, n, r, s) {
    ccs.ProcessBase.prototype.play.call(this, e, n, r, s), this._loopType = r ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._totalDuration = 0, this._betweenDuration = 0, this._fromIndex = (this || window)._toIndex = 0;
    var o = t !== (this || window)._movementBoneData;
    this.setMovementBoneData(t), this._rawDuration = (this || window)._movementBoneData.duration;
    var a = (this || window)._movementBoneData.getFrameData(0);
    this._tweenData.displayIndex = a.displayIndex, this._bone.getArmature().getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeSub(this._tweenData, this._bone.getBoneData()), this._tweenData.scaleX += 1, this._tweenData.scaleY += 1), this._rawDuration === 0 ? (this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME, e === 0 ? this.setBetween(a, a) : this.setBetween(this._tweenData, a), this._frameTweenEasing = ccs.TweenType.LINEAR) : this._movementBoneData.frameList.length > 1 && (this._durationTween = n * this._movementBoneData.scale, r && this._movementBoneData.delay !== 0 ? this.setBetween(this._tweenData, this.tweenNodeTo(this.updateFrameData(1 - this._movementBoneData.delay), this._between)) : !o || e === 0 ? this.setBetween(a, a) : this.setBetween(this._tweenData, a)), this.tweenNodeTo(0);
  },
  gotoAndPlay: function(t) {
    ccs.ProcessBase.prototype.gotoFrame.call(this, t), this._totalDuration = 0, this._betweenDuration = 0, this._fromIndex = (this || window)._toIndex = 0, this._isPlaying = !0, this._isComplete = (this || window)._isPause = !1, this._currentPercent = (this || window)._curFrameIndex / (this._rawDuration - 1), this._currentFrame = (this || window)._nextFrameIndex * this._currentPercent;
  },
  gotoAndPause: function(t) {
    this.gotoAndPlay(t), this.pause();
  },
  updateHandler: function() {
    var t = (this || window)._currentPercent == null ? 1 : this._currentPercent, e = (this || window)._loopType;
    if (t >= 1)
      switch (e) {
        case ccs.ANIMATION_TYPE_SINGLE_FRAME:
          t = 1, this._isComplete = !0, this._isPlaying = !1;
          break;
        case ccs.ANIMATION_TYPE_NO_LOOP:
          if (e = ccs.ANIMATION_TYPE_MAX, this._durationTween <= 0 ? t = 1 : t = (t - 1) * this._nextFrameIndex / this._durationTween, t >= 1) {
            t = 1, this._isComplete = !0, this._isPlaying = !1;
            break;
          } else {
            this._nextFrameIndex = (this || window)._durationTween, this._currentFrame = t * this._nextFrameIndex, this._totalDuration = 0, this._betweenDuration = 0, this._fromIndex = (this || window)._toIndex = 0;
            break;
          }
        case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
          e = ccs.ANIMATION_TYPE_LOOP_FRONT, this._nextFrameIndex = (this || window)._durationTween > 0 ? this._durationTween : 1, this._movementBoneData.delay !== 0 ? (this._currentFrame = (1 - this._movementBoneData.delay) * this._nextFrameIndex, t = (this || window)._currentFrame / this._nextFrameIndex) : (t = 0, this._currentFrame = 0), this._totalDuration = 0, this._betweenDuration = 0, this._fromIndex = (this || window)._toIndex = 0;
          break;
        case ccs.ANIMATION_TYPE_MAX:
          t = 1, this._isComplete = !0, this._isPlaying = !1;
          break;
        default:
          this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex);
          break;
      }
    t < 1 && e < ccs.ANIMATION_TYPE_TO_LOOP_BACK && (t = Math.sin(t * cc.PI / 2)), this._currentPercent = t, this._loopType = e, e > ccs.ANIMATION_TYPE_TO_LOOP_BACK && (t = (this || window).updateFrameData(t)), this._frameTweenEasing !== ccs.TweenType.TWEEN_EASING_MAX && this.tweenNodeTo(t);
  },
  setBetween: function(t, e, n) {
    n === void 0 && (n = !0);
    do {
      if (t.displayIndex < 0 && e.displayIndex >= 0) {
        this._from.copy(e), this._between.subtract(e, e, n);
        break;
      }
      if (e.displayIndex < 0 && t.displayIndex >= 0) {
        this._from.copy(t), this._between.subtract(e, e, n);
        break;
      }
      this._from.copy(t), this._between.subtract(t, e, n);
    } while (0);
    t.isTween || (this._tweenData.copy(t), this._tweenData.isTween = !0), this.arriveKeyFrame(t);
  },
  arriveKeyFrame: function(t) {
    if (t) {
      var e = (this || window)._bone, n = e.getDisplayManager(), r = t.displayIndex;
      n.getForceChangeDisplay() || n.changeDisplayWithIndex(r, !1), this._tweenData.zOrder = t.zOrder, e.updateZOrder(), this._bone.setBlendFunc(t.blendFunc);
      var s = e.getChildArmature();
      s && t.movement !== "" && s.getAnimation().play(t.movement);
    }
  },
  tweenNodeTo: function(t, e) {
    e || (e = (this || window)._tweenData);
    var n = (this || window)._from, r = (this || window)._between;
    return n.isTween || (t = 0), e.x = n.x + t * r.x, e.y = n.y + t * r.y, e.scaleX = n.scaleX + t * r.scaleX, e.scaleY = n.scaleY + t * r.scaleY, e.skewX = n.skewX + t * r.skewX, e.skewY = n.skewY + t * r.skewY, this._bone.setTransformDirty(!0), e && r.isUseColorInfo && this.tweenColorTo(t, e), e;
  },
  tweenColorTo: function(t, e) {
    var n = (this || window)._from, r = (this || window)._between;
    e.a = n.a + t * r.a, e.r = n.r + t * r.r, e.g = n.g + t * r.g, e.b = n.b + t * r.b, this._bone.updateColor();
  },
  updateFrameData: function(t) {
    t > 1 && this._movementBoneData.delay !== 0 && (t = ccs.fmodf(t, 1));
    var e = (this._rawDuration - 1) * t, n, r, s = (this || window)._totalDuration, o = (this || window)._betweenDuration, a = (this || window)._toIndex;
    if (e < s || e >= s + o) {
      var c = (this || window)._movementBoneData.frameList, l = c.length;
      if (e < c[0].frameID)
        return n = r = c[0], this.setBetween(n, r), this._currentPercent;
      if (e >= c[l - 1].frameID) {
        if (this._passLastFrame)
          return n = r = c[l - 1], this.setBetween(n, r), this._currentPercent;
        this._passLastFrame = !0;
      } else
        this._passLastFrame = !1;
      do
        if (this._fromIndex = a, n = c[this._fromIndex], s = n.frameID, a = (this || window)._fromIndex + 1, a >= l && (a = 0), r = c[a], n.strEvent && !this._animation.isIgnoreFrameEvent() && this._animation.frameEvent(this._bone, n.strEvent, n.frameID, e), e === n.frameID || this._passLastFrame && this._fromIndex === l - 1)
          break;
      while (e < n.frameID || e >= r.frameID);
      o = r.frameID - n.frameID, this._frameTweenEasing = n.tweenEasing, this.setBetween(n, r, !1), this._totalDuration = s, this._betweenDuration = o, this._toIndex = a;
    }
    t = o === 0 ? 0 : (e - this._totalDuration) / this._betweenDuration;
    var h = (this || window)._frameTweenEasing !== ccs.TweenType.LINEAR ? this._frameTweenEasing : this._tweenEasing;
    return h !== ccs.TweenType.TWEEN_EASING_MAX && h !== ccs.TweenType.LINEAR && !this._passLastFrame && (t = ccs.TweenFunction.tweenTo(t, h, this._from.easingParams)), t;
  },
  setAnimation: function(t) {
    this._animation = t;
  },
  getAnimation: function() {
    return this._animation;
  },
  setMovementBoneData: function(t) {
    this._movementBoneData = t;
  }
});
var _p = ccs.Tween.prototype;
_p.animation;
cc.defineGetterSetter(_p, "animation", _p.getAnimation, _p.setAnimation);
_p = null;
ccs.Tween.create = function(t) {
  return new ccs.Tween(t);
};
ccs.PT_RATIO = 32;
ccs.ColliderFilter = ccs.Class.extend({
  _collisionType: 0,
  _group: 0,
  _categoryBits: 0,
  _groupIndex: 0,
  _maskBits: 0,
  ctor: function(t, e) {
    this._collisionType = t || 0, this._group = e || 0;
  },
  updateShape: function(t) {
    if (t instanceof cp.Shape)
      t.collision_type = (this || window)._collisionType, t.group = (this || window)._group;
    else if (t instanceof Box2D.b2FilterData) {
      var e = new Box2D.b2FilterData();
      e.categoryBits = (this || window)._categoryBits, e.groupIndex = (this || window)._groupIndex, e.maskBits = (this || window)._maskBits, t.SetFilterData(e);
    }
  }
});
ccs.ColliderBody = ccs.Class.extend({
  shape: null,
  coutourData: null,
  colliderFilter: null,
  _calculatedVertexList: null,
  ctor: function(t) {
    this.shape = null, this.coutourData = t, this.colliderFilter = new ccs.ColliderFilter(), ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX && (this._calculatedVertexList = []);
  },
  getContourData: function() {
    return this.coutourData;
  },
  setColliderFilter: function(t) {
    this.colliderFilter = t;
  },
  getCalculatedVertexList: function() {
    return this._calculatedVertexList;
  },
  setB2Fixture: function(t) {
    this._fixture = t;
  },
  getB2Fixture: function() {
    return this._fixture;
  },
  setShape: function(t) {
    this.shape = t;
  },
  getShape: function() {
    return this.shape;
  },
  setContourData: function(t) {
    this.coutourData = t;
  },
  getColliderFilter: function() {
    return this.colliderFilter;
  }
});
ccs.ColliderDetector = ccs.Class.extend({
  _colliderBodyList: null,
  _bone: null,
  _body: null,
  _active: !1,
  _filter: null,
  helpPoint: cc.p(0, 0),
  ctor: function(t) {
    this._colliderBodyList = [], this._bone = null, this._body = null, this._active = !1, this._filter = null, ccs.ColliderDetector.prototype.init.call(this, t);
  },
  init: function(t) {
    return this._colliderBodyList.length = 0, t && (this._bone = t), this._filter = new ccs.ColliderFilter(), !0;
  },
  addContourData: function(t) {
    var e = new ccs.ColliderBody(t);
    if (this._colliderBodyList.push(e), ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX)
      for (var n = e.getCalculatedVertexList(), r = t.vertexList, s = 0; s < r.length; s++) {
        var o = new ccs.ContourVertex2(0, 0);
        n.push(o);
      }
  },
  addContourDataList: function(t) {
    for (var e = 0; e < t.length; e++)
      this.addContourData(t[e]);
  },
  removeContourData: function(t) {
    var e = [], n, r = (this || window)._colliderBodyList;
    for (n = 0; n < r.length; n++) {
      var s = r[n];
      s && s.getContourData() === t && e.push(s);
    }
    for (n = 0; n < e.length; n++)
      cc.arrayRemoveObject(r, e[n]);
  },
  removeAll: function() {
    this._colliderBodyList.length = 0;
  },
  setActive: function(t) {
    if (this._active !== t) {
      this._active = t;
      var e = (this || window)._body, n;
      if (e) {
        var r = null;
        if (this._active)
          for (var s = 0; s < this._colliderBodyList.length; s++)
            r = (this || window)._colliderBodyList[s], n = r.getShape(), e.space.addShape(n);
        else
          for (var s = 0; s < this._colliderBodyList.length; s++)
            r = (this || window)._colliderBodyList[s], n = r.getShape(), e.space.removeShape(n);
      }
    }
  },
  getActive: function() {
    return this._active;
  },
  getColliderBodyList: function() {
    return this._colliderBodyList;
  },
  setColliderFilter: function(t) {
    this._filter = t;
    for (var e = (this || window)._colliderBodyList, n = 0; n < e.length; n++) {
      var r = e[n];
      r.setColliderFilter(t), r.getShape() && r.getColliderFilter().updateShape(r.getShape());
    }
  },
  getColliderFilter: function() {
    return this._filter;
  },
  updateTransform: function(t) {
    if (this._active)
      for (var e = null, n = (this || window)._body, r = (this || window).helpPoint, s = 0; s < this._colliderBodyList.length; s++) {
        e = (this || window)._colliderBodyList[s];
        var o = e.getContourData(), a = null;
        n && (a = e.getShape());
        for (var c = o.vertexList, l = e.getCalculatedVertexList(), h = 0; h < c.length; h++) {
          if (r.x = c[h].x, r.y = c[h].y, r = cc.pointApplyAffineTransform(r, t), ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
            var u = cc.p(0, 0);
            u.x = r.x, u.y = r.y, l[h] = u;
          }
          a && (a.verts[h * 2] = r.x, a.verts[h * 2 + 1] = r.y);
        }
        if (a)
          for (var h = 0; h < c.length; h++) {
            var _ = a.verts[(h + 1) % a.verts.length], d = cp.v.normalize(cp.v.perp(cp.v.sub(_, a.verts[h])));
            a.planes && (a.planes[h].n = d, a.planes[h].d = cp.v.dot(d, a.verts[h]));
          }
      }
  },
  setBody: function(t) {
    this._body = t;
    for (var e, n = (this || window)._colliderBodyList, r = 0; r < n.length; r++) {
      e = n[r];
      for (var s = e.getContourData(), o = [], a = s.vertexList, c = 0; c < a.length; c++) {
        var l = a[c];
        o.push(l.x), o.push(l.y);
      }
      var h = new cp.PolyShape(this._body, o, cp.vzero);
      h.sensor = !0, h.data = (this || window)._bone, this._active && this._body.space.addShape(h), e.setShape(h), e.getColliderFilter().updateShape(h);
    }
  },
  getBody: function() {
    return this._body;
  }
});
var _p = ccs.ColliderDetector.prototype;
_p.colliderFilter;
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
_p.active;
cc.defineGetterSetter(_p, "active", _p.getActive, _p.setActive);
_p.body;
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
_p = null;
ccs.ColliderDetector.create = function(t) {
  return new ccs.ColliderDetector(t);
};
ccs.Armature = ccs.Node.extend({
  animation: null,
  armatureData: null,
  batchNode: null,
  _textureAtlas: null,
  _parentBone: null,
  _boneDic: null,
  _topBoneList: null,
  _armatureIndexDic: null,
  _offsetPoint: null,
  version: 0,
  _armatureTransformDirty: !0,
  _body: null,
  _blendFunc: null,
  _className: "Armature",
  ctor: function(t, e) {
    cc.Node.prototype.ctor.call(this), this._name = "", this._topBoneList = [], this._armatureIndexDic = {}, this._offsetPoint = cc.p(0, 0), this._armatureTransformDirty = !0, this._blendFunc = { src: cc.BLEND_SRC, dst: cc.BLEND_DST }, t && ccs.Armature.prototype.init.call(this, t, e);
  },
  init: function(t, e) {
    cc.Node.prototype.init.call(this), e && (this._parentBone = e), this.removeAllChildren(), this.animation = new ccs.ArmatureAnimation(), this.animation.init(this), this._boneDic = {}, this._topBoneList.length = 0;
    var n = ccs.armatureDataManager, r;
    if (t !== "") {
      r = n.getAnimationData(t), cc.assert(r, "AnimationData not exist!"), this.animation.setAnimationData(r);
      var s = n.getArmatureData(t);
      cc.assert(s, "ArmatureData not exist!"), this.armatureData = s;
      var o = s.getBoneDataDic();
      for (var a in o) {
        var c = (this || window).createBone(String(a));
        do {
          var l = r.getMovement(r.movementNames[0]);
          if (!l)
            break;
          var h = l.getMovementBoneData(c.getName());
          if (!h || h.frameList.length <= 0)
            break;
          var u = h.getFrameData(0);
          if (!u)
            break;
          c.getTweenData().copy(u), c.changeDisplayWithIndex(u.displayIndex, !1);
        } while (0);
      }
      this.update(0), this.updateOffsetPoint();
    } else
      t = "new_armature", this.armatureData = new ccs.ArmatureData(), this.armatureData.name = t, r = new ccs.AnimationData(), r.name = t, n.addArmatureData(t, this.armatureData), n.addAnimationData(t, r), this.animation.setAnimationData(r);
    return this._renderCmd.initShaderCache(), this.setCascadeOpacityEnabled(!0), this.setCascadeColorEnabled(!0), !0;
  },
  addChild: function(t, e, n) {
    if (t instanceof ccui.Widget) {
      cc.log("Armature doesn't support to add Widget as its child, it will be fix soon.");
      return;
    }
    cc.Node.prototype.addChild.call(this, t, e, n);
  },
  createBone: function(t) {
    var e = (this || window).getBone(t);
    if (e)
      return e;
    var n = (this || window).armatureData.getBoneData(t), r = n.parentName, s = null;
    return r ? (this.createBone(r), s = new ccs.Bone(t), this.addBone(s, r)) : (s = new ccs.Bone(t), this.addBone(s, "")), s.setBoneData(n), s.getDisplayManager().changeDisplayWithIndex(-1, !1), s;
  },
  addBone: function(t, e) {
    cc.assert(t, "Argument must be non-nil");
    var n = (this || window)._boneDic;
    if (t.getName() && cc.assert(!n[t.getName()], "bone already added. It can't be added again"), e) {
      var r = n[e];
      r ? r.addChildBone(t) : this._topBoneList.push(t);
    } else
      this._topBoneList.push(t);
    t.setArmature(this), n[t.getName()] = t, this.addChild(t);
  },
  removeBone: function(t, e) {
    cc.assert(t, "bone must be added to the bone dictionary!"), t.setArmature(null), t.removeFromParent(e), cc.arrayRemoveObject(this._topBoneList, t), delete this._boneDic[t.getName()], this.removeChild(t, !0);
  },
  getBone: function(t) {
    return this._boneDic[t];
  },
  changeBoneParent: function(t, e) {
    cc.assert(t, "bone must be added to the bone dictionary!");
    var n = t.getParentBone();
    if (n && (cc.arrayRemoveObject(n.getChildren(), t), t.setParentBone(null)), e) {
      var r = (this || window)._boneDic[e];
      r ? (r.addChildBone(t), cc.arrayRemoveObject(this._topBoneList, t)) : this._topBoneList.push(t);
    }
  },
  getBoneDic: function() {
    return this._boneDic;
  },
  updateOffsetPoint: function() {
    var t = (this || window).getBoundingBox();
    this.setContentSize(t);
    var e = (this || window)._offsetPoint;
    e.x = -t.x, e.y = -t.y, t.width !== 0 && t.height !== 0 && this.setAnchorPoint(e.x / t.width, e.y / t.height);
  },
  getOffsetPoints: function() {
    return { x: this._offsetPoint.x, y: this._offsetPoint.y };
  },
  setAnimation: function(t) {
    this.animation = t;
  },
  getAnimation: function() {
    return this.animation;
  },
  getArmatureTransformDirty: function() {
    return this._armatureTransformDirty;
  },
  update: function(t) {
    this.animation.update(t);
    for (var e = (this || window)._topBoneList, n = 0; n < e.length; n++)
      e[n].update(t);
    this._armatureTransformDirty = !1;
  },
  onEnter: function() {
    cc.Node.prototype.onEnter.call(this), this.scheduleUpdate();
  },
  onExit: function() {
    cc.Node.prototype.onExit.call(this), this.unscheduleUpdate();
  },
  getBoundingBox: function() {
    for (var t, e, n, r = 0, s = !0, o = cc.rect(0, 0, 0, 0), a = (this || window)._children, c = a.length, l = 0; l < c; l++) {
      var h = a[l];
      if (h) {
        var u = h.getDisplayManager().getBoundingBox();
        if (u.x === 0 && u.y === 0 && u.width === 0 && u.height === 0)
          continue;
        s ? (t = u.x, e = u.y, n = u.x + u.width, r = u.y + u.height, s = !1) : (t = u.x < o.x ? u.x : o.x, e = u.y < o.y ? u.y : o.y, n = u.x + u.width > o.x + o.width ? u.x + u.width : o.x + o.width, r = u.y + u.height > o.y + o.height ? u.y + u.height : o.y + o.height), o.x = t, o.y = e, o.width = n - t, o.height = r - e;
      }
    }
    return cc.rectApplyAffineTransform(o, this.getNodeToParentTransform());
  },
  getBoneAtPoint: function(t, e) {
    for (var n = (this || window)._children, r = n.length - 1; r >= 0; r--) {
      var s = n[r];
      if (s instanceof ccs.Bone && s.getDisplayManager().containPoint(t, e))
        return s;
    }
    return null;
  },
  setParentBone: function(t) {
    this._parentBone = t;
    var e = (this || window)._boneDic;
    for (var n in e)
      e[n].setArmature(this);
  },
  getParentBone: function() {
    return this._parentBone;
  },
  drawContour: function() {
    cc._drawingUtil.setDrawColor(255, 255, 255, 255), cc._drawingUtil.setLineWidth(1);
    var t = (this || window)._boneDic;
    for (var e in t) {
      var n = t[e], r = n.getColliderDetector();
      if (r)
        for (var s = r.getColliderBodyList(), o = 0; o < s.length; o++) {
          var a = s[o], c = a.getCalculatedVertexList();
          cc._drawingUtil.drawPoly(c, c.length, !0);
        }
    }
  },
  setBody: function(t) {
    if (this._body !== t) {
      this._body = t, this._body.data = (this || window);
      for (var e, n, r = (this || window)._children, s = 0; s < r.length; s++)
        if (e = r[s], e instanceof ccs.Bone)
          for (var o = e.getDisplayManager().getDecorativeDisplayList(), a = 0; a < o.length; a++) {
            n = o[a];
            var c = n.getColliderDetector();
            c && c.setBody(this._body);
          }
    }
  },
  getShapeList: function() {
    return this._body ? this._body.shapeList : null;
  },
  getBody: function() {
    return this._body;
  },
  setBlendFunc: function(t, e) {
    e === void 0 ? (this._blendFunc.src = t.src, this._blendFunc.dst = t.dst) : (this._blendFunc.src = t, this._blendFunc.dst = e);
  },
  getBlendFunc: function() {
    return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
  },
  setColliderFilter: function(t) {
    var e = (this || window)._boneDic;
    for (var n in e)
      e[n].setColliderFilter(t);
  },
  getArmatureData: function() {
    return this.armatureData;
  },
  setArmatureData: function(t) {
    this.armatureData = t;
  },
  getBatchNode: function() {
    return this.batchNode;
  },
  setBatchNode: function(t) {
    this.batchNode = t;
  },
  getVersion: function() {
    return this.version;
  },
  setVersion: function(t) {
    this.version = t;
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccs.Armature.CanvasRenderCmd(this) : new ccs.Armature.WebGLRenderCmd(this);
  }
});
var _p = ccs.Armature.prototype;
_p.parentBone;
cc.defineGetterSetter(_p, "parentBone", _p.getParentBone, _p.setParentBone);
_p.body;
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
_p.colliderFilter;
cc.defineGetterSetter(_p, "colliderFilter", null, _p.setColliderFilter);
_p = null;
ccs.Armature.create = function(t, e) {
  return new ccs.Armature(t, e);
};
(function() {
  ccs.Armature.RenderCmd = {
    _updateAnchorPointInPoint: function() {
      var t = (this || window)._node, e = t._contentSize, n = t._anchorPoint, r = t._offsetPoint;
      this._anchorPointInPoints.x = e.width * n.x - r.x, this._anchorPointInPoints.y = e.height * n.y - r.y, this._realAnchorPointInPoints.x = e.width * n.x, this._realAnchorPointInPoints.y = e.height * n.y, this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
    },
    getAnchorPointInPoints: function() {
      return cc.p(this._realAnchorPointInPoints);
    }
  };
})();
(function() {
  ccs.Armature.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !0, this._realAnchorPointInPoints = new cc.Point(0, 0), this._canUseDirtyRegion = !0, this._startRenderCmd = new cc.CustomRenderCmd(this, this._startCmdCallback), this._RestoreRenderCmd = new cc.CustomRenderCmd(this, this._RestoreCmdCallback), this._startRenderCmd._canUseDirtyRegion = !0, this._RestoreRenderCmd._canUseDirtyRegion = !0;
  };
  var t = ccs.Armature.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  cc.inject(ccs.Armature.RenderCmd, t), t.constructor = ccs.Armature.CanvasRenderCmd, t._startCmdCallback = function(e, n, r) {
    var s = (this || window)._node, o = s._parent;
    this.transform(o ? o._renderCmd : null);
    var a = e || cc._renderContext;
    a.save(), a._switchToArmatureMode(!0, this._worldTransform, n, r);
  }, t.transform = function(e, n) {
    ccs.Node.CanvasRenderCmd.prototype.transform.call(this, e, n);
    for (var r = (this || window)._node._children, s = 0, o = r.length; s < o; s++) {
      var a = r[s], c = a._renderCmd;
      if (a && a.getDisplayRenderNode) {
        var l = a.getDisplayRenderNodeType(), h = a.getDisplayRenderNode();
        if (h && h._renderCmd) {
          var u = h._renderCmd;
          u.transform(null), l !== ccs.DISPLAY_TYPE_ARMATURE && l !== ccs.DISPLAY_TYPE_SPRITE && cc.affineTransformConcatIn(u._worldTransform, a._worldTransform);
          var _ = cc.Node._dirtyFlags, d = u._dirtyFlag, f = c._dirtyFlag, C = f & _.colorDirty, m = f & _.opacityDirty;
          C && c._updateDisplayColor(), m && c._updateDisplayOpacity(), (C || m) && c._updateColor();
          var g = a._renderCmd._displayedColor, y = a._renderCmd._displayedOpacity;
          C = d & _.colorDirty, m = d & _.opacityDirty, C && u._updateDisplayColor(g), m && u._updateDisplayOpacity(y), (C || m) && u._updateColor();
        }
      }
    }
  }, t._RestoreCmdCallback = function(e) {
    this._cacheDirty = !1, e._switchToArmatureMode(!1), e.restore();
  }, t.initShaderCache = function() {
  }, t.setShaderProgram = function() {
  }, t.updateChildPosition = function(e, n) {
    e.visit();
  }, t.rendering = function(e, n, r) {
    var s = (this || window)._node, o = s._children;
    cc.BlendFunc.ALPHA_PREMULTIPLIED, cc.BlendFunc.ALPHA_NON_PREMULTIPLIED;
    for (var a = 0, c = o.length; a < c; a++) {
      var l = o[a];
      if (l && l.getDisplayRenderNode) {
        var h = l.getDisplayRenderNode();
        if (h === null)
          continue;
        var u = l._renderCmd;
        switch (u._syncStatus(this), l.getDisplayRenderNodeType()) {
          case ccs.DISPLAY_TYPE_SPRITE:
            h._renderCmd.visit(u);
            break;
          case ccs.DISPLAY_TYPE_ARMATURE:
            h._renderCmd.rendering(e, n, r);
            break;
          default:
            h._renderCmd.visit(u);
            break;
        }
      } else
        l instanceof cc.Node && this._visitNormalChild(l);
    }
  }, t._visitNormalChild = function(e) {
    if (e) {
      var n = e._renderCmd;
      if (e._visible) {
        n._curLevel = (this || window)._curLevel + 1;
        var r, s = e._children, o;
        n._syncStatus(this), n.transform(null);
        var a = s.length;
        if (a > 0) {
          for (e.sortAllChildren(), r = 0; r < a && (o = s[r], o._localZOrder < 0); r++)
            o._renderCmd.visit(n);
          for (cc.renderer.pushRenderCommand(n); r < a; r++)
            s[r]._renderCmd.visit(n);
        } else
          cc.renderer.pushRenderCommand(n);
        this._dirtyFlag = 0;
      }
    }
  }, t.visit = function(e) {
    var n = (this || window)._node;
    n._visible && (this._syncStatus(e), n.sortAllChildren(), cc.renderer.pushRenderCommand(this._startRenderCmd), this.rendering(), cc.renderer.pushRenderCommand(this._RestoreRenderCmd), this._cacheDirty = !1);
  };
})();
ccs.Bone = ccs.Node.extend({
  _boneData: null,
  _armature: null,
  _childArmature: null,
  _displayManager: null,
  ignoreMovementBoneData: !1,
  _tween: null,
  _tweenData: null,
  _parentBone: null,
  _boneTransformDirty: !1,
  _worldTransform: null,
  _blendFunc: null,
  blendDirty: !1,
  _worldInfo: null,
  _armatureParentBone: null,
  _dataVersion: 0,
  _className: "Bone",
  ctor: function(t) {
    cc.Node.prototype.ctor.call(this), this._tweenData = null, this._parentBone = null, this._armature = null, this._childArmature = null, this._boneData = null, this._tween = null, this._displayManager = null, this.ignoreMovementBoneData = !1, this._worldTransform = cc.affineTransformMake(1, 0, 0, 1, 0, 0), this._boneTransformDirty = !0, this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST), this.blendDirty = !1, this._worldInfo = null, this._armatureParentBone = null, this._dataVersion = 0, ccs.Bone.prototype.init.call(this, t);
  },
  init: function(t) {
    return t && (this._name = t), this._tweenData = new ccs.FrameData(), this._tween = new ccs.Tween(this), this._displayManager = new ccs.DisplayManager(this), this._worldInfo = new ccs.BaseData(), this._boneData = new ccs.BaseData(), !0;
  },
  setBoneData: function(t) {
    cc.assert(t, "_boneData must not be null"), this._boneData !== t && (this._boneData = t), this.setName(this._boneData.name), this._localZOrder = (this || window)._boneData.zOrder, this._displayManager.initDisplayList(t);
  },
  getBoneData: function() {
    return this._boneData;
  },
  setArmature: function(t) {
    this._armature = t, t ? (this._tween.setAnimation(this._armature.getAnimation()), this._dataVersion = (this || window)._armature.getArmatureData().dataVersion, this._armatureParentBone = (this || window)._armature.getParentBone()) : this._armatureParentBone = null;
  },
  getArmature: function() {
    return this._armature;
  },
  update: function(t) {
    if (this._parentBone && (this._boneTransformDirty = (this || window)._boneTransformDirty || this._parentBone.isTransformDirty()), this._armatureParentBone && !this._boneTransformDirty && (this._boneTransformDirty = (this || window)._armatureParentBone.isTransformDirty()), this._boneTransformDirty) {
      var e = (this || window)._tweenData;
      this._dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeConcat(e, this._boneData), e.scaleX -= 1, e.scaleY -= 1);
      var n = (this || window)._worldInfo;
      n.copy(e), n.x = e.x + this._position.x, n.y = e.y + this._position.y, n.scaleX = e.scaleX * this._scaleX, n.scaleY = e.scaleY * this._scaleY, n.skewX = e.skewX + this._skewX + cc.degreesToRadians(this._rotationX), n.skewY = e.skewY + this._skewY - cc.degreesToRadians(this._rotationY), this._parentBone ? this._applyParentTransform(this._parentBone) : this._armatureParentBone && this._applyParentTransform(this._armatureParentBone), ccs.TransformHelp.nodeToMatrix(n, this._worldTransform), this._armatureParentBone && cc.affineTransformConcatIn(this._worldTransform, this._armature.getNodeToParentTransform());
    }
    ccs.displayFactory.updateDisplay(this, t, this._boneTransformDirty || this._armature.getArmatureTransformDirty());
    for (var r = 0; r < this._children.length; r++) {
      var s = (this || window)._children[r];
      s.update(t);
    }
    this._boneTransformDirty = !1;
  },
  _applyParentTransform: function(t) {
    var e = (this || window)._worldInfo, n = t._worldTransform, r = t._worldInfo, s = e.x, o = e.y;
    e.x = s * n.a + o * n.c + r.x, e.y = s * n.b + o * n.d + r.y, e.scaleX = e.scaleX * r.scaleX, e.scaleY = e.scaleY * r.scaleY, e.skewX = e.skewX + r.skewX, e.skewY = e.skewY + r.skewY;
  },
  setBlendFunc: function(t, e) {
    var n = (this || window)._blendFunc, r, s;
    e === void 0 ? (r = t.src, s = t.dst) : (r = t, s = e), (n.src !== r || n.dst !== s) && (n.src = r, n.dst = s, this.blendDirty = !0);
  },
  updateColor: function() {
    var t = (this || window)._displayManager.getDisplayRenderNode();
    if (t !== null) {
      var e = (this || window)._renderCmd;
      t.setColor(
        cc.color(
          e._displayedColor.r * this._tweenData.r / 255,
          e._displayedColor.g * this._tweenData.g / 255,
          e._displayedColor.b * this._tweenData.b / 255
        )
      ), t.setOpacity(e._displayedOpacity * this._tweenData.a / 255);
    }
  },
  updateZOrder: function() {
    this._armature.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? this.setLocalZOrder(this._tweenData.zOrder + this._boneData.zOrder) : this.setLocalZOrder(this._tweenData.zOrder);
  },
  addChildBone: function(t) {
    cc.assert(t, "Argument must be non-nil"), cc.assert(!t.parentBone, "child already added. It can't be added again"), this._children.indexOf(t) < 0 && (this._children.push(t), t.setParentBone(this));
  },
  removeChildBone: function(t, e) {
    if (this._children.length > 0 && this._children.getIndex(t) !== -1) {
      if (e)
        for (var n = t._children, r = 0; r < n.length; r++) {
          var s = n[r];
          t.removeChildBone(s, e);
        }
      t.setParentBone(null), t.getDisplayManager().setCurrentDecorativeDisplay(null), cc.arrayRemoveObject(this._children, t);
    }
  },
  removeFromParent: function(t) {
    this._parentBone && this._parentBone.removeChildBone(this, t);
  },
  setParentBone: function(t) {
    this._parentBone = t;
  },
  getParentBone: function() {
    return this._parentBone;
  },
  setChildArmature: function(t) {
    this._childArmature !== t && (t == null && this._childArmature && this._childArmature.setParentBone(null), this._childArmature = t);
  },
  getChildArmature: function() {
    return this._childArmature;
  },
  getTween: function() {
    return this._tween;
  },
  setLocalZOrder: function(t) {
    this._localZOrder !== t && cc.Node.prototype.setLocalZOrder.call(this, t);
  },
  getNodeToArmatureTransform: function() {
    return this._worldTransform;
  },
  getNodeToWorldTransform: function() {
    return cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToWorldTransform());
  },
  getDisplayRenderNode: function() {
    return this._displayManager.getDisplayRenderNode();
  },
  getDisplayRenderNodeType: function() {
    return this._displayManager.getDisplayRenderNodeType();
  },
  addDisplay: function(t, e) {
    return e = e || 0, this._displayManager.addDisplay(t, e);
  },
  removeDisplay: function(t) {
    this._displayManager.removeDisplay(t);
  },
  changeDisplayByIndex: function(t, e) {
    cc.log("changeDisplayByIndex is deprecated. Use changeDisplayWithIndex instead."), this.changeDisplayWithIndex(t, e);
  },
  changeDisplayByName: function(t, e) {
    cc.log("changeDisplayByName is deprecated. Use changeDisplayWithName instead."), this.changeDisplayWithName(t, e);
  },
  changeDisplayWithIndex: function(t, e) {
    this._displayManager.changeDisplayWithIndex(t, e);
  },
  changeDisplayWithName: function(t, e) {
    this._displayManager.changeDisplayWithName(t, e);
  },
  getColliderDetector: function() {
    var t = (this || window)._displayManager.getCurrentDecorativeDisplay();
    if (t) {
      var e = t.getColliderDetector();
      if (e)
        return e;
    }
    return null;
  },
  setColliderFilter: function(t) {
    for (var e = (this || window)._displayManager.getDecorativeDisplayList(), n = 0; n < e.length; n++) {
      var r = e[n], s = r.getColliderDetector();
      s && s.setColliderFilter(t);
    }
  },
  getColliderFilter: function() {
    var t = (this || window).displayManager.getCurrentDecorativeDisplay();
    if (t) {
      var e = t.getColliderDetector();
      if (e)
        return e.getColliderFilter();
    }
    return null;
  },
  setTransformDirty: function(t) {
    this._boneTransformDirty = t;
  },
  isTransformDirty: function() {
    return this._boneTransformDirty;
  },
  getDisplayManager: function() {
    return this._displayManager;
  },
  setIgnoreMovementBoneData: function(t) {
    this._ignoreMovementBoneData = t;
  },
  isIgnoreMovementBoneData: function() {
    return this._ignoreMovementBoneData;
  },
  getBlendFunc: function() {
    return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
  },
  setBlendDirty: function(t) {
    this._blendDirty = t;
  },
  isBlendDirty: function() {
    return this._blendDirty;
  },
  getTweenData: function() {
    return this._tweenData;
  },
  getWorldInfo: function() {
    return this._worldInfo;
  },
  getChildrenBone: function() {
    return this._children;
  },
  nodeToArmatureTransform: function() {
    return this.getNodeToArmatureTransform();
  },
  nodeToWorldTransform: function() {
    return this.getNodeToWorldTransform();
  },
  getColliderBodyList: function() {
    var t = (this || window).getColliderDetector();
    return t ? t.getColliderBodyList() : null;
  },
  getIgnoreMovementBoneData: function() {
    return this.isIgnoreMovementBoneData();
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccs.Bone.CanvasRenderCmd(this) : new ccs.Bone.WebGLRenderCmd(this);
  }
});
var _p = ccs.Bone.prototype;
_p.boneData;
cc.defineGetterSetter(_p, "boneData", _p.getBoneData, _p.setBoneData);
_p.armature;
cc.defineGetterSetter(_p, "armature", _p.getArmature, _p.setArmature);
_p.childArmature;
cc.defineGetterSetter(_p, "childArmature", _p.getChildArmature, _p.setChildArmature);
_p.childrenBone;
cc.defineGetterSetter(_p, "childrenBone", _p.getChildrenBone);
_p.tween;
cc.defineGetterSetter(_p, "tween", _p.getTween);
_p.tweenData;
cc.defineGetterSetter(_p, "tweenData", _p.getTweenData);
_p.colliderFilter;
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
_p = null;
ccs.Bone.create = function(t) {
  return new ccs.Bone(t);
};
ccs.Bone.RenderCmd = {
  _updateColor: function() {
    var t = (this || window)._node, e = t._displayManager.getDisplayRenderNode();
    if (e !== null) {
      var n = e._renderCmd;
      e.setColor(this._displayedColor), e.setOpacity(this._displayedOpacity), n._syncDisplayColor(t._tweenData), n._syncDisplayOpacity(t._tweenData.a), n._updateColor();
    }
  },
  transform: function(t, e) {
    var n = (this || window)._node, r = (this || window)._transform, s = (this || window)._worldTransform, o = t ? t._worldTransform : null;
    o && (this.originTransform(), cc.affineTransformConcatIn(r, n._worldTransform)), o ? (s.a = r.a * o.a + r.b * o.c, s.b = r.a * o.b + r.b * o.d, s.c = r.c * o.a + r.d * o.c, s.d = r.c * o.b + r.d * o.d, s.tx = r.tx * o.a + r.ty * o.c + o.tx, s.ty = r.tx * o.b + r.ty * o.d + o.ty) : (s.a = r.a, s.b = r.b, s.c = r.c, s.d = r.d, s.tx = r.tx, s.ty = r.ty);
  }
};
(function() {
  ccs.Bone.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._needDraw = !1;
  };
  var t = ccs.Bone.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  cc.inject(ccs.Bone.RenderCmd, t), t.constructor = ccs.Bone.CanvasRenderCmd;
})();
(function() {
  if (cc.Node.WebGLRenderCmd) {
    ccs.Bone.WebGLRenderCmd = function(e) {
      cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !1;
    };
    var t = ccs.Bone.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    cc.inject(ccs.Bone.RenderCmd, t), t.constructor = ccs.Bone.WebGLRenderCmd;
  }
})();
ccs.FRAME_TYPE_MOVE = 0;
ccs.FRAME_TYPE_SCALE = 1;
ccs.FRAME_TYPE_ROTATE = 2;
ccs.FRAME_TYPE_TINT = 3;
ccs.FRAME_TYPE_FADE = 4;
ccs.FRAME_TYPE_MAX = 5;
ccs.FrameEaseType = {
  CUSTOM: -1,
  LINEAR: 0,
  SINE_EASEIN: 1,
  SINE_EASEOUT: 2,
  SINE_EASEINOUT: 3,
  QUAD_EASEIN: 4,
  QUAD_EASEOUT: 5,
  QUAD_EASEINOUT: 6,
  CUBIC_EASEIN: 7,
  CUBIC_EASEOUT: 8,
  CUBIC_EASEINOUT: 9,
  QUART_EASEIN: 10,
  QUART_EASEOUT: 11,
  QUART_EASEINOUT: 12,
  QUINT_EASEIN: 13,
  QUINT_EASEOUT: 14,
  QUINT_EASEINOUT: 15,
  EXPO_EASEIN: 16,
  EXPO_EASEOUT: 17,
  EXPO_EASEINOUT: 18,
  CIRC_EASEIN: 19,
  CIRC_EASEOUT: 20,
  CIRC_EASEINOUT: 21,
  ELASTIC_EASEIN: 22,
  ELASTIC_EASEOUT: 23,
  ELASTIC_EASEINOUT: 24,
  BACK_EASEIN: 25,
  BACK_EASEOUT: 26,
  BACK_EASEINOUT: 27,
  BOUNCE_EASEIN: 28,
  BOUNCE_EASEOUT: 29,
  BOUNCE_EASEINOUT: 30,
  TWEEN_EASING_MAX: 1e3
};
ccs.ActionFrame = ccs.Class.extend({
  frameType: 0,
  easingType: 0,
  frameIndex: 0,
  _Parameter: null,
  time: 0,
  ctor: function() {
    this.frameType = 0, this.easingType = ccs.FrameEaseType.LINEAR, this.frameIndex = 0, this.time = 0;
  },
  getAction: function(t, e) {
    return cc.log("Need a definition of <getAction> for ActionFrame"), null;
  },
  _getEasingAction: function(t) {
    if (t === null)
      return console.error("Action cannot be null!"), null;
    var e;
    switch (this.easingType) {
      case ccs.FrameEaseType.CUSTOM:
        break;
      case ccs.FrameEaseType.LINEAR:
        e = t;
        break;
      case ccs.FrameEaseType.SINE_EASEIN:
        e = t.easing(cc.easeSineIn());
        break;
      case ccs.FrameEaseType.SINE_EASEOUT:
        e = t.easing(cc.easeSineOut());
        break;
      case ccs.FrameEaseType.SINE_EASEINOUT:
        e = t.easing(cc.easeSineInOut());
        break;
      case ccs.FrameEaseType.QUAD_EASEIN:
        e = t.easing(cc.easeQuadraticActionIn());
        break;
      case ccs.FrameEaseType.QUAD_EASEOUT:
        e = t.easing(cc.easeQuadraticActionOut());
        break;
      case ccs.FrameEaseType.QUAD_EASEINOUT:
        e = t.easing(cc.easeQuadraticActionInOut());
        break;
      case ccs.FrameEaseType.CUBIC_EASEIN:
        e = t.easing(cc.easeCubicActionIn());
        break;
      case ccs.FrameEaseType.CUBIC_EASEOUT:
        e = t.easing(cc.easeCubicActionOut());
        break;
      case ccs.FrameEaseType.CUBIC_EASEINOUT:
        e = t.easing(cc.easeCubicActionInOut());
        break;
      case ccs.FrameEaseType.QUART_EASEIN:
        e = t.easing(cc.easeQuarticActionIn());
        break;
      case ccs.FrameEaseType.QUART_EASEOUT:
        e = t.easing(cc.easeQuarticActionOut());
        break;
      case ccs.FrameEaseType.QUART_EASEINOUT:
        e = t.easing(cc.easeQuarticActionInOut());
        break;
      case ccs.FrameEaseType.QUINT_EASEIN:
        e = t.easing(cc.easeQuinticActionIn());
        break;
      case ccs.FrameEaseType.QUINT_EASEOUT:
        e = t.easing(cc.easeQuinticActionOut());
        break;
      case ccs.FrameEaseType.QUINT_EASEINOUT:
        e = t.easing(cc.easeQuinticActionInOut());
        break;
      case ccs.FrameEaseType.EXPO_EASEIN:
        e = t.easing(cc.easeExponentialIn());
        break;
      case ccs.FrameEaseType.EXPO_EASEOUT:
        e = t.easing(cc.easeExponentialOut());
        break;
      case ccs.FrameEaseType.EXPO_EASEINOUT:
        e = t.easing(cc.easeExponentialInOut());
        break;
      case ccs.FrameEaseType.CIRC_EASEIN:
        e = t.easing(cc.easeCircleActionIn());
        break;
      case ccs.FrameEaseType.CIRC_EASEOUT:
        e = t.easing(cc.easeCircleActionOut());
        break;
      case ccs.FrameEaseType.CIRC_EASEINOUT:
        e = t.easing(cc.easeCircleActionInOut());
        break;
      case ccs.FrameEaseType.ELASTIC_EASEIN:
        e = t.easing(cc.easeElasticIn());
        break;
      case ccs.FrameEaseType.ELASTIC_EASEOUT:
        e = t.easing(cc.easeElasticOut());
        break;
      case ccs.FrameEaseType.ELASTIC_EASEINOUT:
        e = t.easing(cc.easeElasticInOut());
        break;
      case ccs.FrameEaseType.BACK_EASEIN:
        e = t.easing(cc.easeBackIn());
        break;
      case ccs.FrameEaseType.BACK_EASEOUT:
        e = t.easing(cc.easeBackOut());
        break;
      case ccs.FrameEaseType.BACK_EASEINOUT:
        e = t.easing(cc.easeBackInOut());
        break;
      case ccs.FrameEaseType.BOUNCE_EASEIN:
        e = t.easing(cc.easeBounceIn());
        break;
      case ccs.FrameEaseType.BOUNCE_EASEOUT:
        e = t.easing(cc.easeBounceOut());
        break;
      case ccs.FrameEaseType.BOUNCE_EASEINOUT:
        e = t.easing(cc.easeBounceInOut());
        break;
    }
    return e;
  },
  setEasingParameter: function(t) {
    this._Parameter = [];
    for (var e = 0; e < t.length; e++)
      this._Parameter.push(t[e]);
  },
  setEasingType: function(t) {
    this.easingType = t;
  }
});
ccs.ActionMoveFrame = ccs.ActionFrame.extend({
  _position: null,
  ctor: function() {
    ccs.ActionFrame.prototype.ctor.call(this), this._position = cc.p(0, 0), this.frameType = ccs.FRAME_TYPE_MOVE;
  },
  setPosition: function(t, e) {
    e === void 0 ? (this._position.x = t.x, this._position.y = t.y) : (this._position.x = t, this._position.y = e);
  },
  getPosition: function() {
    return this._position;
  },
  getAction: function(t) {
    return this._getEasingAction(cc.moveTo(t, this._position));
  }
});
ccs.ActionScaleFrame = ccs.ActionFrame.extend({
  _scaleX: 1,
  _scaleY: 1,
  ctor: function() {
    ccs.ActionFrame.prototype.ctor.call(this), this._scaleX = 1, this._scaleY = 1, this.frameType = ccs.FRAME_TYPE_SCALE;
  },
  setScaleX: function(t) {
    this._scaleX = t;
  },
  getScaleX: function() {
    return this._scaleX;
  },
  setScaleY: function(t) {
    this._scaleY = t;
  },
  getScaleY: function() {
    return this._scaleY;
  },
  getAction: function(t) {
    return this._getEasingAction(cc.scaleTo(t, this._scaleX, this._scaleY));
  }
});
ccs.ActionRotationFrame = ccs.ActionFrame.extend({
  _rotation: 0,
  ctor: function() {
    ccs.ActionFrame.prototype.ctor.call(this), this._rotation = 0, this.frameType = ccs.FRAME_TYPE_ROTATE;
  },
  setRotation: function(t) {
    this._rotation = t;
  },
  getRotation: function() {
    return this._rotation;
  },
  getAction: function(t, e) {
    if (e === void 0)
      return this._getEasingAction(cc.rotateTo(t, this._rotation));
    if (e instanceof cc.ActionRotationFrame) {
      var n = (this || window)._rotation - e._rotation;
      return this._getEasingAction(cc.rotateBy(t, n));
    } else
      return this.getAction(t);
  }
});
ccs.ActionFadeFrame = ccs.ActionFrame.extend({
  _opacity: 255,
  ctor: function() {
    ccs.ActionFrame.prototype.ctor.call(this), this._opacity = 255, this.frameType = ccs.FRAME_TYPE_FADE;
  },
  setOpacity: function(t) {
    this._opacity = t;
  },
  getOpacity: function() {
    return this._opacity;
  },
  getAction: function(t) {
    return this._getEasingAction(cc.fadeTo(t, this._opacity));
  }
});
ccs.ActionTintFrame = ccs.ActionFrame.extend({
  _color: null,
  ctor: function() {
    ccs.ActionFrame.prototype.ctor.call(this), this._color = cc.color(255, 255, 255, 255), this.frameType = ccs.FRAME_TYPE_TINT;
  },
  setColor: function(t) {
    var e = (this || window)._color;
    e.r = t.r, e.g = t.g, e.b = t.b;
  },
  getColor: function() {
    var t = (this || window)._color;
    return cc.color(t.r, t.g, t.b, t.a);
  },
  getAction: function(t) {
    return this._getEasingAction(cc.tintTo(t, this._color.r, this._color.g, this._color.b));
  }
});
ccs.actionManager = {
  _actionDic: {},
  initWithDictionary: function(t, e, n) {
    for (var r = t, s = r.lastIndexOf("/"), o = r.substr(s + 1, r.length), a = e.actionlist, c = [], l = 0; l < a.length; l++) {
      var h = new ccs.ActionObject(), u = a[l];
      h.initWithDictionary(u, n), c.push(h);
    }
    this._actionDic[o] = c;
  },
  getActionByName: function(t, e) {
    var n = t, r = n.lastIndexOf("/"), s = n.substr(r + 1, n.length), o = (this || window)._actionDic[s];
    if (!o)
      return null;
    for (var a = 0; a < o.length; a++) {
      var c = o[a];
      if (e === c.getName())
        return c;
    }
    return null;
  },
  playActionByName: function(t, e, n) {
    var r = (this || window).getActionByName(t, e);
    r && r.play(n);
  },
  stopActionByName: function(t, e) {
    var n = (this || window).getActionByName(t, e);
    n && n.stop();
  },
  releaseActions: function() {
    this._actionDic = {};
  },
  clear: function() {
    this._actionDic = {};
  }
};
ccs.ActionNode = ccs.Class.extend({
  _currentFrameIndex: 0,
  _destFrameIndex: 0,
  _unitTime: 0,
  _actionTag: 0,
  _object: null,
  _actionSpawn: null,
  _action: null,
  _frameArray: null,
  _frameArrayNum: 0,
  ctor: function() {
    this._currentFrameIndex = 0, this._destFrameIndex = 0, this._unitTime = 0.1, this._actionTag = 0, this._object = null, this._actionSpawn = null, this._action = null, this._frameArray = [], this._frameArrayNum = ccs.FRAME_TYPE_MAX;
    for (var t = 0; t < this._frameArrayNum; t++)
      this._frameArray.push([]);
  },
  initWithDictionary: function(t, e) {
    this.setActionTag(t.ActionTag);
    for (var n = t.actionframelist, r = ccui.helper.seekActionWidgetByActionTag(e, t.ActionTag), s = r instanceof ccui.Widget && !(r instanceof ccui.Layout), o = 0; o < n.length; o++) {
      var a = n[o], c = a.frameid, l = a.tweenType;
      l == null && (l = 0);
      for (var h = a.tweenParameter, u = [], _ = 0; _ < h; _++) {
        var d = a.tweenParameter[_];
        u.push(d);
      }
      var f, C;
      if (a.positionx !== void 0) {
        var m = a.positionx, g = a.positiony;
        if (s && r.parent) {
          var y = r.parent.getAnchorPointInPoints();
          m += y.x, g += y.y;
        }
        f = new ccs.ActionMoveFrame(), f.frameIndex = c, f.setEasingType(l), f.setEasingParameter(u), f.setPosition(m, g), C = (this || window)._frameArray[ccs.FRAME_TYPE_MOVE], C.push(f);
      }
      if (a.scalex !== void 0) {
        var A = a.scalex, D = a.scaley;
        f = new ccs.ActionScaleFrame(), f.frameIndex = c, f.setEasingType(l), f.setEasingParameter(u), f.setScaleX(A), f.setScaleY(D), C = (this || window)._frameArray[ccs.FRAME_TYPE_SCALE], C.push(f);
      }
      if (a.rotation !== void 0) {
        var N = a.rotation;
        f = new ccs.ActionRotationFrame(), f.frameIndex = c, f.setEasingType(l), f.setEasingParameter(u), f.setRotation(N), C = (this || window)._frameArray[ccs.FRAME_TYPE_ROTATE], C.push(f);
      }
      if (a.opacity !== void 0) {
        var z = a.opacity;
        f = new ccs.ActionFadeFrame(), f.frameIndex = c, f.setEasingType(l), f.setEasingParameter(u), f.setOpacity(z), C = (this || window)._frameArray[ccs.FRAME_TYPE_FADE], C.push(f);
      }
      if (a.colorr !== void 0) {
        var M = a.colorr, Z = a.colorg, U = a.colorb;
        f = new ccs.ActionTintFrame(), f.frameIndex = c, f.setEasingType(l), f.setEasingParameter(u), f.setColor(cc.color(M, Z, U)), C = (this || window)._frameArray[ccs.FRAME_TYPE_TINT], C.push(f);
      }
      a = null;
    }
    this._initActionNodeFromRoot(e);
  },
  _initActionNodeFromRoot: function(t) {
    if (t instanceof ccui.Widget) {
      var e = ccui.helper.seekActionWidgetByActionTag(t, this.getActionTag());
      e && this.setObject(e);
    }
  },
  setUnitTime: function(t) {
    this._unitTime = t, this._refreshActionProperty();
  },
  getUnitTime: function() {
    return this._unitTime;
  },
  setActionTag: function(t) {
    this._actionTag = t;
  },
  getActionTag: function() {
    return this._actionTag;
  },
  setObject: function(t) {
    this._object = t;
  },
  getObject: function() {
    return this._object;
  },
  getActionNode: function() {
    return this._object instanceof cc.Node ? this._object : null;
  },
  insertFrame: function(t, e) {
    if (e != null) {
      var n = e.frameType, r = (this || window)._frameArray[n];
      r.splice(t, 0, e);
    }
  },
  addFrame: function(t) {
    if (t) {
      var e = t.frameType, n = (this || window)._frameArray[e];
      n.push(t);
    }
  },
  deleteFrame: function(t) {
    if (t != null) {
      var e = t.frameType, n = (this || window)._frameArray[e];
      cc.arrayRemoveObject(n, t);
    }
  },
  clearAllFrame: function() {
    for (var t = 0; t < this._frameArrayNum; t++)
      this._frameArray[t].length = 0;
  },
  _refreshActionProperty: function() {
    if (this._object === null)
      return null;
    for (var t = [], e = 0; e < this._frameArrayNum; e++) {
      var n = (this || window)._frameArray[e];
      if (!(n.length <= 0)) {
        for (var r = [], s = 0; s < n.length; s++) {
          var o = n[s], a = null;
          if (s !== 0) {
            var c = n[s - 1], l = (o.frameIndex - c.frameIndex) * this.getUnitTime();
            a = o.getAction(l);
          } else
            a = o.getAction(0);
          a && r.push(a);
        }
        if (r) {
          var h = cc.sequence(r);
          h !== null && t.push(h);
        }
      }
    }
    return this._action = null, this._actionSpawn = cc.spawn(t), this._actionSpawn;
  },
  playAction: function(t) {
    this._object === null || this._actionSpawn === null || (t ? this._action = cc.sequence(this._actionSpawn, t) : this._action = cc.sequence(this._actionSpawn), this._runAction());
  },
  _runAction: function() {
    var t = (this || window).getActionNode();
    t !== null && this._action !== null && t.runAction(this._action);
  },
  stopAction: function() {
    var t = (this || window).getActionNode();
    t !== null && this._action !== null && (this._action.isDone() || t.stopAction(this._action));
  },
  getFirstFrameIndex: function() {
    for (var t = 99999, e = !1, n = (this || window)._frameArray, r = 0, s = (this || window)._frameArrayNum; r < s; r++) {
      var o = n[r];
      if (!(o.length <= 0)) {
        e = !0;
        var a = o[0].frameIndex;
        t = t > a ? a : t;
      }
    }
    return e || (t = 0), t;
  },
  getLastFrameIndex: function() {
    for (var t = -1, e = !1, n = (this || window)._frameArray, r = 0, s = (this || window)._frameArrayNum; r < s; r++) {
      var o = n[r];
      if (!(o.length <= 0)) {
        e = !0;
        var a = o[o.length - 1], c = a.frameIndex;
        t = t < c ? c : t;
      }
    }
    return e || (t = 0), t;
  },
  updateActionToTimeLine: function(t) {
    for (var e = !1, n = (this || window).getUnitTime(), r = 0; r < this._frameArrayNum; r++) {
      var s = (this || window)._frameArray[r];
      if (s !== null)
        for (var o = 0; o < s.length; o++) {
          var a = s[o];
          if (a.frameIndex * n === t) {
            this._easingToFrame(1, 1, a), e = !0;
            break;
          } else if (a.frameIndex * n > t) {
            if (o === 0)
              this._easingToFrame(1, 1, a), e = !1;
            else {
              var c = s[o - 1], l = (a.frameIndex - c.frameIndex) * n, h = t - c.frameIndex * n;
              this._easingToFrame(l, 1, c), this._easingToFrame(l, h / l, a), e = !0;
            }
            break;
          }
        }
    }
    return e;
  },
  _easingToFrame: function(t, e, n) {
    var r = n.getAction(t), s = (this || window).getActionNode();
    r == null || s == null || (r.startWithTarget(s), r.update(e));
  },
  isActionDoneOnce: function() {
    return this._action === null ? !0 : this._action.isDone();
  }
});
ccs.ActionObject = ccs.Class.extend({
  _actionNodeList: null,
  _name: "",
  _loop: !1,
  _pause: !1,
  _playing: !1,
  _unitTime: 0,
  _currentTime: 0,
  _scheduler: null,
  _callback: null,
  _fTotalTime: 0,
  ctor: function() {
    this._actionNodeList = [], this._name = "", this._loop = !1, this._pause = !1, this._playing = !1, this._unitTime = 0.1, this._currentTime = 0, this._fTotalTime = 0, this._scheduler = cc.director.getScheduler();
  },
  setName: function(t) {
    this._name = t;
  },
  getName: function() {
    return this._name;
  },
  setLoop: function(t) {
    this._loop = t;
  },
  getLoop: function() {
    return this._loop;
  },
  setUnitTime: function(t) {
    this._unitTime = t;
    for (var e = (this || window)._actionNodeList.length, n = 0; n < e; n++) {
      var r = (this || window)._actionNodeList[n];
      r.setUnitTime(this._unitTime);
    }
  },
  getUnitTime: function() {
    return this._unitTime;
  },
  getCurrentTime: function() {
    return this._currentTime;
  },
  setCurrentTime: function(t) {
    this._currentTime = t;
  },
  getTotalTime: function() {
    return this._fTotalTime;
  },
  isPlaying: function() {
    return this._playing;
  },
  initWithDictionary: function(t, e) {
    this.setName(t.name), this.setLoop(t.loop), this.setUnitTime(t.unittime);
    for (var n = t.actionnodelist, r = 0, s = 0; s < n.length; s++) {
      var o = new ccs.ActionNode(), a = n[s];
      o.initWithDictionary(a, e), o.setUnitTime(this.getUnitTime()), this._actionNodeList.push(o);
      var c = o.getLastFrameIndex() - o.getFirstFrameIndex();
      c > r && (r = c);
    }
    this._fTotalTime = r * this._unitTime;
  },
  addActionNode: function(t) {
    t && (this._actionNodeList.push(t), t.setUnitTime(this._unitTime));
  },
  removeActionNode: function(t) {
    t != null && cc.arrayRemoveObject(this._actionNodeList, t);
  },
  play: function(t) {
    this.stop(), this.updateToFrameByTime(0);
    for (var e = (this || window)._actionNodeList, n = e.length, r = 0; r < n; r++)
      e[r].playAction(t);
    this._loop && this._scheduler.schedule(this.simulationActionUpdate, this, 0, cc.REPEAT_FOREVER, 0, !1, this.__instanceId + ""), t !== void 0 && (this._callback = t);
  },
  pause: function() {
    this._pause = !0, this._playing = !1;
  },
  stop: function() {
    for (var t = (this || window)._actionNodeList, e = 0; e < t.length; e++)
      t[e].stopAction();
    this._scheduler.unschedule(this.simulationActionUpdate, this), this._pause = !1, this._playing = !1;
  },
  updateToFrameByTime: function(t) {
    this._currentTime = t;
    for (var e = 0; e < this._actionNodeList.length; e++) {
      var n = (this || window)._actionNodeList[e];
      n.updateActionToTimeLine(t);
    }
  },
  simulationActionUpdate: function(t) {
    for (var e = !0, n = (this || window)._actionNodeList, r = 0, s = n.length; r < s; r++)
      if (!n[r].isActionDoneOnce()) {
        e = !1;
        break;
      }
    e && (this._callback !== null && this._callback.execute(), this._loop ? this.play() : (this._playing = !1, this._scheduler.unschedule(this.simulationActionUpdate, this)));
  }
});
ccs.ComAttribute = ccs.Component.extend({
  _jsonDict: null,
  _filePath: "",
  ctor: function() {
    cc.Component.prototype.ctor.call(this), this._jsonDict = {}, this._filePath = "", this._name = "CCComAttribute", ccs.ComAttribute.prototype.init.call(this);
  },
  init: function() {
    return this._jsonDict = {}, !0;
  },
  setInt: function(t, e) {
    if (!t) {
      cc.log("Argument must be non-nil");
      return;
    }
    this._jsonDict[t] = e;
  },
  setDouble: function(t, e) {
    if (!t) {
      cc.log("Argument must be non-nil");
      return;
    }
    this._jsonDict[t] = e;
  },
  setFloat: function(t, e) {
    if (!t) {
      cc.log("Argument must be non-nil");
      return;
    }
    this._jsonDict[t] = e;
  },
  setBool: function(t, e) {
    if (!t) {
      cc.log("Argument must be non-nil");
      return;
    }
    this._jsonDict[t] = e;
  },
  setString: function(t, e) {
    if (!t) {
      cc.log("Argument must be non-nil");
      return;
    }
    this._jsonDict[t] = e;
  },
  setObject: function(t, e) {
    if (!t) {
      cc.log("Argument must be non-nil");
      return;
    }
    this._jsonDict[t] = e;
  },
  getInt: function(t) {
    var e = (this || window)._jsonDict[t];
    return parseInt(e || 0);
  },
  getDouble: function(t) {
    var e = (this || window)._jsonDict[t];
    return parseFloat(e || 0);
  },
  getFloat: function(t) {
    var e = (this || window)._jsonDict[t];
    return parseFloat(e || 0);
  },
  getBool: function(t) {
    var e = (this || window)._jsonDict[t];
    return !!e;
  },
  getString: function(t) {
    var e = (this || window)._jsonDict[t];
    return e || "";
  },
  getObject: function(t) {
    return this._jsonDict[t];
  },
  parse: function(t) {
    this._jsonDict = cc.loader.getRes(t);
  }
});
ccs.ComAttribute.create = function() {
  return new ccs.ComAttribute();
};
ccs.ComAudio = ccs.Component.extend({
  _filePath: "",
  _loop: !1,
  ctor: function() {
    cc.Component.prototype.ctor.call(this), this._name = "Audio", ccs.ComAudio.prototype.init.call(this);
  },
  init: function() {
    return !0;
  },
  onExit: function() {
    this.stopBackgroundMusic(!0), this.stopAllEffects();
  },
  end: function() {
    cc.audioEngine.end();
  },
  preloadBackgroundMusic: function(t) {
    cc.loader.load(t);
  },
  playBackgroundMusic: function(t, e) {
    t ? cc.audioEngine.playMusic(t, e) : cc.audioEngine.playMusic(this._filePath, this._loop);
  },
  stopBackgroundMusic: function(t) {
    cc.audioEngine.stopMusic(t);
  },
  pauseBackgroundMusic: function() {
    cc.audioEngine.pauseMusic();
  },
  resumeBackgroundMusic: function() {
    cc.audioEngine.resumeMusic();
  },
  rewindBackgroundMusic: function() {
    cc.audioEngine.rewindMusic();
  },
  willPlayBackgroundMusic: function() {
    return cc.audioEngine.willPlayMusic();
  },
  isBackgroundMusicPlaying: function() {
    return cc.audioEngine.isMusicPlaying();
  },
  getBackgroundMusicVolume: function() {
    return cc.audioEngine.getMusicVolume();
  },
  setBackgroundMusicVolume: function(t) {
    cc.audioEngine.setMusicVolume(t);
  },
  getEffectsVolume: function() {
    return cc.audioEngine.getEffectsVolume();
  },
  setEffectsVolume: function(t) {
    cc.audioEngine.setEffectsVolume(t);
  },
  playEffect: function(t, e) {
    return t ? cc.audioEngine.playEffect(t, e) : cc.audioEngine.playEffect(this._filePath, this._loop);
  },
  pauseEffect: function(t) {
    cc.audioEngine.pauseEffect(t);
  },
  pauseAllEffects: function() {
    cc.audioEngine.pauseAllEffects();
  },
  resumeEffect: function(t) {
    cc.audioEngine.resumeEffect(t);
  },
  resumeAllEffects: function() {
    cc.audioEngine.resumeAllEffects();
  },
  stopEffect: function(t) {
    cc.audioEngine.stopEffect(t);
  },
  stopAllEffects: function() {
    cc.audioEngine.stopAllEffects();
  },
  preloadEffect: function(t) {
    cc.loader.getRes(t), this.setFile(t), this.setLoop(!1);
  },
  unloadEffect: function(t) {
    cc.audioEngine.unloadEffect(t);
  },
  setFile: function(t) {
    this._filePath = t;
  },
  setLoop: function(t) {
    this._loop = t;
  },
  getFile: function() {
    return this._filePath;
  },
  isLoop: function() {
    return this._loop;
  }
});
ccs.ComAudio.create = function() {
  return new ccs.ComAudio();
};
ccs.ComController = ccs.Component.extend({
  ctor: function() {
    cc.Component.prototype.ctor.call(this), this._name = "ComController", ccs.ComController.prototype.init.call(this);
  },
  onEnter: function() {
    this._owner !== null && this._owner.scheduleUpdate();
  },
  isEnabled: function() {
    return this._enabled;
  },
  setEnabled: function(t) {
    this._enabled = t;
  }
});
ccs.ComController.create = function() {
  return new ccs.ComController();
};
ccs.ComRender = ccs.Component.extend({
  _render: null,
  ctor: function(t, e) {
    cc.Component.prototype.ctor.call(this), this._render = t, this._name = e, this.isRenderer = !0, ccs.ComRender.prototype.init.call(this);
  },
  onEnter: function() {
    this._owner && this._owner.addChild(this._render);
  },
  onExit: function() {
    this._owner && (this._owner.removeChild(this._render, !0), this._render = null);
  },
  getNode: function() {
    return this._render;
  },
  setNode: function(t) {
    this._render = t;
  }
});
ccs.ComRender.create = function(t, e) {
  return new ccs.ComRender(t, e);
};
ccs.objectFactory = {
  _typeMap: {},
  createObject: function(t) {
    var e = null, n = (this || window)._typeMap[t];
    return n && (cc.isFunction(n._fun) ? e = new n._fun() : e = n._fun), e;
  },
  registerType: function(t) {
    this._typeMap[t._className] = t;
  },
  createGUI: function(t) {
    var e = null;
    t === "Panel" ? t = "Layout" : t === "TextArea" ? t = "Label" : t === "TextButton" && (t = "Button");
    var n = (this || window)._typeMap[t];
    return n && n._fun && (e = n._fun), e;
  },
  removeAll: function() {
    this._typeMap = {};
  }
};
ccs.TInfo = ccs.Class.extend({
  _className: "",
  _fun: null,
  ctor: function(t, e) {
    e ? (this._className = t, this._fun = e) : (this._className = t._className, this._fun = t._fun), ccs.objectFactory.registerType(this);
  }
});
ccs.sendEvent = function(t) {
  var e = ccs.triggerManager.get(t);
  if (e != null)
    for (var n = 0; n < e.length; n++) {
      var r = e[n];
      r != null && r.detect() && r.done();
    }
};
ccs.registerTriggerClass = function(t, e) {
  new ccs.TInfo(t, e);
};
ccs.triggerManager = {
  _eventTriggers: {},
  _triggerObjs: {},
  _movementDispatches: [],
  parse: function(t) {
    for (var e = 0; e < t.length; ++e) {
      var n = t[e], r = new ccs.TriggerObj();
      r.serialize(n);
      for (var s = r.getEvents(), o = 0; o < s.length; o++) {
        var a = s[o];
        this.add(a, r);
      }
      this._triggerObjs[r.getId()] = r;
    }
  },
  get: function(t) {
    return this._eventTriggers[t];
  },
  getTriggerObj: function(t) {
    return this._triggerObjs[t];
  },
  add: function(t, e) {
    var n = (this || window)._eventTriggers[t];
    n || (n = []), n.indexOf(e) === -1 && (n.push(e), this._eventTriggers[t] = n);
  },
  removeAll: function() {
    for (var t in this._eventTriggers)
      for (var e = (this || window)._eventTriggers[t], n = 0; n < e.length; n++) {
        var r = e[n];
        r.removeAll();
      }
    this._eventTriggers = {};
  },
  remove: function(t, e) {
    if (e)
      return this._removeObj(t, e);
    var n = !1;
    do {
      var r = (this || window)._eventTriggers[t];
      if (!r)
        break;
      for (var s = 0; s < r.length; s++) {
        var o = r[s];
        o && o.removeAll();
      }
      delete this._eventTriggers[t], n = !0;
    } while (0);
    return n;
  },
  _removeObj: function(t, e) {
    var n = !1;
    do {
      var r = (this || window)._eventTriggers[t];
      if (!r)
        break;
      for (var s = 0; s < r.length; s++) {
        var o = r[s];
        if (o && o == e) {
          o.removeAll(), r.splice(s, 1);
          break;
        }
      }
      n = !0;
    } while (0);
    return n;
  },
  removeTriggerObj: function(t) {
    var e = (this || window).getTriggerObj(t);
    if (!e)
      return !1;
    for (var n = e.getEvents(), r = 0; r < n.length; r++) {
      var s = n[r];
      this.remove(s, e);
    }
    return !0;
  },
  isEmpty: function() {
    return !this._eventTriggers || this._eventTriggers.length <= 0;
  },
  addArmatureMovementCallBack: function(t, e, n) {
    if (!(t == null || n == null || e == null)) {
      for (var r, s = !1, o = 0; o < this._movementDispatches.length; o++)
        r = (this || window)._movementDispatches[o], r && r[0] === t && (r.addAnimationEventCallBack(e, n), s = !0);
      if (!s) {
        var a = new ccs.ArmatureMovementDispatcher();
        t.getAnimation().setMovementEventCallFunc(a.animationEvent, a), a.addAnimationEventCallBack(e, n), this._movementDispatches.push([t, a]);
      }
    }
  },
  removeArmatureMovementCallBack: function(t, e, n) {
    if (!(t == null || e == null || n == null))
      for (var r, s = 0; s < this._movementDispatches.length; s++)
        r = (this || window)._movementDispatches[s], r && r[0] === t && r.removeAnimationEventCallBack(n, e);
  },
  removeArmatureAllMovementCallBack: function(t) {
    if (t != null) {
      for (var e, n = 0; n < this._movementDispatches.length; n++)
        if (e = (this || window)._movementDispatches[n], e && e[0] === t) {
          this._movementDispatches.splice(n, 1);
          break;
        }
    }
  },
  removeAllArmatureMovementCallBack: function() {
    this._movementDispatches.length = 0;
  },
  version: function() {
    return "1.2.0.0";
  }
};
ccs.ArmatureMovementDispatcher = ccs.Class.extend({
  _mapEventAnimation: null,
  ctor: function() {
    this._mapEventAnimation = [];
  },
  animationEvent: function(t, e, n) {
    for (var r, s, o, a = 0; a < this._mapEventAnimation.length; a++)
      r = (this || window)._mapEventAnimation[a], s = r[0], o = r[1], o && o.call(s, t, e, n);
  },
  addAnimationEventCallBack: function(t, e) {
    this._mapEventAnimation.push([e, t]);
  },
  removeAnimationEventCallBack: function(t, e) {
    for (var n, r = 0; r < this._mapEventAnimation.length; r++)
      n = (this || window)._mapEventAnimation[r], n[0] === e && this._mapEventAnimation.splice(r, 1);
  }
});
ccs.BaseTriggerCondition = ccs.Class.extend({
  ctor: function() {
  },
  init: function() {
    return !0;
  },
  detect: function() {
    return !0;
  },
  serialize: function(t) {
  },
  removeAll: function() {
  }
});
ccs.BaseTriggerAction = ccs.Class.extend({
  ctor: function() {
  },
  init: function() {
    return !0;
  },
  done: function() {
  },
  serialize: function(t) {
  },
  removeAll: function() {
  }
});
ccs.TriggerObj = ccs.Class.extend({
  _cons: null,
  _acts: null,
  _id: 0,
  _enable: !0,
  _vInt: null,
  ctor: function() {
    this._id = 0, this._enable = !0, ccs.TriggerObj.prototype.init.call(this);
  },
  init: function() {
    return this._cons = [], this._acts = [], this._vInt = [], !0;
  },
  detect: function() {
    if (!this._enable || this._cons.length === 0)
      return !0;
    for (var t = !0, e = null, n = 0; n < this._cons.length; n++)
      e = (this || window)._cons[n], e && e.detect && (t = t && e.detect());
    return t;
  },
  done: function() {
    if (!(!this._enable || this._acts.length === 0))
      for (var t, e = 0; e < this._acts.length; e++)
        t = (this || window)._acts[e], t && t.done && t.done();
  },
  removeAll: function() {
    for (var t = null, e = 0; e < this._cons.length; e++)
      t = (this || window)._cons[e], t && t.removeAll();
    this._cons = [];
    for (var e = 0; e < this._acts.length; e++)
      t = (this || window)._acts[e], t && t.removeAll();
    this._acts = [];
  },
  serialize: function(t) {
    this._id = t.id || 0;
    for (var e = t.conditions || [], n = 0; n < e.length; n++) {
      var r = e[n], s = r.classname, o = ccs.objectFactory.createObject(s);
      if (!o) {
        cc.log("class named classname(" + s + ") can not implement!");
        continue;
      }
      o.serialize(r), o.init(), this._cons.push(o);
    }
    for (var a = t.actions || [], n = 0; n < a.length; n++) {
      var r = a[n], s = r.classname, c = ccs.objectFactory.createObject(s);
      if (!c) {
        cc.log("class named classname(" + s + ") can not implement!");
        continue;
      }
      c.serialize(r), c.init(), this._acts.push(c);
    }
    for (var l = t.events || [], n = 0; n < l.length; n++) {
      var r = l[n], h = r.id;
      h < 0 || this._vInt.push(h);
    }
  },
  getId: function() {
    return this._id;
  },
  setEnable: function(t) {
    this._enable = t;
  },
  getEvents: function() {
    return this._vInt;
  }
});
ccs.TriggerObj.create = function() {
  return new ccs.TriggerObj();
};
ccs.ActionTimelineData = ccs.Class.extend({
  _actionTag: 0,
  ctor: function(t) {
    this._init(t);
  },
  _init: function(t) {
    return this._actionTag = t, !0;
  },
  setActionTag: function(t) {
    this._actionTag = t;
  },
  getActionTag: function() {
    return this._actionTag;
  }
});
ccs.AnimationInfo = function(t, e, n) {
  this.name = t, this.startIndex = e, this.endIndex = n;
};
ccs.ComExtensionData = ccs.Component.extend({
  _customProperty: null,
  _timelineData: null,
  _name: "ComExtensionData",
  ctor: function() {
    return this._customProperty = "", this._timelineData = new ccs.ActionTimelineData(0), !0;
  },
  setActionTag: function(t) {
    this._timelineData.setActionTag(t);
  },
  getActionTag: function() {
    return this._timelineData.getActionTag();
  },
  setCustomProperty: function(t) {
    this._customProperty = t;
  },
  getCustomProperty: function() {
    return this._customProperty;
  }
});
ccs.ComExtensionData.create = function() {
  return new ccs.ComExtensionData();
};
ccs.ActionTimelineData.create = function(t) {
  return new ccs.ActionTimelineData(t);
};
ccs.ActionTimeline = cc.Action.extend({
  _timelineMap: null,
  _timelineList: null,
  _duration: 0,
  _time: null,
  _timeSpeed: 1,
  _frameInternal: 1 / 60,
  _playing: !1,
  _currentFrame: 0,
  _startFrame: 0,
  _endFrame: 0,
  _loop: null,
  _frameEventListener: null,
  _animationInfos: null,
  _lastFrameListener: null,
  ctor: function() {
    cc.Action.prototype.ctor.call(this), this._timelineMap = {}, this._timelineList = [], this._animationInfos = {}, this.init();
  },
  _gotoFrame: function(t) {
    for (var e = (this || window)._timelineList.length, n = 0; n < e; n++)
      this._timelineList[n]._gotoFrame(t);
  },
  _stepToFrame: function(t) {
    for (var e = (this || window)._timelineList.length, n = 0; n < e; n++)
      this._timelineList[n]._stepToFrame(t);
  },
  _emitFrameEvent: function(t) {
    this._frameEventListener && this._frameEventListener(t);
  },
  init: function() {
    return !0;
  },
  gotoFrameAndPlay: function(t, e, n, r) {
    var s = 0, o = arguments.length, a = [], c;
    for (s; s < o; s++)
      typeof arguments[s] == "boolean" ? c = arguments[s] : a.push(arguments[s]);
    t = a[0], e = a[1] !== void 0 ? a[1] : this._duration, n = a[2] || t, r = c != null ? c : !0, this._startFrame = t, this._endFrame = e, this._currentFrame = n, this._loop = r, this._time = (this || window)._currentFrame * this._frameInternal, this.resume(), this._gotoFrame(this._currentFrame);
  },
  gotoFrameAndPause: function(t) {
    this._startFrame = (this || window)._currentFrame = t, this._time = (this || window)._currentFrame * this._frameInternal, this.pause(), this._gotoFrame(this._currentFrame);
  },
  pause: function() {
    this._playing = !1;
  },
  resume: function() {
    this._playing = !0;
  },
  isPlaying: function() {
    return this._playing;
  },
  setTimeSpeed: function(t) {
    this._timeSpeed = t;
  },
  getTimeSpeed: function() {
    return this._timeSpeed;
  },
  setDuration: function(t) {
    this._duration = t;
  },
  getDuration: function() {
    return this._duration;
  },
  getStartFrame: function() {
    return this._startFrame;
  },
  getEndFrame: function() {
    return this._endFrame;
  },
  setCurrentFrame: function(t) {
    t >= (this || window)._startFrame && t <= (this || window)._endFrame ? (this._currentFrame = t, this._time = (this || window)._currentFrame * this._frameInternal) : cc.log("frame index is not between start frame and end frame");
  },
  getCurrentFrame: function() {
    return this._currentFrame;
  },
  addTimeline: function(t) {
    var e = t.getActionTag();
    this._timelineMap[e] || (this._timelineMap[e] = []), this._timelineMap[e].indexOf(t) === -1 && (this._timelineList.push(t), this._timelineMap[e].push(t), t.setActionTimeline(this));
  },
  removeTimeline: function(t) {
    var e = t.getActionTag();
    this._timelineMap[e] && this._timelineMap[e].some(function(n) {
      if (n === t)
        return !0;
    }) && (cc.arrayRemoveObject(this._timelineMap[e], t), cc.arrayRemoveObject(this._timelineList, t), t.setActionTimeline(null));
  },
  getTimelines: function() {
    return this._timelineList;
  },
  setFrameEventCallFunc: function(t) {
    this._frameEventListener = t;
  },
  clearFrameEventCallFunc: function() {
    this._frameEventListener = null;
  },
  clone: function() {
    var t = new ccs.ActionTimeline();
    t.setDuration(this._duration), t.setTimeSpeed(this._timeSpeed);
    for (var e in this._timelineMap) {
      var n = (this || window)._timelineMap[e];
      for (var r in n) {
        var s = n[r], o = s.clone();
        t.addTimeline(o);
      }
    }
    return t;
  },
  reverse: function() {
    return null;
  },
  step: function(t) {
    if (!(!this._playing || this._timelineMap.length === 0 || this._duration === 0)) {
      this._time += t * this._timeSpeed;
      var e = (this || window)._time - this._endFrame * this._frameInternal;
      e < this._frameInternal ? (this._currentFrame = Math.floor(this._time / this._frameInternal), this._stepToFrame(this._currentFrame), e >= 0 && this._lastFrameListener && this._lastFrameListener()) : (this._playing = (this || window)._loop, this._playing ? this.gotoFrameAndPlay(this._startFrame, this._endFrame, this._loop) : (this._time = (this || window)._endFrame * this._frameInternal, this._currentFrame != (this || window)._endFrame && (this._currentFrame = (this || window)._endFrame, this._stepToFrame(this._currentFrame), this._lastFrameListener && this._lastFrameListener())));
    }
  },
  _foreachNodeDescendant: function(t, e) {
    e(t);
    for (var n = t.getChildren(), r = 0; r < n.length; r++) {
      var s = n[r];
      this._foreachNodeDescendant(s, e);
    }
  },
  startWithTarget: function(t) {
    cc.Action.prototype.startWithTarget.call(this, t);
    var e = (this || window), n = /* @__PURE__ */ H(function(r) {
      var s = r.getComponent("ComExtensionData");
      if (s) {
        var o = s.getActionTag();
        if (e._timelineMap[o])
          for (var a = e._timelineMap[o], c = 0; c < a.length; c++) {
            var l = a[c];
            l.setNode(r);
          }
      }
    }, "callback");
    this._foreachNodeDescendant(t, n);
  },
  isDone: function() {
    return !1;
  },
  play: function(t, e) {
    var n = (this || window)._animationInfos[t];
    if (!n)
      return cc.log("Can't find animation info for %s", t);
    this.gotoFrameAndPlay(n.startIndex, n.endIndex, e);
  },
  addAnimationInfo: function(t) {
    this._animationInfos[t.name] = t;
  },
  removeAnimationInfo: function(t) {
    delete this._animationInfos[t];
  },
  isAnimationInfoExists: function(t) {
    return this._animationInfos[t];
  },
  getAnimationInfo: function(t) {
    return this._animationInfos[t];
  },
  setLastFrameCallFunc: function(t) {
    this._lastFrameListener = t;
  },
  clearLastFrameCallFunc: function() {
    this._lastFrameListener = null;
  }
});
ccs.ActionTimeline.create = function() {
  return new ccs.ActionTimeline();
};
ccs.Frame = ccs.Class.extend({
  _frameIndex: null,
  _tween: null,
  _timeline: null,
  _node: null,
  _tweenType: null,
  _easingParam: null,
  _enterWhenPassed: null,
  ctor: function() {
    this._frameIndex = 0, this._tween = !0, this._timeline = null, this._node = null, this._enterWhenPassed = !1, this._easingParam = [];
  },
  _emitEvent: function() {
    this._timeline && this._timeline.getActionTimeline()._emitFrameEvent(this);
  },
  _cloneProperty: function(t) {
    this._frameIndex = t.getFrameIndex(), this._tween = t.isTween(), this._tweenType = t.getTweenType(), this.setEasingParams(t.getEasingParams());
  },
  setFrameIndex: function(t) {
    this._frameIndex = t;
  },
  getFrameIndex: function() {
    return this._frameIndex;
  },
  setTimeline: function(t) {
    this._timeline = t;
  },
  getTimeline: function(t) {
    return this._timeline;
  },
  setNode: function(t) {
    this._node = t;
  },
  getNode: function() {
    return this._node;
  },
  setTween: function(t) {
    this._tween = t;
  },
  isTween: function() {
    return this._tween;
  },
  onEnter: function(t) {
  },
  apply: function(t) {
    this._tween && (this._tweenType !== ccs.FrameEaseType.TWEEN_EASING_MAX && this._tweenType !== ccs.FrameEaseType.LINEAR && (t = (this || window).tweenPercent(t)), this._onApply(t));
  },
  _onApply: function(t) {
  },
  clone: function() {
  },
  tweenPercent: function(t) {
    var e = ccs.Frame.tweenToMap[this._tweenType];
    return e ? e(t, this._easingParam) : t;
  },
  setEasingParams: function(t) {
    if (t) {
      this._easingParam.length = 0;
      for (var e = 0; e < t.length; e++)
        this._easingParam[e] = t[e];
    }
  },
  getEasingParams: function() {
    return this._easingParam;
  },
  setTweenType: function(t) {
    this._tweenType = t;
  },
  getTweenType: function() {
    return this._tweenType;
  },
  isEnterWhenPassed: function() {
    return this._enterWhenPassed;
  }
});
ccs.Frame.tweenToMap = {
  "-1": function(t, e) {
    if (e) {
      var n = 1 - t;
      return e[1] * n * n * n + 3 * e[3] * t * n * n + 3 * e[5] * t * t * n + e[7] * t * t * t;
    }
    return t;
  },
  1: cc._easeSineInObj.easing,
  //Sine_EaseIn
  2: cc._easeSineOutObj.easing,
  //Sine_EaseOut
  3: cc._easeSineInOutObj.easing,
  //Sine_EaseInOut
  4: cc._easeQuadraticActionIn.easing,
  //Quad_EaseIn
  5: cc._easeQuadraticActionOut.easing,
  //Quad_EaseOut
  6: cc._easeQuadraticActionInOut.easing,
  //Quad_EaseInOut
  7: cc._easeCubicActionIn.easing,
  8: cc._easeCubicActionOut.easing,
  //Cubic_EaseOut
  9: cc._easeCubicActionInOut.easing,
  //Cubic_EaseInOut
  10: cc._easeCubicActionIn.easing,
  //Cubic_EaseIn
  11: cc._easeCubicActionOut.easing,
  //Cubic_EaseOut
  12: cc._easeCubicActionInOut.easing,
  //Cubic_EaseInOut
  13: cc._easeQuinticActionIn.easing,
  //Quint_EaseIn
  14: cc._easeQuinticActionOut.easing,
  //Quint_EaseOut
  15: cc._easeQuinticActionInOut.easing,
  //Quint_EaseInOut
  16: cc._easeExponentialInObj.easing,
  //Expo_EaseIn
  17: cc._easeExponentialOutObj.easing,
  //Expo_EaseOut
  18: cc._easeExponentialInOutObj.easing,
  //Expo_EaseInOut
  19: cc._easeCircleActionIn.easing,
  //Circ_EaseIn
  20: cc._easeCircleActionOut.easing,
  //Circ_EaseOut
  21: cc._easeCircleActionInOut.easing,
  //Circ_EaseInOut
  22: function(t, e) {
    var n = 0.3;
    return e != null && (n = e[0]), cc.easeElasticIn(n).easing(t);
  },
  //Elastic_EaesIn
  23: function(t, e) {
    var n = 0.3;
    return e != null && (n = e[0]), cc.easeElasticOut(n).easing(t);
  },
  //Elastic_EaesOut
  24: function(t, e) {
    var n = 0.3;
    return e != null && (n = e[0]), cc.easeElasticInOut(n).easing(t);
  },
  //Elastic_EaesInOut
  25: cc._easeBackInObj.easing,
  26: cc._easeBackOutObj.easing,
  27: cc._easeBackInOutObj.easing,
  28: cc._easeBounceInObj.easing,
  29: cc._easeBounceOutObj.easing,
  30: cc._easeBounceInOutObj.easing
};
ccs.VisibleFrame = ccs.Frame.extend({
  _visible: !0,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._visible = !0;
  },
  onEnter: function(t) {
    this._node && this._node.setVisible(this._visible);
  },
  clone: function() {
    var t = new ccs.VisibleFrame();
    return t.setVisible(this._visible), t._cloneProperty(this), t;
  },
  setVisible: function(t) {
    this._visible = t;
  },
  isVisible: function() {
    return this._visible;
  }
});
ccs.VisibleFrame.create = function() {
  return new ccs.VisibleFrame();
};
ccs.TextureFrame = ccs.Frame.extend({
  _sprite: null,
  _textureName: null,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._textureName = "";
  },
  setNode: function(t) {
    ccs.Frame.prototype.setNode.call(this, t), this._sprite = t;
  },
  onEnter: function(t) {
    if (this._sprite) {
      var e = (this || window)._sprite.getBlendFunc(), n = cc.spriteFrameCache._spriteFrames[this._textureName];
      n != null ? this._sprite.setSpriteFrame(n) : this._sprite.setTexture(this._textureName), this._sprite.getBlendFunc() !== e && this._sprite.setBlendFunc(e);
    }
  },
  clone: function() {
    var t = new ccs.TextureFrame();
    return t.setTextureName(this._textureName), t._cloneProperty(this), t;
  },
  setTextureName: function(t) {
    this._textureName = t;
  },
  getTextureName: function() {
    return this._textureName;
  }
});
ccs.TextureFrame.create = function() {
  return new ccs.TextureFrame();
};
ccs.RotationFrame = ccs.Frame.extend({
  _rotation: null,
  _betwennRotation: null,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._rotation = 0;
  },
  onEnter: function(t) {
    this._node && (this._node.setRotation(this._rotation), this._tween && (this._betwennRotation = t._rotation - this._rotation));
  },
  _onApply: function(t) {
    if (this._betwennRotation !== 0) {
      var e = (this || window)._rotation + t * this._betwennRotation;
      this._node.setRotation(e);
    }
  },
  clone: function() {
    var t = new ccs.RotationFrame();
    return t.setRotation(this._rotation), t._cloneProperty(this), t;
  },
  setRotation: function(t) {
    this._rotation = t;
  },
  getRotation: function() {
    return this._rotation;
  }
});
ccs.RotationFrame.create = function() {
  return new ccs.RotationFrame();
};
ccs.SkewFrame = ccs.Frame.extend({
  _skewX: null,
  _skewY: null,
  _betweenSkewX: null,
  _betweenSkewY: null,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._skewX = 0, this._skewY = 0;
  },
  onEnter: function(t) {
    this._node && (this._node.setSkewX(this._skewX), this._node.setSkewY(this._skewY), this._tween && (this._betweenSkewX = t._skewX - this._skewX, this._betweenSkewY = t._skewY - this._skewY));
  },
  _onApply: function(t) {
    if (this._betweenSkewX !== 0 || this._betweenSkewY !== 0) {
      var e = (this || window)._skewX + t * this._betweenSkewX, n = (this || window)._skewY + t * this._betweenSkewY;
      this._node.setSkewX(e), this._node.setSkewY(n);
    }
  },
  clone: function() {
    var t = new ccs.SkewFrame();
    return t.setSkewX(this._skewX), t.setSkewY(this._skewY), t._cloneProperty(this), t;
  },
  setSkewX: function(t) {
    this._skewX = t;
  },
  getSkewX: function() {
    return this._skewX;
  },
  setSkewY: function(t) {
    this._skewY = t;
  },
  getSkewY: function() {
    return this._skewY;
  }
});
ccs.SkewFrame.create = function() {
  return new ccs.SkewFrame();
};
ccs.RotationSkewFrame = ccs.SkewFrame.extend({
  onEnter: function(t) {
    this._node && (this._node.setRotationX(this._skewX), this._node.setRotationY(this._skewY), this._tween && (this._betweenSkewX = t._skewX - this._skewX, this._betweenSkewY = t._skewY - this._skewY));
  },
  _onApply: function(t) {
    if (this._node && (this._betweenSkewX !== 0 || this._betweenSkewY !== 0)) {
      var e = (this || window)._skewX + t * this._betweenSkewX, n = (this || window)._skewY + t * this._betweenSkewY;
      this._node.setRotationX(e), this._node.setRotationY(n);
    }
  },
  clone: function() {
    var t = new ccs.RotationSkewFrame();
    return t.setSkewX(this._skewX), t.setSkewY(this._skewY), t._cloneProperty(this), t;
  }
});
ccs.RotationSkewFrame.create = function() {
  return new ccs.RotationSkewFrame();
};
ccs.PositionFrame = ccs.Frame.extend({
  _position: null,
  _betweenX: null,
  _betweenY: null,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._position = cc.p(0, 0);
  },
  onEnter: function(t) {
    this._node && (this._node.setPosition(this._position), this._tween && (this._betweenX = t._position.x - this._position.x, this._betweenY = t._position.y - this._position.y));
  },
  _onApply: function(t) {
    if (this._node && (this._betweenX !== 0 || this._betweenY !== 0)) {
      var e = cc.p(0, 0);
      e.x = (this || window)._position.x + this._betweenX * t, e.y = (this || window)._position.y + this._betweenY * t, this._node.setPosition(e);
    }
  },
  clone: function() {
    var t = new ccs.PositionFrame();
    return t.setPosition(this._position), t._cloneProperty(this), t;
  },
  setPosition: function(t) {
    this._position = t;
  },
  getPosition: function() {
    return this._position;
  },
  setX: function(t) {
    this._position.x = t;
  },
  getX: function() {
    return this._position.x;
  },
  setY: function(t) {
    this._position.y = t;
  },
  getY: function() {
    return this._position.y;
  }
});
ccs.PositionFrame.create = function() {
  return new ccs.PositionFrame();
};
ccs.ScaleFrame = ccs.Frame.extend({
  _scaleX: null,
  _scaleY: null,
  _betweenScaleX: null,
  _betweenScaleY: null,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._scaleX = 1, this._scaleY = 1;
  },
  onEnter: function(t) {
    this._node && (this._node.setScaleX(this._scaleX), this._node.setScaleY(this._scaleY), this._tween && (this._betweenScaleX = t._scaleX - this._scaleX, this._betweenScaleY = t._scaleY - this._scaleY));
  },
  _onApply: function(t) {
    if (this._node && (this._betweenScaleX !== 0 || this._betweenScaleY !== 0)) {
      var e = (this || window)._scaleX + this._betweenScaleX * t, n = (this || window)._scaleY + this._betweenScaleY * t;
      this._node.setScaleX(e), this._node.setScaleY(n);
    }
  },
  clone: function() {
    var t = new ccs.ScaleFrame();
    return t.setScaleX(this._scaleX), t.setScaleY(this._scaleY), t._cloneProperty(this), t;
  },
  setScale: function(t) {
    this._scaleX = t, this._scaleY = t;
  },
  setScaleX: function(t) {
    this._scaleX = t;
  },
  getScaleX: function() {
    return this._scaleX;
  },
  setScaleY: function(t) {
    this._scaleY = t;
  },
  getScaleY: function() {
    return this._scaleY;
  }
});
ccs.ScaleFrame.create = function() {
  return new ccs.ScaleFrame();
};
ccs.AnchorPointFrame = ccs.Frame.extend({
  _anchorPoint: null,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._anchorPoint = cc.p(0, 0);
  },
  onEnter: function(t) {
    this._node && this._node.setAnchorPoint(this._anchorPoint);
  },
  clone: function() {
    var t = new ccs.AnchorPointFrame();
    return t.setAnchorPoint(this._anchorPoint), t._cloneProperty(this), t;
  },
  setAnchorPoint: function(t) {
    this._anchorPoint = t;
  },
  getAnchorPoint: function() {
    return this._anchorPoint;
  }
});
ccs.AnchorPointFrame.create = function() {
  return new ccs.AnchorPointFrame();
};
ccs.InnerActionType = {
  LoopAction: 0,
  NoLoopAction: 1,
  SingleFrame: 2
};
ccs.InnerActionFrame = ccs.Frame.extend({
  _innerActionType: null,
  _startFrameIndex: null,
  _endFrameIndex: 0,
  _singleFrameIndex: 0,
  _enterWithName: null,
  _animationName: "",
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._enterWithName = !1, this._innerActionType = ccs.InnerActionType.LoopAction, this._startFrameIndex = 0;
  },
  onEnter: function(t) {
    if (this._node) {
      var e = (this || window)._node.getActionByTag(this._node.getTag());
      if (e) {
        if (ccs.InnerActionType.SingleFrame === (this || window)._innerActionType) {
          e.gotoFrameAndPause(this._singleFrameIndex);
          return;
        }
        var n = (this || window)._startFrameIndex, r = (this || window)._endFrameIndex;
        if (this._enterWithName)
          if (this._animationName === "-- ALL --")
            n = 0, r = e.getDuration();
          else if (e.isAnimationInfoExists(this._animationName)) {
            var s = e.getAnimationInfo(this._animationName);
            n = s.startIndex, r = s.endIndex;
          } else
            cc.log("Animation %s not exists!", this._animationName);
        var o = (this || window)._timeline.getActionTimeline().getDuration(), a = o - this._frameIndex - r + n;
        a < 0 && (r += a), ccs.InnerActionType.NoLoopAction === (this || window)._innerActionType ? e.gotoFrameAndPlay(n, r, !1) : ccs.InnerActionType.LoopAction === (this || window)._innerActionType && e.gotoFrameAndPlay(n, r, !0);
      }
    }
  },
  setAnimationName: function(t) {
    this._animationName = t;
  },
  setSingleFrameIndex: function(t) {
    this._singleFrameIndex = t;
  },
  getSingleFrameIndex: function() {
    return this._startFrameIndex;
  },
  setEnterWithName: function(t) {
    this._enterWithName = t;
  },
  getEnterWithName: function() {
    return this._enterWithName;
  },
  clone: function() {
    var t = new ccs.InnerActionFrame();
    return t.setInnerActionType(this._innerActionType), t.setStartFrameIndex(this._startFrameIndex), t.setEnterWithName(this._enterWithName), t.setAnimationName(this._animationName), t.setSingleFrameIndex(this._singleFrameIndex), t._cloneProperty(this), t;
  },
  setInnerActionType: function(t) {
    this._innerActionType = t;
  },
  getInnerActionType: function() {
    return this._innerActionType;
  },
  setStartFrameIndex: function(t) {
    this._startFrameIndex = t;
  },
  getStartFrameIndex: function() {
    return this._startFrameIndex;
  }
});
ccs.InnerActionFrame.create = function() {
  return new ccs.InnerActionFrame();
};
ccs.ColorFrame = ccs.Frame.extend({
  _alpha: null,
  _color: null,
  _betweenAlpha: null,
  _betweenRed: null,
  _betweenGreen: null,
  _betweenBlue: null,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._color = cc.color(255, 255, 255);
  },
  onEnter: function(t) {
    if (this._node && (this._node.setColor(this._color), this._tween)) {
      var e = t._color;
      this._betweenRed = e.r - this._color.r, this._betweenGreen = e.g - this._color.g, this._betweenBlue = e.b - this._color.b;
    }
  },
  _onApply: function(t) {
    if (this._node && this._tween && (this._betweenAlpha !== 0 || this._betweenRed !== 0 || this._betweenGreen !== 0 || this._betweenBlue !== 0)) {
      var e = cc.color(255, 255, 255);
      if (e.r = (this || window)._color.r + this._betweenRed * t, e.g = (this || window)._color.g + this._betweenGreen * t, e.b = (this || window)._color.b + this._betweenBlue * t, this._node.setColor(e), this._alpha !== null) {
        var n = (this || window)._alpha + this._betweenAlpha * t;
        this._node.setOpacity(n);
      }
    }
  },
  clone: function() {
    var t = new ccs.ColorFrame();
    return t.setColor(this._color), t._cloneProperty(this), t;
  },
  setColor: function(t) {
    this._color = t;
  },
  getColor: function() {
    return this._color;
  }
});
ccs.ColorFrame.create = function() {
  return new ccs.ColorFrame();
};
ccs.AlphaFrame = ccs.Frame.extend({
  _alpha: null,
  _betweenAlpha: null,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._alpha = 255;
  },
  onEnter: function(t) {
    this._node && (this._node.setOpacity(this._alpha), this._tween && (this._betweenAlpha = t._alpha - this._alpha));
  },
  _onApply: function(t) {
    if (this._node) {
      var e = (this || window)._alpha + this._betweenAlpha * t;
      this._node.setOpacity(e);
    }
  },
  setAlpha: function(t) {
    this._alpha = t;
  },
  getAlpha: function() {
    return this._alpha;
  },
  clone: function() {
    var t = new ccs.AlphaFrame();
    return t.setAlpha(this._alpha), t._cloneProperty(this), t;
  }
});
ccs.EventFrame = ccs.Frame.extend({
  _event: null,
  ctor: function() {
    ccs.Frame.prototype.ctor.call(this), this._event = "", this._enterWhenPassed = !0;
  },
  onEnter: function(t) {
    this._emitEvent();
  },
  clone: function() {
    var t = new ccs.EventFrame();
    return t.setEvent(this._event), t._cloneProperty(this), t;
  },
  setEvent: function(t) {
    this._event = t;
  },
  getEvent: function() {
    return this._event;
  }
});
ccs.EventFrame.create = function() {
  return new ccs.EventFrame();
};
ccs.ZOrderFrame = ccs.Frame.extend({
  _zorder: 0,
  onEnter: function(t) {
    this._node && this._node.setLocalZOrder(this._zorder);
  },
  clone: function() {
    var t = new ccs.ZOrderFrame();
    return t.setZOrder(this._zorder), t._cloneProperty(this), t;
  },
  setZOrder: function(t) {
    this._zorder = t;
  },
  getZOrder: function() {
    return this._zorder;
  }
});
ccs.ZOrderFrame.create = function() {
  return new ccs.ZOrderFrame();
};
ccs.BlendFuncFrame = ccs.Frame.extend({
  ctor: function() {
    this._super(), this._blendFunc = null;
  },
  onEnter: function(t, e) {
    this._node && this._blendFunc && this._node.setBlendFunc(this._blendFunc);
  },
  clone: function() {
    var t = new ccs.BlendFuncFrame();
    return t.setBlendFunc(this._blendFunc), t._cloneProperty(this), t;
  },
  setBlendFunc: function(t) {
    t && t.src && t.dst && (this._blendFunc = t);
  },
  getBlendFunc: function() {
    return this._blendFunc;
  }
});
ccs.BlendFuncFrame.create = function() {
  return new ccs.BlendFuncFrame();
};
ccs.Timeline = ccs.Class.extend({
  _frames: null,
  _currentKeyFrame: null,
  _currentKeyFrameIndex: null,
  _fromIndex: null,
  _toIndex: null,
  _betweenDuration: null,
  _actionTag: null,
  _ActionTimeline: null,
  _node: null,
  ctor: function() {
    this._frames = [], this._currentKeyFrame = null, this._currentKeyFrameIndex = 0, this._fromIndex = 0, this._toIndex = 0, this._betweenDuration = 0, this._actionTag = 0, this._ActionTimeline = null, this._node = null;
  },
  _gotoFrame: function(t) {
    this._frames.length !== 0 && (this._binarySearchKeyFrame(t), this._apply(t));
  },
  _stepToFrame: function(t) {
    this._frames.length !== 0 && (this._updateCurrentKeyFrame(t), this._apply(t));
  },
  getFrames: function() {
    return this._frames;
  },
  addFrame: function(t) {
    this._frames.push(t), t.setTimeline(this);
  },
  insertFrame: function(t, e) {
    this._frames.splice(e, 0, t), t.setTimeline(this);
  },
  removeFrame: function(t) {
    cc.arrayRemoveObject(this._frames, t), t.setTimeline(null);
  },
  setActionTag: function(t) {
    this._actionTag = t;
  },
  getActionTag: function() {
    return this._actionTag;
  },
  setNode: function(t) {
    for (var e = 0; e < this._frames.length; e++) {
      var n = (this || window)._frames[e];
      n.setNode(t);
    }
  },
  getNode: function() {
    return this._node;
  },
  setActionTimeline: function(t) {
    this._ActionTimeline = t;
  },
  getActionTimeline: function() {
    return this._ActionTimeline;
  },
  clone: function() {
    var t = new ccs.Timeline();
    t._actionTag = (this || window)._actionTag;
    for (var e = 0; e < this._frames.length; e++) {
      var n = (this || window)._frames[e], r = n.clone();
      t.addFrame(r);
    }
    return t;
  },
  _apply: function(t) {
    if (this._currentKeyFrame) {
      var e = (this || window)._betweenDuration <= 0 ? 0 : (t - this._currentKeyFrameIndex) / this._betweenDuration;
      this._currentKeyFrame.apply(e);
    }
  },
  _binarySearchKeyFrame: function(t) {
    var e = null, n = null, r = (this || window)._frames.length, s = !1;
    do {
      if (t < this._frames[0].getFrameIndex()) {
        this._currentKeyFrameIndex >= (this || window)._frames[0].getFrameIndex() && (s = !0), this._fromIndex = 0, this._toIndex = 0, e = n = (this || window)._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = (this || window)._frames[0].getFrameIndex();
        break;
      } else if (t >= (this || window)._frames[r - 1].getFrameIndex()) {
        this._fromIndex = r - 1, this._toIndex = 0, e = n = (this || window)._frames[r - 1], this._currentKeyFrameIndex = (this || window)._frames[r - 1].getFrameIndex(), this._betweenDuration = 0;
        break;
      }
      for (var o = -1, a = 0, c = r - 1, l = 0; a <= c; ) {
        if (l = Math.ceil((a + c) / 2), t >= (this || window)._frames[l].getFrameIndex() && t < this._frames[l + 1].getFrameIndex()) {
          o = l;
          break;
        }
        this._frames[l].getFrameIndex() > t ? c = l - 1 : a = l + 1;
      }
      this._fromIndex = o, r > 1 ? this._toIndex = o + 1 | 0 : this._toIndex = o | 0, e = (this || window)._frames[this._fromIndex], n = (this || window)._frames[this._toIndex], e = (this || window)._frames[o], n = (this || window)._frames[o + 1], o === 0 && this._currentKeyFrameIndex < e.getFrameIndex() && (s = !0), this._currentKeyFrameIndex = e.getFrameIndex(), this._betweenDuration = n.getFrameIndex() - e.getFrameIndex();
    } while (0);
    (s || this._currentKeyFrame != e) && (this._currentKeyFrame = e, this._currentKeyFrame.onEnter(n));
  },
  _updateCurrentKeyFrame: function(t) {
    if (t < this._currentKeyFrameIndex || t >= (this || window)._currentKeyFrameIndex + this._betweenDuration) {
      var e = null, n = null;
      do {
        var r = (this || window)._frames.length;
        if (t < this._frames[0].getFrameIndex()) {
          e = n = (this || window)._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = (this || window)._frames[0].getFrameIndex();
          break;
        } else if (t >= (this || window)._frames[r - 1].getFrameIndex()) {
          var s = (this || window)._frames[r - 1].getFrameIndex();
          if (this._currentKeyFrameIndex >= s)
            return;
          t = s;
        }
        do {
          if (this._fromIndex = (this || window)._toIndex, e = (this || window)._frames[this._fromIndex], this._currentKeyFrameIndex = e.getFrameIndex(), this._toIndex = (this || window)._fromIndex + 1, this._toIndex >= r && (this._toIndex = 0), n = (this || window)._frames[this._toIndex], t === e.getFrameIndex() || t > e.getFrameIndex() && t < n.getFrameIndex())
            break;
          e.isEnterWhenPassed() && e.onEnter(n);
        } while (!0);
        this._betweenDuration = n.getFrameIndex() - e.getFrameIndex();
      } while (0);
      this._currentKeyFrame = e, this._currentKeyFrame.onEnter(n);
    }
  }
});
ccs.Timeline.create = function() {
  return new ccs.Timeline();
};
ccs.SkinNode = function() {
  var t = cc.Node, e = {}, n = t.extend(e);
  return n.create = function() {
  }, n;
}();
ccs.BoneNode = function() {
  var t = cc.Node, e = ccs.SkinNode, n = cc.BlendFunc, r = {
    p: cc.p,
    size: cc.size,
    rect: cc.rect
  }, s = {
    log: cc.log,
    assert: cc.assert
  }, o = t.extend({
    _customCommand: null,
    _blendFunc: null,
    _rackColor: null,
    _rackLength: null,
    _rackWidth: null,
    _childBones: null,
    _boneSkins: null,
    _rootSkeleton: null,
    _squareVertices: null,
    _squareColors: null,
    _noMVPVertices: null,
    ctor: function(l) {
      t.prototype.ctor.call(this), this._squareVertices === null && (this._squareVertices = [
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 }
      ]), this._rackColor = cc.color.WHITE, this._blendFunc = n.ALPHA_NON_PREMULTIPLIED, this._childBones = [], this._boneSkins = [], this._rackLength = l === void 0 ? 50 : l, this._rackWidth = 20, this._updateVertices();
    },
    addSkin: function(l, h, u) {
      var _ = (this || window)._boneSkins;
      if (s.assert(l != null, "Argument must be non-nil"), u)
        for (var d = 0; d < _.length; d++)
          _[d].setVisible(!1);
      t.prototype.addChild.call(this, l), this._boneSkins.push(l), l.setVisible(h);
    },
    getChildBones: function() {
      return this._childBones;
    },
    getSkins: function() {
      return this._boneSkins;
    },
    displaySkin: function(l, h) {
      var u = (this || window)._boneSkins, _, d;
      if (typeof l == "string")
        for (d = 0; d < u.length; d++)
          _ = u[d], l == _.getName() ? _.setVisible(!0) : h && _.setVisible(!1);
      else
        for (d = 0; d < u.length; d++)
          _ = u[d], _ == l ? _.setVisible(!0) : h && _.setVisible(!1);
    },
    getVisibleSkins: function() {
      for (var l = [], h = (this || window)._boneSkins, u, _ = 0; _ < h.length; _++)
        u = h[_], u.isVisible() && l.push(u);
      return l;
    },
    getRootSkeletonNode: function() {
      return this._rootSkeleton;
    },
    getAllSubBones: function() {
      for (var l = [], h = [], u = (this || window)._childBones, _ = 0; _ < u.length; _++)
        h.push(u[_]);
      for (; h.length > 0; ) {
        var d = h.pop();
        l.push(d);
        for (var f = d.getChildBones(), C = 0; C < f; C++)
          h.push(f[C]);
      }
      return l;
    },
    getAllSubSkins: function() {
      for (var l = (this || window).getAllSubBones(), h = [], u = 0; u < l.length; u++)
        for (var _ = l[u].getSkins(), d = 0; d < _.length; d++)
          h.push(_[u]);
      return h;
    },
    addChild: function(l, h, u) {
      t.prototype.addChild.call(this, l, h, u), this._addToChildrenListHelper(l);
    },
    removeChild: function(l, h) {
      this._children.indexOf(l) !== -1 && (t.prototype.removeChild.call(this, l, h), this._removeFromChildrenListHelper(l));
    },
    setBlendFunc: function(l) {
      var h = (this || window)._blendFunc;
      if (l && h.src !== l.src && h.dst !== l.dst) {
        this._blendFunc = l;
        for (var u = (this || window)._boneSkins, _, d = 0; d < u.length; d++)
          _ = u[d], _.setBlendFunc(l);
      }
    },
    getBlendFunc: function() {
      return this._blendFunc;
    },
    setDebugDrawLength: function(l) {
      this._rackLength = l, this._updateVertices();
    },
    getDebugDrawLength: function() {
      return this._rackLength;
    },
    setDebugDrawWidth: function(l) {
      this._rackWidth = l, this._updateVertices();
    },
    getDebugDrawWidth: function() {
      return this._rackWidth;
    },
    setDebugDrawEnabled: function(l) {
      var h = (this || window)._renderCmd;
      h._debug !== l && (h._debug = l, cc.renderer.childrenOrderDirty = !0, this._visible && this._rootSkeleton != null && (this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0));
    },
    isDebugDrawEnabled: function() {
      return this._renderCmd._debug;
    },
    setDebugDrawColor: function(l) {
      this._rackColor = l;
    },
    getDebugDrawColor: function() {
      return this._rackColor;
    },
    getVisibleSkinsRect: function() {
      var l, h, u, _ = 0;
      l = h = u = _;
      var d = !0, f = r.rect(0, 0, 0, 0);
      this._renderCmd._debug && this._rootSkeleton != null && this._rootSkeleton._renderCmd._debug && (u = (this || window)._rackWidth, _ = (this || window)._rackLength, d = !1);
      for (var C = (this || window)._boneSkins, m, g = 0; g < C.length; g++) {
        m = C[g];
        var y = m.getBoundingBox();
        !m.isVisible() || y.x === 0 && y.y === 0 && y.width === 0 && y.height === 0 || (d ? (l = cc.rectGetMinX(y), h = cc.rectGetMinY(y), u = cc.rectGetMaxX(y), _ = cc.rectGetMaxY(y), d = !1) : (l = Math.min(cc.rectGetMinX(y), l), h = Math.min(cc.rectGetMinY(y), h), u = Math.max(cc.rectGetMaxX(y), u), _ = Math.max(cc.rectGetMaxY(y), _)), f.setRect(l, h, u - l, _ - h));
      }
      return f;
    },
    getBoundingBox: function() {
      var l = (this || window).getVisibleSkinsRect();
      return cc.rectApplyAffineTransform(l, this.getNodeToParentAffineTransform());
    },
    batchBoneDrawToSkeleton: function(l) {
    },
    setLocalZOrder: function(l) {
      t.prototype.setLocalZOrder.call(this, l), this._rootSkeleton != null && (this._rootSkeleton._subBonesOrderDirty = !0);
    },
    setName: function(l) {
      var h = (this || window)._rootSkeleton, u = (this || window).getName();
      if (t.prototype.setName.call(this, l), h != null) {
        var _ = h._subBonesMap[u], d = h._subBonesMap[l];
        _ && !d && (delete h._subBonesMap[_], h._subBonesMap[l] = _);
      }
    },
    setContentSize: function(l) {
      t.prototype.setContentSize.call(this, l), this._updateVertices();
    },
    setAnchorPoint: function(l) {
      t.prototype.setAnchorPoint.call(this, l), this._updateVertices();
    },
    setVisible: function(l) {
      this._visible != l && (t.prototype.setVisible.call(this, l), this._rootSkeleton != null && (this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0));
    },
    _addToChildrenListHelper: function(l) {
      l instanceof o ? this._addToBoneList(l) : this._addToSkinList(l);
    },
    _removeFromChildrenListHelper: function(l) {
      l instanceof o ? this._removeFromBoneList(l) : l instanceof e && this._removeFromSkinList(skin);
    },
    _removeFromBoneList: function(l) {
      if (this._rootSkeleton != null && l instanceof ccs.SkeletonNode && l._rootSkeleton === (this || window)._rootSkeleton) {
        l._rootSkeleton = null;
        var h = l.getAllSubBones();
        h.push(l);
        for (var u, _ = 0; _ < h.length; _++)
          u = h[_], u._rootSkeleton = null, delete this._rootSkeleton._subBonesMap[u.getName()], this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0;
      } else
        this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0;
      cc.arrayRemoveObject(this._childBones, l);
    },
    _setRootSkeleton: function(l) {
      this._rootSkeleton = l;
      for (var h = (this || window).getAllSubBones(), u = 0; u < h.length; u++)
        this._addToBoneList(h[u]);
    },
    _addToBoneList: function(l) {
      if (this._childBones.indexOf(l) === -1 && this._childBones.push(l), this._rootSkeleton != null) {
        var h = l;
        if (!(h instanceof e) && !l._rootSkeleton) {
          var u = l.getAllSubBones();
          u.push(l);
          for (var _, d = 0; d < u.length; d++) {
            _ = u[d], _._setRootSkeleton(this._rootSkeleton);
            var f = _.getName();
            this._rootSkeleton._subBonesMap[f] ? (cc.log("already has a bone named %s in skeleton %s", f, this._rootSkeleton.getName()), this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0) : (this._rootSkeleton._subBonesMap[_.getName()] = _, this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0);
          }
        }
      }
    },
    _visitSkins: function() {
      var l = (this || window)._renderCmd;
      if (this._visible) {
        var h = l.getParentRenderCmd();
        h && (l._curLevel = h._curLevel + 1);
        var u, _ = (this || window)._boneSkins, d;
        l._syncStatus(h);
        var f = _.length;
        if (f > 0) {
          for (this.sortAllChildren(), u = 0; u < f && (d = _[u], d._localZOrder < 0); u++)
            d._renderCmd.visit(l);
          for (; u < f; u++)
            _[u]._renderCmd.visit(l);
        }
        l._dirtyFlag = 0;
      }
    },
    _addToSkinList: function(l) {
      if (this._boneSkins.push(l), l.getBlendFunc) {
        var h = l.getBlendFunc();
        this._blendFunc.src !== h.src && this._blendFunc.dst !== h.dst && l.setBlendFunc(this._blendFunc);
      }
    },
    _removeFromSkinList: function(l) {
      cc.arrayRemoveObject(this._boneSkins, l);
    },
    sortAllChildren: function() {
      this._sortArray(this._childBones), this._sortArray(this._boneSkins), t.prototype.sortAllChildren.call(this);
    },
    _sortArray: function(l) {
      if (l) {
        var h = l.length, u, _, d;
        for (u = 1; u < h; u++) {
          for (d = l[u], _ = u - 1; _ >= 0; ) {
            if (d._localZOrder < l[_]._localZOrder)
              l[_ + 1] = l[_];
            else if (d._localZOrder === l[_]._localZOrder && d.arrivalOrder < l[_].arrivalOrder)
              l[_ + 1] = l[_];
            else
              break;
            _--;
          }
          l[_ + 1] = d;
        }
      }
    },
    _updateVertices: function() {
      var l = (this || window)._squareVertices, h = (this || window)._renderCmd._anchorPointInPoints;
      if (this._rackLength != l[2].x - h.x || l[3].y != (this || window)._rackWidth / 2 - h.y) {
        l[1].x = l[1].y = l[3].y = 0, l[0].x = l[2].x = (this || window)._rackLength * 0.1, l[2].y = (this || window)._rackWidth * 0.5, l[0].y = -l[2].y, l[3].x = (this || window)._rackLength;
        for (var u = 0; u < l.length; u++)
          l[u].x += h.x, l[u].y += h.y;
        this._renderCmd.updateDebugPoint(l);
      }
    },
    _createRenderCmd: function() {
      return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new a(this) : new c(this);
    }
  });
  o.create = function(l, h) {
    return new ccui.BoneNode(l, h);
  };
  var a = function() {
    var l = /* @__PURE__ */ H(function(u) {
      t.CanvasRenderCmd.call(this, u), this._debug = !1, this._color = cc.color.WHITE, this._drawNode = new cc.DrawNode();
    }, "BoneNodeCanvasCmd"), h = l.prototype = Object.create(t.CanvasRenderCmd.prototype);
    return h.constructor = l, h.visit = function(u) {
      var _ = (this || window)._node;
      _._visit && _._visit(u);
    }, h.updateDebugPoint = function(u) {
      this._drawNode.clear(), this._drawNode.drawPoly(u, this._color, 0, this._color);
    }, h.transform = function(u, _) {
      var d = (this || window)._node._rootSkeleton;
      t.CanvasRenderCmd.prototype.transform.call(this, u, _), d && d._renderCmd._debug && this._drawNode._renderCmd.transform(this);
    }, l;
  }(), c = function() {
    var l = /* @__PURE__ */ H(function(u) {
      t.WebGLRenderCmd.call(this, u), this._debug = !1, this._color = cc.color.WHITE, this._drawNode = new cc.DrawNode();
    }, "BoneNodeWebGLCmd"), h = l.prototype = Object.create(t.WebGLRenderCmd.prototype);
    return h.constructor = l, h.visit = function(u) {
      var _ = (this || window)._node;
      _._visit && _._visit(u);
    }, h.updateDebugPoint = function(u) {
      this._drawNode.clear(), this._drawNode.drawPoly(u, this._color, 0, this._color);
    }, h.transform = function(u, _) {
      var d = (this || window)._node._rootSkeleton;
      t.WebGLRenderCmd.prototype.transform.call(this, u, _), d && d._renderCmd._debug && this._drawNode._renderCmd.transform(this);
    }, l;
  }();
  return o;
}();
ccs.SkeletonNode = function() {
  var t = ccs.BoneNode;
  cc.p, cc.size, cc.rect;
  var e = t.extend({
    _subBonesMap: null,
    _squareVertices: null,
    _squareColors: null,
    _noMVPVertices: null,
    _skinGroupMap: null,
    _sortedAllBonesDirty: !1,
    _sortedAllBones: null,
    _batchedBoneVetices: null,
    _batchedBoneColors: null,
    _batchedVeticesCount: null,
    _batchBoneCommand: null,
    _subOrderedAllBones: null,
    ctor: function() {
      this._squareVertices = [
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 },
        { x: 0, y: 0 }
      ], this._rootSkeleton = (this || window), t.prototype.ctor.call(this), this._subBonesMap = {}, this._subOrderedAllBones = [], this._skinGroupMap = {}, this._rackLength = (this || window)._rackWidth = 20, this._updateVertices();
    },
    getBoneNode: function(n) {
      var r = (this || window)._subBonesMap[n];
      return r || null;
    },
    getAllSubBonesMap: function() {
      return this._subBonesMap;
    },
    changeSkins: function(n) {
      if (typeof n == "object") {
        var r;
        for (var s in n) {
          r = n[s];
          var o = (this || window).getBoneNode(s);
          o !== null && o.displaySkin(r, !0);
        }
      } else {
        var a = (this || window)._suitMap[n];
        a && this.changeSkins(a, !0);
      }
    },
    addSkinGroup: function(n, r) {
      this._skinGroupMap[n] = r;
    },
    getBoundingBox: function() {
      var n, r, s, o = 0;
      n = r = s = o;
      var a = (this || window).getVisibleSkinsRect(), c = !0;
      (a.x !== 0 || a.y !== 0 || a.width !== 0 || a.height !== 0) && (n = cc.rectGetMinX(a), r = cc.rectGetMinY(a), s = cc.rectGetMaxX(a), o = cc.rectGetMaxY(a), c = !1);
      for (var l = (this || window).getAllSubBones(), h, u = 0; u < l.length; u++) {
        h = l[u];
        var _ = cc.rectApplyAffineTransform(h.getVisibleSkinsRect(), h.getNodeToParentTransform(h.getRootSkeletonNode()));
        _.x === 0 && _.y === 0 && _.width === 0 && _.height === 0 || (c ? (n = cc.rectGetMinX(_), r = cc.rectGetMinY(_), s = cc.rectGetMaxX(_), o = cc.rectGetMaxY(_), c = !1) : (n = Math.min(cc.rectGetMinX(_), n), r = Math.min(cc.rectGetMinY(_), r), s = Math.max(cc.rectGetMaxX(_), s), o = Math.max(cc.rectGetMaxY(_), o)));
      }
      return a.x = n, a.y = r, a.width = s - n, a.height = o - r, cc.rectApplyAffineTransform(a, this.getNodeToParentTransform());
    },
    _visit: function(n) {
      if (this._visible) {
        var r = (this || window)._renderCmd;
        n = n || r.getParentRenderCmd(), r._syncStatus(n);
        var s, o;
        if (this._children.length !== 0)
          for (s = 0; s < this._children.length; s++)
            o = (this || window)._children[s], o._renderCmd.visit(r);
        this._checkSubBonesDirty();
        var a = (this || window)._subOrderedAllBones, c, l;
        for (s = 0; s < a.length; s++)
          c = a[s], c._visitSkins();
        if (r._debug)
          for (s = 0; s < a.length; s++)
            l = a[s]._renderCmd, cc.renderer.pushRenderCommand(l._drawNode._renderCmd);
        this._dirtyFlag = 0;
      }
    },
    _checkSubBonesDirty: function() {
      this._subBonesDirty && (this._updateOrderedAllbones(), this._subBonesDirty = !1), this._subBonesOrderDirty && (this._sortOrderedAllBones(), this._subBonesOrderDirty = !1);
    },
    _updateOrderedAllbones: function() {
      this._subOrderedAllBones.length = 0;
      for (var n = [], r = (this || window)._childBones, s, o = 0; o < r.length; o++)
        s = r[o], s.isVisible() && n.push(s);
      for (; n.length > 0; ) {
        var a = n.pop(), c = a._renderCmd;
        c._syncStatus(c.getParentRenderCmd()), this._subOrderedAllBones.push(a);
        for (var l = a.getChildBones(), h, o = 0; o < l.length; o++)
          h = l[o], h.isVisible() && n.push(h);
      }
    },
    _sortOrderedAllBones: function() {
      this._sortArray(this._subOrderedAllBones);
    },
    _updateVertices: function() {
      var n = (this || window)._squareVertices, r = (this || window)._renderCmd._anchorPointInPoints;
      if (this._rackLength != n[6].x - r.x || this._rackWidth != n[3].y - r.y) {
        var s = (this || window)._rackLength * 0.5, o = (this || window)._rackWidth * 0.5, a = s * 0.25, c = o * 0.25;
        n[5].y = n[2].y = n[1].y = n[6].y = n[0].x = n[4].x = n[7].x = n[3].x = 0, n[5].x = -s, n[0].y = -o, n[6].x = s, n[3].y = o, n[1].x = a, n[7].y = c, n[2].x = -a, n[4].y = -c;
        for (var l = 0; l < n.length; l++)
          n[l].x += r.x, n[l].y += r.y;
      }
    },
    _updateAllDrawBones: function() {
      this._subDrawBones = {};
      for (var n in this._subBonesMap) {
        var r = (this || window)._subBonesMap[n];
        r.isVisible() && r.isDebugDrawEnabled() && this._subDrawBones.push(r);
      }
      this._sortArray(this._sortedAllBones), this._subDrawBones = !1;
    }
  });
  return e.create = function() {
    return new e();
  }, e;
}();
ccs._load = function() {
  var t = /* @__PURE__ */ H(function(a, c, l) {
    var h = cc.loader.getRes(a);
    if (!h)
      return cc.log("%s does not exist", a);
    var u = n(a).toLocaleLowerCase();
    if (u !== "json" && u !== "exportjson")
      return cc.log("%s load error, must be json file", a);
    var _;
    if (c ? _ = e[c] : h.widgetTree ? _ = e.ccui : h.nodeTree || h.Content && h.Content.Content ? _ = e.timeline : h.gameobjects && (_ = e.scene), !_)
      return cc.log("Can't find the parser : %s", a), new cc.Node();
    var d = h.version || h.Version;
    if (!d && h.armature_data)
      return cc.warn("%s is armature. please use:", a), cc.warn("    ccs.armatureDataManager.addArmatureFileInfoAsync(%s);", a), cc.warn("    var armature = new ccs.Armature('name');"), new cc.Node();
    var f = o(_, d);
    return f ? f.parse(a, h, l) || null : (cc.log("Can't find the parser : %s", a), new cc.Node());
  }, "load"), e = {
    ccui: {},
    timeline: {},
    action: {},
    scene: {}
  };
  t.registerParser = function(a, c, l) {
    if (!a || !c || !l)
      return cc.log("register parser error");
    e[a] || (e[a] = {}), e[a][c] = l;
  }, t.getParser = function(a, c) {
    return a && c ? e[a] ? e[a][c] : void 0 : a ? e[a] : e;
  };
  var n = /* @__PURE__ */ H(function(a) {
    var c = a.match(r);
    return c && c[1] ? c[1] : null;
  }, "extname"), r = /\.([^\.]+)$/, s = /([^\.](\.\*)?)*$/, o = /* @__PURE__ */ H(function(a, c) {
    return a[c] ? a[c] : c === "*" ? null : o(a, c.replace(s, "*"));
  }, "getParser");
  return t;
}();
ccs._parser = cc.Class.extend({
  ctor: function() {
    this.parsers = {};
  },
  _dirnameReg: /\S*\//,
  _dirname: function(t) {
    var e = t.match(this._dirnameReg);
    return e && e[0] ? e[0] : "";
  },
  getClass: function(t) {
    return t.classname;
  },
  getNodeJson: function(t) {
    return t.widgetTree;
  },
  parse: function(t, e, n) {
    n = n || this._dirname(t), this.pretreatment(e, n);
    var r = (this || window).parseNode(this.getNodeJson(e), n, t);
    return r && this.deferred(e, n, r, t), r;
  },
  pretreatment: function(t, e, n) {
  },
  deferred: function(t, e, n, r) {
  },
  parseNode: function(t, e) {
    var n = (this || window).parsers[this.getClass(t)], r = null;
    return n ? r = n.call(this, t, e) : cc.log("Can't find the parser : %s", this.getClass(t)), r;
  },
  registerParser: function(t, e) {
    this.parsers[t] = e;
  }
});
ccs.load = function(t, e) {
  var n = {
    node: null,
    action: null
  };
  return n.node = ccs._load(t, null, e), n.action = ccs._load(t, "action", e), n.action && n.action.tag === -1 && n.node && (n.action.tag = n.node.tag), n;
};
ccs.load.validate = {};
ccs.load.preload = !0;
ccs.loadWithVisibleSize = function(t, e) {
  var n = ccs.load(t, e), r = cc.director.getVisibleSize();
  return n.node && r && (n.node.setContentSize(r.width, r.height), ccui.helper.doLayout(n.node)), n;
};
ccs.actionTimelineCache = {
  createAction: function(t) {
    return ccs._load(t, "action");
  }
};
ccs.csLoader = {
  createNode: function(t) {
    return ccs._load(t);
  }
};
cc.loader.register(["json"], {
  load: function(t, e, n, r) {
    cc.loader.loadJson(t, function(s, o) {
      var a = cc.path;
      if (o && o.Content && o.Content.Content.UsedResources) {
        for (var c = o.Content.Content.UsedResources, l = a.dirname(e), h = [], u, _, d = 0; d < c.length; d++)
          !ccs.load.preload && /\.(png|jpg$)/.test(c[d]) || (u = a.join(l, c[d]), _ = a._normalize(u), ccs.load.validate[_] || (ccs.load.validate[_] = !0, h.push(_)));
        cc.loader.load(h, function() {
          r(s, o);
        });
      } else
        r(s, o);
    });
  }
});
(function(t, e) {
  var n = e.extend({
    getNodeJson: function(o) {
      return o.action;
    },
    parseNode: function(o, a, c) {
      if (!o)
        return null;
      var l = (this || window), h = new ccs.ActionTimeline();
      h.setDuration(o.duration), h.setTimeSpeed(o.speed || 1);
      var u = o.timelines;
      return u.forEach(function(_) {
        var d = l.parsers[_.frameType], f;
        d ? f = d.call(l, _, a) : cc.log("parser does not exist : %s", _.frameType), f && h.addTimeline(f), _.frameType === "ColorFrame" && h.addTimeline(
          l.parsers.AlphaFrame.call(l, _, a)
        );
      }), h;
    }
  }), r = new n(), s = [
    {
      name: "PositionFrame",
      handle: function(o) {
        var a = new ccs.PositionFrame(), c = o.x, l = o.y;
        return a.setPosition(cc.p(c, l)), a;
      }
    },
    {
      name: "VisibleFrame",
      handle: function(o) {
        var a = new ccs.VisibleFrame(), c = o.value;
        return a.setVisible(c), a;
      }
    },
    {
      name: "ScaleFrame",
      handle: function(o) {
        var a = new ccs.ScaleFrame(), c = o.x, l = o.y;
        return a.setScaleX(c), a.setScaleY(l), a;
      }
    },
    {
      name: "RotationFrame",
      handle: function(o) {
        var a = new ccs.RotationFrame(), c = o.rotation;
        return a.setRotation(c), a;
      }
    },
    {
      name: "SkewFrame",
      handle: function(o) {
        var a = new ccs.SkewFrame(), c = o.x, l = o.y;
        return a.setSkewX(c), a.setSkewY(l), a;
      }
    },
    {
      name: "RotationSkewFrame",
      handle: function(o) {
        var a = new ccs.RotationSkewFrame(), c = o.x, l = o.y;
        return a.setSkewX(c), a.setSkewY(l), a;
      }
    },
    {
      name: "AnchorFrame",
      handle: function(o) {
        var a = new ccs.AnchorPointFrame(), c = o.x, l = o.y;
        return a.setAnchorPoint(cc.p(c, l)), a;
      }
    },
    {
      name: "InnerActionFrame",
      handle: function(o) {
        var a = new ccs.InnerActionFrame(), c = o.innerActionType, l = o.startFrame;
        return a.setInnerActionType(c), a.setStartFrameIndex(l), a;
      }
    },
    {
      name: "ColorFrame",
      handle: function(o) {
        var a = new ccs.ColorFrame(), c = o.red, l = o.green, h = o.blue;
        a.setColor(cc.color(c, l, h));
        var u = new ccs.AlphaFrame(), _ = o.alpha;
        return u.setAlpha(_), a;
      }
    },
    {
      name: "AlphaFrame",
      handle: function(o) {
        var a = new ccs.AlphaFrame(), c = o.alpha;
        return a.setAlpha(c), a;
      }
    },
    {
      name: "TextureFrame",
      handle: function(o) {
        var a = new ccs.TextureFrame(), c = o.value;
        if (c != null) {
          var l = c, h = cc.spriteFrameCache.getSpriteFrame(l);
          if (h == null) {
            var u = ccs.csLoader.getJsonPath();
            l = u + c;
          }
          a.setTextureName(l);
        }
        return a;
      }
    },
    {
      name: "EventFrame",
      handle: function(o) {
        var a = new ccs.EventFrame(), c = o.value;
        return c != null && a.setEvent(c), a;
      }
    },
    {
      name: "ZOrderFrame",
      handle: function(o) {
        var a = new ccs.ZOrderFrame(), c = o.value;
        return a.setZOrder(c), a;
      }
    }
  ];
  s.forEach(function(o) {
    r.registerParser(o.name, function(a, c) {
      var l = new ccs.Timeline();
      l.setActionTag(a.actionTag);
      var h = a.frames;
      return h && h.length && h.forEach(function(u) {
        var _ = o.handle(u);
        _.setFrameIndex(u.frameIndex), _.setTween(u.tween), l.addFrame(_);
      }), l;
    });
  }), t.registerParser("action", "0.*", r), t.registerParser("action", "1.*", r);
})(ccs._load, ccs._parser);
(function(t, e) {
  var n = e.extend({
    getNodeJson: function(a) {
      return a.Content.Content.Animation;
    },
    parseNode: function(a, c, l) {
      if (!a)
        return null;
      var h = (this || window), u = new ccs.ActionTimeline();
      u.setDuration(a.Duration), u.setTimeSpeed(a.Speed || 1);
      var _ = a.Timelines;
      return _.forEach(function(d) {
        var f = h.parsers[d.Property], C;
        f ? C = f.call(h, d, c) : cc.log("parser does not exist : %s", d.Property), C && u.addTimeline(C);
      }), u;
    },
    deferred: function(a, c, l, h) {
      for (var u = a.Content.Content.AnimationList, _ = u ? u.length : 0, d = 0; d < _; d++) {
        var f = u[d], C = { name: null, startIndex: null, endIndex: null };
        C.name = f.Name, C.startIndex = f.StartIndex, C.endIndex = f.EndIndex, l.addAnimationInfo(C);
      }
    }
  }), r = new n(), s = [
    {
      name: "Position",
      handle: function(a) {
        var c = new ccs.PositionFrame(), l = a.X, h = a.Y;
        return c.setPosition(cc.p(l, h)), c;
      }
    },
    {
      name: "VisibleForFrame",
      handle: function(a) {
        var c = new ccs.VisibleFrame(), l = a.Value;
        return c.setVisible(l), c;
      }
    },
    {
      name: "Scale",
      handle: function(a) {
        var c = new ccs.ScaleFrame(), l = a.X, h = a.Y;
        return c.setScaleX(l), c.setScaleY(h), c;
      }
    },
    {
      name: "Rotation",
      handle: function(a) {
        var c = new ccs.RotationFrame(), l = a.Rotation || a.Value || 0;
        return c.setRotation(l), c;
      }
    },
    {
      name: "Skew",
      handle: function(a) {
        var c = new ccs.SkewFrame(), l = a.X, h = a.Y;
        return c.setSkewX(l), c.setSkewY(h), c;
      }
    },
    {
      name: "RotationSkew",
      handle: function(a) {
        var c = new ccs.RotationSkewFrame(), l = a.X, h = a.Y;
        return c.setSkewX(l), c.setSkewY(h), c;
      }
    },
    {
      name: "Anchor",
      handle: function(a) {
        var c = new ccs.AnchorPointFrame(), l = a.X, h = a.Y;
        return c.setAnchorPoint(cc.p(l, h)), c;
      }
    },
    {
      name: "AnchorPoint",
      handle: function(a) {
        var c = new ccs.AnchorPointFrame(), l = a.X, h = a.Y;
        return c.setAnchorPoint(cc.p(l, h)), c;
      }
    },
    {
      name: "InnerAction",
      handle: function(a) {
        var c = new ccs.InnerActionFrame(), l = a.InnerActionType, h = a.StartFrame;
        return c.setInnerActionType(l), c.setStartFrameIndex(h), c;
      }
    },
    {
      name: "CColor",
      handle: function(a) {
        var c = new ccs.ColorFrame(), l = a.Color;
        return l || (l = {}), l.R = l.R === void 0 ? 255 : l.R, l.G = l.G === void 0 ? 255 : l.G, l.B = l.B === void 0 ? 255 : l.B, c.setColor(cc.color(l.R, l.G, l.B)), c;
      }
    },
    {
      name: "Alpha",
      handle: function(a) {
        var c = new ccs.AlphaFrame(), l = a.Value;
        return c.setAlpha(l), c;
      }
    },
    {
      name: "FileData",
      handle: function(a, c) {
        var l, h, u, _, d;
        return l = new ccs.TextureFrame(), h = a.TextureFile, h != null && (u = h.Plist, _ = h.Path, d = cc.spriteFrameCache.getSpriteFrame(_), !d && u && (cc.loader.getRes(c + u) ? (cc.spriteFrameCache.addSpriteFrames(c + u), d = cc.spriteFrameCache.getSpriteFrame(_)) : cc.log("%s need to be preloaded", c + u)), d == null && (_ = c + _), l.setTextureName(_)), l;
      }
    },
    {
      name: "FrameEvent",
      handle: function(a) {
        var c = new ccs.EventFrame(), l = a.Value;
        return l != null && c.setEvent(l), c;
      }
    },
    {
      name: "ZOrder",
      handle: function(a) {
        var c = new ccs.ZOrderFrame(), l = a.Value;
        return c.setZOrder(l), c;
      }
    },
    {
      name: "ActionValue",
      handle: function(a) {
        var c = new ccs.InnerActionFrame(), l = a.InnerActionType, h = a.CurrentAniamtionName, u = a.SingleFrameIndex, _ = a.FrameIndex;
        return _ !== void 0 && c.setFrameIndex(_), c.setInnerActionType(ccs.InnerActionType[l]), c.setSingleFrameIndex(u), c.setEnterWithName(!0), h && c.setAnimationName(h), c;
      }
    },
    {
      name: "BlendFunc",
      handle: function(a) {
        var c = new ccs.BlendFuncFrame(), l = a.BlendFunc;
        return l && l.Src !== void 0 && l.Dst !== void 0 && c.setBlendFunc(new cc.BlendFunc(l.Src, l.Dst)), c;
      }
    }
  ], o = /* @__PURE__ */ H(function(a, c) {
    var l = c.Type;
    a.setTweenType(l);
    var h = c.Points, u = [];
    h && (h.forEach(function(_) {
      u.push(_.X), u.push(_.Y);
    }), a.setEasingParams(u));
  }, "loadEasingDataWithFlatBuffers");
  s.forEach(function(a) {
    r.registerParser(a.name, function(c, l) {
      var h = new ccs.Timeline();
      h.setActionTag(c.ActionTag);
      var u = c.Frames;
      return u && u.length && u.forEach(function(_) {
        var d = a.handle(_, l);
        d.setFrameIndex(_.FrameIndex);
        var f = _.Tween != null ? _.Tween : !0;
        d.setTween(f);
        var C = _.EasingData;
        C && o(d, C), h.addFrame(d);
      }), h;
    });
  }), t.registerParser("action", "2.*", r), t.registerParser("action", "*", r);
})(ccs._load, ccs._parser);
(function(t, e) {
  var n = e.extend({
    getNodeJson: function(c) {
      return c;
    },
    parseNode: function(c, l) {
      var h = (this || window).parsers[this.getClass(c)], u = null;
      return h ? u = h.call(this, c, l) : cc.log("Can't find the parser : %s", this.getClass(c)), u;
    },
    deferred: function(c, l, h, u) {
      ccs.triggerManager.parse(c.Triggers || []), ccs.sceneReader && (ccs.sceneReader._node = h);
    },
    setPropertyFromJsonDict: function(c, l) {
      var h = cc.isUndefined(l.x) ? 0 : l.x, u = cc.isUndefined(l.y) ? 0 : l.y;
      c.setPosition(h, u);
      var _ = !!(cc.isUndefined(l.visible) || l.visible);
      c.setVisible(_);
      var d = cc.isUndefined(l.objecttag) ? -1 : l.objecttag;
      c.setTag(d);
      var f = cc.isUndefined(l.zorder) ? 0 : l.zorder;
      c.setLocalZOrder(f);
      var C = cc.isUndefined(l.scalex) ? 1 : l.scalex, m = cc.isUndefined(l.scaley) ? 1 : l.scaley;
      c.setScaleX(C), c.setScaleY(m);
      var g = cc.isUndefined(l.rotation) ? 0 : l.rotation;
      c.setRotation(g);
      var y = l.name || "";
      c.setName(y);
    }
  }), r = new n();
  r.parseChild = function(c, l, h) {
    for (var u = 0; u < l.length; u++) {
      var _, d = l[u];
      d && (_ = (this || window).parseNode(d, h)), _ && c.addChild(_);
    }
  };
  var s = {
    CCSprite: function(c, l, h) {
      var u = new cc.Sprite();
      a(l.fileData, h, function(d, f) {
        if (f === 0)
          u.setTexture(d);
        else if (f === 1) {
          var C = cc.spriteFrameCache.getSpriteFrame(d);
          u.setSpriteFrame(C);
        }
      });
      var _ = new ccs.ComRender(u, "CCSprite");
      return c.addComponent(_), _;
    },
    CCTMXTiledMap: function(c, l, h) {
      var u = null;
      a(l.fileData, h, function(d, f) {
        f === 0 && (u = new cc.TMXTiledMap(d));
      });
      var _ = new ccs.ComRender(u, "CCTMXTiledMap");
      return c.addComponent(_), _;
    },
    CCParticleSystemQuad: function(c, l, h) {
      var u = null;
      a(l.fileData, h, function(d, f) {
        f === 0 ? u = new cc.ParticleSystem(d) : cc.log("unknown resourcetype on CCParticleSystemQuad!"), u.setPosition(0, 0);
      });
      var _ = new ccs.ComRender(u, "CCParticleSystemQuad");
      return c.addComponent(_), _;
    },
    CCArmature: function(c, l, h) {
      var u = null;
      if (a(l.fileData, h, function(f, C) {
        if (C === 0) {
          var m = cc.loader.getRes(f);
          m || cc.log("Please load the resource [%s] first!", f);
          var g = m.armature_data, y = g[0], A = y.name;
          ccs.armatureDataManager.addArmatureFileInfo(f), u = new ccs.Armature(A);
        }
      }), u) {
        var _ = new ccs.ComRender(u, "CCArmature");
        c.addComponent(_);
        var d = l.selectedactionname;
        return d && u.getAnimation() && u.getAnimation().play(d), _;
      }
    },
    CCComAudio: function(c, l, h) {
      var u = null;
      a(l.fileData, h, function(_, d) {
        if (d === 0) {
          u = new ccs.ComAudio(), u.preloadEffect(_);
          var f = l.name;
          f && u.setName(f), c.addComponent(u);
        }
      });
    },
    CCComAttribute: function(c, l, h) {
      var u = null;
      return a(l.fileData, h, function(_, d) {
        d === 0 ? (u = new ccs.ComAttribute(), _ !== "" && u.parse(_), c.addComponent(u)) : cc.log("unknown resourcetype on CCComAttribute!");
      }), u;
    },
    CCBackgroundAudio: function(c, l, h) {
      var u = null;
      a(l.fileData, h, function(_, d) {
        if (d === 0) {
          u = new ccs.ComAudio(), u.preloadBackgroundMusic(_), u.setFile(_);
          var f = !!l.loop;
          u.setLoop(f);
          var C = l.name;
          C && u.setName(C), c.addComponent(u), u.playBackgroundMusic(_, f);
        }
      });
    },
    GUIComponent: function(c, l, h) {
      var u = null;
      a(l.fileData, h, function(d, f) {
        u = ccs._load(d, "ccui");
      });
      var _ = new ccs.ComRender(u, "GUIComponent");
      return c.addComponent(_), _;
    },
    CCScene: function() {
    }
  }, o = {}, a = /* @__PURE__ */ H(function(c, l, h) {
    if (c != null) {
      var u = c.path, _ = c.resourceType, d = c.plist;
      if (!u)
        return;
      d && (cc.loader.getRes(l + d) ? (o[l + d] = !0, cc.spriteFrameCache.addSpriteFrames(l + d)) : o[l + d] || cc.log("%s need to be preloaded", l + d)), h(_ !== 0 ? u : l + u, _);
    }
  }, "loadTexture");
  r.parseComponents = function(c, l, h) {
    !c || !l || l.forEach(function(u) {
      var _ = s[u.classname], d = null;
      _ ? d = _(c, u, h) : cc.log("Can't find the component parser : %s", u.classname);
      var f = u.name;
      d && f && d.setName(f);
    });
  }, r.registerParser("CCNode", function(c, l) {
    var h = new cc.Node();
    this.setPropertyFromJsonDict(h, c), this.parseChild.call(this, h, c.gameobjects, l), this.parseComponents(h, c.components, l);
    var u = c.CanvasSize;
    return u && h.setContentSize(cc.size(u._width, u._height)), h;
  }), t.registerParser("scene", "*", r);
})(ccs._load, ccs._parser);
(function(t, e) {
  var n = {}, r = e.extend({
    getNodeJson: function(c) {
      return c.nodeTree;
    },
    addSpriteFrame: function(c, l, h) {
      if (!(!c || !l || c.length !== l.length))
        for (var u = 0; u < c.length; u++) {
          var _ = h + c[u];
          !cc.loader.getRes(_) && !n[_] ? cc.log("%s need to be preloaded", _) : n[_] = !0, cc.spriteFrameCache.addSpriteFrames(
            _,
            h + l[u]
          );
        }
    },
    pretreatment: function(c, l, h) {
      this.addSpriteFrame(c.textures, c.texturesPng, l);
    }
  }), s = new r();
  s.generalAttributes = function(c, l) {
    var h = l.width != null ? l.width : 0, u = l.height != null ? l.height : 0, _ = l.x != null ? l.x : 0, d = l.y != null ? l.y : 0, f = l.scaleX != null ? l.scaleX : 1, C = l.scaleY != null ? l.scaleY : 1, m = l.rotation != null ? l.rotation : 0, g = l.rotationSkewX != null ? l.rotationSkewX : 0, y = l.rotationSkewY != null ? l.rotationSkewY : 0, A = l.skewX != null ? l.skewX : 0, D = l.skewY != null ? l.skewY : 0, N = l.anchorPointX != null ? l.anchorPointX : 0.5, z = l.anchorPointY != null ? l.anchorPointY : 0.5, M = l.opacity != null ? l.opacity : 255, Z = l.colorR != null ? l.colorR : 255, U = l.colorG != null ? l.colorG : 255, Q = l.colorB != null ? l.colorB : 255, et = l.colorR != null ? l.colorR : 0, rt = l.tag != null ? l.tag : 0, w = l.actionTag != null ? l.actionTag : 0, L = l.visible != null ? l.visible : !0;
    (_ != 0 || d != 0) && c.setPosition(cc.p(_, d)), f != 1 && c.setScaleX(f), C != 1 && c.setScaleY(C), m != 0 && c.setRotation(m), g != 0 && c.setRotationX(g), y != 0 && c.setRotationY(y), A != 0 && c.setSkewX(A), D != 0 && c.setSkewY(D), (N != 0.5 || z != 0.5) && c.setAnchorPoint(cc.p(N, z)), (h != 0 || u != 0) && c.setContentSize(cc.size(h, u)), et != 0 && c.setLocalZOrder(et), L != !0 && c.setVisible(L), M != 255 && c.setOpacity(M), (Z != 255 || U != 255 || Q != 255) && c.setColor(cc.color(Z, U, Q)), c.setTag(rt), c.setUserObject(new ccs.ActionTimelineData(w));
  }, s.parseComponent = function(c, l) {
    if (l)
      for (var h = 0; h < l.length; ++h) {
        var u = l[h], _ = (this || window).loadComponent(u);
        _ && c.addComponent(_);
      }
  }, s.parseChild = function(c, l, h, u) {
    for (var _ = h.children, d = 0; d < _.length; d++) {
      var f = (this || window).parseNode(_[d], u);
      if (f)
        if (l instanceof ccui.PageView)
          f instanceof ccui.Layout && l.addPage(f);
        else if (l instanceof ccui.ListView)
          f instanceof ccui.Widget && l.pushBackCustomItem(f);
        else {
          if (!(l instanceof ccui.Layout) && f instanceof ccui.Widget) {
            if (f.getPositionType() === ccui.Widget.POSITION_PERCENT) {
              var C = f.getPositionPercent(), m = l.getAnchorPoint();
              f.setPositionPercent(cc.p(C.x + m.x, C.y + m.y));
            }
            var g = l.getAnchorPointInPoints();
            f.setPosition(cc.p(f.getPositionX() + g.x, f.getPositionY() + g.y));
          }
          l.addChild(f);
        }
    }
  }, s.initNode = function(c) {
    var l = new cc.Node();
    return this.generalAttributes(l, c), l;
  }, s.initSubGraph = function(c) {
    var l = c.fileName, h;
    return l && l !== "" ? h = (this || window).createNode(l) : h = new ccs.Node(), this.generalAttributes(h, c), h;
  }, s.initSprite = function(c, l) {
    var h = c.fileName, u;
    if (h != null) {
      var _ = cc.spriteFrameCache.getSpriteFrame(h);
      _ ? u = ccs.Sprite.createWithSpriteFrame(_) : (h = l + h, u = new ccs.Sprite(h)), u || (u = new cc.Sprite(), cc.log("filePath is empty. Create a sprite with no texture"));
    } else
      u = new ccs.Sprite();
    this.generalAttributes(u, c);
    var d = c.flipX, f = c.flipY;
    return d != !1 && u.setFlippedX(d), f != !1 && u.setFlippedY(f), u;
  }, s.initParticle = function(c, l) {
    var h = c.plistFile, u = c.tmxFile, _ = new cc.ParticleSystemQuad(h);
    return _.setTotalParticles(u), this.generalAttributes(_, c), _;
  }, s.initTMXTiledMap = function(c, l) {
    var h = c.tmxFile, u = c.tmxString, _ = c.resourcePath, d = null;
    return h && h !== "" ? d = new cc.TMXTiledMap(h) : u && u !== "" && _ && _ !== "" && (d = new cc.TMXTiledMap(u, _)), d;
  };
  var o = t.getParser("ccui")["*"];
  s.initWidget = function(c, l) {
    var h = c.classname, u = o.parsers[h];
    if (!u)
      return cc.log("%s parser is not found", h);
    var _ = u.call(o, c, l);
    if (_) {
      var d = c.rotationSkewX, f = c.rotationSkewY, C = c.skewX, m = c.skewY;
      d != 0 && _.setRotationX(d), f != 0 && _.setRotationY(f), C != 0 && _.setSkewX(C), m != 0 && _.setSkewY(m);
      var g = c.actionTag;
      _.setUserObject(new ccs.ActionTimelineData(g));
    }
    return _;
  };
  var a = [
    { name: "Node", handle: s.initNode },
    { name: "SubGraph", handle: s.initSubGraph },
    { name: "Sprite", handle: s.initSprite },
    { name: "Particle", handle: s.initParticle },
    { name: "TMXTiledMap", handle: s.initTMXTiledMap },
    { name: "Widget", handle: s.initWidget },
    { name: "Panel", handle: s.initWidget },
    { name: "Button", handle: s.initWidget },
    { name: "CheckBox", handle: s.initWidget },
    { name: "ImageView", handle: s.initWidget },
    { name: "LabelAtlas", handle: s.initWidget },
    { name: "LabelBMFont", handle: s.initWidget },
    { name: "Label", handle: s.initWidget },
    { name: "ListView", handle: s.initWidget },
    { name: "LoadingBar", handle: s.initWidget },
    { name: "PageView", handle: s.initWidget },
    { name: "ScrollView", handle: s.initWidget },
    { name: "Slider", handle: s.initWidget },
    { name: "TextField", handle: s.initWidget }
  ];
  a.forEach(function(c) {
    s.registerParser(c.name, function(l, h, u) {
      var _ = c.handle.call(this, l.options);
      return this.parseComponent(_, l.components), this.parseChild(h, _, l, u), _;
    });
  }), t.registerParser("timeline", "0.*", s), t.registerParser("timeline", "1.*", s);
})(ccs._load, ccs._parser);
(function(t, e) {
  var n = e.extend({
    parse: function(m, g, y) {
      var A;
      y !== void 0 ? A = y : A = (this || window)._dirname(m), this.pretreatment(g, A, m);
      var D = (this || window).parseNode(this.getNodeJson(g), A);
      return this.deferred(g, A, D, m), D;
    },
    getNodeJson: function(m) {
      var g = m.Content;
      return g.ObjectData ? g.ObjectData : g.Content.ObjectData;
    },
    getClass: function(m) {
      return m.ctype;
    }
  }), r = new n(), s = /* @__PURE__ */ H(function(m, g) {
    return m === void 0 ? g : m;
  }, "getParam");
  r.generalAttributes = function(m, g) {
    g.Name != null && m.setName(g.Name);
    var y = g.Position;
    y != null && (y.X != null || y.Y != null) && m.setPosition(cc.p(y.X || 0, y.Y || 0));
    var A = g.Scale;
    A != null && (A.ScaleX != null && m.setScaleX(A.ScaleX), A.ScaleY != null && m.setScaleY(A.ScaleY));
    var D = g.RotationSkewX;
    D != null && m.setRotationX(D);
    var N = g.RotationSkewY;
    g.RotationSkewY != null && m.setRotationY(N);
    var z = g.AnchorPoint;
    z != null && (z.ScaleX == null && (z.ScaleX = 0), z.ScaleY == null && (z.ScaleY = 0), (z.ScaleX != 0.5 || z.ScaleY != 0.5) && m.setAnchorPoint(cc.p(z.ScaleX, z.ScaleY))), g.ZOrder != null && m.setLocalZOrder(g.ZOrder);
    var M = s(g.VisibleForFrame, !0);
    m.setVisible(M);
    var Z = g.Size;
    Z && f(m, Z), g.Alpha != null && m.setOpacity(g.Alpha), m.setTag(g.Tag || 0);
    var U = g.ActionTag || 0, Q = new ccs.ComExtensionData(), et = g.UserData;
    et !== void 0 && Q.setCustomProperty(et), Q.setActionTag(U), m.getComponent("ComExtensionData") && m.removeComponent("ComExtensionData"), m.addComponent(Q), m.setCascadeColorEnabled(!0), m.setCascadeOpacityEnabled(!0), a(m, g);
  }, r.parseChild = function(m, g, y) {
    if (!(!m || !g))
      for (var A = 0; A < g.length; A++) {
        var D = (this || window).parseNode(g[A], y);
        if (D)
          if (m instanceof ccui.PageView)
            D instanceof ccui.Layout && m.addPage(D);
          else if (m instanceof ccui.ListView)
            D instanceof ccui.Widget && m.pushBackCustomItem(D);
          else {
            if (!(m instanceof ccui.Layout) && D instanceof ccui.Widget && D.getPositionType() === ccui.Widget.POSITION_PERCENT) {
              var N = D.getPositionPercent(), z = m.getAnchorPoint();
              D.setPositionPercent(cc.p(N.x + z.x, N.y + z.y));
            }
            m.addChild(D);
          }
      }
  }, r.initSingleNode = function(m) {
    var g = new cc.Node();
    this.generalAttributes(g, m);
    var y = m.CColor;
    return y != null && g.setColor(d(y)), g;
  }, r.initSprite = function(m, g) {
    var y = new cc.Sprite();
    _(m.FileData, g, function(z, M) {
      if (M === 0)
        y.setTexture(z);
      else if (M === 1) {
        var Z = cc.spriteFrameCache.getSpriteFrame(z);
        Z && y.setSpriteFrame(Z);
      }
    });
    var A = m.BlendFunc;
    if (m.BlendFunc) {
      var D = cc.BlendFunc.ALPHA_PREMULTIPLIED;
      A.Src !== void 0 && (D.src = A.Src), A.Dst !== void 0 && (D.dst = A.Dst), y.setBlendFunc(D);
    }
    m.FlipX && y.setFlippedX(!0), m.FlipY && y.setFlippedY(!0), this.generalAttributes(y, m);
    var N = m.CColor;
    return N != null && y.setColor(d(N)), y;
  }, r.initParticle = function(m, g) {
    var y, A = (this || window);
    return _(m.FileData, g, function(D, N) {
      cc.loader.getRes(D) || cc.log("%s need to be preloaded", D), y = new cc.ParticleSystem(D), A.generalAttributes(y, m), y.setPositionType(cc.ParticleSystem.TYPE_GROUPED), !cc.sys.isNative && y.setDrawMode(cc.ParticleSystem.TEXTURE_MODE);
      var z = m.BlendFunc;
      if (m.BlendFunc) {
        var M = cc.BlendFunc.ALPHA_PREMULTIPLIED;
        z.Src !== void 0 && (M.src = z.Src), z.Dst !== void 0 && (M.dst = z.Dst), y.setBlendFunc(M);
      }
    }), y;
  }, r.widgetAttributes = function(m, g, y) {
    m.setCascadeColorEnabled(!0), m.setCascadeOpacityEnabled(!0), m.setUnifySizeEnabled(!1), m.ignoreContentAdaptWithSize(!1), !y && f(m, g.Size);
    var A = g.Name;
    A && m.setName(A);
    var D = g.ActionTag || 0;
    m.setActionTag(D);
    var N = new ccs.ComExtensionData(), z = g.UserData;
    z !== void 0 && N.setCustomProperty(z), N.setActionTag(D), m.getComponent("ComExtensionData") && m.removeComponent("ComExtensionData"), m.addComponent(N);
    var M = g.RotationSkewX;
    M && m.setRotationX(M);
    var Z = g.RotationSkewY;
    Z && m.setRotationY(Z);
    var U = g.FlipX;
    U && m.setFlippedX(!0);
    var Q = g.FlipY;
    Q && m.setFlippedY(!0);
    var et = g.zOrder;
    et != null && m.setLocalZOrder(et);
    var rt = s(g.VisibleForFrame, !0);
    m.setVisible(rt);
    var w = g.Alpha;
    w != null && m.setOpacity(w), m.setTag(g.Tag || 0);
    var L = g.TouchEnable || !1;
    m.setTouchEnabled(L);
    var G = g.CallBackType;
    G != null && m.setCallbackType(G);
    var I = g.CallBackName;
    I && m.setCallbackName(I);
    var O = g.Position;
    O != null && m.setPosition(O.X || 0, O.Y || 0);
    var K = g.Scale;
    if (K != null) {
      var $ = s(K.ScaleX, 1), S = s(K.ScaleY, 1);
      m.setScaleX($), m.setScaleY(S);
    }
    var b = g.AnchorPoint;
    b != null && m.setAnchorPoint(b.ScaleX || 0, b.ScaleY || 0);
    var W = g.CColor;
    W != null && m.setColor(d(W)), a(m, g), o(m, g);
  };
  var o = /* @__PURE__ */ H(function(m, g) {
    var y = g.CallBackType, A = g.CallBackName, D = /* @__PURE__ */ H(function(N) {
      typeof m[A] == "function" && m[A](N);
    }, "callBack");
    y === "Click" ? m.addClickEventListener(D) : y === "Touch" ? m.addTouchEventListener(D) : y === "Event" && m.addCCSEventListener(D);
  }, "bindCallback"), a = /* @__PURE__ */ H(function(m, g) {
    var y = ccui.LayoutComponent.bindLayoutComponent(m);
    if (y) {
      var A = g.PositionPercentXEnable || g.PositionPercentXEnabled || !1, D = g.PositionPercentYEnable || g.PositionPercentYEnabled || !1, N = 0, z = 0, M = g.PrePosition;
      M != null && (N = M.X || 0, z = M.Y || 0);
      var Z = g.PercentWidthEnable || g.PercentWidthEnabled || !1, U = g.PercentHeightEnable || g.PercentHeightEnabled || !1, Q = 0, et = 0, rt = g.PreSize;
      M != null && (Q = rt.X || 0, et = rt.Y || 0);
      var w = g.StretchWidthEnable || !1, L = g.StretchHeightEnable || !1, G = g.HorizontalEdge, I = g.VerticalEdge, O = g.LeftMargin || 0, K = g.RightMargin || 0, $ = g.TopMargin || 0, S = g.BottomMargin || 0;
      y.setPositionPercentXEnabled(A), y.setPositionPercentYEnabled(D), y.setPositionPercentX(N), y.setPositionPercentY(z), y.setPercentWidthEnabled(Z), y.setPercentHeightEnabled(U), y.setPercentWidth(Q), y.setPercentHeight(et), y.setPercentWidthEnabled(Z || U), y.setStretchWidthEnabled(w), y.setStretchHeightEnabled(L);
      var b = ccui.LayoutComponent.horizontalEdge.NONE;
      G === "LeftEdge" ? b = ccui.LayoutComponent.horizontalEdge.LEFT : G === "RightEdge" ? b = ccui.LayoutComponent.horizontalEdge.RIGHT : G === "BothEdge" && (b = ccui.LayoutComponent.horizontalEdge.CENTER), y.setHorizontalEdge(b);
      var W = ccui.LayoutComponent.verticalEdge.NONE;
      I === "TopEdge" ? W = ccui.LayoutComponent.verticalEdge.TOP : I === "BottomEdge" ? W = ccui.LayoutComponent.verticalEdge.BOTTOM : I === "BothEdge" && (W = ccui.LayoutComponent.verticalEdge.CENTER), y.setVerticalEdge(W), y.setTopMargin($), y.setBottomMargin(S), y.setLeftMargin(O), y.setRightMargin(K), y.setVerticalEdge(W), y.setTopMargin($), y.setBottomMargin(S), y.setLeftMargin(O), y.setRightMargin(K);
    }
  }, "setLayoutComponent"), c = /* @__PURE__ */ H(function(m, g, y, A) {
    m.getBackGroundColorType() === 2 ? (y = y || {}, A = A || {}, m.setBackGroundColor(d(y), d(A))) : (g = g || {}, m.setBackGroundColor(d(g)));
  }, "setLayoutBackground"), l = /* @__PURE__ */ H(function(m, g) {
    var y = g.ScaleX || 0, A = g.ScaleY || 0;
    m.setBackGroundColorVector(cc.p(y, A));
  }, "setLayoutBackgroundVector");
  r.initPanel = function(m, g) {
    var y = new ccui.Layout();
    this.widgetAttributes(y, m);
    var A = m.ClipAble || !1;
    A != null && y.setClippingEnabled(A);
    var D = s(m.ComboBoxIndex, 0);
    y.setBackGroundColorType(D);
    var N = s(m.BackColorAlpha, 255);
    N != null && y.setBackGroundColorOpacity(N);
    var z = m.Scale9Enable;
    z != null && y.setBackGroundImageScale9Enabled(z);
    var M = s(m.Alpha, 255);
    if (y.setOpacity(M), _(m.FileData, g, function(rt, w) {
      y.setBackGroundImage(rt, w);
    }), z) {
      var Z = m.Scale9OriginX || 0, U = m.Scale9OriginY || 0, Q = m.Scale9Width || 0, et = m.Scale9Height || 0;
      y.setBackGroundImageCapInsets(cc.rect(
        Z,
        U,
        Q,
        et
      )), f(y, m.Size);
    } else
      y.isIgnoreContentAdaptWithSize() || f(y, m.Size);
    return c(y, m.SingleColor, m.FirstColor, m.EndColor), l(y, m.ColorVector), y;
  }, r.initText = function(m, g) {
    var y = new ccui.Text(), A = m.TouchScaleChangeAble;
    A != null && y.setTouchScaleChangeEnabled(A);
    var D = m.LabelText;
    D != null && y.setString(D);
    var N = m.FontSize;
    N != null && y.setFontSize(N);
    var z = m.FontName;
    z != null && y.setFontName(z);
    var M = m.AreaWidth, Z = m.areaHeight;
    M && Z && y.setTextAreaSize(cc.size(M, Z));
    var U = m.HorizontalAlignmentType || "HT_Left";
    switch (U) {
      case "HT_Right":
        U = 2;
        break;
      case "HT_Center":
        U = 1;
        break;
      case "HT_Left":
      default:
        U = 0;
    }
    y.setTextHorizontalAlignment(U);
    var Q = m.VerticalAlignmentType || "VT_Top";
    switch (Q) {
      case "VT_Bottom":
        Q = 2;
        break;
      case "VT_Center":
        Q = 1;
        break;
      case "VT_Top":
      default:
        Q = 0;
    }
    y.setTextVerticalAlignment(Q);
    var et = m.FontResource;
    if (et != null) {
      var rt = et.Path;
      rt != null && (cc.sys.isNative ? z = cc.path.join(cc.loader.resPath, g, rt) : (z = rt.match(/([^\/]+)\.(\S+)/), z = z ? z[1] : ""), y.setFontName(z));
    }
    m.OutlineEnabled && m.OutlineColor && y.enableOutline && y.enableOutline(d(m.OutlineColor), s(m.OutlineSize, 1)), m.ShadowEnabled && m.ShadowColor && y.enableShadow && y.enableShadow(
      d(m.ShadowColor),
      cc.size(s(m.ShadowOffsetX, 2), s(m.ShadowOffsetY, -2)),
      m.ShadowBlurRadius || 0
    );
    var w = m.IsCustomSize;
    w != null && y.ignoreContentAdaptWithSize(!w), y.setUnifySizeEnabled(!1);
    var L = m.CColor;
    return m.CColor = null, y.setTextColor(d(L)), this.widgetAttributes(y, m, y.isIgnoreContentAdaptWithSize()), m.CColor = L, y;
  }, r.initButton = function(m, g) {
    var y = new ccui.Button();
    _(m.NormalFileData, g, function(w, L) {
      y.loadTextureNormal(w, L);
    }), _(m.PressedFileData, g, function(w, L) {
      y.loadTexturePressed(w, L);
    }), _(m.DisabledFileData, g, function(w, L) {
      y.loadTextureDisabled(w, L);
    });
    var A = s(m.Scale9Enable, !1);
    A && y.setScale9Enabled(A);
    var D = m.ButtonText;
    D != null && y.setTitleText(D);
    var N = m.FontSize;
    N != null && y.setTitleFontSize(N);
    var z = m.FontName;
    z != null && y.setTitleFontName(z);
    var M = m.TextColor;
    M != null && y.setTitleColor(d(M));
    var Z = s(m.DisplayState, !0);
    y.setBright(Z), y.setEnabled(Z);
    var U = m.FontResource;
    if (U != null) {
      var Q = U.Path;
      Q != null && (cc.sys.isNative ? z = cc.path.join(cc.loader.resPath, g, Q) : (z = Q.match(/([^\/]+)\.(\S+)/), z = z ? z[1] : ""), y.setTitleFontName(z));
    }
    var et = y.getTitleRenderer();
    if (et && m.ShadowEnabled && m.ShadowColor && et.enableShadow && et.enableShadow(
      d(m.ShadowColor),
      cc.size(s(m.ShadowOffsetX, 2), s(m.ShadowOffsetY, -2)),
      m.ShadowBlurRadius || 0
    ), et && m.OutlineEnabled && m.OutlineColor && et.enableStroke && et.enableStroke(d(m.OutlineColor), s(m.OutlineSize, 1)), this.widgetAttributes(y, m), A) {
      y.setUnifySizeEnabled(!1), y.ignoreContentAdaptWithSize(!1);
      var rt = cc.rect(
        m.Scale9OriginX || 0,
        m.Scale9OriginY || 0,
        m.Scale9Width || 0,
        m.Scale9Height || 0
      );
      y.setCapInsets(rt);
    }
    return f(y, m.Size), y;
  }, r.initCheckBox = function(m, g) {
    var y = new ccui.CheckBox();
    this.widgetAttributes(y, m);
    var A = [
      { name: "NormalBackFileData", handle: y.loadTextureBackGround },
      { name: "PressedBackFileData", handle: y.loadTextureBackGroundSelected },
      { name: "NodeNormalFileData", handle: y.loadTextureFrontCross },
      { name: "DisableBackFileData", handle: y.loadTextureBackGroundDisabled },
      { name: "NodeDisableFileData", handle: y.loadTextureFrontCrossDisabled }
    ];
    A.forEach(function(z) {
      _(m[z.name], g, function(M, Z) {
        z.handle.call(y, M, Z);
      });
    });
    var D = s(m.CheckedState, !1);
    y.setSelected(D);
    var N = s(m.DisplayState, !0);
    return y.setBright(N), y.setEnabled(N), y;
  }, r.initScrollView = function(m, g) {
    var y = new ccui.ScrollView();
    this.widgetAttributes(y, m), _(m.FileData, g, function(G, I) {
      y.setBackGroundImage(G, I);
    });
    var A = m.ClipAble || !1;
    y.setClippingEnabled(A);
    var D = s(m.ComboBoxIndex, 0);
    y.setBackGroundColorType(D);
    var N = m.BackColorAlpha;
    N != null && y.setBackGroundColorOpacity(N);
    var z = m.Scale9Enable;
    if (z) {
      y.setBackGroundImageScale9Enabled(!0);
      var M = m.Scale9OriginX || 0, Z = m.Scale9OriginY || 0, U = m.Scale9Width || 0, Q = m.Scale9Height || 0;
      y.setBackGroundImageCapInsets(cc.rect(
        M,
        Z,
        U,
        Q
      )), f(y, m.Size);
    } else
      y.isIgnoreContentAdaptWithSize() || f(y, m.Size);
    c(y, m.SingleColor, m.FirstColor, m.EndColor), l(y, m.ColorVector);
    var et = m.InnerNodeSize, rt = cc.size(
      et.Width || 0,
      et.Height || 0
    );
    y.setInnerContainerSize(rt);
    var w = 0;
    m.ScrollDirectionType === "Vertical" && (w = 1), m.ScrollDirectionType === "Horizontal" && (w = 2), m.ScrollDirectionType === "Vertical_Horizontal" && (w = 3), y.setDirection(w);
    var L = s(m.IsBounceEnabled, !1);
    return y.setBounceEnabled(L), y;
  }, r.initImageView = function(m, g) {
    var y = new ccui.ImageView();
    _(m.FileData, g, function(Z, U) {
      y.loadTexture(Z, U);
    }), _(m.ImageFileData, g, function(Z, U) {
      y.loadTexture(Z, U);
    });
    var A = m.Scale9Enable;
    if (A) {
      y.setScale9Enabled(!0), y.setUnifySizeEnabled(!1), y.ignoreContentAdaptWithSize(!1);
      var D = m.Scale9OriginX || 0, N = m.Scale9OriginY || 0, z = m.Scale9Width || 0, M = m.Scale9Height || 0;
      y.setCapInsets(cc.rect(
        D,
        N,
        z,
        M
      ));
    } else
      f(y, m.Size);
    return this.widgetAttributes(y, m), y;
  }, r.initLoadingBar = function(m, g) {
    var y = new ccui.LoadingBar();
    this.widgetAttributes(y, m), _(m.ImageFileData, g, function(N, z) {
      y.loadTexture(N, z);
    });
    var A = m.ProgressType === "Right_To_Left" ? 1 : 0;
    y.setDirection(A);
    var D = s(m.ProgressInfo, 80);
    return D != null && y.setPercent(D), y;
  }, r.initSlider = function(m, g) {
    var y = new ccui.Slider(), A = cc.loader;
    this.widgetAttributes(y, m);
    var D = [
      { name: "BackGroundData", handle: y.loadBarTexture },
      { name: "BallNormalData", handle: y.loadSlidBallTextureNormal },
      { name: "BallPressedData", handle: y.loadSlidBallTexturePressed },
      { name: "BallDisabledData", handle: y.loadSlidBallTextureDisabled },
      { name: "ProgressBarData", handle: y.loadProgressBarTexture }
    ];
    D.forEach(function(M) {
      _(m[M.name], g, function(Z, U) {
        U === 0 && !A.getRes(Z) && cc.log("%s need to be preloaded", Z), M.handle.call(y, Z, U);
      });
    });
    var N = m.PercentInfo || 0;
    y.setPercent(N);
    var z = s(m.DisplayState, !0);
    return y.setBright(z), y.setEnabled(z), y;
  }, r.initPageView = function(m, g) {
    var y = new ccui.PageView();
    this.widgetAttributes(y, m), _(m.FileData, g, function(et, rt) {
      y.setBackGroundImage(et, rt);
    });
    var A = m.ClipAble || !1;
    y.setClippingEnabled(A);
    var D = m.Scale9Enable;
    if (D) {
      y.setBackGroundImageScale9Enabled(!0);
      var N = m.Scale9OriginX || 0, z = m.Scale9OriginY || 0, M = m.Scale9Width || 0, Z = m.Scale9Height || 0;
      y.setBackGroundImageCapInsets(cc.rect(
        N,
        z,
        M,
        Z
      ));
    }
    var U = s(m.ComboBoxIndex, 0);
    y.setBackGroundColorType(U), c(y, m.SingleColor, m.FirstColor, m.EndColor), l(y, m.ColorVector);
    var Q = m.BackColorAlpha;
    return Q != null && y.setBackGroundColorOpacity(Q), f(y, m.Size), y;
  }, r.initListView = function(m, g) {
    var y = new ccui.ListView();
    this.widgetAttributes(y, m), _(m.FileData, g, function(O, K) {
      y.setBackGroundImage(O, K);
    });
    var A = m.ClipAble || !1;
    y.setClippingEnabled(A);
    var D = s(m.ComboBoxIndex, 0);
    y.setBackGroundColorType(D);
    var N = s(m.BackColorAlpha, 255), z = m.Scale9Enable;
    if (z) {
      y.setBackGroundImageScale9Enabled(!0);
      var M = m.Scale9OriginX || 0, Z = m.Scale9OriginY || 0, U = m.Scale9Width || 0, Q = m.Scale9Height || 0;
      y.setBackGroundImageCapInsets(cc.rect(
        M,
        Z,
        U,
        Q
      ));
    }
    var et = s(m.DirectionType, ccui.ListView.DIR_HORIZONTAL), rt = s(m.VerticalType, "Align_Left"), w = s(m.HorizontalType, "Align_Top");
    et ? et === "Vertical" && (y.setDirection(ccui.ScrollView.DIR_VERTICAL), w === "" ? y.setGravity(ccui.ListView.GRAVITY_LEFT) : w === "Align_Right" ? y.setGravity(ccui.ListView.GRAVITY_RIGHT) : w === "Align_HorizontalCenter" && y.setGravity(ccui.ListView.GRAVITY_CENTER_HORIZONTAL)) : (y.setDirection(ccui.ScrollView.DIR_HORIZONTAL), rt === "Align_Bottom" ? y.setGravity(ccui.ListView.GRAVITY_BOTTOM) : rt === "Align_VerticalCenter" ? y.setGravity(ccui.ListView.GRAVITY_CENTER_VERTICAL) : y.setGravity(ccui.ListView.GRAVITY_TOP));
    var L = s(m.IsBounceEnabled, !1);
    y.setBounceEnabled(L);
    var G = m.ItemMargin || 0;
    y.setItemsMargin(G);
    var I = m.InnerNodeSize;
    return I != null && y.setInnerContainerSize(cc.size(I.Widget || 0, I.Height || 0)), c(y, m.SingleColor, m.FirstColor, m.EndColor), l(y, m.ColorVector), N != null && y.setBackGroundColorOpacity(N), f(y, m.Size), y;
  }, r.initTextAtlas = function(m, g) {
    var y = new ccui.TextAtlas(), A = m.LabelText, D = m.CharWidth, N = m.CharHeight, z = m.StartChar;
    return _(m.LabelAtlasFileImage_CNB, g, function(M, Z) {
      cc.loader.getRes(M) || cc.log("%s need to be preloaded", M), Z === 0 && y.setProperty(A, M, D, N, z);
    }), this.widgetAttributes(y, m), y.ignoreContentAdaptWithSize(!0), y;
  }, r.initTextBMFont = function(m, g) {
    var y = new ccui.TextBMFont();
    this.widgetAttributes(y, m);
    var A = m.LabelText;
    return y.setString(A), _(m.LabelBMFontFile_CNB, g, function(D, N) {
      cc.loader.getRes(D) || cc.log("%s need to be pre loaded", D), y.setFntFile(D);
    }), y.ignoreContentAdaptWithSize(!0), y;
  }, r.initTextField = function(m, g) {
    var y = new ccui.TextField(), A = m.PasswordEnable;
    if (A) {
      y.setPasswordEnabled(!0);
      var D = m.PasswordStyleText || "*";
      y.setPasswordStyleText(D);
    }
    var N = m.PlaceHolderText;
    N != null && y.setPlaceHolder(N);
    var z = m.FontSize;
    z != null && y.setFontSize(z);
    var M = m.FontName;
    M != null && y.setFontName(M);
    var Z = m.MaxLengthEnable;
    if (Z) {
      y.setMaxLengthEnabled(!0);
      var U = m.MaxLengthText || 0;
      y.setMaxLength(U);
    }
    this.widgetAttributes(y, m);
    var Q = m.LabelText;
    Q != null && y.setString(Q);
    var et = m.FontResource;
    if (et != null) {
      var rt = et.Path;
      rt != null && (cc.sys.isNative ? M = cc.path.join(cc.loader.resPath, g, rt) : (M = rt.match(/([^\/]+)\.(\S+)/), M = M ? M[1] : ""), y.setFontName(M));
    }
    y.setUnifySizeEnabled(!1), y.ignoreContentAdaptWithSize(!1);
    var w = m.CColor;
    return w != null && y.setTextColor(d(w)), y.isIgnoreContentAdaptWithSize() || (f(y, m.Size), cc.sys.isNative && y.getVirtualRenderer().setLineBreakWithoutSpace(!0)), y;
  }, r.initSimpleAudio = function(m, g) {
    var y = new ccs.ComAudio(), A = m.Loop || !1;
    y.setLoop(A), _(m.FileData, g, function(D, N) {
      y.setFile(D);
    });
  }, r.initGameMap = function(m, g) {
    var y = null;
    return _(m.FileData, g, function(A, D) {
      D === 0 && (y = new cc.TMXTiledMap(A)), r.generalAttributes(y, m);
    }), y;
  }, r.initProjectNode = function(m, g) {
    var y = m.FileData;
    if (y != null && y.Path) {
      var A = g + y.Path;
      if (cc.loader.getRes(A)) {
        var D = ccs.load(A, g);
        if (r.generalAttributes(D.node, m), D.action && D.node) {
          D.action.tag = D.node.tag;
          var N = m.InnerActionSpeed;
          N !== void 0 && D.action.setTimeSpeed(N), D.node.runAction(D.action), D.action.gotoFrameAndPause(0);
        }
        return D.node;
      } else
        cc.log("%s need to be preloaded", A);
    }
  };
  var h = /* @__PURE__ */ H(function(m) {
    if (!m)
      return "";
    var g = m.match(/([^\/]+)\.[^\/]+$/);
    return g && g[1] ? g[1] : "";
  }, "getFileName");
  r.initArmature = function(m, g) {
    var y = new ccs.Armature(), A = m.IsLoop, D = m.IsAutoPlay, N = m.CurrentAnimationName;
    return _(m.FileData, g, function(z, M) {
      var Z, U, Q = cc.loader.getRes(z);
      Q ? (Z = Q.config_file_path, U = Q.config_png_path, Z.forEach(function(et, rt) {
        U[rt] && cc.spriteFrameCache.addSpriteFrames(et, U[rt]);
      })) : cc.log("%s need to be preloaded", z), ccs.armatureDataManager.addArmatureFileInfo(z), y.init(h(z)), D ? y.getAnimation().play(N, -1, A) : (y.getAnimation().play(N), y.getAnimation().gotoAndPause(0));
    }), delete m.AnchorPoint, delete m.Size, r.generalAttributes(y, m), y.setColor(d(m.CColor)), y;
  }, r.initBoneNode = function(m, g) {
    var y = new ccs.BoneNode(), A = m.Length;
    A !== void 0 && y.setDebugDrawLength(A);
    var D = m.BlendFunc;
    D && D.Src !== void 0 && D.Dst !== void 0 && y.setBlendFunc(new cc.BlendFunc(D.Src, D.Dst)), r.generalAttributes(y, m);
    var N = m.CColor;
    return N && (N.R !== void 0 || N.G !== void 0 || N.B !== void 0) && y.setColor(d(N)), y;
  }, r.initSkeletonNode = function(m) {
    var g = new ccs.SkeletonNode();
    r.generalAttributes(g, m);
    var y = m.CColor;
    return y && (y.R !== void 0 || y.G !== void 0 || y.B !== void 0) && g.setColor(d(y)), g;
  };
  var u = {}, _ = /* @__PURE__ */ H(function(m, g, y) {
    if (m != null) {
      var A = m.Path, D;
      m.Type === "Default" || m.Type === "Normal" ? D = 0 : D = 1;
      var N = m.Plist;
      N && (cc.loader.getRes(g + N) ? (u[g + N] = !0, cc.spriteFrameCache.addSpriteFrames(g + N)) : !u[g + N] && !cc.spriteFrameCache.getSpriteFrame(A) && cc.log("%s need to be preloaded", g + N)), D !== 0 ? cc.spriteFrameCache.getSpriteFrame(A) ? y(A, D) : cc.log("failed to get spriteFrame: %s", A) : y(g + A, D);
    }
  }, "loadTexture"), d = /* @__PURE__ */ H(function(m) {
    if (m) {
      var g = m.R != null ? m.R : 255, y = m.G != null ? m.G : 255, A = m.B != null ? m.B : 255, D = m.A != null ? m.A : 255;
      return cc.color(g, y, A, D);
    }
  }, "getColor"), f = /* @__PURE__ */ H(function(m, g) {
    var y = g.X || 0, A = g.Y || 0;
    g && m.setContentSize(cc.size(y, A));
  }, "setContentSize"), C = [
    { name: "SingleNodeObjectData", handle: r.initSingleNode },
    { name: "NodeObjectData", handle: r.initSingleNode },
    { name: "LayerObjectData", handle: r.initSingleNode },
    { name: "GameNodeObjectData", handle: r.initSingleNode },
    { name: "GameLayerObjectData", handle: r.initSingleNode },
    { name: "SpriteObjectData", handle: r.initSprite },
    { name: "ParticleObjectData", handle: r.initParticle },
    { name: "PanelObjectData", handle: r.initPanel },
    { name: "TextObjectData", handle: r.initText },
    { name: "ButtonObjectData", handle: r.initButton },
    { name: "CheckBoxObjectData", handle: r.initCheckBox },
    { name: "ScrollViewObjectData", handle: r.initScrollView },
    { name: "ImageViewObjectData", handle: r.initImageView },
    { name: "LoadingBarObjectData", handle: r.initLoadingBar },
    { name: "SliderObjectData", handle: r.initSlider },
    { name: "PageViewObjectData", handle: r.initPageView },
    { name: "ListViewObjectData", handle: r.initListView },
    { name: "TextAtlasObjectData", handle: r.initTextAtlas },
    { name: "TextBMFontObjectData", handle: r.initTextBMFont },
    { name: "TextFieldObjectData", handle: r.initTextField },
    { name: "SimpleAudioObjectData", handle: r.initSimpleAudio },
    { name: "GameMapObjectData", handle: r.initGameMap },
    { name: "ProjectNodeObjectData", handle: r.initProjectNode },
    { name: "ArmatureNodeObjectData", handle: r.initArmature },
    { name: "BoneNodeObjectData", handle: r.initBoneNode },
    { name: "SkeletonNodeObjectData", handle: r.initSkeletonNode }
  ];
  C.forEach(function(m) {
    r.registerParser(m.name, function(g, y) {
      var A = m.handle.call(this, g, y);
      return this.parseChild(A, g.Children, y), A;
    });
  }), t.registerParser("timeline", "2.*", r), t.registerParser("timeline", "*", r);
})(ccs._load, ccs._parser);
(function(t, e) {
  var n = e.extend({
    addSpriteFrame: function(c, l) {
      if (c)
        for (var h = 0; h < c.length; h++)
          cc.spriteFrameCache.addSpriteFrames(l + c[h]);
    },
    pretreatment: function(c, l) {
      this.addSpriteFrame(c.textures, l);
    },
    deferred: function(c, l, h, u) {
      h && (ccs.actionManager.initWithDictionary(u, c.animation, h), h.setContentSize(cc.size(c.designWidth, c.designHeight)));
    }
  }), r = new n();
  r.generalAttributes = function(c, l) {
    var h = l.ignoreSize;
    h != null && c.ignoreContentAdaptWithSize(h), l.sizeType && c.setSizeType(l.sizeType), l.positionType && c.setPositionType(l.positionType), c.setSizePercent(cc.p(l.sizePercentX, l.sizePercentY)), c.setPositionPercent(cc.p(l.positionPercentX, l.positionPercentY));
    var u = 0, _ = 0, d = l.adaptScreen;
    if (d) {
      var f = cc.director.getWinSize();
      u = f.width, _ = f.height;
    } else
      u = l.width, _ = l.height;
    c.setContentSize(u, _), c.setTag(l.tag), c.setActionTag(l.actiontag), c.setTouchEnabled(l.touchAble);
    var C = l.name, m = C || "default";
    c.setName(m);
    var g = l.x, y = l.y;
    c.setPosition(g, y);
    var A = l.scaleX != null ? l.scaleX : 1;
    c.setScaleX(A);
    var D = l.scaleY != null ? l.scaleY : 1;
    c.setScaleY(D);
    var N = l.rotation || 0;
    c.setRotation(N);
    var z = l.visible || !1;
    z != null && c.setVisible(z), c.setLocalZOrder(l.ZOrder);
    var M = l.layoutParameter;
    if (M != null) {
      var Z = l.layoutParameter, U = Z.type, Q = null;
      switch (U) {
        case 0:
          break;
        case 1:
          Q = new ccui.LinearLayoutParameter();
          var et = Z.gravity;
          Q.setGravity(et);
          break;
        case 2:
          Q = new ccui.RelativeLayoutParameter();
          var rt = Q, w = Z.relativeName;
          rt.setRelativeName(w);
          var L = Z.relativeToName;
          rt.setRelativeToWidgetName(L);
          var G = Z.align;
          rt.setAlign(G);
          break;
      }
      if (Q != null) {
        var I = Z.marginLeft || 0, O = Z.marginTop || 0, K = Z.marginRight || 0, $ = Z.marginDown || 0;
        Q.setMargin(I, O, K, $), c.setLayoutParameter(Q);
      }
    }
  }, r.colorAttributes = function(c, l) {
    var h = l.opacity;
    h != null && c.setOpacity(h);
    var u = l.colorR, _ = l.colorG, d = l.colorB;
    c.setColor(cc.color(u == null ? 255 : u, _ == null ? 255 : _, d == null ? 255 : d)), c.setFlippedX(l.flipX), c.setFlippedY(l.flipY);
  }, r.anchorPointAttributes = function(c, l) {
    var h = l.anchorPointX, u;
    h != null ? u = l.anchorPointX : u = c.getAnchorPoint().x;
    var _ = l.anchorPointY, d;
    _ != null ? d = l.anchorPointY : d = c.getAnchorPoint().y, (h != null || _ != null) && c.setAnchorPoint(cc.p(u, d));
  }, r.parseChild = function(c, l, h) {
    for (var u = l.children, _ = 0; _ < u.length; _++) {
      var d = (this || window).parseNode(u[_], h);
      if (d)
        if (c instanceof ccui.PageView)
          c.addPage(d);
        else if (c instanceof ccui.ListView)
          c.pushBackCustomItem(d);
        else {
          if (!(c instanceof ccui.Layout)) {
            if (d.getPositionType() === ccui.Widget.POSITION_PERCENT) {
              var f = d.getPositionPercent(), C = c.getAnchorPoint();
              d.setPositionPercent(cc.p(f.x + C.x, f.y + C.y));
            }
            var m = c.getAnchorPointInPoints();
            d.setPosition(cc.p(d.getPositionX() + m.x, d.getPositionY() + m.y));
          }
          c.addChild(d);
        }
    }
  };
  var s = /* @__PURE__ */ H(function(c, l, h, u) {
    h && u(l === 0 ? c + h : h, l);
  }, "getPath");
  r.LayoutAttributes = function(c, l, h) {
    var u = 0, _ = 0, d = l.adaptScreen;
    if (d) {
      var f = cc.director.getWinSize();
      u = f.width, _ = f.height;
    } else
      u = l.width, _ = l.height;
    c.setSize(cc.size(u, _)), c.setClippingEnabled(l.clipAble);
    var C = l.backGroundScale9Enable;
    c.setBackGroundImageScale9Enabled(C);
    var m = l.bgColorR, g = l.bgColorG, y = l.bgColorB, A = l.bgStartColorR, D = l.bgStartColorG, N = l.bgStartColorB, z = l.bgEndColorR, M = l.bgEndColorG, Z = l.bgEndColorB, U = l.vectorX, Q = l.vectorY;
    c.setBackGroundColorVector(cc.p(U, Q));
    var et = l.bgColorOpacity, rt = l.colorType;
    c.setBackGroundColorType(rt), c.setBackGroundColor(cc.color(A, D, N), cc.color(z, M, Z)), c.setBackGroundColor(cc.color(m, g, y)), c.setBackGroundColorOpacity(et);
    var w = l.backGroundImageData;
    if (w && s(h, w.resourceType, w.path, function(K, $) {
      c.setBackGroundImage(K, $);
    }), C) {
      var L = l.capInsetsX, G = l.capInsetsY, I = l.capInsetsWidth, O = l.capInsetsHeight;
      c.setBackGroundImageCapInsets(cc.rect(L, G, I, O));
    }
    l.layoutType && c.setLayoutType(l.layoutType);
  }, r.ButtonAttributes = function(c, l, h) {
    var u = c, _ = l.scale9Enable;
    u.setScale9Enabled(_);
    var d = l.normalData;
    s(h, d.resourceType, d.path, function(G, I) {
      u.loadTextureNormal(G, I);
    });
    var f = l.pressedData;
    s(h, f.resourceType, f.path, function(G, I) {
      u.loadTexturePressed(G, I);
    });
    var C = l.disabledData;
    if (s(h, C.resourceType, C.path, function(G, I) {
      u.loadTextureDisabled(G, I);
    }), _) {
      var m = l.capInsetsX, g = l.capInsetsY, y = l.capInsetsWidth, A = l.capInsetsHeight;
      u.setCapInsets(cc.rect(m, g, y, A));
      var D = l.scale9Width, N = l.scale9Height;
      D != null && N != null && u.setSize(cc.size(D, N));
    }
    var z = l.text;
    z != null && u.setTitleText(z);
    var M = l.textColorR, Z = l.textColorG, U = l.textColorB, Q = M !== null ? l.textColorR : 255, et = Z !== null ? l.textColorG : 255, rt = U !== null ? l.textColorB : 255;
    u.setTitleColor(cc.color(Q, et, rt));
    var w = l.fontSize;
    w != null && u.setTitleFontSize(l.fontSize);
    var L = l.fontName;
    L && u.setTitleFontName(l.fontName);
  }, r.CheckBoxAttributes = function(c, l, h) {
    var u = l.backGroundBoxData;
    s(h, u.resourceType, u.path, function(m, g) {
      c.loadTextureBackGround(m, g);
    });
    var _ = l.backGroundBoxSelectedData;
    s(
      h,
      _.resourceType || u.resourceType,
      _.path || u.path,
      function(m, g) {
        c.loadTextureBackGroundSelected(m, g);
      }
    );
    var d = l.frontCrossData;
    s(h, d.resourceType, d.path, function(m, g) {
      c.loadTextureFrontCross(m, g);
    });
    var f = l.backGroundBoxDisabledData;
    s(
      h,
      f.resourceType || d.resourceType,
      f.path || d.path,
      function(m, g) {
        c.loadTextureBackGroundDisabled(m, g);
      }
    );
    var C = l.frontCrossDisabledData;
    s(h, C.resourceType, C.path, function(m, g) {
      c.loadTextureFrontCrossDisabled(m, g);
    }), l.selectedState && c.setSelected(l.selectedState);
  }, r.ImageViewAttributes = function(c, l, h) {
    var u = l.fileNameData;
    s(h, u.resourceType, u.path, function(z, M) {
      c.loadTexture(z, M);
    });
    var _ = l.scale9Enable, d = !1;
    if (_ && (d = l.scale9Enable), c.setScale9Enabled(d), d) {
      var f = l.scale9Width, C = l.scale9Height;
      if (f && C) {
        var m = l.scale9Width, g = l.scale9Height;
        c.setSize(cc.size(m, g));
      }
      var y = l.capInsetsX, A = l.capInsetsY, D = l.capInsetsWidth, N = l.capInsetsHeight;
      c.setCapInsets(cc.rect(y, A, D, N));
    }
  }, r.TextAtlasAttributes = function(c, l, h) {
    var u = l.stringValue, _ = l.charMapFileData, d = l.itemWidth, f = l.itemHeight, C = l.startCharMap;
    if (u != null && _ && d != null && f != null && C != null) {
      var m = l.charMapFileData, g = m.resourceType;
      switch (g) {
        case 0:
          var y = h, A = m.path, D = y + A;
          c.setProperty(u, D, d, f, C);
          break;
        case 1:
          cc.log("Wrong res type of LabelAtlas!");
          break;
      }
    }
  }, r.TextBMFontAttributes = function(c, l, h) {
    var u = l.fileNameData, _ = u.resourceType;
    switch (_) {
      case 0:
        var d = h, f = u.path, C = d + f;
        c.setFntFile(C);
        break;
      case 1:
        cc.log("Wrong res type of LabelAtlas!");
        break;
    }
    var m = l.text;
    c.setString(m);
  };
  var o = /\.ttf$/;
  r.TextAttributes = function(c, l, h) {
    var u = l.touchScaleEnable;
    c.setTouchScaleChangeEnabled(u);
    var _ = l.text;
    c.setString(_);
    var d = l.fontSize;
    d != null && c.setFontSize(l.fontSize);
    var f = l.fontName;
    f != null && (cc.sys.isNative ? o.test(f) ? c.setFontName(cc.path.join(cc.loader.resPath, h, f)) : c.setFontName(f) : c.setFontName(f.replace(o, "")));
    var C = l.areaWidth, m = l.areaHeight;
    if (C != null && m != null) {
      var g = cc.size(l.areaWidth, l.areaHeight);
      c.setTextAreaSize(g);
    }
    var y = l.hAlignment;
    y != null && c.setTextHorizontalAlignment(l.hAlignment);
    var A = l.vAlignment;
    A != null && c.setTextVerticalAlignment(l.vAlignment);
  }, r.ListViewAttributes = function(c, l, h) {
    r.ScrollViewAttributes(c, l, h);
    var u = l.direction;
    c.setDirection(u);
    var _ = l.gravity;
    c.setGravity(_);
    var d = l.itemMargin;
    c.setItemsMargin(d);
  }, r.LoadingBarAttributes = function(c, l, h) {
    var u = l.textureData;
    s(h, u.resourceType, u.path, function(A, D) {
      c.loadTexture(A, D);
    });
    var _ = l.scale9Enable;
    if (c.setScale9Enabled(_), _) {
      var d = l.capInsetsX, f = l.capInsetsY, C = l.capInsetsWidth, m = l.capInsetsHeight;
      c.setCapInsets(cc.rect(d, f, C, m));
      var g = l.width, y = l.height;
      c.setSize(cc.size(g, y));
    }
    c.setDirection(l.direction), c.setPercent(l.percent);
  }, r.PageViewAttributes = r.LayoutAttributes, r.ScrollViewAttributes = function(c, l, h) {
    r.LayoutAttributes(c, l, h);
    var u = l.innerWidth != null ? l.innerWidth : 200, _ = l.innerHeight != null ? l.innerHeight : 200;
    c.setInnerContainerSize(cc.size(u, _));
    var d = l.direction != null ? l.direction : 1;
    c.setDirection(d), c.setBounceEnabled(l.bounceEnable);
  }, r.SliderAttributes = function(c, l, h) {
    var u = c, _ = l.scale9Enable;
    u.setScale9Enabled(_);
    var d = l.barFileName, f = l.length, C = l.barFileNameData, m = C.resourceType, g = C.path;
    d != null ? _ && (s(h, m, g, function(z, M) {
      u.loadBarTexture(z, M);
    }), u.setSize(cc.size(f, u.getContentSize().height))) : s(h, m, g, function(z, M) {
      u.loadBarTexture(z, M);
    });
    var y = l.ballNormalData;
    s(h, y.resourceType, y.path, function(z, M) {
      u.loadSlidBallTextureNormal(z, M);
    });
    var A = l.ballPressedData;
    s(
      h,
      A.resourceType || y.resourceType,
      A.path || y.path,
      function(z, M) {
        u.loadSlidBallTexturePressed(z, M);
      }
    );
    var D = l.ballDisabledData;
    s(h, D.resourceType, D.path, function(z, M) {
      u.loadSlidBallTextureDisabled(z, M);
    });
    var N = l.progressBarData;
    s(h, N.resourceType, N.path, function(z, M) {
      u.loadProgressBarTexture(z, M);
    });
  }, r.TextFieldAttributes = function(c, l, h) {
    var u = l.placeHolder;
    u && c.setPlaceHolder(u), c.setString(l.text || "");
    var _ = l.fontSize;
    _ && c.setFontSize(_);
    var d = l.fontName;
    d != null && (cc.sys.isNative ? o.test(d) ? c.setFontName(cc.path.join(cc.loader.resPath, h, d)) : c.setFontName(d) : c.setFontName(d.replace(o, "")));
    var f = l.touchSizeWidth, C = l.touchSizeHeight;
    f != null && C != null && c.setTouchSize(f, C), l.width, l.height;
    var m = l.maxLengthEnable;
    if (c.setMaxLengthEnabled(m), m) {
      var g = l.maxLength;
      c.setMaxLength(g);
    }
    var y = l.passwordEnable;
    c.setPasswordEnabled(y), y && c.setPasswordStyleText(l.passwordStyleText);
    var A = l.areaWidth, D = l.areaHeight;
    if (A && D) {
      var N = cc.size(A, D);
      c.setTextAreaSize(N);
    }
    var z = l.hAlignment;
    z && c.setTextHorizontalAlignment(z);
    var M = l.vAlignment;
    M && c.setTextVerticalAlignment(M);
    var Z = l.colorR, U = l.colorG, Q = l.colorB;
    Z !== void 0 && U !== void 0 && Q !== void 0 && c.setTextColor(cc.color(Z, U, Q));
  };
  var a = [
    { name: "Panel", object: ccui.Layout, handle: r.LayoutAttributes },
    { name: "Button", object: ccui.Button, handle: r.ButtonAttributes },
    { name: "CheckBox", object: ccui.CheckBox, handle: r.CheckBoxAttributes },
    { name: "ImageView", object: ccui.ImageView, handle: r.ImageViewAttributes },
    { name: "LabelAtlas", object: ccui.TextAtlas, handle: r.TextAtlasAttributes },
    { name: "LabelBMFont", object: ccui.TextBMFont, handle: r.TextBMFontAttributes },
    { name: "Label", object: ccui.Text, handle: r.TextAttributes },
    { name: "ListView", object: ccui.ListView, handle: r.ListViewAttributes },
    { name: "LoadingBar", object: ccui.LoadingBar, handle: r.LoadingBarAttributes },
    { name: "PageView", object: ccui.PageView, handle: r.PageViewAttributes },
    { name: "ScrollView", object: ccui.ScrollView, handle: r.ScrollViewAttributes },
    { name: "Slider", object: ccui.Slider, handle: r.SliderAttributes },
    { name: "TextField", object: ccui.TextField, handle: r.TextFieldAttributes }
  ];
  a.forEach(function(c) {
    r.registerParser(c.name, function(l, h) {
      var u = new c.object(), _ = l.options;
      return r.generalAttributes(u, _), c.handle(u, _, h), r.colorAttributes(u, _), r.anchorPointAttributes(u, _), r.parseChild.call(this, u, l, h), u;
    });
  }), t.registerParser("ccui", "*", r);
})(ccs._load, ccs._parser);
(function() {
  ccs.uiReader = {
    _fileDesignSizes: {},
    widgetFromJsonFile: function(e) {
      var n = cc.loader.getRes(e);
      n && (this._fileDesignSizes[e] = cc.size(n.designWidth || 0, n.designHeight || 0));
      var r = n.Version || n.version, s = ccs.uiReader.getVersionInteger(r);
      return !r || s >= 1700 ? (cc.warn("Not supported file types, Please try use the ccs.load"), null) : ccs._load(e, "ccui");
    },
    registerTypeAndCallBack: function(e, n, r, s) {
      var o = ccs._load.getParser("ccui")["*"], a = s.bind(r);
      o.registerParser(e, function(c, l) {
        var h = new n(), u = c.options;
        r.setPropsFromJsonDictionary && r.setPropsFromJsonDictionary(h, u), this.generalAttributes(h, u);
        var _ = u.customProperty;
        return _ ? _ = JSON.parse(_) : _ = {}, a(e, h, _), this.colorAttributes(h, u), this.anchorPointAttributes(h, u), this.parseChild.call(this, h, c, l), h;
      });
    },
    getVersionInteger: function(e) {
      if (!e || typeof e != "string")
        return 0;
      var n = e.split(".");
      if (n.length !== 4)
        return 0;
      var r = 0;
      return n.forEach(function(s, o) {
        r += s * Math.pow(10, 3 - o);
      }), r;
    },
    storeFileDesignSize: function(e, n) {
      this._fileDesignSizes[e] = n;
    },
    getFileDesignSize: function(e) {
      return this._fileDesignSizes[e];
    },
    getFilePath: function() {
      return this._filePath;
    },
    setFilePath: function(e) {
      this._filePath = e;
    },
    getParseObjectMap: function() {
      return ccs._load.getParser("ccui")["*"].parsers;
    },
    getParseCallBackMap: function() {
      return ccs._load.getParser("ccui")["*"].parsers;
    },
    clear: function() {
    }
  };
  var t = ccs._load.getParser("ccui")["*"];
  ccs.imageViewReader = { setPropsFromJsonDictionary: t.ImageViewAttributes }, ccs.buttonReader = { setPropsFromJsonDictionary: t.ButtonAttributes }, ccs.checkBoxReader = { setPropsFromJsonDictionary: t.CheckBoxAttributes }, ccs.labelAtlasReader = { setPropsFromJsonDictionary: t.TextAtlasAttributes }, ccs.labelBMFontReader = { setPropsFromJsonDictionary: t.TextBMFontAttributes }, ccs.labelReader = { setPropsFromJsonDictionary: t.TextAttributes }, ccs.layoutReader = { setPropsFromJsonDictionary: t.LayoutAttributes }, ccs.listViewReader = { setPropsFromJsonDictionary: t.ListViewAttributes }, ccs.loadingBarReader = { setPropsFromJsonDictionary: t.LoadingBarAttributes }, ccs.pageViewReader = { setPropsFromJsonDictionary: t.PageViewAttributes }, ccs.scrollViewReader = { setPropsFromJsonDictionary: t.ScrollViewAttributes }, ccs.sliderReader = { setPropsFromJsonDictionary: t.SliderAttributes }, ccs.textFieldReader = { setPropsFromJsonDictionary: t.TextFieldAttributes };
})();
(function() {
  ccs.sceneReader = {
    _node: null,
    createNodeWithSceneFile: function(t) {
      var e = ccs._load(t, "scene");
      return this._node = e, e;
    },
    getNodeByTag: function(t) {
      return this._node == null ? null : this._node.getTag() === t ? this._node : this._nodeByTag(this._node, t);
    },
    _nodeByTag: function(t, e) {
      if (t == null)
        return null;
      for (var n = null, r = t.getChildren(), s = 0; s < r.length; s++) {
        var o = r[s];
        if (o && o.getTag() === e) {
          n = o;
          break;
        } else if (n = (this || window)._nodeByTag(o, e), n)
          break;
      }
      return n;
    },
    version: function() {
      return "*";
    },
    setTarget: function() {
    },
    clear: function() {
      ccs.triggerManager.removeAll(), cc.audioEngine.end();
    }
  };
})();
(function() {
  ccs.Armature.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._parentCmd = null, this._realAnchorPointInPoints = new cc.Point(0, 0);
  };
  var t = ccs.Armature.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  cc.inject(ccs.Armature.RenderCmd, t), t.constructor = ccs.Armature.WebGLRenderCmd, t.uploadData = function(e, n, r) {
    for (var s = (this || window)._node, o, a = (this || window)._parentCmd || this, c = s._children, l = cc.BlendFunc.ALPHA_PREMULTIPLIED, h = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, u = 0, _ = c.length; u < _; u++) {
      var d = c[u], f = d._renderCmd;
      if (d && d.getDisplayRenderNode) {
        var C = d.getDisplayRenderNode();
        if (C === null)
          continue;
        switch (o = C._renderCmd, d.getDisplayRenderNodeType()) {
          case ccs.DISPLAY_TYPE_SPRITE:
            if (C instanceof ccs.Skin) {
              C.setShaderProgram(this._shaderProgram), this._updateColorAndOpacity(o, d), o.transform(a);
              var m = d.getBlendFunc();
              if (m.src !== l.src || m.dst !== l.dst)
                C.setBlendFunc(d.getBlendFunc());
              else {
                var g = C.getTexture();
                s._blendFunc.src === l.src && s._blendFunc.dst === l.dst && g && !g.hasPremultipliedAlpha() ? C.setBlendFunc(h) : C.setBlendFunc(s._blendFunc);
              }
              cc.renderer._uploadBufferData(o);
            }
            break;
          case ccs.DISPLAY_TYPE_ARMATURE:
            C.setShaderProgram(this._shaderProgram), o._parentCmd = (this || window);
          default:
            f._syncStatus(a), o._syncStatus(f), o.uploadData ? cc.renderer._uploadBufferData(o) : o.rendering && (cc.renderer._batchRendering(), o.rendering(cc._renderContext));
            break;
        }
      } else
        d instanceof cc.Node && (d.setShaderProgram(this._shaderProgram), f._syncStatus(a), f.uploadData ? cc.renderer._uploadBufferData(f) : f.rendering && (cc.renderer._batchRendering(), f.rendering(cc._renderContext)));
    }
    return this._parentCmd = null, 0;
  }, t.initShaderCache = function() {
    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_SPRITE_POSITION_TEXTURECOLOR);
  }, t.setShaderProgram = function(e) {
    this._shaderProgram = e;
  }, t._updateColorAndOpacity = function(e, n) {
    var r = n._renderCmd._displayedColor, s = n._renderCmd._displayedOpacity, o = cc.Node._dirtyFlags, a = e._dirtyFlag, c = a & o.colorDirty, l = a & o.opacityDirty;
    c && e._updateDisplayColor(r), l && e._updateDisplayOpacity(s), (c || l) && e._updateColor();
  }, t.visit = function(e) {
    var n = (this || window)._node;
    if (n._visible) {
      e = e || this.getParentRenderCmd(), e && (this._curLevel = e._curLevel + 1), this._syncStatus(e), n.sortAllChildren();
      var r = cc.renderer, s = n._children, o, a, c = s.length;
      for (isNaN(n._customZ) && (n._vertexZ = r.assignedZ, r.assignedZ += r.assignedZStep), a = 0; a < c && (o = s[a], o._localZOrder < 0); a++)
        isNaN(o._customZ) && (o._vertexZ = r.assignedZ, r.assignedZ += r.assignedZStep);
      for (r.pushRenderCommand(this); a < c; a++)
        o = s[a], isNaN(o._customZ) && (o._vertexZ = r.assignedZ, r.assignedZ += r.assignedZStep);
      this._dirtyFlag = 0;
    }
  };
})();
cc.pool = {
  _pool: {},
  _releaseCB: function() {
    this.release();
  },
  _autoRelease: function(t) {
    var e = t._running === void 0 ? !1 : !t._running;
    cc.director.getScheduler().schedule(this._releaseCB, t, 0, 0, 0, e);
  },
  putInPool: function(t) {
    var e = t.constructor.prototype.__pid;
    if (!e) {
      var n = { writable: !0, enumerable: !1, configurable: !0 };
      n.value = ClassManager.getNewID(), Object.defineProperty(t.constructor.prototype, "__pid", n);
    }
    this._pool[e] || (this._pool[e] = []), t.retain && t.retain(), t.unuse && t.unuse(), this._pool[e].push(t);
  },
  hasObject: function(t) {
    var e = t.prototype.__pid, n = (this || window)._pool[e];
    return !(!n || n.length === 0);
  },
  removeObject: function(t) {
    var e = t.constructor.prototype.__pid;
    if (e) {
      var n = (this || window)._pool[e];
      if (n)
        for (var r = 0; r < n.length; r++)
          t === n[r] && (t.release && t.release(), n.splice(r, 1));
    }
  },
  getFromPool: function(t) {
    if (this.hasObject(t)) {
      var e = t.prototype.__pid, n = (this || window)._pool[e], r = Array.prototype.slice.call(arguments);
      r.shift();
      var s = n.pop();
      return s.reuse && s.reuse.apply(s, r), cc.sys.isNative && s.release && this._autoRelease(s), s;
    }
  },
  drainAllPools: function() {
    for (var t in this._pool)
      for (var e = 0; e < this._pool[t].length; e++) {
        var n = (this || window)._pool[t][e];
        n.release && n.release();
      }
    this._pool = {};
  }
};
(function() {
  if (cc !== void 0) {
    var PluginManager = /* @__PURE__ */ H(function() {
    }, "PluginManager");
    PluginManager.prototype = {
      constructor: PluginManager,
      getInstance: function() {
        return (this || window)
      },
      loadPlugin: function(t) {
      },
      unloadPlugin: function(t) {
      }
    };
    var PluginAssembly = /* @__PURE__ */ H(function() {
    }, "PluginAssembly");
    PluginAssembly.prototype = {
      constructor: PluginAssembly,
      setDebugMode: function(t) {
      },
      startSession: function(t) {
      },
      setCaptureUncaughtException: function(t) {
      },
      callFuncWithParam: function(t) {
        if (typeof this[t] == "function")
          return this[t].apply(this, Array.prototype.splice.call(arguments, 1));
        cc.log("function is not define");
      },
      callStringFuncWithParam: function(t) {
        this.callFuncWithParam.apply(arguments);
      },
      getPluginName: function() {
        return this._name;
      },
      getPluginVersion: function() {
        return this._version;
      }
    }, PluginAssembly.extend = function(name, porp) {
      var p, prototype = {};
      for (p in PluginAssembly.prototype)
        prototype[p] = PluginAssembly.prototype[p];
      for (p in porp)
        prototype[p] = porp[p];
      var tmp = eval("(function " + name + "Plugin(){})");
      return prototype.constructor = tmp, tmp.prototype = prototype, tmp;
    };
    var Param = /* @__PURE__ */ H(function(t, e) {
      var n = plugin.PluginParam.ParamType, r;
      switch (t) {
        case n.TypeInt:
          r = parseInt(e);
          break;
        case n.TypeFloat:
          r = parseFloat(e);
          break;
        case n.TypeBool:
          r = !!e;
          break;
        case n.TypeString:
          r = String(e);
          break;
        case n.TypeStringMap:
          r = e;
          break;
        default:
          r = e;
      }
      return r;
    }, "Param");
    Param.ParamType = {
      TypeInt: 1,
      TypeFloat: 2,
      TypeBool: 3,
      TypeString: 4,
      TypeStringMap: 5
    }, Param.AdsResultCode = {
      AdsReceived: 0,
      FullScreenViewShown: 1,
      FullScreenViewDismissed: 2,
      PointsSpendSucceed: 3,
      PointsSpendFailed: 4,
      NetworkError: 5,
      UnknownError: 6
    }, Param.PayResultCode = {
      PaySuccess: 0,
      PayFail: 1,
      PayCancel: 2,
      PayTimeOut: 3
    }, Param.ShareResultCode = {
      ShareSuccess: 0,
      ShareFail: 1,
      ShareCancel: 2,
      ShareTimeOut: 3
    };
    var PluginList = {}, Plugin = {
      extend: function(t, e) {
        var n = cc.game.config && cc.game.config.plugin || {};
        PluginList[t] = new (PluginAssembly.extend(t, e))(), typeof PluginList[t].ctor == "function" && PluginList[t].ctor(n[t]);
      },
      PluginList,
      PluginParam: Param,
      PluginManager: new PluginManager()
    };
    window.plugin = Plugin;
  }
})();
(function() {
  var t = {
    _ignoreBodyRotation: !1,
    _body: null,
    _rotation: 1,
    ctor: function(n, r) {
      if (cc.Sprite.prototype.ctor.call(this), n === void 0)
        cc.PhysicsSprite.prototype.init.call(this);
      else if (cc.isString(n))
        if (n[0] === "#") {
          var s = n.substr(1, n.length - 1), o = cc.spriteFrameCache.getSpriteFrame(s);
          this.initWithSpriteFrame(o);
        } else
          this.init(n, r);
      else
        cc.isObject(n) && (n instanceof cc.Texture2D ? this.initWithTexture(n, r) : n instanceof cc.SpriteFrame && this.initWithSpriteFrame(n));
      cc.renderer.pushRenderCommand(this._renderCmd);
    },
    visit: function() {
      cc.renderer.pushRenderCommand(this._renderCmd), cc.Sprite.prototype.visit.call(this);
    },
    setBody: function(n) {
      this._body = n;
    },
    getBody: function() {
      return this._body;
    },
    getPosition: function() {
      var n = (this || window)._body;
      return { x: n.p.x, y: n.p.y };
    },
    getPositionX: function() {
      return this._body.p.x;
    },
    getPositionY: function() {
      return this._body.p.y;
    },
    setPosition: function(n, r) {
      r === void 0 ? (this._body.p.x = n.x, this._body.p.y = n.y) : (this._body.p.x = n, this._body.p.y = r);
    },
    setPositionX: function(n) {
      this._body.p.x = n;
    },
    setPositionY: function(n) {
      this._body.p.y = n;
    },
    _syncPosition: function() {
      var n = (this || window)._position, r = (this || window)._body;
      (n.x !== r.p.x || n.y !== r.p.y) && cc.Sprite.prototype.setPosition.call(this, r.p.x, r.p.y);
    },
    getRotation: function() {
      return this._ignoreBodyRotation ? this._rotationX : -cc.radiansToDegrees(this._body.a);
    },
    setRotation: function(n) {
      this._ignoreBodyRotation ? cc.Sprite.prototype.setRotation.call(this, n) : this._body.a = -cc.degreesToRadians(n);
    },
    _syncRotation: function() {
      var n = -cc.radiansToDegrees(this._body.a);
      this._rotationX !== n && cc.Sprite.prototype.setRotation.call(this, n);
    },
    getNodeToParentTransform: function() {
      return this._renderCmd.getNodeToParentTransform();
    },
    isDirty: function() {
      return !this._body.isSleeping();
    },
    setDirty: function() {
    },
    setIgnoreBodyRotation: function(n) {
      this._ignoreBodyRotation = n;
    },
    _createRenderCmd: function() {
      return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.PhysicsSprite.CanvasRenderCmd(this) : new cc.PhysicsSprite.WebGLRenderCmd(this);
    }
  };
  cc.PhysicsSprite = cc.Sprite.extend(t), cc.PhysicsSprite._className = "PhysicsSprite";
  var e = cc.PhysicsSprite.prototype;
  e.body, cc.defineGetterSetter(e, "body", e.getBody, e.setBody), e.dirty, cc.defineGetterSetter(e, "dirty", e.isDirty, e.setDirty), cc.PhysicsSprite.create = function(n, r) {
    return new cc.PhysicsSprite(n, r);
  }, cc.PhysicsSprite.createWithSpriteFrameName = cc.PhysicsSprite.create, cc.PhysicsSprite.createWithSpriteFrame = cc.PhysicsSprite.create;
})();
(function() {
  cc.PhysicsSprite.CanvasRenderCmd = function(e) {
    cc.Sprite.CanvasRenderCmd.call(this, e), this._needDraw = !0;
  };
  var t = cc.PhysicsSprite.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
  t.constructor = cc.PhysicsSprite.CanvasRenderCmd, t.rendering = function(e, n, r) {
    var s = (this || window)._node;
    s._syncPosition(), s._ignoreBodyRotation || s._syncRotation(), this.transform(this.getParentRenderCmd()), cc.Sprite.CanvasRenderCmd.prototype.rendering.call(this, e, n, r);
  };
})();
cc.__convertVerts = function(t) {
  for (var e = [], n = 0; n < t.length / 2; n++)
    e[n] = { x: t[n * 2], y: t[n * 2 + 1] };
  return e;
};
cc.ColorForBody = function(t) {
  return t.isRogue() || t.isSleeping() ? cc.color(128, 128, 128, 128) : t.nodeIdleTime > t.space.sleepTimeThreshold ? cc.color(84, 84, 84, 128) : cc.color(255, 0, 0, 128);
};
cc.DrawShape = function(t, e) {
  var n = t.body, r = cc.ColorForBody(n);
  switch (t.collisionCode) {
    case cp.CircleShape.prototype.collisionCode:
      this.drawDot(t.tc, Math.max(t.r, 1), r), this.drawSegment(t.tc, cp.v.add(t.tc, cp.v.mult(n.rot, t.r)), 1, r);
      break;
    case cp.SegmentShape.prototype.collisionCode:
      this.drawSegment(t.ta, t.tb, Math.max(t.r, 2), r);
      break;
    case cp.PolyShape.prototype.collisionCode:
      var s = cc.color(r.r, r.g, r.b, cc.lerp(r.a, 255, 0.5));
      this.drawPoly(cc.__convertVerts(t.tVerts), r, 1, s);
      break;
    default:
      cc.log("cc.DrawShape(): Bad assertion in DrawShape()");
      break;
  }
};
cc.DrawConstraint = function(t, e) {
  var n = t.a, r = t.b, s, o;
  if (t instanceof cp.PinJoint)
    s = n.local2World(t.anchr1), o = r.local2World(t.anchr2), this.drawDot(s, 3, cc.CONSTRAINT_COLOR), this.drawDot(o, 3, cc.CONSTRAINT_COLOR), this.drawSegment(s, o, 1, cc.CONSTRAINT_COLOR);
  else if (t instanceof cp.SlideJoint)
    s = n.local2World(t.anchr1), o = r.local2World(t.anchr2), this.drawDot(s, 3, cc.CONSTRAINT_COLOR), this.drawDot(o, 3, cc.CONSTRAINT_COLOR), this.drawSegment(s, o, 1, cc.CONSTRAINT_COLOR);
  else if (t instanceof cp.PivotJoint)
    s = n.local2World(t.anchr1), o = r.local2World(t.anchr2), this.drawDot(s, 3, cc.CONSTRAINT_COLOR), this.drawDot(o, 3, cc.CONSTRAINT_COLOR);
  else if (t instanceof cp.GrooveJoint) {
    s = n.local2World(t.grv_a), o = n.local2World(t.grv_b);
    var a = r.local2World(t.anchr2);
    this.drawDot(a, 3, cc.CONSTRAINT_COLOR), this.drawSegment(s, o, 1, cc.CONSTRAINT_COLOR);
  } else
    t instanceof cp.DampedSpring;
};
cc.CONSTRAINT_COLOR = cc.color(0, 255, 0, 128);
cc.PhysicsDebugNode = cc.DrawNode.extend({
  _space: null,
  _className: "PhysicsDebugNode",
  ctor: function(t) {
    cc.DrawNode.prototype.ctor.call(this), this._space = t;
  },
  getSpace: function() {
    return this._space;
  },
  setSpace: function(t) {
    this._space = t;
  },
  draw: function(t) {
    this._space && (this._space.eachShape(cc.DrawShape.bind(this)), this._space.eachConstraint(cc.DrawConstraint.bind(this)), cc.DrawNode.prototype.draw.call(this), this.clear());
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.PhysicsDebugNode.CanvasRenderCmd(this) : new cc.PhysicsDebugNode.WebGLRenderCmd(this);
  }
});
cc.PhysicsDebugNode.create = function(t) {
  return new cc.PhysicsDebugNode(t);
};
(function() {
  cc.PhysicsDebugNode.CanvasRenderCmd = function(e) {
    cc.Node.CanvasRenderCmd.call(this, e), this._buffer = e._buffer, this._needDraw = !0;
  };
  var t = cc.PhysicsDebugNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = cc.PhysicsDebugNode.CanvasRenderCmd, t.rendering = function(e, n, r) {
    var s = (this || window)._node;
    s._space && (s._space.eachShape(cc.DrawShape.bind(s)), s._space.eachConstraint(cc.DrawConstraint.bind(s)), cc.DrawNode.CanvasRenderCmd.prototype.rendering.call(this, e, n, r), s.clear());
  }, t._drawDot = cc.DrawNode.CanvasRenderCmd.prototype._drawDot, t._drawSegment = cc.DrawNode.CanvasRenderCmd.prototype._drawSegment, t._drawPoly = cc.DrawNode.CanvasRenderCmd.prototype._drawPoly;
})();
(function() {
  cc.PhysicsDebugNode.WebGLRenderCmd = function(t) {
    cc.Node.WebGLRenderCmd.call(this, t), this._needDraw = !0, this._matrix = new cc.math.Matrix4(), this._matrix.identity();
  }, cc.PhysicsDebugNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype), cc.PhysicsDebugNode.WebGLRenderCmd.prototype.constructor = cc.PhysicsDebugNode.WebGLRenderCmd, cc.PhysicsDebugNode.WebGLRenderCmd.prototype.rendering = function(t) {
    var e = (this || window)._node;
    if (e._space) {
      e._space.eachShape(cc.DrawShape.bind(e)), e._space.eachConstraint(cc.DrawConstraint.bind(e));
      var n = (this || window)._worldTransform;
      this._matrix.mat[0] = n.a, this._matrix.mat[4] = n.c, this._matrix.mat[12] = n.tx, this._matrix.mat[1] = n.b, this._matrix.mat[5] = n.d, this._matrix.mat[13] = n.ty, cc.glBlendFunc(e._blendFunc.src, e._blendFunc.dst), this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix), e._render(), e.clear();
    }
  };
})();
(function() {
  cc.PhysicsSprite.WebGLRenderCmd = function(e) {
    cc.Sprite.WebGLRenderCmd.call(this, e), this._needDraw = !0;
  };
  var t = cc.PhysicsSprite.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
  t.constructor = cc.PhysicsSprite.WebGLRenderCmd, t.spUploadData = cc.Sprite.WebGLRenderCmd.prototype.uploadData, t.uploadData = function(e, n, r) {
    var s = (this || window)._node;
    return s._syncPosition(), s._ignoreBodyRotation || s._syncRotation(), this.transform(this.getParentRenderCmd(), !0), this.spUploadData(e, n, r);
  };
})();
(function(t) {
  if (typeof exports == "object" && typeof module != "undefined")
    module.exports = t();
  else if (typeof define == "function" && define.amd)
    define([], t);
  else {
    var e;
    typeof window != "undefined" ? e = window : typeof global != "undefined" ? e = global : typeof self != "undefined" && (e = self), e.io = t();
  }
})(function() {
  return (/* @__PURE__ */ H(function t(e, n, r) {
    function s(c, l) {
      if (!n[c]) {
        if (!e[c]) {
          var h = typeof require == "function" && require;
          if (!l && h)
            return h(c, !0);
          if (o)
            return o(c, !0);
          throw new Error("Cannot find module '" + c + "'");
        }
        var u = n[c] = { exports: {} };
        e[c][0].call(u.exports, function(_) {
          var d = e[c][1][_];
          return s(d || _);
        }, u, u.exports, t, e, n, r);
      }
      return n[c].exports;
    }
    H(s, "s");
    for (var o = typeof require == "function" && require, a = 0; a < r.length; a++)
      s(r[a]);
    return s;
  }, "e"))({ 1: [function(t, e, n) {
    e.exports = t("./lib/");
  }, { "./lib/": 2 }], 2: [function(t, e, n) {
    var r = t("./url"), s = t("socket.io-parser"), o = t("./manager"), a = t("debug")("socket.io-client");
    e.exports = n = l;
    var c = n.managers = {};
    function l(h, u) {
      typeof h == "object" && (u = h, h = void 0), u = u || {};
      var _ = r(h), d = _.source, f = _.id, C;
      return u.forceNew || u["force new connection"] || u.multiplex === !1 ? (a("ignoring socket cache for %s", d), C = o(d, u)) : (c[f] || (a("new io instance for %s", d), c[f] = o(d, u)), C = c[f]), C.socket(_.path);
    }
    H(l, "lookup"), n.protocol = s.protocol, n.connect = l, n.Manager = t("./manager"), n.Socket = t("./socket");
  }, { "./manager": 3, "./socket": 5, "./url": 6, debug: 10, "socket.io-parser": 46 }], 3: [function(t, e, n) {
    t("./url");
    var r = t("engine.io-client"), s = t("./socket"), o = t("component-emitter"), a = t("socket.io-parser"), c = t("./on"), l = t("component-bind");
    t("object-component");
    var h = t("debug")("socket.io-client:manager"), u = t("indexof"), _ = t("backo2");
    e.exports = d;
    function d(f, C) {
      if (!(this instanceof d))
        return new d(f, C);
      f && typeof f == "object" && (C = f, f = void 0), C = C || {}, C.path = C.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = C, this.reconnection(C.reconnection !== !1), this.reconnectionAttempts(C.reconnectionAttempts || 1 / 0), this.reconnectionDelay(C.reconnectionDelay || 1e3), this.reconnectionDelayMax(C.reconnectionDelayMax || 5e3), this.randomizationFactor(C.randomizationFactor || 0.5), this.backoff = new _({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(C.timeout == null ? 2e4 : C.timeout), this.readyState = "closed", this.uri = f, this.connected = [], this.encoding = !1, this.packetBuffer = [], this.encoder = new a.Encoder(), this.decoder = new a.Decoder(), this.autoConnect = C.autoConnect !== !1, this.autoConnect && this.open();
    }
    H(d, "Manager"), d.prototype.emitAll = function() {
      this.emit.apply(this, arguments);
      for (var f in this.nsps)
        this.nsps[f].emit.apply(this.nsps[f], arguments);
    }, d.prototype.updateSocketIds = function() {
      for (var f in this.nsps)
        this.nsps[f].id = (this || window).engine.id;
    }, o(d.prototype), d.prototype.reconnection = function(f) {
      return arguments.length ? (this._reconnection = !!f, this) : this._reconnection;
    }, d.prototype.reconnectionAttempts = function(f) {
      return arguments.length ? (this._reconnectionAttempts = f, this) : this._reconnectionAttempts;
    }, d.prototype.reconnectionDelay = function(f) {
      return arguments.length ? (this._reconnectionDelay = f, this.backoff && this.backoff.setMin(f), this) : this._reconnectionDelay;
    }, d.prototype.randomizationFactor = function(f) {
      return arguments.length ? (this._randomizationFactor = f, this.backoff && this.backoff.setJitter(f), this) : this._randomizationFactor;
    }, d.prototype.reconnectionDelayMax = function(f) {
      return arguments.length ? (this._reconnectionDelayMax = f, this.backoff && this.backoff.setMax(f), this) : this._reconnectionDelayMax;
    }, d.prototype.timeout = function(f) {
      return arguments.length ? (this._timeout = f, this) : this._timeout;
    }, d.prototype.maybeReconnectOnOpen = function() {
      !this.reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
    }, d.prototype.open = d.prototype.connect = function(f) {
      if (h("readyState %s", this.readyState), ~this.readyState.indexOf("open"))
        return (this || window)
      h("opening %s", this.uri), this.engine = r(this.uri, this.opts);
      var C = (this || window).engine, m = (this || window);
      this.readyState = "opening", this.skipReconnect = !1;
      var g = c(C, "open", function() {
        m.onopen(), f && f();
      }), y = c(C, "error", function(N) {
        if (h("connect_error"), m.cleanup(), m.readyState = "closed", m.emitAll("connect_error", N), f) {
          var z = new Error("Connection error");
          z.data = N, f(z);
        } else
          m.maybeReconnectOnOpen();
      });
      if (this._timeout !== !1) {
        var A = (this || window)._timeout;
        h("connect attempt will timeout after %d", A);
        var D = setTimeout(function() {
          h("connect attempt timed out after %d", A), g.destroy(), C.close(), C.emit("error", "timeout"), m.emitAll("connect_timeout", A);
        }, A);
        this.subs.push({ destroy: function() {
          clearTimeout(D);
        } });
      }
      return this.subs.push(g), this.subs.push(y), (this || window)
    }, d.prototype.onopen = function() {
      h("open"), this.cleanup(), this.readyState = "open", this.emit("open");
      var f = (this || window).engine;
      this.subs.push(c(f, "data", l(this, "ondata"))), this.subs.push(c(this.decoder, "decoded", l(this, "ondecoded"))), this.subs.push(c(f, "error", l(this, "onerror"))), this.subs.push(c(f, "close", l(this, "onclose")));
    }, d.prototype.ondata = function(f) {
      this.decoder.add(f);
    }, d.prototype.ondecoded = function(f) {
      this.emit("packet", f);
    }, d.prototype.onerror = function(f) {
      h("error", f), this.emitAll("error", f);
    }, d.prototype.socket = function(f) {
      var C = (this || window).nsps[f];
      if (!C) {
        C = new s(this, f), this.nsps[f] = C;
        var m = (this || window);
        C.on("connect", function() {
          C.id = m.engine.id, ~u(m.connected, C) || m.connected.push(C);
        });
      }
      return C;
    }, d.prototype.destroy = function(f) {
      var C = u(this.connected, f);
      ~C && this.connected.splice(C, 1), !this.connected.length && this.close();
    }, d.prototype.packet = function(f) {
      h("writing packet %j", f);
      var C = (this || window);
      C.encoding ? C.packetBuffer.push(f) : (C.encoding = !0, this.encoder.encode(f, function(m) {
        for (var g = 0; g < m.length; g++)
          C.engine.write(m[g]);
        C.encoding = !1, C.processPacketQueue();
      }));
    }, d.prototype.processPacketQueue = function() {
      if (this.packetBuffer.length > 0 && !this.encoding) {
        var f = (this || window).packetBuffer.shift();
        this.packet(f);
      }
    }, d.prototype.cleanup = function() {
      for (var f; f = (this || window).subs.shift(); )
        f.destroy();
      this.packetBuffer = [], this.encoding = !1, this.decoder.destroy();
    }, d.prototype.close = d.prototype.disconnect = function() {
      this.skipReconnect = !0, this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close();
    }, d.prototype.onclose = function(f) {
      h("close"), this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", f), this._reconnection && !this.skipReconnect && this.reconnect();
    }, d.prototype.reconnect = function() {
      if (this.reconnecting || this.skipReconnect)
        return (this || window)
      var f = (this || window);
      if (this.backoff.attempts >= (this || window)._reconnectionAttempts)
        h("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1;
      else {
        var C = (this || window).backoff.duration();
        h("will wait %dms before reconnect attempt", C), this.reconnecting = !0;
        var m = setTimeout(function() {
          f.skipReconnect || (h("attempting reconnect"), f.emitAll("reconnect_attempt", f.backoff.attempts), f.emitAll("reconnecting", f.backoff.attempts), !f.skipReconnect && f.open(function(g) {
            g ? (h("reconnect attempt error"), f.reconnecting = !1, f.reconnect(), f.emitAll("reconnect_error", g.data)) : (h("reconnect success"), f.onreconnect());
          }));
        }, C);
        this.subs.push({ destroy: function() {
          clearTimeout(m);
        } });
      }
    }, d.prototype.onreconnect = function() {
      var f = (this || window).backoff.attempts;
      this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", f);
    };
  }, { "./on": 4, "./socket": 5, "./url": 6, backo2: 7, "component-bind": 8, "component-emitter": 9, debug: 10, "engine.io-client": 11, indexof: 42, "object-component": 43, "socket.io-parser": 46 }], 4: [function(t, e, n) {
    e.exports = r;
    function r(s, o, a) {
      return s.on(o, a), { destroy: function() {
        s.removeListener(o, a);
      } };
    }
    H(r, "on");
  }, {}], 5: [function(t, e, n) {
    var r = t("socket.io-parser"), s = t("component-emitter"), o = t("to-array"), a = t("./on"), c = t("component-bind"), l = t("debug")("socket.io-client:socket"), h = t("has-binary");
    e.exports = d;
    var u = { connect: 1, connect_error: 1, connect_timeout: 1, disconnect: 1, error: 1, reconnect: 1, reconnect_attempt: 1, reconnect_failed: 1, reconnect_error: 1, reconnecting: 1 }, _ = s.prototype.emit;
    function d(f, C) {
      this.io = f, this.nsp = C, this.json = (this || window), this.ids = 0, this.acks = {}, this.io.autoConnect && this.open(), this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0;
    }
    H(d, "Socket"), s(d.prototype), d.prototype.subEvents = function() {
      if (!this.subs) {
        var f = (this || window).io;
        this.subs = [a(f, "open", c(this, "onopen")), a(f, "packet", c(this, "onpacket")), a(f, "close", c(this, "onclose"))];
      }
    }, d.prototype.open = d.prototype.connect = function() {
      return this.connected ? this : (this.subEvents(), this.io.open(), this.io.readyState == "open" && this.onopen(), this);
    }, d.prototype.send = function() {
      var f = o(arguments);
      return f.unshift("message"), this.emit.apply(this, f), (this || window)
    }, d.prototype.emit = function(f) {
      if (u.hasOwnProperty(f))
        return _.apply(this, arguments), (this || window)
      var C = o(arguments), m = r.EVENT;
      h(C) && (m = r.BINARY_EVENT);
      var g = { type: m, data: C };
      return typeof C[C.length - 1] == "function" && (l("emitting packet with ack id %d", this.ids), this.acks[this.ids] = C.pop(), g.id = (this || window).ids++), this.connected ? this.packet(g) : this.sendBuffer.push(g), (this || window)
    }, d.prototype.packet = function(f) {
      f.nsp = (this || window).nsp, this.io.packet(f);
    }, d.prototype.onopen = function() {
      l("transport is open - connecting"), this.nsp != "/" && this.packet({ type: r.CONNECT });
    }, d.prototype.onclose = function(f) {
      l("close (%s)", f), this.connected = !1, this.disconnected = !0, delete this.id, this.emit("disconnect", f);
    }, d.prototype.onpacket = function(f) {
      if (f.nsp == (this || window).nsp)
        switch (f.type) {
          case r.CONNECT:
            this.onconnect();
            break;
          case r.EVENT:
            this.onevent(f);
            break;
          case r.BINARY_EVENT:
            this.onevent(f);
            break;
          case r.ACK:
            this.onack(f);
            break;
          case r.BINARY_ACK:
            this.onack(f);
            break;
          case r.DISCONNECT:
            this.ondisconnect();
            break;
          case r.ERROR:
            this.emit("error", f.data);
            break;
        }
    }, d.prototype.onevent = function(f) {
      var C = f.data || [];
      l("emitting event %j", C), f.id != null && (l("attaching ack callback to event"), C.push(this.ack(f.id))), this.connected ? _.apply(this, C) : this.receiveBuffer.push(C);
    }, d.prototype.ack = function(f) {
      var C = (this || window), m = !1;
      return function() {
        if (!m) {
          m = !0;
          var g = o(arguments);
          l("sending ack %j", g);
          var y = h(g) ? r.BINARY_ACK : r.ACK;
          C.packet({ type: y, id: f, data: g });
        }
      };
    }, d.prototype.onack = function(f) {
      l("calling ack %s with %j", f.id, f.data);
      var C = (this || window).acks[f.id];
      C.apply(this, f.data), delete this.acks[f.id];
    }, d.prototype.onconnect = function() {
      this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered();
    }, d.prototype.emitBuffered = function() {
      var f;
      for (f = 0; f < this.receiveBuffer.length; f++)
        _.apply(this, this.receiveBuffer[f]);
      for (this.receiveBuffer = [], f = 0; f < this.sendBuffer.length; f++)
        this.packet(this.sendBuffer[f]);
      this.sendBuffer = [];
    }, d.prototype.ondisconnect = function() {
      l("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect");
    }, d.prototype.destroy = function() {
      if (this.subs) {
        for (var f = 0; f < this.subs.length; f++)
          this.subs[f].destroy();
        this.subs = null;
      }
      this.io.destroy(this);
    }, d.prototype.close = d.prototype.disconnect = function() {
      return this.connected && (l("performing disconnect (%s)", this.nsp), this.packet({ type: r.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), (this || window)
    };
  }, { "./on": 4, "component-bind": 8, "component-emitter": 9, debug: 10, "has-binary": 38, "socket.io-parser": 46, "to-array": 50 }], 6: [function(t, e, n) {
    (function(r) {
      var s = t("parseuri"), o = t("debug")("socket.io-client:url");
      e.exports = a;
      function a(c, u) {
        var h = c, u = u || r.location;
        return c == null && (c = u.protocol + "//" + u.host), typeof c == "string" && (c.charAt(0) == "/" && (c.charAt(1) == "/" ? c = u.protocol + c : c = u.hostname + c), /^(https?|wss?):\/\//.test(c) || (o("protocol-less url %s", c), typeof u != "undefined" ? c = u.protocol + "//" + c : c = "https://" + c), o("parse %s", c), h = s(c)), h.port || (/^(http|ws)$/.test(h.protocol) ? h.port = "80" : /^(http|ws)s$/.test(h.protocol) && (h.port = "443")), h.path = h.path || "/", h.id = h.protocol + "://" + h.host + ":" + h.port, h.href = h.protocol + "://" + h.host + (u && u.port == h.port ? "" : ":" + h.port), h;
      }
      H(a, "url");
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { debug: 10, parseuri: 44 }], 7: [function(t, e, n) {
    e.exports = r;
    function r(s) {
      s = s || {}, this.ms = s.min || 100, this.max = s.max || 1e4, this.factor = s.factor || 2, this.jitter = s.jitter > 0 && s.jitter <= 1 ? s.jitter : 0, this.attempts = 0;
    }
    H(r, "Backoff"), r.prototype.duration = function() {
      var s = (this || window).ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var o = Math.random(), a = Math.floor(o * this.jitter * s);
        s = Math.floor(o * 10) & 1 ? s + a : s - a;
      }
      return Math.min(s, this.max) | 0;
    }, r.prototype.reset = function() {
      this.attempts = 0;
    }, r.prototype.setMin = function(s) {
      this.ms = s;
    }, r.prototype.setMax = function(s) {
      this.max = s;
    }, r.prototype.setJitter = function(s) {
      this.jitter = s;
    };
  }, {}], 8: [function(t, e, n) {
    var r = [].slice;
    e.exports = function(s, o) {
      if (typeof o == "string" && (o = s[o]), typeof o != "function")
        throw new Error("bind() requires a function");
      var a = r.call(arguments, 2);
      return function() {
        return o.apply(s, a.concat(r.call(arguments)));
      };
    };
  }, {}], 9: [function(t, e, n) {
    e.exports = r;
    function r(o) {
      if (o)
        return s(o);
    }
    H(r, "Emitter");
    function s(o) {
      for (var a in r.prototype)
        o[a] = r.prototype[a];
      return o;
    }
    H(s, "mixin"), r.prototype.on = r.prototype.addEventListener = function(o, a) {
      return this._callbacks = (this || window)._callbacks || {}, (this._callbacks[o] = (this || window)._callbacks[o] || []).push(a), (this || window)
    }, r.prototype.once = function(o, a) {
      var c = (this || window);
      this._callbacks = (this || window)._callbacks || {};
      function l() {
        c.off(o, l), a.apply(this, arguments);
      }
      return H(l, "on"), l.fn = a, this.on(o, l), (this || window)
    }, r.prototype.off = r.prototype.removeListener = r.prototype.removeAllListeners = r.prototype.removeEventListener = function(o, a) {
      if (this._callbacks = (this || window)._callbacks || {}, arguments.length == 0)
        return this._callbacks = {}, (this || window)
      var c = (this || window)._callbacks[o];
      if (!c)
        return (this || window)
      if (arguments.length == 1)
        return delete this._callbacks[o], (this || window)
      for (var l, h = 0; h < c.length; h++)
        if (l = c[h], l === a || l.fn === a) {
          c.splice(h, 1);
          break;
        }
      return (this || window)
    }, r.prototype.emit = function(o) {
      this._callbacks = (this || window)._callbacks || {};
      var a = [].slice.call(arguments, 1), c = (this || window)._callbacks[o];
      if (c) {
        c = c.slice(0);
        for (var l = 0, h = c.length; l < h; ++l)
          c[l].apply(this, a);
      }
      return (this || window)
    }, r.prototype.listeners = function(o) {
      return this._callbacks = (this || window)._callbacks || {}, this._callbacks[o] || [];
    }, r.prototype.hasListeners = function(o) {
      return !!this.listeners(o).length;
    };
  }, {}], 10: [function(t, e, n) {
    e.exports = r;
    function r(o) {
      return r.enabled(o) ? function(a) {
        a = s(a);
        var c = /* @__PURE__ */ new Date(), l = c - (r[o] || c);
        r[o] = c, a = o + " " + a + " +" + r.humanize(l), window.console && console.log && Function.prototype.apply.call(console.log, console, arguments);
      } : function() {
      };
    }
    H(r, "debug"), r.names = [], r.skips = [], r.enable = function(o) {
      try {
        localStorage.debug = o;
      } catch (h) {
      }
      for (var a = (o || "").split(/[\s,]+/), c = a.length, l = 0; l < c; l++)
        o = a[l].replace("*", ".*?"), o[0] === "-" ? r.skips.push(new RegExp("^" + o.substr(1) + "$")) : r.names.push(new RegExp("^" + o + "$"));
    }, r.disable = function() {
      r.enable("");
    }, r.humanize = function(o) {
      var a = 1e3, c = 60 * 1e3, l = 60 * c;
      return o >= l ? (o / l).toFixed(1) + "h" : o >= c ? (o / c).toFixed(1) + "m" : o >= a ? (o / a | 0) + "s" : o + "ms";
    }, r.enabled = function(o) {
      for (var a = 0, c = r.skips.length; a < c; a++)
        if (r.skips[a].test(o))
          return !1;
      for (var a = 0, c = r.names.length; a < c; a++)
        if (r.names[a].test(o))
          return !0;
      return !1;
    };
    function s(o) {
      return o instanceof Error ? o.stack || o.message : o;
    }
    H(s, "coerce");
    try {
      window.localStorage && r.enable(localStorage.debug);
    } catch (o) {
    }
  }, {}], 11: [function(t, e, n) {
    e.exports = t("./lib/");
  }, { "./lib/": 12 }], 12: [function(t, e, n) {
    e.exports = t("./socket"), e.exports.parser = t("engine.io-parser");
  }, { "./socket": 13, "engine.io-parser": 25 }], 13: [function(t, e, n) {
    (function(r) {
      var s = t("./transports"), o = t("component-emitter"), a = t("debug")("engine.io-client:socket"), c = t("indexof"), l = t("engine.io-parser"), h = t("parseuri"), u = t("parsejson"), _ = t("parseqs");
      e.exports = d;
      function d(C, m) {
        if (!(this instanceof d))
          return new d(C, m);
        if (m = m || {}, C && typeof C == "object" && (m = C, C = null), C && (C = h(C), m.host = C.host, m.secure = C.protocol == "https" || C.protocol == "wss", m.port = C.port, C.query && (m.query = C.query)), this.secure = m.secure != null ? m.secure : r.location && location.protocol == "https:", m.host) {
          var g = m.host.split(":");
          m.hostname = g.shift(), g.length ? m.port = g.pop() : m.port || (m.port = (this || window).secure ? "443" : "80");
        }
        this.agent = m.agent || !1, this.hostname = m.hostname || (r.location ? location.hostname : "localhost"), this.port = m.port || (r.location && location.port ? location.port : this.secure ? 443 : 80), this.query = m.query || {}, typeof this.query == "string" && (this.query = _.decode(this.query)), this.upgrade = m.upgrade !== !1, this.path = (m.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!m.forceJSONP, this.jsonp = m.jsonp !== !1, this.forceBase64 = !!m.forceBase64, this.enablesXDR = !!m.enablesXDR, this.timestampParam = m.timestampParam || "t", this.timestampRequests = m.timestampRequests, this.transports = m.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.callbackBuffer = [], this.policyPort = m.policyPort || 843, this.rememberUpgrade = m.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = m.onlyBinaryUpgrades, this.pfx = m.pfx || null, this.key = m.key || null, this.passphrase = m.passphrase || null, this.cert = m.cert || null, this.ca = m.ca || null, this.ciphers = m.ciphers || null, this.rejectUnauthorized = m.rejectUnauthorized || null, this.open();
      }
      H(d, "Socket"), d.priorWebsocketSuccess = !1, o(d.prototype), d.protocol = l.protocol, d.Socket = d, d.Transport = t("./transport"), d.transports = t("./transports"), d.parser = t("engine.io-parser"), d.prototype.createTransport = function(C) {
        a('creating transport "%s"', C);
        var m = f(this.query);
        m.EIO = l.protocol, m.transport = C, this.id && (m.sid = (this || window).id);
        var g = new s[C]({ agent: this.agent, hostname: this.hostname, port: this.port, secure: this.secure, path: this.path, query: m, forceJSONP: this.forceJSONP, jsonp: this.jsonp, forceBase64: this.forceBase64, enablesXDR: this.enablesXDR, timestampRequests: this.timestampRequests, timestampParam: this.timestampParam, policyPort: this.policyPort, socket: this, pfx: this.pfx, key: this.key, passphrase: this.passphrase, cert: this.cert, ca: this.ca, ciphers: this.ciphers, rejectUnauthorized: this.rejectUnauthorized });
        return g;
      };
      function f(C) {
        var m = {};
        for (var g in C)
          C.hasOwnProperty(g) && (m[g] = C[g]);
        return m;
      }
      H(f, "clone"), d.prototype.open = function() {
        var m;
        if (this.rememberUpgrade && d.priorWebsocketSuccess && this.transports.indexOf("websocket") != -1)
          m = "websocket";
        else if (this.transports.length == 0) {
          var C = (this || window);
          setTimeout(function() {
            C.emit("error", "No transports available");
          }, 0);
          return;
        } else
          m = (this || window).transports[0];
        this.readyState = "opening";
        var m;
        try {
          m = (this || window).createTransport(m);
        } catch (g) {
          this.transports.shift(), this.open();
          return;
        }
        m.open(), this.setTransport(m);
      }, d.prototype.setTransport = function(C) {
        a("setting transport %s", C.name);
        var m = (this || window);
        this.transport && (a("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = C, C.on("drain", function() {
          m.onDrain();
        }).on("packet", function(g) {
          m.onPacket(g);
        }).on("error", function(g) {
          m.onError(g);
        }).on("close", function() {
          m.onClose("transport close");
        });
      }, d.prototype.probe = function(C) {
        a('probing transport "%s"', C);
        var m = (this || window).createTransport(C, { probe: 1 }), g = !1, y = (this || window);
        d.priorWebsocketSuccess = !1;
        function A() {
          if (y.onlyBinaryUpgrades) {
            var Q = !this.supportsBinary && y.transport.supportsBinary;
            g = g || Q;
          }
          g || (a('probe transport "%s" opened', C), m.send([{ type: "ping", data: "probe" }]), m.once("packet", function(et) {
            if (!g)
              if (et.type == "pong" && et.data == "probe") {
                if (a('probe transport "%s" pong', C), y.upgrading = !0, y.emit("upgrading", m), !m)
                  return;
                d.priorWebsocketSuccess = m.name == "websocket", a('pausing current transport "%s"', y.transport.name), y.transport.pause(function() {
                  g || y.readyState != "closed" && (a("changing transport and sending upgrade packet"), U(), y.setTransport(m), m.send([{ type: "upgrade" }]), y.emit("upgrade", m), m = null, y.upgrading = !1, y.flush());
                });
              } else {
                a('probe transport "%s" failed', C);
                var rt = new Error("probe error");
                rt.transport = m.name, y.emit("upgradeError", rt);
              }
          }));
        }
        H(A, "onTransportOpen");
        function D() {
          g || (g = !0, U(), m.close(), m = null);
        }
        H(D, "freezeTransport");
        function N(Q) {
          var et = new Error("probe error: " + Q);
          et.transport = m.name, D(), a('probe transport "%s" failed because of error: %s', C, Q), y.emit("upgradeError", et);
        }
        H(N, "onerror");
        function z() {
          N("transport closed");
        }
        H(z, "onTransportClose");
        function M() {
          N("socket closed");
        }
        H(M, "onclose");
        function Z(Q) {
          m && Q.name != m.name && (a('"%s" works - aborting "%s"', Q.name, m.name), D());
        }
        H(Z, "onupgrade");
        function U() {
          m.removeListener("open", A), m.removeListener("error", N), m.removeListener("close", z), y.removeListener("close", M), y.removeListener("upgrading", Z);
        }
        H(U, "cleanup"), m.once("open", A), m.once("error", N), m.once("close", z), this.once("close", M), this.once("upgrading", Z), m.open();
      }, d.prototype.onOpen = function() {
        if (a("socket open"), this.readyState = "open", d.priorWebsocketSuccess = (this || window).transport.name == "websocket", this.emit("open"), this.flush(), this.readyState == "open" && this.upgrade && this.transport.pause) {
          a("starting upgrade probes");
          for (var C = 0, m = (this || window).upgrades.length; C < m; C++)
            this.probe(this.upgrades[C]);
        }
      }, d.prototype.onPacket = function(C) {
        if (this.readyState == "opening" || this.readyState == "open")
          switch (a('socket receive: type "%s", data "%s"', C.type, C.data), this.emit("packet", C), this.emit("heartbeat"), C.type) {
            case "open":
              this.onHandshake(u(C.data));
              break;
            case "pong":
              this.setPing();
              break;
            case "error":
              var m = new Error("server error");
              m.code = C.data, this.emit("error", m);
              break;
            case "message":
              this.emit("data", C.data), this.emit("message", C.data);
              break;
          }
        else
          a('packet received with socket readyState "%s"', this.readyState);
      }, d.prototype.onHandshake = function(C) {
        this.emit("handshake", C), this.id = C.sid, this.transport.query.sid = C.sid, this.upgrades = (this || window).filterUpgrades(C.upgrades), this.pingInterval = C.pingInterval, this.pingTimeout = C.pingTimeout, this.onOpen(), this.readyState != "closed" && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat));
      }, d.prototype.onHeartbeat = function(C) {
        clearTimeout(this.pingTimeoutTimer);
        var m = (this || window);
        m.pingTimeoutTimer = setTimeout(function() {
          m.readyState != "closed" && m.onClose("ping timeout");
        }, C || m.pingInterval + m.pingTimeout);
      }, d.prototype.setPing = function() {
        var C = (this || window);
        clearTimeout(C.pingIntervalTimer), C.pingIntervalTimer = setTimeout(function() {
          a("writing ping packet - expecting pong within %sms", C.pingTimeout), C.ping(), C.onHeartbeat(C.pingTimeout);
        }, C.pingInterval);
      }, d.prototype.ping = function() {
        this.sendPacket("ping");
      }, d.prototype.onDrain = function() {
        for (var C = 0; C < this.prevBufferLen; C++)
          this.callbackBuffer[C] && this.callbackBuffer[C]();
        this.writeBuffer.splice(0, this.prevBufferLen), this.callbackBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length == 0 ? this.emit("drain") : this.flush();
      }, d.prototype.flush = function() {
        this.readyState != "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length && (a("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = (this || window).writeBuffer.length, this.emit("flush"));
      }, d.prototype.write = d.prototype.send = function(C, m) {
        return this.sendPacket("message", C, m), (this || window)
      }, d.prototype.sendPacket = function(C, m, g) {
        if (!(this.readyState == "closing" || this.readyState == "closed")) {
          var y = { type: C, data: m };
          this.emit("packetCreate", y), this.writeBuffer.push(y), this.callbackBuffer.push(g), this.flush();
        }
      }, d.prototype.close = function() {
        if (this.readyState == "opening" || this.readyState == "open") {
          let m = function() {
            C.onClose("forced close"), a("socket closing - telling transport to close"), C.transport.close();
          }, g = function() {
            C.removeListener("upgrade", g), C.removeListener("upgradeError", g), m();
          }, y = function() {
            C.once("upgrade", g), C.once("upgradeError", g);
          };
          H(m, "close"), H(g, "cleanupAndClose"), H(y, "waitForUpgrade"), this.readyState = "closing";
          var C = (this || window);
          this.writeBuffer.length ? this.once("drain", function() {
            this.upgrading ? y() : m();
          }) : this.upgrading ? y() : m();
        }
        return (this || window)
      }, d.prototype.onError = function(C) {
        a("socket error %j", C), d.priorWebsocketSuccess = !1, this.emit("error", C), this.onClose("transport error", C);
      }, d.prototype.onClose = function(C, m) {
        if (this.readyState == "opening" || this.readyState == "open" || this.readyState == "closing") {
          a('socket close with reason: "%s"', C);
          var g = (this || window);
          clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), setTimeout(function() {
            g.writeBuffer = [], g.callbackBuffer = [], g.prevBufferLen = 0;
          }, 0), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", C, m);
        }
      }, d.prototype.filterUpgrades = function(C) {
        for (var m = [], g = 0, y = C.length; g < y; g++)
          ~c(this.transports, C[g]) && m.push(C[g]);
        return m;
      };
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "./transport": 14, "./transports": 15, "component-emitter": 9, debug: 22, "engine.io-parser": 25, indexof: 42, parsejson: 34, parseqs: 35, parseuri: 36 }], 14: [function(t, e, n) {
    var r = t("engine.io-parser"), s = t("component-emitter");
    e.exports = o;
    function o(a) {
      this.path = a.path, this.hostname = a.hostname, this.port = a.port, this.secure = a.secure, this.query = a.query, this.timestampParam = a.timestampParam, this.timestampRequests = a.timestampRequests, this.readyState = "", this.agent = a.agent || !1, this.socket = a.socket, this.enablesXDR = a.enablesXDR, this.pfx = a.pfx, this.key = a.key, this.passphrase = a.passphrase, this.cert = a.cert, this.ca = a.ca, this.ciphers = a.ciphers, this.rejectUnauthorized = a.rejectUnauthorized;
    }
    H(o, "Transport"), s(o.prototype), o.timestamps = 0, o.prototype.onError = function(a, c) {
      var l = new Error(a);
      return l.type = "TransportError", l.description = c, this.emit("error", l), (this || window)
    }, o.prototype.open = function() {
      return (this.readyState == "closed" || this.readyState == "") && (this.readyState = "opening", this.doOpen()), (this || window)
    }, o.prototype.close = function() {
      return (this.readyState == "opening" || this.readyState == "open") && (this.doClose(), this.onClose()), (this || window)
    }, o.prototype.send = function(a) {
      if (this.readyState == "open")
        this.write(a);
      else
        throw new Error("Transport not open");
    }, o.prototype.onOpen = function() {
      this.readyState = "open", this.writable = !0, this.emit("open");
    }, o.prototype.onData = function(a) {
      var c = r.decodePacket(a, this.socket.binaryType);
      this.onPacket(c);
    }, o.prototype.onPacket = function(a) {
      this.emit("packet", a);
    }, o.prototype.onClose = function() {
      this.readyState = "closed", this.emit("close");
    };
  }, { "component-emitter": 9, "engine.io-parser": 25 }], 15: [function(t, e, n) {
    (function(r) {
      var s = t("xmlhttprequest"), o = t("./polling-xhr"), a = t("./polling-jsonp"), c = t("./websocket");
      n.polling = l, n.websocket = c;
      function l(h) {
        var u, _ = !1, d = !1, f = h.jsonp !== !1;
        if (r.location) {
          var C = location.protocol == "https:", m = location.port;
          m || (m = C ? 443 : 80), _ = h.hostname != location.hostname || m != h.port, d = h.secure != C;
        }
        if (h.xdomain = _, h.xscheme = d, u = new s(h), "open" in u && !h.forceJSONP)
          return new o(h);
        if (!f)
          throw new Error("JSONP disabled");
        return new a(h);
      }
      H(l, "polling");
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "./polling-jsonp": 16, "./polling-xhr": 17, "./websocket": 19, xmlhttprequest: 20 }], 16: [function(t, e, n) {
    (function(r) {
      var s = t("./polling"), o = t("component-inherit");
      e.exports = u;
      var a = /\n/g, c = /\\n/g, l;
      function h() {
      }
      H(h, "empty");
      function u(_) {
        s.call(this, _), this.query = (this || window).query || {}, l || (r.___eio || (r.___eio = []), l = r.___eio), this.index = l.length;
        var d = (this || window);
        l.push(function(f) {
          d.onData(f);
        }), this.query.j = (this || window).index, r.document && r.addEventListener && r.addEventListener("beforeunload", function() {
          d.script && (d.script.onerror = h);
        }, !1);
      }
      H(u, "JSONPPolling"), o(u, s), u.prototype.supportsBinary = !1, u.prototype.doClose = function() {
        this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), s.prototype.doClose.call(this);
      }, u.prototype.doPoll = function() {
        var _ = (this || window), d = document.createElement("script");
        this.script && (this.script.parentNode.removeChild(this.script), this.script = null), d.async = !0, d.src = (this || window).uri(), d.onerror = function(m) {
          _.onError("jsonp poll error", m);
        };
        var f = document.getElementsByTagName("script")[0];
        f.parentNode.insertBefore(d, f), this.script = d;
        var C = typeof navigator != "undefined" && /gecko/i.test(navigator.userAgent);
        C && setTimeout(function() {
          var m = document.createElement("iframe");
          document.body.appendChild(m), document.body.removeChild(m);
        }, 100);
      }, u.prototype.doWrite = function(_, d) {
        var f = (this || window);
        if (!this.form) {
          var C = document.createElement("form"), m = document.createElement("textarea"), g = (this || window).iframeId = "eio_iframe_" + this.index, y;
          C.className = "socketio", C.style.position = "absolute", C.style.top = "-1000px", C.style.left = "-1000px", C.target = g, C.method = "POST", C.setAttribute("accept-charset", "utf-8"), m.name = "d", C.appendChild(m), document.body.appendChild(C), this.form = C, this.area = m;
        }
        this.form.action = (this || window).uri();
        function A() {
          D(), d();
        }
        H(A, "complete");
        function D() {
          if (f.iframe)
            try {
              f.form.removeChild(f.iframe);
            } catch (z) {
              f.onError("jsonp polling iframe removal error", z);
            }
          try {
            var N = '<iframe src="javascript:0" name="' + f.iframeId + '">';
            y = document.createElement(N);
          } catch (z) {
            y = document.createElement("iframe"), y.name = f.iframeId, y.src = "javascript:0";
          }
          y.id = f.iframeId, f.form.appendChild(y), f.iframe = y;
        }
        H(D, "initIframe"), D(), _ = _.replace(c, `\\
`), this.area.value = _.replace(a, "\\n");
        try {
          this.form.submit();
        } catch (N) {
        }
        this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
          f.iframe.readyState == "complete" && A();
        } : this.iframe.onload = A;
      };
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "./polling": 18, "component-inherit": 21 }], 17: [function(t, e, n) {
    (function(r) {
      var s = t("xmlhttprequest"), o = t("./polling"), a = t("component-emitter"), c = t("component-inherit"), l = t("debug")("engine.io-client:polling-xhr");
      e.exports = u, e.exports.Request = _;
      function h() {
      }
      H(h, "empty");
      function u(f) {
        if (o.call(this, f), r.location) {
          var C = location.protocol == "https:", m = location.port;
          m || (m = C ? 443 : 80), this.xd = f.hostname != r.location.hostname || m != f.port, this.xs = f.secure != C;
        }
      }
      H(u, "XHR"), c(u, o), u.prototype.supportsBinary = !0, u.prototype.request = function(f) {
        return f = f || {}, f.uri = (this || window).uri(), f.xd = (this || window).xd, f.xs = (this || window).xs, f.agent = (this || window).agent || !1, f.supportsBinary = (this || window).supportsBinary, f.enablesXDR = (this || window).enablesXDR, f.pfx = (this || window).pfx, f.key = (this || window).key, f.passphrase = (this || window).passphrase, f.cert = (this || window).cert, f.ca = (this || window).ca, f.ciphers = (this || window).ciphers, f.rejectUnauthorized = (this || window).rejectUnauthorized, new _(f);
      }, u.prototype.doWrite = function(f, C) {
        var m = typeof f != "string" && f !== void 0, g = (this || window).request({ method: "POST", data: f, isBinary: m }), y = (this || window);
        g.on("success", C), g.on("error", function(A) {
          y.onError("xhr post error", A);
        }), this.sendXhr = g;
      }, u.prototype.doPoll = function() {
        l("xhr poll");
        var f = (this || window).request(), C = (this || window);
        f.on("data", function(m) {
          C.onData(m);
        }), f.on("error", function(m) {
          C.onError("xhr poll error", m);
        }), this.pollXhr = f;
      };
      function _(f) {
        this.method = f.method || "GET", this.uri = f.uri, this.xd = !!f.xd, this.xs = !!f.xs, this.async = f.async !== !1, this.data = f.data != null ? f.data : null, this.agent = f.agent, this.isBinary = f.isBinary, this.supportsBinary = f.supportsBinary, this.enablesXDR = f.enablesXDR, this.pfx = f.pfx, this.key = f.key, this.passphrase = f.passphrase, this.cert = f.cert, this.ca = f.ca, this.ciphers = f.ciphers, this.rejectUnauthorized = f.rejectUnauthorized, this.create();
      }
      H(_, "Request"), a(_.prototype), _.prototype.create = function() {
        var f = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
        f.pfx = (this || window).pfx, f.key = (this || window).key, f.passphrase = (this || window).passphrase, f.cert = (this || window).cert, f.ca = (this || window).ca, f.ciphers = (this || window).ciphers, f.rejectUnauthorized = (this || window).rejectUnauthorized;
        var C = (this || window).xhr = new s(f), m = (this || window);
        try {
          if (l("xhr open %s: %s", this.method, this.uri), C.open(this.method, this.uri, this.async), this.supportsBinary && (C.responseType = "arraybuffer"), this.method == "POST")
            try {
              this.isBinary ? C.setRequestHeader("Content-type", "application/octet-stream") : C.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (g) {
            }
          "withCredentials" in C && (C.withCredentials = !0), this.hasXDR() ? (C.onload = function() {
            m.onLoad();
          }, C.onerror = function() {
            m.onError(C.responseText);
          }) : C.onreadystatechange = function() {
            C.readyState == 4 && (C.status == 200 || C.status == 1223 ? m.onLoad() : setTimeout(function() {
              m.onError(C.status);
            }, 0));
          }, l("xhr data %s", this.data), C.send(this.data);
        } catch (g) {
          setTimeout(function() {
            m.onError(g);
          }, 0);
          return;
        }
        r.document && (this.index = _.requestsCount++, _.requests[this.index] = (this || window));
      }, _.prototype.onSuccess = function() {
        this.emit("success"), this.cleanup();
      }, _.prototype.onData = function(f) {
        this.emit("data", f), this.onSuccess();
      }, _.prototype.onError = function(f) {
        this.emit("error", f), this.cleanup(!0);
      }, _.prototype.cleanup = function(f) {
        if (!(typeof this.xhr == "undefined" || this.xhr === null)) {
          if (this.hasXDR() ? this.xhr.onload = (this || window).xhr.onerror = h : this.xhr.onreadystatechange = h, f)
            try {
              this.xhr.abort();
            } catch (C) {
            }
          r.document && delete _.requests[this.index], this.xhr = null;
        }
      }, _.prototype.onLoad = function() {
        var f;
        try {
          var C;
          try {
            C = (this || window).xhr.getResponseHeader("Content-Type").split(";")[0];
          } catch (m) {
          }
          C === "application/octet-stream" ? f = (this || window).xhr.response : this.supportsBinary ? f = "ok" : f = (this || window).xhr.responseText;
        } catch (m) {
          this.onError(m);
        }
        f != null && this.onData(f);
      }, _.prototype.hasXDR = function() {
        return typeof r.XDomainRequest != "undefined" && !this.xs && this.enablesXDR;
      }, _.prototype.abort = function() {
        this.cleanup();
      }, r.document && (_.requestsCount = 0, _.requests = {}, r.attachEvent ? r.attachEvent("onunload", d) : r.addEventListener && r.addEventListener("beforeunload", d, !1));
      function d() {
        for (var f in _.requests)
          _.requests.hasOwnProperty(f) && _.requests[f].abort();
      }
      H(d, "unloadHandler");
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "./polling": 18, "component-emitter": 9, "component-inherit": 21, debug: 22, xmlhttprequest: 20 }], 18: [function(t, e, n) {
    var r = t("../transport"), s = t("parseqs"), o = t("engine.io-parser"), a = t("component-inherit"), c = t("debug")("engine.io-client:polling");
    e.exports = h;
    var l = function() {
      var u = t("xmlhttprequest"), _ = new u({ xdomain: !1 });
      return _.responseType != null;
    }();
    function h(u) {
      var _ = u && u.forceBase64;
      (!l || _) && (this.supportsBinary = !1), r.call(this, u);
    }
    H(h, "Polling"), a(h, r), h.prototype.name = "polling", h.prototype.doOpen = function() {
      this.poll();
    }, h.prototype.pause = function(u) {
      var _ = (this || window);
      this.readyState = "pausing";
      function d() {
        c("paused"), _.readyState = "paused", u();
      }
      if (H(d, "pause"), this.polling || !this.writable) {
        var f = 0;
        this.polling && (c("we are currently polling - waiting to pause"), f++, this.once("pollComplete", function() {
          c("pre-pause polling complete"), --f || d();
        })), this.writable || (c("we are currently writing - waiting to pause"), f++, this.once("drain", function() {
          c("pre-pause writing complete"), --f || d();
        }));
      } else
        d();
    }, h.prototype.poll = function() {
      c("polling"), this.polling = !0, this.doPoll(), this.emit("poll");
    }, h.prototype.onData = function(u) {
      var _ = (this || window);
      c("polling got data %s", u);
      var d = /* @__PURE__ */ H(function(f, C, m) {
        if (_.readyState == "opening" && _.onOpen(), f.type == "close")
          return _.onClose(), !1;
        _.onPacket(f);
      }, "callback");
      o.decodePayload(u, this.socket.binaryType, d), this.readyState != "closed" && (this.polling = !1, this.emit("pollComplete"), this.readyState == "open" ? this.poll() : c('ignoring poll - transport state "%s"', this.readyState));
    }, h.prototype.doClose = function() {
      var u = (this || window);
      function _() {
        c("writing close packet"), u.write([{ type: "close" }]);
      }
      H(_, "close"), this.readyState == "open" ? (c("transport open - closing"), _()) : (c("transport not open - deferring close"), this.once("open", _));
    }, h.prototype.write = function(u) {
      var d = (this || window);
      this.writable = !1;
      var _ = /* @__PURE__ */ H(function() {
        d.writable = !0, d.emit("drain");
      }, "callbackfn"), d = (this || window);
      o.encodePayload(u, this.supportsBinary, function(f) {
        d.doWrite(f, _);
      });
    }, h.prototype.uri = function() {
      var u = (this || window).query || {}, _ = (this || window).secure ? "https" : "http", d = "";
      return this.timestampRequests !== !1 && (u[this.timestampParam] = +/* @__PURE__ */ new Date() + "-" + r.timestamps++), !this.supportsBinary && !u.sid && (u.b64 = 1), u = s.encode(u), this.port && (_ == "https" && this.port != 443 || _ == "http" && this.port != 80) && (d = ":" + this.port), u.length && (u = "?" + u), _ + "://" + this.hostname + d + this.path + u;
    };
  }, { "../transport": 14, "component-inherit": 21, debug: 22, "engine.io-parser": 25, parseqs: 35, xmlhttprequest: 20 }], 19: [function(t, e, n) {
    var r = t("../transport"), s = t("engine.io-parser"), o = t("parseqs"), a = t("component-inherit"), c = t("debug")("engine.io-client:websocket"), l = t("ws");
    e.exports = h;
    function h(u) {
      var _ = u && u.forceBase64;
      _ && (this.supportsBinary = !1), r.call(this, u);
    }
    H(h, "WS"), a(h, r), h.prototype.name = "websocket", h.prototype.supportsBinary = !0, h.prototype.doOpen = function() {
      if (this.check()) {
        var u = (this || window).uri(), _ = void 0, d = { agent: this.agent };
        d.pfx = (this || window).pfx, d.key = (this || window).key, d.passphrase = (this || window).passphrase, d.cert = (this || window).cert, d.ca = (this || window).ca, d.ciphers = (this || window).ciphers, d.rejectUnauthorized = (this || window).rejectUnauthorized, this.ws = new l(u, _, d), this.ws.binaryType === void 0 && (this.supportsBinary = !1), this.ws.binaryType = "arraybuffer", this.addEventListeners();
      }
    }, h.prototype.addEventListeners = function() {
      var u = (this || window);
      this.ws.onopen = function() {
        u.onOpen();
      }, this.ws.onclose = function() {
        u.onClose();
      }, this.ws.onmessage = function(_) {
        u.onData(_.data);
      }, this.ws.onerror = function(_) {
        u.onError("websocket error", _);
      };
    }, typeof navigator != "undefined" && /iPad|iPhone|iPod/i.test(navigator.userAgent) && (h.prototype.onData = function(u) {
      var _ = (this || window);
      setTimeout(function() {
        r.prototype.onData.call(_, u);
      }, 0);
    }), h.prototype.write = function(u) {
      var _ = (this || window);
      this.writable = !1;
      for (var d = 0, f = u.length; d < f; d++)
        s.encodePacket(u[d], this.supportsBinary, function(m) {
          try {
            _.ws.send(m);
          } catch (g) {
            c("websocket closed before onclose event");
          }
        });
      function C() {
        _.writable = !0, _.emit("drain");
      }
      H(C, "ondrain"), setTimeout(C, 0);
    }, h.prototype.onClose = function() {
      r.prototype.onClose.call(this);
    }, h.prototype.doClose = function() {
      typeof this.ws != "undefined" && this.ws.close();
    }, h.prototype.uri = function() {
      var u = (this || window).query || {}, _ = (this || window).secure ? "wss" : "ws", d = "";
      return this.port && (_ == "wss" && this.port != 443 || _ == "ws" && this.port != 80) && (d = ":" + this.port), this.timestampRequests && (u[this.timestampParam] = +/* @__PURE__ */ new Date()), this.supportsBinary || (u.b64 = 1), u = o.encode(u), u.length && (u = "?" + u), _ + "://" + this.hostname + d + this.path + u;
    }, h.prototype.check = function() {
      return !!l && !("__initialize" in l && this.name === h.prototype.name);
    };
  }, { "../transport": 14, "component-inherit": 21, debug: 22, "engine.io-parser": 25, parseqs: 35, ws: 37 }], 20: [function(t, e, n) {
    var r = t("has-cors");
    e.exports = function(s) {
      var o = s.xdomain, a = s.xscheme, c = s.enablesXDR;
      try {
        if (typeof XMLHttpRequest != "undefined" && (!o || r))
          return new XMLHttpRequest();
      } catch (l) {
      }
      try {
        if (typeof XDomainRequest != "undefined" && !a && c)
          return new XDomainRequest();
      } catch (l) {
      }
      if (!o)
        try {
          return new ActiveXObject("Microsoft.XMLHTTP");
        } catch (l) {
        }
    };
  }, { "has-cors": 40 }], 21: [function(t, e, n) {
    e.exports = function(r, s) {
      var o = /* @__PURE__ */ H(function() {
      }, "fn");
      o.prototype = s.prototype, r.prototype = new o(), r.prototype.constructor = r;
    };
  }, {}], 22: [function(t, e, n) {
    n = e.exports = t("./debug"), n.log = o, n.formatArgs = s, n.save = a, n.load = c, n.useColors = r, n.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"];
    function r() {
      return "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
    }
    H(r, "useColors"), n.formatters.j = function(l) {
      return JSON.stringify(l);
    };
    function s() {
      var l = arguments, h = (this || window).useColors;
      if (l[0] = (h ? "%c" : "") + this.namespace + (h ? " %c" : " ") + l[0] + (h ? "%c " : " ") + "+" + n.humanize(this.diff), !h)
        return l;
      var u = "color: " + this.color;
      l = [l[0], u, "color: inherit"].concat(Array.prototype.slice.call(l, 1));
      var _ = 0, d = 0;
      return l[0].replace(/%[a-z%]/g, function(f) {
        f !== "%" && (_++, f === "%c" && (d = _));
      }), l.splice(d, 0, u), l;
    }
    H(s, "formatArgs");
    function o() {
      return typeof console == "object" && typeof console.log == "function" && Function.prototype.apply.call(console.log, console, arguments);
    }
    H(o, "log");
    function a(l) {
      try {
        l == null ? localStorage.removeItem("debug") : localStorage.debug = l;
      } catch (h) {
      }
    }
    H(a, "save");
    function c() {
      var l;
      try {
        l = localStorage.debug;
      } catch (h) {
      }
      return l;
    }
    H(c, "load"), n.enable(c());
  }, { "./debug": 23 }], 23: [function(t, e, n) {
    n = e.exports = a, n.coerce = u, n.disable = l, n.enable = c, n.enabled = h, n.humanize = t("ms"), n.names = [], n.skips = [], n.formatters = {};
    var r = 0, s;
    function o() {
      return n.colors[r++ % n.colors.length];
    }
    H(o, "selectColor");
    function a(_) {
      function d() {
      }
      H(d, "disabled"), d.enabled = !1;
      function f() {
        var m = f, g = +/* @__PURE__ */ new Date(), y = g - (s || g);
        m.diff = y, m.prev = s, m.curr = g, s = g, m.useColors == null && (m.useColors = n.useColors()), m.color == null && m.useColors && (m.color = o());
        var A = Array.prototype.slice.call(arguments);
        A[0] = n.coerce(A[0]), typeof A[0] != "string" && (A = ["%o"].concat(A));
        var D = 0;
        A[0] = A[0].replace(/%([a-z%])/g, function(z, M) {
          if (z === "%")
            return z;
          D++;
          var Z = n.formatters[M];
          if (typeof Z == "function") {
            var U = A[D];
            z = Z.call(m, U), A.splice(D, 1), D--;
          }
          return z;
        }), typeof n.formatArgs == "function" && (A = n.formatArgs.apply(m, A));
        var N = f.log || n.log || console.log.bind(console);
        N.apply(m, A);
      }
      H(f, "enabled"), f.enabled = !0;
      var C = n.enabled(_) ? f : d;
      return C.namespace = _, C;
    }
    H(a, "debug");
    function c(_) {
      n.save(_);
      for (var d = (_ || "").split(/[\s,]+/), f = d.length, C = 0; C < f; C++)
        d[C] && (_ = d[C].replace(/\*/g, ".*?"), _[0] === "-" ? n.skips.push(new RegExp("^" + _.substr(1) + "$")) : n.names.push(new RegExp("^" + _ + "$")));
    }
    H(c, "enable");
    function l() {
      n.enable("");
    }
    H(l, "disable");
    function h(_) {
      var d, f;
      for (d = 0, f = n.skips.length; d < f; d++)
        if (n.skips[d].test(_))
          return !1;
      for (d = 0, f = n.names.length; d < f; d++)
        if (n.names[d].test(_))
          return !0;
      return !1;
    }
    H(h, "enabled");
    function u(_) {
      return _ instanceof Error ? _.stack || _.message : _;
    }
    H(u, "coerce");
  }, { ms: 24 }], 24: [function(t, e, n) {
    var r = 1e3, s = r * 60, o = s * 60, a = o * 24, c = a * 365.25;
    e.exports = function(d, f) {
      return f = f || {}, typeof d == "string" ? l(d) : f.long ? u(d) : h(d);
    };
    function l(d) {
      var f = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(d);
      if (f) {
        var C = parseFloat(f[1]), m = (f[2] || "ms").toLowerCase();
        switch (m) {
          case "years":
          case "year":
          case "y":
            return C * c;
          case "days":
          case "day":
          case "d":
            return C * a;
          case "hours":
          case "hour":
          case "h":
            return C * o;
          case "minutes":
          case "minute":
          case "m":
            return C * s;
          case "seconds":
          case "second":
          case "s":
            return C * r;
          case "ms":
            return C;
        }
      }
    }
    H(l, "parse");
    function h(d) {
      return d >= a ? Math.round(d / a) + "d" : d >= o ? Math.round(d / o) + "h" : d >= s ? Math.round(d / s) + "m" : d >= r ? Math.round(d / r) + "s" : d + "ms";
    }
    H(h, "short");
    function u(d) {
      return _(d, a, "day") || _(d, o, "hour") || _(d, s, "minute") || _(d, r, "second") || d + " ms";
    }
    H(u, "long");
    function _(d, f, C) {
      if (!(d < f))
        return d < f * 1.5 ? Math.floor(d / f) + " " + C : Math.ceil(d / f) + " " + C + "s";
    }
    H(_, "plural");
  }, {}], 25: [function(t, e, n) {
    (function(r) {
      var s = t("./keys"), o = t("has-binary"), a = t("arraybuffer.slice"), c = t("base64-arraybuffer"), l = t("after"), h = t("utf8"), u = navigator.userAgent.match(/Android/i), _ = /PhantomJS/i.test(navigator.userAgent), d = u || _;
      n.protocol = 3;
      var f = n.packets = { open: 0, close: 1, ping: 2, pong: 3, message: 4, upgrade: 5, noop: 6 }, C = s(f), m = { type: "error", data: "parser error" }, g = t("blob");
      n.encodePacket = function(M, Z, U, Q) {
        typeof Z == "function" && (Q = Z, Z = !1), typeof U == "function" && (Q = U, U = null);
        var et = M.data === void 0 ? void 0 : M.data.buffer || M.data;
        if (r.ArrayBuffer && et instanceof ArrayBuffer)
          return A(M, Z, Q);
        if (g && et instanceof r.Blob)
          return N(M, Z, Q);
        if (et && et.base64)
          return y(M, Q);
        var rt = f[M.type];
        return M.data !== void 0 && (rt += U ? h.encode(String(M.data)) : String(M.data)), Q("" + rt);
      };
      function y(M, Z) {
        var U = "b" + n.packets[M.type] + M.data.data;
        return Z(U);
      }
      H(y, "encodeBase64Object");
      function A(M, Z, U) {
        if (!Z)
          return n.encodeBase64Packet(M, U);
        var Q = M.data, et = new Uint8Array(Q), rt = new Uint8Array(1 + Q.byteLength);
        rt[0] = f[M.type];
        for (var w = 0; w < et.length; w++)
          rt[w + 1] = et[w];
        return U(rt.buffer);
      }
      H(A, "encodeArrayBuffer");
      function D(M, Z, U) {
        if (!Z)
          return n.encodeBase64Packet(M, U);
        var Q = new FileReader();
        return Q.onload = function() {
          M.data = Q.result, n.encodePacket(M, Z, !0, U);
        }, Q.readAsArrayBuffer(M.data);
      }
      H(D, "encodeBlobAsArrayBuffer");
      function N(M, Z, U) {
        if (!Z)
          return n.encodeBase64Packet(M, U);
        if (d)
          return D(M, Z, U);
        var Q = new Uint8Array(1);
        Q[0] = f[M.type];
        var et = new g([Q.buffer, M.data]);
        return U(et);
      }
      H(N, "encodeBlob"), n.encodeBase64Packet = function(M, Z) {
        var U = "b" + n.packets[M.type];
        if (g && M.data instanceof g) {
          var Q = new FileReader();
          return Q.onload = function() {
            var G = Q.result.split(",")[1];
            Z(U + G);
          }, Q.readAsDataURL(M.data);
        }
        var et;
        try {
          et = String.fromCharCode.apply(null, new Uint8Array(M.data));
        } catch (G) {
          for (var rt = new Uint8Array(M.data), w = new Array(rt.length), L = 0; L < rt.length; L++)
            w[L] = rt[L];
          et = String.fromCharCode.apply(null, w);
        }
        return U += r.btoa(et), Z(U);
      }, n.decodePacket = function(M, Z, U) {
        if (typeof M == "string" || M === void 0) {
          if (M.charAt(0) == "b")
            return n.decodeBase64Packet(M.substr(1), Z);
          if (U)
            try {
              M = h.decode(M);
            } catch (L) {
              return m;
            }
          var et = M.charAt(0);
          return Number(et) != et || !C[et] ? m : M.length > 1 ? { type: C[et], data: M.substring(1) } : { type: C[et] };
        }
        var Q = new Uint8Array(M), et = Q[0], rt = a(M, 1);
        return g && Z === "blob" && (rt = new g([rt])), { type: C[et], data: rt };
      }, n.decodeBase64Packet = function(M, Z) {
        var U = C[M.charAt(0)];
        if (!r.ArrayBuffer)
          return { type: U, data: { base64: !0, data: M.substr(1) } };
        var Q = c.decode(M.substr(1));
        return Z === "blob" && g && (Q = new g([Q])), { type: U, data: Q };
      }, n.encodePayload = function(M, Z, U) {
        typeof Z == "function" && (U = Z, Z = null);
        var Q = o(M);
        if (Z && Q)
          return g && !d ? n.encodePayloadAsBlob(M, U) : n.encodePayloadAsArrayBuffer(M, U);
        if (!M.length)
          return U("0:");
        function et(w) {
          return w.length + ":" + w;
        }
        H(et, "setLengthHeader");
        function rt(w, L) {
          n.encodePacket(w, Q ? Z : !1, !0, function(G) {
            L(null, et(G));
          });
        }
        H(rt, "encodeOne"), z(M, rt, function(w, L) {
          return U(L.join(""));
        });
      };
      function z(M, Z, U) {
        for (var Q = new Array(M.length), et = l(M.length, U), rt = /* @__PURE__ */ H(function(L, G, I) {
          Z(G, function(O, K) {
            Q[L] = K, I(O, Q);
          });
        }, "eachWithIndex"), w = 0; w < M.length; w++)
          rt(w, M[w], et);
      }
      H(z, "map"), n.decodePayload = function(M, Z, U) {
        if (typeof M != "string")
          return n.decodePayloadAsBinary(M, Z, U);
        typeof Z == "function" && (U = Z, Z = null);
        var Q;
        if (M == "")
          return U(m, 0, 1);
        for (var et = "", rt, w, L = 0, G = M.length; L < G; L++) {
          var I = M.charAt(L);
          if (I != ":")
            et += I;
          else {
            if (et == "" || et != (rt = Number(et)) || (w = M.substr(L + 1, rt), et != w.length))
              return U(m, 0, 1);
            if (w.length) {
              if (Q = n.decodePacket(w, Z, !0), m.type == Q.type && m.data == Q.data)
                return U(m, 0, 1);
              var O = U(Q, L + rt, G);
              if (O === !1)
                return;
            }
            L += rt, et = "";
          }
        }
        if (et != "")
          return U(m, 0, 1);
      }, n.encodePayloadAsArrayBuffer = function(M, Z) {
        if (!M.length)
          return Z(new ArrayBuffer(0));
        function U(Q, et) {
          n.encodePacket(Q, !0, !0, function(rt) {
            return et(null, rt);
          });
        }
        H(U, "encodeOne"), z(M, U, function(Q, et) {
          var rt = et.reduce(function(G, I) {
            var O;
            return typeof I == "string" ? O = I.length : O = I.byteLength, G + O.toString().length + O + 2;
          }, 0), w = new Uint8Array(rt), L = 0;
          return et.forEach(function(G) {
            var I = typeof G == "string", O = G;
            if (I) {
              for (var S = new Uint8Array(G.length), K = 0; K < G.length; K++)
                S[K] = G.charCodeAt(K);
              O = S.buffer;
            }
            I ? w[L++] = 0 : w[L++] = 1;
            for (var $ = O.byteLength.toString(), K = 0; K < $.length; K++)
              w[L++] = parseInt($[K]);
            w[L++] = 255;
            for (var S = new Uint8Array(O), K = 0; K < S.length; K++)
              w[L++] = S[K];
          }), Z(w.buffer);
        });
      }, n.encodePayloadAsBlob = function(M, Z) {
        function U(Q, et) {
          n.encodePacket(Q, !0, !0, function(rt) {
            var w = new Uint8Array(1);
            if (w[0] = 1, typeof rt == "string") {
              for (var L = new Uint8Array(rt.length), G = 0; G < rt.length; G++)
                L[G] = rt.charCodeAt(G);
              rt = L.buffer, w[0] = 0;
            }
            for (var I = rt instanceof ArrayBuffer ? rt.byteLength : rt.size, O = I.toString(), K = new Uint8Array(O.length + 1), G = 0; G < O.length; G++)
              K[G] = parseInt(O[G]);
            if (K[O.length] = 255, g) {
              var $ = new g([w.buffer, K.buffer, rt]);
              et(null, $);
            }
          });
        }
        H(U, "encodeOne"), z(M, U, function(Q, et) {
          return Z(new g(et));
        });
      }, n.decodePayloadAsBinary = function(M, Z, U) {
        typeof Z == "function" && (U = Z, Z = null);
        for (var Q = M, et = [], rt = !1; Q.byteLength > 0; ) {
          for (var w = new Uint8Array(Q), L = w[0] === 0, G = "", I = 1; w[I] != 255; I++) {
            if (G.length > 310) {
              rt = !0;
              break;
            }
            G += w[I];
          }
          if (rt)
            return U(m, 0, 1);
          Q = a(Q, 2 + G.length), G = parseInt(G);
          var O = a(Q, 0, G);
          if (L)
            try {
              O = String.fromCharCode.apply(null, new Uint8Array(O));
            } catch (S) {
              var K = new Uint8Array(O);
              O = "";
              for (var I = 0; I < K.length; I++)
                O += String.fromCharCode(K[I]);
            }
          et.push(O), Q = a(Q, G);
        }
        var $ = et.length;
        et.forEach(function(S, b) {
          U(n.decodePacket(S, Z, !0), b, $);
        });
      };
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "./keys": 26, after: 27, "arraybuffer.slice": 28, "base64-arraybuffer": 29, blob: 30, "has-binary": 31, utf8: 33 }], 26: [function(t, e, n) {
    e.exports = Object.keys || /* @__PURE__ */ H(function(s) {
      var o = [], a = Object.prototype.hasOwnProperty;
      for (var c in s)
        a.call(s, c) && o.push(c);
      return o;
    }, "keys");
  }, {}], 27: [function(t, e, n) {
    e.exports = r;
    function r(o, a, c) {
      var l = !1;
      return c = c || s, h.count = o, o === 0 ? a() : h;
      function h(u, _) {
        if (h.count <= 0)
          throw new Error("after called too many times");
        --h.count, u ? (l = !0, a(u), a = c) : h.count === 0 && !l && a(null, _);
      }
      H(h, "proxy");
    }
    H(r, "after");
    function s() {
    }
    H(s, "noop");
  }, {}], 28: [function(t, e, n) {
    e.exports = function(r, s, o) {
      var a = r.byteLength;
      if (s = s || 0, o = o || a, r.slice)
        return r.slice(s, o);
      if (s < 0 && (s += a), o < 0 && (o += a), o > a && (o = a), s >= a || s >= o || a === 0)
        return new ArrayBuffer(0);
      for (var c = new Uint8Array(r), l = new Uint8Array(o - s), h = s, u = 0; h < o; h++, u++)
        l[u] = c[h];
      return l.buffer;
    };
  }, {}], 29: [function(t, e, n) {
    (function(r) {
      n.encode = function(s) {
        var o = new Uint8Array(s), a, c = o.length, l = "";
        for (a = 0; a < c; a += 3)
          l += r[o[a] >> 2], l += r[(o[a] & 3) << 4 | o[a + 1] >> 4], l += r[(o[a + 1] & 15) << 2 | o[a + 2] >> 6], l += r[o[a + 2] & 63];
        return c % 3 === 2 ? l = l.substring(0, l.length - 1) + "=" : c % 3 === 1 && (l = l.substring(0, l.length - 2) + "=="), l;
      }, n.decode = function(s) {
        var o = s.length * 0.75, a = s.length, c, l = 0, h, u, _, d;
        s[s.length - 1] === "=" && (o--, s[s.length - 2] === "=" && o--);
        var f = new ArrayBuffer(o), C = new Uint8Array(f);
        for (c = 0; c < a; c += 4)
          h = r.indexOf(s[c]), u = r.indexOf(s[c + 1]), _ = r.indexOf(s[c + 2]), d = r.indexOf(s[c + 3]), C[l++] = h << 2 | u >> 4, C[l++] = (u & 15) << 4 | _ >> 2, C[l++] = (_ & 3) << 6 | d & 63;
        return f;
      };
    })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
  }, {}], 30: [function(t, e, n) {
    (function(r) {
      var s = r.BlobBuilder || r.WebKitBlobBuilder || r.MSBlobBuilder || r.MozBlobBuilder, o = function() {
        try {
          var l = new Blob(["hi"]);
          return l.size == 2;
        } catch (h) {
          return !1;
        }
      }(), a = s && s.prototype.append && s.prototype.getBlob;
      function c(l, h) {
        h = h || {};
        for (var u = new s(), _ = 0; _ < l.length; _++)
          u.append(l[_]);
        return h.type ? u.getBlob(h.type) : u.getBlob();
      }
      H(c, "BlobBuilderConstructor"), e.exports = function() {
        return o ? r.Blob : a ? c : void 0;
      }();
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, {}], 31: [function(t, e, n) {
    (function(r) {
      var s = t("isarray");
      e.exports = o;
      function o(a) {
        function c(l) {
          if (!l)
            return !1;
          if (r.Buffer && r.Buffer.isBuffer(l) || r.ArrayBuffer && l instanceof ArrayBuffer || r.Blob && l instanceof Blob || r.File && l instanceof File)
            return !0;
          if (s(l)) {
            for (var h = 0; h < l.length; h++)
              if (c(l[h]))
                return !0;
          } else if (l && typeof l == "object") {
            l.toJSON && (l = l.toJSON());
            for (var u in l)
              if (l.hasOwnProperty(u) && c(l[u]))
                return !0;
          }
          return !1;
        }
        return H(c, "_hasBinary"), c(a);
      }
      H(o, "hasBinary");
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { isarray: 32 }], 32: [function(t, e, n) {
    e.exports = Array.isArray || function(r) {
      return Object.prototype.toString.call(r) == "[object Array]";
    };
  }, {}], 33: [function(t, e, n) {
    (function(r) {
      (function(s) {
        var o = typeof n == "object" && n, a = typeof e == "object" && e && e.exports == o && e, c = typeof r == "object" && r;
        (c.global === c || c.window === c) && (s = c);
        var l = String.fromCharCode;
        function h(U) {
          for (var Q = [], et = 0, rt = U.length, w, L; et < rt; )
            w = U.charCodeAt(et++), w >= 55296 && w <= 56319 && et < rt ? (L = U.charCodeAt(et++), (L & 64512) == 56320 ? Q.push(((w & 1023) << 10) + (L & 1023) + 65536) : (Q.push(w), et--)) : Q.push(w);
          return Q;
        }
        H(h, "ucs2decode");
        function u(U) {
          for (var Q = U.length, et = -1, rt, w = ""; ++et < Q; )
            rt = U[et], rt > 65535 && (rt -= 65536, w += l(rt >>> 10 & 1023 | 55296), rt = 56320 | rt & 1023), w += l(rt);
          return w;
        }
        H(u, "ucs2encode");
        function _(U, Q) {
          return l(U >> Q & 63 | 128);
        }
        H(_, "createByte");
        function d(U) {
          if (!(U & 4294967168))
            return l(U);
          var Q = "";
          return U & 4294965248 ? U & 4294901760 ? U & 4292870144 || (Q = l(U >> 18 & 7 | 240), Q += _(U, 12), Q += _(U, 6)) : (Q = l(U >> 12 & 15 | 224), Q += _(U, 6)) : Q = l(U >> 6 & 31 | 192), Q += l(U & 63 | 128), Q;
        }
        H(d, "encodeCodePoint");
        function f(U) {
          for (var Q = h(U), et = Q.length, rt = -1, w, L = ""; ++rt < et; )
            w = Q[rt], L += d(w);
          return L;
        }
        H(f, "utf8encode");
        function C() {
          if (A >= y)
            throw Error("Invalid byte index");
          var U = g[A] & 255;
          if (A++, (U & 192) == 128)
            return U & 63;
          throw Error("Invalid continuation byte");
        }
        H(C, "readContinuationByte");
        function m() {
          var U, Q, et, rt, w;
          if (A > y)
            throw Error("Invalid byte index");
          if (A == y)
            return !1;
          if (U = g[A] & 255, A++, !(U & 128))
            return U;
          if ((U & 224) == 192) {
            var Q = C();
            if (w = (U & 31) << 6 | Q, w >= 128)
              return w;
            throw Error("Invalid continuation byte");
          }
          if ((U & 240) == 224) {
            if (Q = C(), et = C(), w = (U & 15) << 12 | Q << 6 | et, w >= 2048)
              return w;
            throw Error("Invalid continuation byte");
          }
          if ((U & 248) == 240 && (Q = C(), et = C(), rt = C(), w = (U & 15) << 18 | Q << 12 | et << 6 | rt, w >= 65536 && w <= 1114111))
            return w;
          throw Error("Invalid UTF-8 detected");
        }
        H(m, "decodeSymbol");
        var g, y, A;
        function D(U) {
          g = h(U), y = g.length, A = 0;
          for (var Q = [], et; (et = m()) !== !1; )
            Q.push(et);
          return u(Q);
        }
        H(D, "utf8decode");
        var N = { version: "2.0.0", encode: f, decode: D };
        if (o && !o.nodeType)
          if (a)
            a.exports = N;
          else {
            var z = {}, M = z.hasOwnProperty;
            for (var Z in N)
              M.call(N, Z) && (o[Z] = N[Z]);
          }
        else
          s.utf8 = N;
      })(this);
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, {}], 34: [function(t, e, n) {
    (function(r) {
      var s = /^[\],:{}\s]*$/, o = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, a = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, c = /(?:^|:|,)(?:\s*\[)+/g, l = /^\s+/, h = /\s+$/;
      e.exports = /* @__PURE__ */ H(function(_) {
        if (typeof _ != "string" || !_)
          return null;
        if (_ = _.replace(l, "").replace(h, ""), r.JSON && JSON.parse)
          return JSON.parse(_);
        if (s.test(_.replace(o, "@").replace(a, "]").replace(c, "")))
          return new Function("return " + _)();
      }, "parsejson");
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, {}], 35: [function(t, e, n) {
    n.encode = function(r) {
      var s = "";
      for (var o in r)
        r.hasOwnProperty(o) && (s.length && (s += "&"), s += encodeURIComponent(o) + "=" + encodeURIComponent(r[o]));
      return s;
    }, n.decode = function(r) {
      for (var s = {}, o = r.split("&"), a = 0, c = o.length; a < c; a++) {
        var l = o[a].split("=");
        s[decodeURIComponent(l[0])] = decodeURIComponent(l[1]);
      }
      return s;
    };
  }, {}], 36: [function(t, e, n) {
    var r = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, s = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
    e.exports = /* @__PURE__ */ H(function(a) {
      var c = a, l = a.indexOf("["), h = a.indexOf("]");
      l != -1 && h != -1 && (a = a.substring(0, l) + a.substring(l, h).replace(/:/g, ";") + a.substring(h, a.length));
      for (var u = r.exec(a || ""), _ = {}, d = 14; d--; )
        _[s[d]] = u[d] || "";
      return l != -1 && h != -1 && (_.source = c, _.host = _.host.substring(1, _.host.length - 1).replace(/;/g, ":"), _.authority = _.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), _.ipv6uri = !0), _;
    }, "parseuri");
  }, {}], 37: [function(t, e, n) {
    var r = function() {
      return (this || window)
    }(), s = r.WebSocket || r.MozWebSocket;
    e.exports = s ? o : null;
    function o(a, c, l) {
      var h;
      return c ? h = new s(a, c) : h = new s(a), h;
    }
    H(o, "ws"), s && (o.prototype = s.prototype);
  }, {}], 38: [function(t, e, n) {
    (function(r) {
      var s = t("isarray");
      e.exports = o;
      function o(a) {
        function c(l) {
          if (!l)
            return !1;
          if (r.Buffer && r.Buffer.isBuffer(l) || r.ArrayBuffer && l instanceof ArrayBuffer || r.Blob && l instanceof Blob || r.File && l instanceof File)
            return !0;
          if (s(l)) {
            for (var h = 0; h < l.length; h++)
              if (c(l[h]))
                return !0;
          } else if (l && typeof l == "object") {
            l.toJSON && (l = l.toJSON());
            for (var u in l)
              if (Object.prototype.hasOwnProperty.call(l, u) && c(l[u]))
                return !0;
          }
          return !1;
        }
        return H(c, "_hasBinary"), c(a);
      }
      H(o, "hasBinary");
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { isarray: 39 }], 39: [function(t, e, n) {
    e.exports = t(32);
  }, {}], 40: [function(t, e, n) {
    var r = t("global");
    try {
      e.exports = "XMLHttpRequest" in r && "withCredentials" in new r.XMLHttpRequest();
    } catch (s) {
      e.exports = !1;
    }
  }, { global: 41 }], 41: [function(t, e, n) {
    e.exports = function() {
      return (this || window)
    }();
  }, {}], 42: [function(t, e, n) {
    var r = [].indexOf;
    e.exports = function(s, o) {
      if (r)
        return s.indexOf(o);
      for (var a = 0; a < s.length; ++a)
        if (s[a] === o)
          return a;
      return -1;
    };
  }, {}], 43: [function(t, e, n) {
    var r = Object.prototype.hasOwnProperty;
    n.keys = Object.keys || function(s) {
      var o = [];
      for (var a in s)
        r.call(s, a) && o.push(a);
      return o;
    }, n.values = function(s) {
      var o = [];
      for (var a in s)
        r.call(s, a) && o.push(s[a]);
      return o;
    }, n.merge = function(s, o) {
      for (var a in o)
        r.call(o, a) && (s[a] = o[a]);
      return s;
    }, n.length = function(s) {
      return n.keys(s).length;
    }, n.isEmpty = function(s) {
      return n.length(s) == 0;
    };
  }, {}], 44: [function(t, e, n) {
    var r = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, s = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
    e.exports = /* @__PURE__ */ H(function(a) {
      for (var c = r.exec(a || ""), l = {}, h = 14; h--; )
        l[s[h]] = c[h] || "";
      return l;
    }, "parseuri");
  }, {}], 45: [function(t, e, n) {
    (function(r) {
      var s = t("isarray"), o = t("./is-buffer");
      n.deconstructPacket = function(a) {
        var c = [], l = a.data;
        function h(_) {
          if (!_)
            return _;
          if (o(_)) {
            var d = { _placeholder: !0, num: c.length };
            return c.push(_), d;
          } else if (s(_)) {
            for (var f = new Array(_.length), C = 0; C < _.length; C++)
              f[C] = h(_[C]);
            return f;
          } else if (typeof _ == "object" && !(_ instanceof Date)) {
            var f = {};
            for (var m in _)
              f[m] = h(_[m]);
            return f;
          }
          return _;
        }
        H(h, "_deconstructPacket");
        var u = a;
        return u.data = h(l), u.attachments = c.length, { packet: u, buffers: c };
      }, n.reconstructPacket = function(a, c) {
        function l(h) {
          if (h && h._placeholder) {
            var u = c[h.num];
            return u;
          } else if (s(h)) {
            for (var _ = 0; _ < h.length; _++)
              h[_] = l(h[_]);
            return h;
          } else if (h && typeof h == "object") {
            for (var d in h)
              h[d] = l(h[d]);
            return h;
          }
          return h;
        }
        return H(l, "_reconstructPacket"), a.data = l(a.data), a.attachments = void 0, a;
      }, n.removeBlobs = function(a, c) {
        function l(_, d, f) {
          if (!_)
            return _;
          if (r.Blob && _ instanceof Blob || r.File && _ instanceof File) {
            h++;
            var C = new FileReader();
            C.onload = function() {
              f ? f[d] = (this || window).result : u = (this || window).result, --h || c(u);
            }, C.readAsArrayBuffer(_);
          } else if (s(_))
            for (var m = 0; m < _.length; m++)
              l(_[m], m, _);
          else if (_ && typeof _ == "object" && !o(_))
            for (var g in _)
              l(_[g], g, _);
        }
        H(l, "_removeBlobs");
        var h = 0, u = a;
        l(u), h || c(u);
      };
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, { "./is-buffer": 47, isarray: 48 }], 46: [function(t, e, n) {
    var r = t("debug")("socket.io-parser"), s = t("json3");
    t("isarray");
    var o = t("component-emitter"), a = t("./binary"), c = t("./is-buffer");
    n.protocol = 4, n.types = ["CONNECT", "DISCONNECT", "EVENT", "BINARY_EVENT", "ACK", "BINARY_ACK", "ERROR"], n.CONNECT = 0, n.DISCONNECT = 1, n.EVENT = 2, n.ACK = 3, n.ERROR = 4, n.BINARY_EVENT = 5, n.BINARY_ACK = 6, n.Encoder = l, n.Decoder = _;
    function l() {
    }
    H(l, "Encoder"), l.prototype.encode = function(m, g) {
      if (r("encoding packet %j", m), n.BINARY_EVENT == m.type || n.BINARY_ACK == m.type)
        u(m, g);
      else {
        var y = h(m);
        g([y]);
      }
    };
    function h(m) {
      var g = "", y = !1;
      return g += m.type, (n.BINARY_EVENT == m.type || n.BINARY_ACK == m.type) && (g += m.attachments, g += "-"), m.nsp && m.nsp != "/" && (y = !0, g += m.nsp), m.id != null && (y && (g += ",", y = !1), g += m.id), m.data != null && (y && (g += ","), g += s.stringify(m.data)), r("encoded %j as %s", m, g), g;
    }
    H(h, "encodeAsString");
    function u(m, g) {
      function y(A) {
        var D = a.deconstructPacket(A), N = h(D.packet), z = D.buffers;
        z.unshift(N), g(z);
      }
      H(y, "writeEncoding"), a.removeBlobs(m, y);
    }
    H(u, "encodeAsBinary");
    function _() {
      this.reconstructor = null;
    }
    H(_, "Decoder"), o(_.prototype), _.prototype.add = function(m) {
      var g;
      if (typeof m == "string")
        g = d(m), n.BINARY_EVENT == g.type || n.BINARY_ACK == g.type ? (this.reconstructor = new f(g), this.reconstructor.reconPack.attachments === 0 && this.emit("decoded", g)) : this.emit("decoded", g);
      else if (c(m) || m.base64)
        if (this.reconstructor)
          g = (this || window).reconstructor.takeBinaryData(m), g && (this.reconstructor = null, this.emit("decoded", g));
        else
          throw new Error("got binary data when not reconstructing a packet");
      else
        throw new Error("Unknown type: " + m);
    };
    function d(m) {
      var g = {}, y = 0;
      if (g.type = Number(m.charAt(0)), n.types[g.type] == null)
        return C();
      if (n.BINARY_EVENT == g.type || n.BINARY_ACK == g.type) {
        for (var A = ""; m.charAt(++y) != "-" && (A += m.charAt(y), y != m.length); )
          ;
        if (A != Number(A) || m.charAt(y) != "-")
          throw new Error("Illegal attachments");
        g.attachments = Number(A);
      }
      if (m.charAt(y + 1) == "/")
        for (g.nsp = ""; ++y; ) {
          var D = m.charAt(y);
          if (D == "," || (g.nsp += D, y == m.length))
            break;
        }
      else
        g.nsp = "/";
      var N = m.charAt(y + 1);
      if (N !== "" && Number(N) == N) {
        for (g.id = ""; ++y; ) {
          var D = m.charAt(y);
          if (D == null || Number(D) != D) {
            --y;
            break;
          }
          if (g.id += m.charAt(y), y == m.length)
            break;
        }
        g.id = Number(g.id);
      }
      if (m.charAt(++y))
        try {
          g.data = s.parse(m.substr(y));
        } catch (z) {
          return C();
        }
      return r("decoded %s as %j", m, g), g;
    }
    H(d, "decodeString"), _.prototype.destroy = function() {
      this.reconstructor && this.reconstructor.finishedReconstruction();
    };
    function f(m) {
      this.reconPack = m, this.buffers = [];
    }
    H(f, "BinaryReconstructor"), f.prototype.takeBinaryData = function(m) {
      if (this.buffers.push(m), this.buffers.length == (this || window).reconPack.attachments) {
        var g = a.reconstructPacket(this.reconPack, this.buffers);
        return this.finishedReconstruction(), g;
      }
      return null;
    }, f.prototype.finishedReconstruction = function() {
      this.reconPack = null, this.buffers = [];
    };
    function C(m) {
      return { type: n.ERROR, data: "parser error" };
    }
    H(C, "error");
  }, { "./binary": 45, "./is-buffer": 47, "component-emitter": 9, debug: 10, isarray: 48, json3: 49 }], 47: [function(t, e, n) {
    (function(r) {
      e.exports = s;
      function s(o) {
        return r.Buffer && r.Buffer.isBuffer(o) || r.ArrayBuffer && o instanceof ArrayBuffer;
      }
      H(s, "isBuf");
    }).call(this, typeof self != "undefined" ? self : typeof window != "undefined" ? window : {});
  }, {}], 48: [function(t, e, n) {
    e.exports = t(32);
  }, {}], 49: [function(t, e, n) {
    (function(r) {
      var s = {}.toString, o, a, c, l = typeof JSON == "object" && JSON, h = typeof n == "object" && n && !n.nodeType && n;
      h && l ? (h.stringify = l.stringify, h.parse = l.parse) : h = r.JSON = l || {};
      var u = /* @__PURE__ */ new Date(-3509827334573292);
      try {
        u = u.getUTCFullYear() == -109252 && u.getUTCMonth() === 0 && u.getUTCDate() === 1 && u.getUTCHours() == 10 && u.getUTCMinutes() == 37 && u.getUTCSeconds() == 6 && u.getUTCMilliseconds() == 708;
      } catch (E) {
      }
      function _(E) {
        if (_[E] !== c)
          return _[E];
        var R;
        if (E == "bug-string-char-index")
          R = "a"[0] != "a";
        else if (E == "json")
          R = _("json-stringify") && _("json-parse");
        else {
          var F, k = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
          if (E == "json-stringify") {
            var X = h.stringify, j = typeof X == "function" && u;
            if (j) {
              (F = /* @__PURE__ */ H(function() {
                return 1;
              }, "value")).toJSON = F;
              try {
                j = X(0) === "0" && X(new Number()) === "0" && X(new String()) == '""' && X(s) === c && X(c) === c && X() === c && X(F) === "1" && X([F]) == "[1]" && X([c]) == "[null]" && X(null) == "null" && X([c, s, null]) == "[null,null,null]" && X({ a: [F, !0, !1, null, `\0\b
\f\r	`] }) == k && X(null, F) === "1" && X([1, 2], null, 1) == `[
 1,
 2
]` && X(/* @__PURE__ */ new Date(-864e13)) == '"-271821-04-20T00:00:00.000Z"' && X(/* @__PURE__ */ new Date(864e13)) == '"+275760-09-13T00:00:00.000Z"' && X(/* @__PURE__ */ new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' && X(/* @__PURE__ */ new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
              } catch (tt) {
                j = !1;
              }
            }
            R = j;
          }
          if (E == "json-parse") {
            var V = h.parse;
            if (typeof V == "function")
              try {
                if (V("0") === 0 && !V(!1)) {
                  F = V(k);
                  var Y = F.a.length == 5 && F.a[0] === 1;
                  if (Y) {
                    try {
                      Y = !V('"	"');
                    } catch (tt) {
                    }
                    if (Y)
                      try {
                        Y = V("01") !== 1;
                      } catch (tt) {
                      }
                    if (Y)
                      try {
                        Y = V("1.") !== 1;
                      } catch (tt) {
                      }
                  }
                }
              } catch (tt) {
                Y = !1;
              }
            R = Y;
          }
        }
        return _[E] = !!R;
      }
      if (H(_, "has"), !_("json")) {
        var d = "[object Function]", f = "[object Date]", C = "[object Number]", m = "[object String]", g = "[object Array]", y = "[object Boolean]", A = _("bug-string-char-index");
        if (!u)
          var D = Math.floor, N = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], z = /* @__PURE__ */ H(function(E, R) {
            return N[R] + 365 * (E - 1970) + D((E - 1969 + (R = +(R > 1))) / 4) - D((E - 1901 + R) / 100) + D((E - 1601 + R) / 400);
          }, "getDay");
        (o = {}.hasOwnProperty) || (o = /* @__PURE__ */ H(function(E) {
          var R = {}, F;
          return (R.__proto__ = null, R.__proto__ = { toString: 1 }, R).toString != s ? o = /* @__PURE__ */ H(function(k) {
            var X = (this || window).__proto__, j = k in (this.__proto__ = null, this);
            return this.__proto__ = X, j;
          }, "isProperty") : (F = R.constructor, o = /* @__PURE__ */ H(function(k) {
            var X = (this.constructor || F).prototype;
            return k in this && !(k in X && this[k] === X[k]);
          }, "isProperty")), R = null, o.call(this, E);
        }, "isProperty"));
        var M = { boolean: 1, number: 1, string: 1, undefined: 1 }, Z = /* @__PURE__ */ H(function(E, R) {
          var F = typeof E[R];
          return F == "object" ? !!E[R] : !M[F];
        }, "isHostType");
        if (a = /* @__PURE__ */ H(function(E, R) {
          var F = 0, k, X, j;
          (k = /* @__PURE__ */ H(function() {
            this.valueOf = 0;
          }, "Properties")).prototype.valueOf = 0, X = new k();
          for (j in X)
            o.call(X, j) && F++;
          return k = X = null, F ? F == 2 ? a = /* @__PURE__ */ H(function(V, Y) {
            var tt = {}, it = s.call(V) == d, lt;
            for (lt in V)
              !(it && lt == "prototype") && !o.call(tt, lt) && (tt[lt] = 1) && o.call(V, lt) && Y(lt);
          }, "forEach") : a = /* @__PURE__ */ H(function(V, Y) {
            var tt = s.call(V) == d, it, lt;
            for (it in V)
              !(tt && it == "prototype") && o.call(V, it) && !(lt = it === "constructor") && Y(it);
            (lt || o.call(V, it = "constructor")) && Y(it);
          }, "forEach") : (X = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"], a = /* @__PURE__ */ H(function(V, Y) {
            var tt = s.call(V) == d, it, lt, ut = !tt && typeof V.constructor != "function" && Z(V, "hasOwnProperty") ? V.hasOwnProperty : o;
            for (it in V)
              !(tt && it == "prototype") && ut.call(V, it) && Y(it);
            for (lt = X.length; it = X[--lt]; ut.call(V, it) && Y(it))
              ;
          }, "forEach")), a(E, R);
        }, "forEach"), !_("json-stringify")) {
          var U = { 92: "\\\\", 34: '\\"', 8: "\\b", 12: "\\f", 10: "\\n", 13: "\\r", 9: "\\t" }, Q = "000000", et = /* @__PURE__ */ H(function(E, R) {
            return (Q + (R || 0)).slice(-E);
          }, "toPaddedString"), rt = "\\u00", w = /* @__PURE__ */ H(function(E) {
            var R = '"', F = 0, k = E.length, X = k > 10 && A, j;
            for (X && (j = E.split("")); F < k; F++) {
              var V = E.charCodeAt(F);
              switch (V) {
                case 8:
                case 9:
                case 10:
                case 12:
                case 13:
                case 34:
                case 92:
                  R += U[V];
                  break;
                default:
                  if (V < 32) {
                    R += rt + et(2, V.toString(16));
                    break;
                  }
                  R += X ? j[F] : A ? E.charAt(F) : E[F];
              }
            }
            return R + '"';
          }, "quote"), L = /* @__PURE__ */ H(function(E, R, F, k, X, j, V) {
            var Y, tt, it, lt, ut, ft, vt, pt, gt, St, ht, ct, bt, Et, wt, It;
            try {
              Y = R[E];
            } catch (Dt) {
            }
            if (typeof Y == "object" && Y)
              if (tt = s.call(Y), tt == f && !o.call(Y, "toJSON"))
                if (Y > -1 / 0 && Y < 1 / 0) {
                  if (z) {
                    for (ut = D(Y / 864e5), it = D(ut / 365.2425) + 1970 - 1; z(it + 1, 0) <= ut; it++)
                      ;
                    for (lt = D((ut - z(it, 0)) / 30.42); z(it, lt + 1) <= ut; lt++)
                      ;
                    ut = 1 + ut - z(it, lt), ft = (Y % 864e5 + 864e5) % 864e5, vt = D(ft / 36e5) % 24, pt = D(ft / 6e4) % 60, gt = D(ft / 1e3) % 60, St = ft % 1e3;
                  } else
                    it = Y.getUTCFullYear(), lt = Y.getUTCMonth(), ut = Y.getUTCDate(), vt = Y.getUTCHours(), pt = Y.getUTCMinutes(), gt = Y.getUTCSeconds(), St = Y.getUTCMilliseconds();
                  Y = (it <= 0 || it >= 1e4 ? (it < 0 ? "-" : "+") + et(6, it < 0 ? -it : it) : et(4, it)) + "-" + et(2, lt + 1) + "-" + et(2, ut) + "T" + et(2, vt) + ":" + et(2, pt) + ":" + et(2, gt) + "." + et(3, St) + "Z";
                } else
                  Y = null;
              else
                typeof Y.toJSON == "function" && (tt != C && tt != m && tt != g || o.call(Y, "toJSON")) && (Y = Y.toJSON(E));
            if (F && (Y = F.call(R, E, Y)), Y === null)
              return "null";
            if (tt = s.call(Y), tt == y)
              return "" + Y;
            if (tt == C)
              return Y > -1 / 0 && Y < 1 / 0 ? "" + Y : "null";
            if (tt == m)
              return w("" + Y);
            if (typeof Y == "object") {
              for (Et = V.length; Et--; )
                if (V[Et] === Y)
                  throw TypeError();
              if (V.push(Y), ht = [], wt = j, j += X, tt == g) {
                for (bt = 0, Et = Y.length; bt < Et; bt++)
                  ct = L(bt, Y, F, k, X, j, V), ht.push(ct === c ? "null" : ct);
                It = ht.length ? X ? `[
` + j + ht.join(`,
` + j) + `
` + wt + "]" : "[" + ht.join(",") + "]" : "[]";
              } else
                a(k || Y, function(Dt) {
                  var Ut = L(Dt, Y, F, k, X, j, V);
                  Ut !== c && ht.push(w(Dt) + ":" + (X ? " " : "") + Ut);
                }), It = ht.length ? X ? `{
` + j + ht.join(`,
` + j) + `
` + wt + "}" : "{" + ht.join(",") + "}" : "{}";
              return V.pop(), It;
            }
          }, "serialize");
          h.stringify = function(E, R, F) {
            var k, X, j, V;
            if (typeof R == "function" || typeof R == "object" && R) {
              if ((V = s.call(R)) == d)
                X = R;
              else if (V == g) {
                j = {};
                for (var Y = 0, tt = R.length, it; Y < tt; it = R[Y++], V = s.call(it), (V == m || V == C) && (j[it] = 1))
                  ;
              }
            }
            if (F)
              if ((V = s.call(F)) == C) {
                if ((F -= F % 1) > 0)
                  for (k = "", F > 10 && (F = 10); k.length < F; k += " ")
                    ;
              } else
                V == m && (k = F.length <= 10 ? F : F.slice(0, 10));
            return L("", (it = {}, it[""] = E, it), X, j, k, "", []);
          };
        }
        if (!_("json-parse")) {
          var G = String.fromCharCode, I = { 92: "\\", 34: '"', 47: "/", 98: "\b", 116: "	", 110: `
`, 102: "\f", 114: "\r" }, O, K, $ = /* @__PURE__ */ H(function() {
            throw O = K = null, SyntaxError();
          }, "abort"), S = /* @__PURE__ */ H(function() {
            for (var E = K, R = E.length, F, k, X, j, V; O < R; )
              switch (V = E.charCodeAt(O), V) {
                case 9:
                case 10:
                case 13:
                case 32:
                  O++;
                  break;
                case 123:
                case 125:
                case 91:
                case 93:
                case 58:
                case 44:
                  return F = A ? E.charAt(O) : E[O], O++, F;
                case 34:
                  for (F = "@", O++; O < R; )
                    if (V = E.charCodeAt(O), V < 32)
                      $();
                    else if (V == 92)
                      switch (V = E.charCodeAt(++O), V) {
                        case 92:
                        case 34:
                        case 47:
                        case 98:
                        case 116:
                        case 110:
                        case 102:
                        case 114:
                          F += I[V], O++;
                          break;
                        case 117:
                          for (k = ++O, X = O + 4; O < X; O++)
                            V = E.charCodeAt(O), V >= 48 && V <= 57 || V >= 97 && V <= 102 || V >= 65 && V <= 70 || $();
                          F += G("0x" + E.slice(k, O));
                          break;
                        default:
                          $();
                      }
                    else {
                      if (V == 34)
                        break;
                      for (V = E.charCodeAt(O), k = O; V >= 32 && V != 92 && V != 34; )
                        V = E.charCodeAt(++O);
                      F += E.slice(k, O);
                    }
                  if (E.charCodeAt(O) == 34)
                    return O++, F;
                  $();
                default:
                  if (k = O, V == 45 && (j = !0, V = E.charCodeAt(++O)), V >= 48 && V <= 57) {
                    for (V == 48 && (V = E.charCodeAt(O + 1), V >= 48 && V <= 57) && $(), j = !1; O < R && (V = E.charCodeAt(O), V >= 48 && V <= 57); O++)
                      ;
                    if (E.charCodeAt(O) == 46) {
                      for (X = ++O; X < R && (V = E.charCodeAt(X), V >= 48 && V <= 57); X++)
                        ;
                      X == O && $(), O = X;
                    }
                    if (V = E.charCodeAt(O), V == 101 || V == 69) {
                      for (V = E.charCodeAt(++O), (V == 43 || V == 45) && O++, X = O; X < R && (V = E.charCodeAt(X), V >= 48 && V <= 57); X++)
                        ;
                      X == O && $(), O = X;
                    }
                    return +E.slice(k, O);
                  }
                  if (j && $(), E.slice(O, O + 4) == "true")
                    return O += 4, !0;
                  if (E.slice(O, O + 5) == "false")
                    return O += 5, !1;
                  if (E.slice(O, O + 4) == "null")
                    return O += 4, null;
                  $();
              }
            return "$";
          }, "lex"), b = /* @__PURE__ */ H(function(E) {
            var R, F;
            if (E == "$" && $(), typeof E == "string") {
              if ((A ? E.charAt(0) : E[0]) == "@")
                return E.slice(1);
              if (E == "[") {
                for (R = []; E = S(), E != "]"; F || (F = !0))
                  F && (E == "," ? (E = S(), E == "]" && $()) : $()), E == "," && $(), R.push(b(E));
                return R;
              } else if (E == "{") {
                for (R = {}; E = S(), E != "}"; F || (F = !0))
                  F && (E == "," ? (E = S(), E == "}" && $()) : $()), (E == "," || typeof E != "string" || (A ? E.charAt(0) : E[0]) != "@" || S() != ":") && $(), R[E.slice(1)] = b(S());
                return R;
              }
              $();
            }
            return E;
          }, "get"), W = /* @__PURE__ */ H(function(E, R, F) {
            var k = x(E, R, F);
            k === c ? delete E[R] : E[R] = k;
          }, "update"), x = /* @__PURE__ */ H(function(E, R, F) {
            var k = E[R], X;
            if (typeof k == "object" && k)
              if (s.call(k) == g)
                for (X = k.length; X--; )
                  W(k, X, F);
              else
                a(k, function(j) {
                  W(k, j, F);
                });
            return F.call(E, R, k);
          }, "walk");
          h.parse = function(E, R) {
            var F, k;
            return O = 0, K = "" + E, F = b(S()), S() != "$" && $(), O = K = null, R && s.call(R) == d ? x((k = {}, k[""] = F, k), "", R) : F;
          };
        }
      }
    })(this);
  }, {}], 50: [function(t, e, n) {
    e.exports = r;
    function r(s, o) {
      var a = [];
      o = o || 0;
      for (var c = o || 0; c < s.length; c++)
        a[c - o] = s[c];
      return a;
    }
    H(r, "toArray");
  }, {}] }, {}, [1])(1);
});
var gaf = gaf || {};
gaf.COMPRESSION_NONE = 4669766;
gaf.COMPRESSION_ZIP = 4669763;
gaf.IDNONE = 4294967295;
gaf.FIRST_FRAME_INDEX = 0;
gaf.EFFECT_DROP_SHADOW = 0;
gaf.EFFECT_BLUR = 1;
gaf.EFFECT_GLOW = 2;
gaf.EFFECT_COLOR_MATRIX = 6;
gaf.ACTION_STOP = 0;
gaf.ACTION_PLAY = 1;
gaf.ACTION_GO_TO_AND_STOP = 2;
gaf.ACTION_GO_TO_AND_PLAY = 3;
gaf.ACTION_DISPATCH_EVENT = 4;
gaf.PI_FRAME = 0;
gaf.PI_EVENT_TYPE = 0;
gaf.TYPE_TEXTURE = 0;
gaf.TYPE_TEXT_FIELD = 1;
gaf.TYPE_TIME_LINE = 2;
gaf.UNIFORM_BLUR_TEXEL_OFFSET = "u_step";
gaf.UNIFORM_GLOW_TEXEL_OFFSET = "u_step";
gaf.UNIFORM_GLOW_COLOR = "u_glowColor";
gaf.UNIFORM_ALPHA_TINT_MULT = "colorTransformMult";
gaf.UNIFORM_ALPHA_TINT_OFFSET = "colorTransformOffsets";
gaf.UNIFORM_ALPHA_COLOR_MATRIX_BODY = "colorMatrix";
gaf.UNIFORM_ALPHA_COLOR_MATRIX_APPENDIX = "colorMatrix2";
var gaf = gaf || {};
gaf._tmp = gaf._tmp || {};
gaf._initialized = !1;
gaf.CCGAFLoader = function() {
  this.load = function(t, e, n, r) {
    gaf._initialized || gaf._setup();
    var s = new gaf.Loader();
    s.LoadFile(t, function(o) {
      r(null, o);
    });
  };
};
gaf._setup = function() {
  gaf._setupShaders(), gaf._initialized = !0;
};
cc.loader.register(".gaf", new gaf.CCGAFLoader());
gaf.CGAffineTransformCocosFormatFromFlashFormat = function(t) {
  var e = {};
  return e.a = t.a, e.b = -t.b, e.c = -t.c, e.d = t.d, e.tx = t.tx, e.ty = -t.ty, e;
};
gaf._AssetPreload = function() {
  this[0] = (this || window).End, this[1] = (this || window).Atlases, this[2] = (this || window).AnimationMasks, this[3] = (this || window).AnimationObjects, this[4] = (this || window).AnimationFrames, this[5] = (this || window).NamedParts, this[6] = (this || window).Sequences, this[7] = (this || window).TextFields, this[8] = (this || window).Atlases, this[9] = (this || window).Stage, this[10] = (this || window).AnimationObjects, this[11] = (this || window).AnimationMasks, this[12] = (this || window).AnimationFrames, this[13] = (this || window).TimeLine;
};
gaf._AssetPreload.prototype.End = function(t, e, n) {
  n && (n.getFps = function() {
    return t.getSceneFps();
  });
};
gaf._AssetPreload.prototype.Tag = function(t, e, n) {
  this[e.tagId].call(this, t, e.content, n);
};
gaf._AssetPreload.prototype.Tags = function(t, e, n) {
  var r = (this || window);
  e.forEach(function(s) {
    r.Tag(t, s, n);
  });
};
gaf._AssetPreload.prototype.AtlasCreateFrames = function(t, e, n) {
  t.forEach(function(r) {
    var s = e._atlases[r.atlasId], o = cc.rect(r.origin.x, r.origin.y, r.size.x, r.size.y), a = new cc.SpriteFrame(s, o);
    a._gafAnchor = {
      x: 0 - (0 - r.pivot.x / r.size.x),
      y: 0 + (1 - r.pivot.y / r.size.y)
    }, n[r.elementAtlasId] = a;
  });
};
gaf._AssetPreload.prototype.Atlases = function(t, e, n) {
  var r = t._atlasScales[e.scale] = t._atlasScales[e.scale] || [], s = cc.Director._getInstance().getContentScaleFactor();
  e.atlases.forEach(function(o) {
    var a = o.id, c = /* @__PURE__ */ H(function() {
      gaf._AssetPreload.AtlasCreateFrames(e.elements, t, r);
    }, "finalizeLoading"), l = "";
    o.sources.forEach(function(y) {
      y.csf === s && (l = y.source);
    }), cc.assert(l, "GAF Error. Texture for current CSF not found. Reconvert animation with correct parameters."), t._textureLoadDelegate && (l = t._textureLoadDelegate(l));
    for (var h = !1, u = t._getSearchPaths(l), _ = 0, d = u.length; _ < d; ++_) {
      var f = u[_], C = cc.textureCache.getTextureForKey(f);
      if (C && C.isLoaded()) {
        C.handleLoadedTexture(!0), h = !0, t._atlases[a] = C, c();
        break;
      }
    }
    if (!h) {
      var m = /* @__PURE__ */ H(function(y) {
        y.handleLoadedTexture(!0), t._onAtlasLoaded(a, y);
      }, "success"), g = /* @__PURE__ */ H(function() {
        cc.log("GAF Error. Couldn't find `" + l + "` required by `" + t.getGAFFileName() + "`");
      }, "fail");
      t._atlasesToLoad.hasOwnProperty(a) || (gaf._AtlasLoader.loadArray(u, m, g), t._atlasesToLoad[a] = {}), t._onLoadTasks.push(c);
    }
  });
};
gaf._AssetPreload.prototype.AnimationObjects = function(t, e, n) {
  e.forEach(function(r) {
    r.type = r.type === void 0 ? gaf.TYPE_TEXTURE : r.type, n._objects.push(r.objectId), t._objects[r.objectId] = r;
  });
};
gaf._AssetPreload.prototype.convertTint = function(t, e) {
  return t ? {
    mult: {
      r: t.redMultiplier * 255,
      g: t.greenMultiplier * 255,
      b: t.blueMultiplier * 255,
      a: e * 255
    },
    offset: {
      r: t.redOffset * 255,
      g: t.greenOffset * 255,
      b: t.blueOffset * 255,
      a: t.alphaOffset * 255
    }
  } : null;
};
gaf._AssetPreload.prototype.convertState = function(t) {
  return {
    hasColorTransform: t.hasColorTransform,
    hasMask: t.hasMask,
    hasEffect: t.hasEffect,
    objectIdRef: t.objectIdRef,
    depth: t.depth,
    alpha: t.alpha * 255,
    matrix: gaf.CGAffineTransformCocosFormatFromFlashFormat(t.matrix),
    colorTransform: this.convertTint(t.colorTransform, t.alpha),
    effect: t.effect,
    maskObjectIdRef: t.maskObjectIdRef
  };
};
gaf._AssetPreload.prototype.AnimationFrames = function(t, e, n) {
  var r = (this || window);
  cc.assert(n, "Error. Time Line should not be null.");
  for (var s = {}, o = [], a = 0, c = e.length; a < c; ++a) {
    var l = e[a];
    l.state && l.state.forEach(function(_) {
      _.alpha !== 0 ? s[_.objectIdRef] = r.convertState(_) : s[_.objectIdRef] = null;
    });
    var h = [];
    for (var u in s)
      s.hasOwnProperty(u) && s[u] && h.push(s[u]);
    o[l.frame - 1] = { states: h, actions: l.actions || null };
  }
  n.getFrames = function() {
    return o;
  };
};
gaf._AssetPreload.prototype.NamedParts = function(t, e, n) {
  var r = {};
  e.forEach(function(s) {
    r[s.name] = s.objectId;
  }), n.getNamedParts = function() {
    return r;
  };
};
gaf._AssetPreload.prototype.Sequences = function(t, e, n) {
  var r = {};
  e.forEach(function(s) {
    r[s.id] = { start: s.start - 1, end: s.end };
  }), n.getSequences = function() {
    return r;
  };
};
gaf._AssetPreload.prototype.TextFields = function(t, e, n) {
  debugger;
};
gaf._AssetPreload.prototype.Stage = function(t, e, n) {
  t._sceneFps = e.fps, t._sceneColor = e.color, t._sceneWidth = e.width, t._sceneHeight = e.height;
};
gaf._AssetPreload.prototype.AnimationMasks = function(t, e, n) {
  e.forEach(function(r) {
    r.type = r.type === void 0 ? gaf.TYPE_TEXTURE : r.type, n._objects.push(r.objectId), t._masks[r.objectId] = r;
  });
};
gaf._AssetPreload.prototype.TimeLine = function(t, e, n) {
  var r = new gaf._TimeLineProto(t, e.animationFrameCount, e.boundingBox, e.pivotPoint, e.id, e.linkageName);
  t._pushTimeLine(r), this.Tags(t, e.tags, r);
};
gaf._AssetPreload = new gaf._AssetPreload();
var gaf = gaf || {};
gaf.Asset = cc.Class.extend({
  _className: "GAFAsset",
  _header: null,
  _timeLines: null,
  _textFields: null,
  _protos: null,
  _objects: null,
  _masks: null,
  _rootTimeLine: null,
  _textureLoadDelegate: null,
  _sceneFps: 60,
  _sceneWidth: 0,
  _sceneHeight: 0,
  _sceneColor: 0,
  _gafData: null,
  _desiredAtlasScale: 1,
  _usedAtlasScale: 0,
  _atlases: null,
  _onLoadTasks: null,
  _atlasScales: null,
  _textureLoaded: !1,
  _atlasesToLoad: null,
  _gafName: null,
  initWithGAFFile: function(t, e) {
    var n = (this || window);
    this._textureLoadDelegate = e, this._gafName = t;
    var r = cc.loader.getRes(t);
    if (!r)
      cc.loader.load(t, function(s, o) {
        s || n._init(o[0]);
      });
    else
      return this._init(r);
    return !1;
  },
  initWithGAFBundle: function(t, e, n) {
    return cc.assert(!1, "initWithGAFBundle is not yet implemented"), !1;
  },
  setRootTimelineWithName: function(t) {
    for (var e = 0, n = (this || window)._timeLines.length; e < n; ++e) {
      var r = (this || window)._timeLines[e];
      if (r && r.getLinkageName() === t) {
        this._setRootTimeline(r);
        return;
      }
    }
  },
  isAssetVersionPlayable: function() {
    return !0;
  },
  desiredAtlasScale: function() {
    return this._desiredAtlasScale;
  },
  setDesiredAtlasScale: function(t) {
    this._desiredAtlasScale = t;
    for (var e in this._atlasScales)
      this._atlasScales.hasOwnProperty(e) && (this._usedAtlasScale === 0 || Math.abs(this._usedAtlasScale - t) > Math.abs(e - t)) && (this._usedAtlasScale = e);
  },
  createObject: function() {
    return this._instantiateGaf(this._gafData);
  },
  createObjectAndRun: function(t) {
    cc.assert(arguments.length === 1, "GAFAsset::createObjectAndRun should have one param");
    var e = (this || window)._instantiateGaf(this._gafData);
    return e.setLooped(t, !0), e.start(), e;
  },
  setTextureLoadDelegate: function(t) {
    debugger;
  },
  getSceneFps: function() {
    return this._sceneFps;
  },
  getSceneWidth: function() {
    debugger;
  },
  getSceneHeight: function() {
    debugger;
  },
  getSceneColor: function() {
    debugger;
  },
  setSceneFps: function(t) {
    this._sceneFps = t;
  },
  setSceneWidth: function(t) {
    debugger;
  },
  setSceneHeight: function(t) {
    debugger;
  },
  setSceneColor: function(t) {
    debugger;
  },
  getHeader: function() {
    return this._header;
  },
  getGAFFileName: function() {
    return this._gafName;
  },
  ctor: function() {
    this._header = {}, this._timeLines = [], this._textFields = [], this._objects = [], this._masks = [], this._protos = [], this._atlases = {}, this._onLoadTasks = [], this._atlasScales = {}, this._atlasesToLoad = {}, arguments.length > 0 && this.initWithGAFFile.apply(this, arguments);
  },
  _getProtos: function() {
    return this._protos;
  },
  _setRootTimeline: function(t) {
    this._rootTimeLine = t, this._header.pivot = t.getPivot(), this._header.frameSize = t.getRect();
  },
  _setHeader: function(t) {
    for (var e in t)
      t.hasOwnProperty(e) && (this._header[e] = t[e]);
  },
  _getMajorVerison: function() {
    return this._header.versionMajor;
  },
  _init: function(t) {
    var e = (this || window);
    this._gafData = t, this._setHeader(t.header), this._timeLinesToLink = [], this._getMajorVerison() < 4 && this._pushTimeLine(new gaf._TimeLineProto(this, this._header.framesCount, this._header.frameSize, this._header.pivot)), gaf._AssetPreload.Tags(this, t.tags, this._rootTimeLine), this._objects.forEach(function(n) {
      switch (n.type) {
        case gaf.TYPE_TEXTURE:
          e._protos[n.objectId] || (e._protos[n.objectId] = new gaf._SpriteProto(e, e._atlasScales, n.elementAtlasIdRef));
          break;
        case gaf.TYPE_TIME_LINE:
          e._protos[n.objectId] = e._timeLines[n.elementAtlasIdRef];
          break;
        case gaf.TYPE_TEXT_FIELD:
          e._protos[n.objectId] = e._textFields[n.elementAtlasIdRef];
          break;
        default:
          cc.log("Unknown object type: " + n.type);
          break;
      }
    }), this._masks.forEach(function(n) {
      if (!e._protos[n.objectId]) {
        var r = null;
        switch (n.type) {
          case gaf.TYPE_TEXTURE:
            r = new gaf._SpriteProto(e, e._atlasScales, n.elementAtlasIdRef);
            break;
          case gaf.TYPE_TIME_LINE:
            r = e._timeLines[n.elementAtlasIdRef];
            break;
          case gaf.TYPE_TEXT_FIELD:
            r = e._textFields[n.elementAtlasIdRef];
            break;
        }
        e._protos[n.objectId] = new gaf._MaskProto(e, r, n.elementAtlasIdRef);
      }
    }), this.setDesiredAtlasScale(this._desiredAtlasScale), Object.keys(this._atlasesToLoad).length === 0 && (this._textureLoaded = !0, this.dispatchEvent("load"));
  },
  _pushTimeLine: function(t) {
    this._timeLines[t.getId()] = t, t.getId() === 0 && this._setRootTimeline(t);
  },
  _instantiateGaf: function() {
    var t = null;
    return t = (this || window)._rootTimeLine._gafConstruct(), t;
  },
  _onAtlasLoaded: function(t, e) {
    this._atlases[t] = e, delete this._atlasesToLoad[t], Object.keys(this._atlasesToLoad).length === 0 && (this._onLoadTasks.forEach(function(n) {
      n();
    }), this._onLoadTasks.length = 0, this._textureLoaded = !0, this.dispatchEvent("load"));
  },
  isLoaded: function() {
    return this._textureLoaded;
  },
  _getSearchPaths: function(t) {
    var e = (this || window).getGAFFileName().split("/");
    e[e.length - 1] = t;
    var n = e.join("/");
    return [t, n];
  }
});
gaf.Asset.create = function(t, e) {
  return new gaf.Asset(t, e);
};
gaf.Asset.createWithBundle = function(t, e, n) {
  var r = new gaf.Asset();
  return r.initWithGAFBundle(t, e, n), r;
};
cc.EventHelper.prototype.apply(gaf.Asset.prototype);
var gaf = gaf || {};
gaf._stateHasCtx = function(t) {
  if (t.hasColorTransform && (t.colorTransform.offset.r > 0 || t.colorTransform.offset.g > 0 || t.colorTransform.offset.b > 0 || t.colorTransform.offset.a > 0))
    return !0;
  if (t.hasEffect) {
    for (var e = 0, n = t.effect.length; e < n; ++e)
      if (t.effect[e].type === gaf.EFFECT_COLOR_MATRIX)
        return !0;
  }
  return !1;
};
gaf.Object = cc.Node.extend({
  _asset: null,
  _className: "GAFObject",
  _id: gaf.IDNONE,
  _gafproto: null,
  _parentTimeLine: null,
  _lastVisibleInFrame: 0,
  _filterStack: null,
  _cascadeColorMult: null,
  _cascadeColorOffset: null,
  _needsCtx: !1,
  _usedAtlasScale: 1,
  ctor: function(t) {
    arguments.length == 1 && (this._usedAtlasScale = t), this._super(), this._cascadeColorMult = cc.color(255, 255, 255, 255), this._cascadeColorOffset = cc.color(0, 0, 0, 0), this._filterStack = [];
  },
  setAnimationStartedNextLoopDelegate: function(t) {
  },
  setAnimationFinishedPlayDelegate: function(t) {
  },
  setLooped: function(t) {
  },
  getBoundingBoxForCurrentFrame: function() {
    return null;
  },
  setFps: function(t) {
  },
  getObjectByName: function(t) {
    return null;
  },
  clearSequence: function() {
  },
  getIsAnimationRunning: function() {
    return !1;
  },
  getSequences: function() {
    return [];
  },
  gotoAndStop: function(t) {
  },
  getStartFrame: function(t) {
    return gaf.IDNONE;
  },
  setFramePlayedDelegate: function(t) {
  },
  getCurrentFrameIndex: function() {
    return gaf.IDNONE;
  },
  getTotalFrameCount: function() {
    return 0;
  },
  start: function() {
  },
  stop: function() {
  },
  isVisibleInCurrentFrame: function() {
    return !(this._parentTimeLine && this._parentTimeLine.getCurrentFrameIndex() + 1 != (this || window)._lastVisibleInFrame);
  },
  isDone: function() {
    return !0;
  },
  playSequence: function(t, e, n) {
    return !1;
  },
  isReversed: function() {
    return !1;
  },
  setSequenceDelegate: function(t) {
  },
  setFrame: function(t) {
    return !1;
  },
  setControlDelegate: function(t) {
  },
  getEndFrame: function(t) {
    return gaf.IDNONE;
  },
  pauseAnimation: function() {
  },
  gotoAndPlay: function(t) {
  },
  isLooped: function() {
    return !1;
  },
  resumeAnimation: function() {
  },
  setReversed: function(t) {
  },
  hasSequences: function() {
    return !1;
  },
  getFps: function() {
    return 60;
  },
  setLocator: function(t) {
  },
  setExternalTransform: function(t) {
    cc.affineTransformEqualToTransform(this._additionalTransform, t) || this.setAdditionalTransform(t);
  },
  getExternalTransform: function() {
    return this._additionalTransform;
  },
  setAnimationRunning: function() {
  },
  _enableTick: function(t) {
  },
  _resetState: function() {
  },
  _updateVisibility: function(t, e) {
    var n = t.hasColorTransform ? t.colorTransform.offset.a : 0;
    this.setOpacity(t.alpha + n);
  },
  isVisible: function() {
    return this.getOpacity() > 0;
  },
  visit: function(t) {
    this.isVisibleInCurrentFrame() && this._super(t);
  },
  _getFilters: function() {
    return null;
  },
  _processAnimation: function() {
  },
  _applyState: function(t, e) {
    this._applyStateSuper(t, e);
  },
  _applyStateSuper: function(t, e) {
    if (this._needsCtx = e._needsCtx, this._filterStack.length = 0, this._parentTimeLine = e, this._usedAtlasScale != 1) {
      var n = cc.clone(t.matrix);
      n.tx *= (this || window)._usedAtlasScale, n.ty *= (this || window)._usedAtlasScale, this.setExternalTransform(n);
    } else
      this.setExternalTransform(t.matrix);
    t.hasEffect && (this._filterStack = (this || window)._filterStack.concat(t.effect), this._needsCtx = !0), e._filterStack && e._filterStack.length > 0 && (this._filterStack = (this || window)._filterStack.concat(e._filterStack)), this._filterStack.length > 0 && this._filterStack[0].type === gaf.EFFECT_COLOR_MATRIX && (this._needsCtx = !0), t.hasColorTransform ? (this._cascadeColorMult.r = t.colorTransform.mult.r * e._cascadeColorMult.r / 255, this._cascadeColorMult.g = t.colorTransform.mult.g * e._cascadeColorMult.g / 255, this._cascadeColorMult.b = t.colorTransform.mult.b * e._cascadeColorMult.b / 255, this._cascadeColorMult.a = t.colorTransform.mult.a * e._cascadeColorMult.a / 255, this._cascadeColorOffset.r = t.colorTransform.offset.r + e._cascadeColorOffset.r, this._cascadeColorOffset.g = t.colorTransform.offset.g + e._cascadeColorOffset.g, this._cascadeColorOffset.b = t.colorTransform.offset.b + e._cascadeColorOffset.b, this._cascadeColorOffset.a = t.colorTransform.offset.a + e._cascadeColorOffset.a) : (this._cascadeColorMult.r = e._cascadeColorMult.r, this._cascadeColorMult.g = e._cascadeColorMult.g, this._cascadeColorMult.b = e._cascadeColorMult.b, this._cascadeColorMult.a = t.alpha * (e._cascadeColorMult.a / 255), this._cascadeColorOffset.r = e._cascadeColorOffset.r, this._cascadeColorOffset.g = e._cascadeColorOffset.g, this._cascadeColorOffset.b = e._cascadeColorOffset.b, this._cascadeColorOffset.a = e._cascadeColorOffset.a), (this._cascadeColorOffset.r > 0 || this._cascadeColorOffset.g > 0 || this._cascadeColorOffset.b > 0 || this._cascadeColorOffset.a > 0) && (this._needsCtx = !0);
  },
  _initRendererCmd: function() {
    this._renderCmd = cc.renderer.getRenderCmd(this), this._renderCmd._visit = (this || window)._renderCmd.visit;
    var t = (this || window);
    this._renderCmd.visit = function(e) {
      t.isVisibleInCurrentFrame() && this._visit(e);
    };
  },
  _getNode: function() {
    return (this || window)
  },
  setAnchorPoint: function(t, e) {
    e === void 0 ? this._super(t.x, t.y - 1) : this._super(t, e - 1);
  }
});
gaf.Object._createNullObject = function() {
  var t = new gaf.Object();
  return t.isVisible = function() {
    return !0;
  }, t;
};
gaf.TimeLine = gaf.Object.extend({
  _className: "GAFTimeLine",
  _objects: null,
  _container: null,
  _animationStartedNextLoopDelegate: null,
  _animationFinishedPlayDelegate: null,
  _framePlayedDelegate: null,
  _sequenceDelegate: null,
  _fps: 60,
  _frameTime: 1 / 60,
  _currentSequenceStart: gaf.FIRST_FRAME_INDEX,
  _currentSequenceEnd: gaf.FIRST_FRAME_INDEX,
  _totalFrameCount: 0,
  _isRunning: !1,
  _isLooped: !1,
  _isReversed: !1,
  _timeDelta: 0,
  _animationsSelectorScheduled: !1,
  _currentFrame: gaf.FIRST_FRAME_INDEX,
  setAnimationStartedNextLoopDelegate: function(t) {
    this._animationStartedNextLoopDelegate = t;
  },
  setAnimationFinishedPlayDelegate: function(t) {
    this._animationFinishedPlayDelegate = t;
  },
  setLooped: function(t, e) {
    this._isLooped = t, e && this._objects.forEach(function(n) {
      n.setLooped(t, e);
    });
  },
  getBoundingBoxForCurrentFrame: function() {
    var t = null, e = !0;
    return this._objects.forEach(function(n) {
      if (n.isVisibleInCurrentFrame() && n.isVisible()) {
        var r = n.getBoundingBoxForCurrentFrame();
        r || (r = n.getBoundingBox()), e ? (e = !1, t = r) : t = cc.rectUnion(t, r);
      }
    }), cc._rectApplyAffineTransformIn(t, this._container.getNodeToParentTransform());
  },
  setFps: function(t) {
    cc.assert(t !== 0, "Error! Fps is set to zero."), this._fps = t, this._frameTime = 1 / t;
  },
  getObjectByName: function(t) {
    var e = t.split("."), n = null, r = -1, s = (this || window), o = {};
    try {
      e.forEach(function(a) {
        var c = s._gafproto.getNamedParts();
        if (c.hasOwnProperty(a))
          r = c[a];
        else
          throw o.lastElement = a, o;
        n = s._objects[r], s = n;
      });
    } catch (a) {
      if (a !== o)
        throw a;
      return cc.log("Sequence incorrect: `" + t + "` At: `" + o.lastElement + "`"), null;
    }
    return n;
  },
  clearSequence: function() {
    this._currentSequenceStart = gaf.FIRST_FRAME_INDEX, this._currentSequenceEnd = (this || window)._gafproto.getTotalFrames();
  },
  getIsAnimationRunning: function() {
    return this._isRunning;
  },
  gotoAndStop: function(t) {
    var e = 0;
    return typeof t == "string" ? e = (this || window).getStartFrame(t) : e = t, this.setFrame(e) ? (this.setAnimationRunning(!1, !1), !0) : !1;
  },
  gotoAndPlay: function(t) {
    var e = 0;
    return typeof t == "string" ? e = (this || window).getStartFrame(t) : e = t, this.setFrame(e) ? (this.setAnimationRunning(!0, !1), !0) : !1;
  },
  getStartFrame: function(t) {
    var e = (this || window)._gafproto.getSequences()[t];
    return e ? e.start : gaf.IDNONE;
  },
  getEndFrame: function(t) {
    var e = (this || window)._gafproto.getSequences()[t];
    return e ? e.end : gaf.IDNONE;
  },
  setFramePlayedDelegate: function(t) {
    this._framePlayedDelegate = t;
  },
  getCurrentFrameIndex: function() {
    return this._showingFrame;
  },
  getTotalFrameCount: function() {
    return this._gafproto.getTotalFrames();
  },
  start: function() {
    this._enableTick(!0), this._isRunning || (this._currentFrame = gaf.FIRST_FRAME_INDEX, this.setAnimationRunning(!0, !0));
  },
  stop: function() {
    this._enableTick(!1), this._isRunning && (this._currentFrame = gaf.FIRST_FRAME_INDEX, this.setAnimationRunning(!1, !0));
  },
  isDone: function() {
    return this._isLooped ? !1 : this._isReversed ? this._currentFrame < gaf.FIRST_FRAME_INDEX - 1 : this._currentFrame > this._totalFrameCount;
  },
  getSequences: function() {
    return this._gafproto.getSequences();
  },
  playSequence: function(t, e) {
    var n = (this || window).getStartFrame(t), r = (this || window).getEndFrame(t);
    return gaf.IDNONE === n || gaf.IDNONE === r ? !1 : (this._currentSequenceStart = n, this._currentSequenceEnd = r, this._currentFrame < this._currentSequenceStart || this._currentFrame > this._currentSequenceEnd ? this._currentFrame = (this || window)._currentSequenceStart : this._currentFrame = (this || window)._currentSequenceStart, this.setLooped(e, !1), this.resumeAnimation(), !0);
  },
  isReversed: function() {
    return this._isReversed;
  },
  setSequenceDelegate: function(t) {
    this._sequenceDelegate = t;
  },
  setFrame: function(t) {
    return t >= gaf.FIRST_FRAME_INDEX && t < this._totalFrameCount ? (this._showingFrame = t, this._currentFrame = t, this._processAnimation(), !0) : !1;
  },
  pauseAnimation: function() {
    this._isRunning && this.setAnimationRunning(!1, !1);
  },
  isLooped: function() {
    return this._isLooped;
  },
  resumeAnimation: function() {
    this._isRunning || this.setAnimationRunning(!0, !1);
  },
  setReversed: function(t) {
    this._isReversed = t;
  },
  hasSequences: function() {
    return this._gafproto.getSequences().length > 0;
  },
  getFps: function() {
    return this._fps;
  },
  ctor: function(t, e) {
    this._super(e), this._objects = [], cc.assert(t, "Error! Missing mandatory parameter."), this._gafproto = t;
  },
  setExternalTransform: function(t) {
    cc.affineTransformEqualToTransform(this._container._additionalTransform, t) || this._container.setAdditionalTransform(t);
  },
  _init: function() {
    this.setContentSize(this._gafproto.getBoundingBox()), this._currentSequenceEnd = (this || window)._gafproto.getTotalFrames(), this._totalFrameCount = (this || window)._currentSequenceEnd, this.setFps(this._gafproto.getFps()), this._container = new cc.Node(), this.addChild(this._container);
    var t = (this || window), e = (this || window)._gafproto.getAsset();
    this._gafproto.getObjects().forEach(function(n) {
      var r = e._getProtos()[n];
      cc.assert(r, "Error. GAF proto for type: " + n.type + " and reference id: " + n + " not found."), t._objects[n] = r._gafConstruct();
    });
  },
  _enableTick: function(t) {
    !this._animationsSelectorScheduled && t ? (this.schedule(this._processAnimations), this._animationsSelectorScheduled = !0) : this._animationsSelectorScheduled && !t && (this.unschedule(this._processAnimations), this._animationsSelectorScheduled = !1);
  },
  _processAnimations: function(t) {
    for (this._timeDelta += t; this._timeDelta >= (this || window)._frameTime; )
      this._timeDelta -= (this || window)._frameTime, this._step();
  },
  _step: function() {
    if (this._showingFrame = (this || window)._currentFrame, !this.getIsAnimationRunning()) {
      this._processAnimation();
      return;
    }
    if (this._sequenceDelegate) {
      var t;
      this._isReversed ? t = (this || window)._getSequenceByFirstFrame(this._currentFrame + 1) : t = (this || window)._getSequenceByLastFrame(this._currentFrame), t && this._sequenceDelegate(this, t);
    }
    this._isCurrentFrameLastInSequence() && (this._isLooped ? this._animationStartedNextLoopDelegate && this._animationStartedNextLoopDelegate(this) : (this.setAnimationRunning(!1, !1), this._animationFinishedPlayDelegate && this._animationFinishedPlayDelegate(this))), this._processAnimation(), this._currentFrame = (this || window)._nextFrame();
  },
  _isCurrentFrameLastInSequence: function() {
    return this._isReversed ? this._currentFrame == (this || window)._currentSequenceStart : this._currentFrame == (this || window)._currentSequenceEnd - 1;
  },
  _nextFrame: function() {
    return this._isCurrentFrameLastInSequence() ? this._isLooped ? this._isReversed ? this._currentSequenceEnd - 1 : this._currentSequenceStart : this._currentFrame : this._currentFrame + (this._isReversed ? -1 : 1);
  },
  _processAnimation: function() {
    this._realizeFrame(this._container, this._currentFrame), this._framePlayedDelegate && this._framePlayedDelegate(this, this._currentFrame);
  },
  _realizeFrame: function(t, e) {
    var n = (this || window), r = n._objects, s = n._gafproto.getFrames();
    if (!(e > s.length)) {
      var o = s[e];
      if (o)
        for (var a = o.states, c = 0, l = a.length; c < l; ++c) {
          var h = a[c], u = r[h.objectIdRef];
          if (!u)
            return;
          if (h.alpha < 0 && u._resetState(), u._updateVisibility(h, n), !!u.isVisible()) {
            u._applyState(h, n);
            var _ = t;
            h.hasMask && (_ = r[h.maskObjectIdRef]._getNode(), cc.assert(_, "Error! Mask not found.")), u._lastVisibleInFrame = 1 + e, gaf.TimeLine.rearrangeSubobject(_, u, h.depth), u._step && u._step();
          }
        }
    }
  },
  setAnimationRunning: function(t, e) {
    this._isRunning = t, e && this._objects.forEach(function(n) {
      n && n.setAnimationRunning && n.setAnimationRunning(t, e);
    });
  },
  _getSequenceByLastFrame: function() {
    var t = (this || window)._gafproto.getSequences();
    for (var e in t)
      if (t.hasOwnProperty(e) && t[e].end === frame + 1)
        return e;
    return "";
  },
  _resetState: function() {
    this._super(), this._currentFrame = (this || window)._currentSequenceStart;
  },
  _getSequenceByFirstFrame: function() {
    var t = (this || window)._gafproto.getSequences();
    for (var e in t)
      if (t.hasOwnProperty(e) && t[e].start === frame)
        return e;
    return "";
  }
});
gaf.TimeLine.rearrangeSubobject = function(t, e, n) {
  var r = e.getParent();
  r !== t ? (e.removeFromParent(!1), t.addChild(e, n)) : e.setLocalZOrder(n);
};
gaf.TextField = gaf.Object.extend({
  _className: "GAFTextField"
});
gaf.Sprite = gaf.Object.extend({
  _className: "GAFSprite",
  _hasCtx: !1,
  _hasFilter: !1,
  ctor: function(t, e) {
    this._super(e), cc.assert(t, "Error! Missing mandatory parameter."), this._gafproto = t;
  },
  _init: function() {
    var t = (this || window)._gafproto.getFrame();
    cc.assert(t instanceof cc.SpriteFrame, "Error. Wrong object type."), this._sprite = new cc.Sprite(), this._sprite._renderCmd = (this || window)._gafCreateRenderCmd(this._sprite), this._sprite.initWithSpriteFrame(t), this._sprite.setAnchorPoint(this._gafproto.getAnchor()), this.addChild(this._sprite), this._sprite.setOpacityModifyRGB(!0), cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._sprite.setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
  },
  _applyState: function(t, e) {
    this._applyStateSuper(t, e), this._needsCtx ? (this._hasCtx || (this._enableCtx(), this._hasCtx = !0), this._applyCtxState(t)) : (this._hasCtx && (this._disableCtx(), this._hasCtx = !1), cc.colorEqual(this._sprite._realColor, this._cascadeColorMult) || this._sprite.setColor(this._cascadeColorMult), this._sprite.getOpacity() != (this || window)._cascadeColorMult.a && this._sprite.setOpacity(this._cascadeColorMult.a));
  },
  _enableCtx: function() {
    this._sprite._renderCmd._enableCtx();
  },
  _disableCtx: function() {
    this._sprite._renderCmd._disableCtx();
  },
  _applyCtxState: function(t) {
    this._sprite._renderCmd._applyCtxState(this);
  },
  getBoundingBoxForCurrentFrame: function() {
    var t = (this || window)._sprite.getBoundingBox();
    return cc._rectApplyAffineTransformIn(t, this.getNodeToParentTransform());
  },
  _gafCreateRenderCmd: function(t) {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new gaf.Sprite.CanvasRenderCmd(t) : new gaf.Sprite.WebGLRenderCmd(t);
  }
});
gaf.Mask = gaf.Object.extend({
  _className: "GAFMask",
  _clippingNode: null,
  ctor: function(t) {
    this._super(), cc.assert(t, "Error! Missing mandatory parameter."), this._gafproto = t;
  },
  _init: function() {
    var t = (this || window)._gafproto.getMaskNodeProto();
    cc.assert(t, "Error. Mask node for id ref " + this._gafproto.getIdRef() + " not found."), this._maskNode = t._gafConstruct(), this._clippingNode = cc.ClippingNode.create(this._maskNode), this._clippingNode.setAlphaThreshold(0.5), this.addChild(this._clippingNode);
  },
  setExternalTransform: function(t) {
    cc.affineTransformEqualToTransform(this._maskNode._additionalTransform, t) || this._maskNode.setAdditionalTransform(t);
  },
  _getNode: function() {
    return this._clippingNode;
  }
});
(function() {
  gaf.Sprite.CanvasRenderCmd = function(e) {
    cc.Sprite.CanvasRenderCmd.call(this, e), this._hasTintMult = !1, this._hasTintOffset = !1, this._hasCtx = !1, this._tintMult = cc.color(255, 255, 255, 255), this._tintOffset = cc.color(0, 0, 0, 0), this._textureDirty = !1;
  };
  var t = gaf.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
  t.constructor = gaf.Sprite.CanvasRenderCmd, t._disableCtx = function() {
    this._hasTintOffset = !1, this._hasCtx = !1, this._textureDirty = !0, this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty), this._tintMult = cc.color(255, 255, 255, 255), this._tintOffset = cc.color(0, 0, 0, 0);
  }, t._enableCtx = function() {
  }, t._applyCtxState = function(e) {
    var n = e._cascadeColorMult, r = e._cascadeColorOffset, s = n.a;
    this._node.getOpacity() != s && this._node.setOpacity(s);
    var o = !cc.colorEqual(this._tintMult, n);
    o && (this._node.setColor(n), this._tintMult = n, this._hasTintMult = n.r !== 255 || n.g !== 255 || n.b !== 255);
    var a = (this || window)._tintOffset.r != r.r || this._tintOffset.g != r.g || this._tintOffset.b != r.b || this._tintOffset.a != r.a;
    a && (this._tintOffset = r, this._hasTintOffset = r.r !== 0 || r.g !== 0 || r.b !== 0 || r.a !== 0), this._textureDirty = o || a, this._textureDirty && this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty), this._hasCtx = e._filterStack.length > 0 && e._filterStack[0].type === gaf.EFFECT_COLOR_MATRIX;
  }, t.rendering = function(e, n, r) {
    var s = (this || window)._node, o = (this || window)._textureCoord, a = (this || window)._displayedOpacity / 255;
    if (!(s._texture && (o.width === 0 || o.height === 0 || !s._texture._textureLoaded) || a === 0)) {
      var c = e || cc._renderContext, l = c.getContext(), h = s._offsetPosition.x, u = s._rect.height, _ = s._rect.width, d = -s._offsetPosition.y - u, f;
      c.setTransform(this._worldTransform, n, r), c.setCompositeOperation(this._blendFuncStr), c.setGlobalAlpha(a), (s._flippedX || s._flippedY) && c.save(), s._flippedX && (h = -h - _, l.scale(-1, 1)), s._flippedY && (d = s._offsetPosition.y, l.scale(1, -1)), f = s._texture._htmlElementObj, this._colorized ? l.drawImage(
        f,
        0,
        0,
        o.width,
        o.height,
        h * n,
        d * r,
        _ * n,
        u * r
      ) : l.drawImage(
        f,
        o.renderX,
        o.renderY,
        o.width,
        o.height,
        h * n,
        d * r,
        _ * n,
        u * r
      ), (s._flippedX || s._flippedY) && c.restore(), cc.g_NumberOfDraws++;
    }
  }, cc.sys._supportCanvasNewBlendModes && (t._updateColor = function() {
    var e = (this || window)._displayedColor, n = (this || window)._node;
    if (this._hasTintMult |= e.r !== 255 || e.g !== 255 || e.b !== 255, this._textureDirty)
      this._textureDirty = !1, this._colorized && (this._colorized = !1, n.texture = (this || window)._originalTexture);
    else
      return;
    var r, s = n._texture, o = (this || window)._textureCoord;
    if (this._hasTintMult && s && o.validRect && this._originalTexture) {
      if (r = s.getHtmlElementObj(), !r)
        return;
      this._colorized = !0, (this._hasTintOffset || this._hasCtx) && (e = (this || window)._tintMult), r = cc.Sprite.CanvasRenderCmd._generateTintImageWithMultiply(this._originalTexture._htmlElementObj, e, o), s = new cc.Texture2D(), s.initWithElement(r), s.handleLoadedTexture(), n.texture = s;
    }
    if (s = n._texture, this._hasTintOffset) {
      var a = cc.textureCache.getTextureColors(this._originalTexture.getHtmlElementObj());
      if (s && o.validRect && this._originalTexture) {
        if (r = s.getHtmlElementObj(), !r)
          return;
        if (this._colorized)
          var c = cc.rect(0, 0, o.width, o.height);
        else
          c = o;
        r = (this || window)._gafGenerateTintImage(n.texture._htmlElementObj, c, a, this._tintOffset, o), s = new cc.Texture2D(), s.initWithElement(r), s.handleLoadedTexture(), n.texture = s, this._colorized = !0;
      }
    }
  }, t._gafGenerateTintImage = function(e, n, r, s, o, a) {
    o || (o = cc.rect(0, 0, e.width, e.height));
    var c = Math.min(o.width, r[0].width), l = Math.min(o.height, r[0].height), h = a, u;
    return h ? (u = h.getContext("2d"), u.clearRect(0, 0, c, l)) : (h = document.createElement("canvas"), h.width = c, h.height = l, u = h.getContext("2d")), u.save(), u.globalCompositeOperation = "source-over", u.drawImage(r[2], o.x, o.y, c, l, 0, 0, c, l), u.globalCompositeOperation = "source-in", u.fillStyle = "rgba(" + Math.round(s.r) + "," + Math.round(s.g) + "," + Math.round(s.b) + ",1)", u.fillRect(0, 0, c, l), u.globalCompositeOperation = "lighter", u.drawImage(e, n.x, n.y, c, l, 0, 0, c, l), u.restore(), h;
  });
})();
gaf._TimeLineProto = function(t, e, n, r, s, o) {
  s = typeof s != "undefined" ? s : 0, o = o || "", this._objects = [], this.getTotalFrames = function() {
    return e;
  }, this.getBoundingBox = function() {
    return n;
  }, this.getId = function() {
    return s;
  }, this.getLinkageName = function() {
    return o;
  }, this.getPivot = function() {
    return r;
  }, this.getRect = function() {
    return n;
  }, this.getNamedParts = function() {
    return {};
  }, this.getSequences = function() {
    return {};
  }, this.getFrames = function() {
    return [];
  }, this.getFps = function() {
    return 60;
  }, this.getObjects = function() {
    return this._objects;
  }, this.getAsset = function() {
    return t;
  }, this._gafConstruct = function() {
    var a = (this || window).getAsset()._usedAtlasScale, c = new gaf.TimeLine(this, a);
    return c._init(), c;
  };
};
gaf._SpriteProto = function(t, e, n) {
  this.getFrames = function() {
    return e;
  }, this.getIdRef = function() {
    return n;
  }, this.getAsset = function() {
    return t;
  }, this._gafConstruct = function() {
    var r = (this || window).getAsset()._usedAtlasScale, s = new gaf.Sprite(this, r);
    return s._init(), s;
  };
};
gaf._SpriteProto.prototype.getFrame = function() {
  var t = (this || window).getAsset()._usedAtlasScale;
  cc.assert(t, "Error. Atlas scale zero.");
  var e = (this || window).getFrames()[t];
  return cc.assert(e, "Error. No frames found for used scale `" + t + "`"), e[this.getIdRef()];
};
gaf._SpriteProto.prototype.getAnchor = function() {
  return this.getFrame()._gafAnchor;
};
gaf._MaskProto = function(t, e, n) {
  this.getIdRef = function() {
    return n;
  }, this.getMaskNodeProto = function() {
    return e;
  }, this._gafConstruct = function() {
    var r = new gaf.Mask(this);
    return r._init(), r;
  };
};
gaf.ReadSingleTag = function(t) {
  var e = t.Ushort(), n = gaf.Tags[e], r = {};
  return typeof n == "undefined" ? (console.log("GAF. Non implemented tag detected."), gaf.Tags.Default.parse(t, e)) : r = n.parse(t, e), r;
};
gaf.ReadTags = function(t) {
  var e = [];
  try {
    do {
      var n = gaf.ReadSingleTag(t);
      e.push(n);
    } while (n.tagId != 0);
  } catch (r) {
    if (r instanceof Error && r.message == "GAF format error")
      console.log(`GAF format error:
` + r.stack);
    else
      throw console.log(r.stack), r;
  }
  return e;
};
gaf.Tag = function() {
  this.Default = Object.create(gaf.Tag.base), this[0] = Object.create(gaf.Tag.End), this[1] = Object.create(gaf.Tag.DefineAtlas), this[2] = Object.create(gaf.Tag.DefineAnimationMasks), this[3] = Object.create(gaf.Tag.DefineAnimationObjects), this[4] = Object.create(gaf.Tag.DefineAnimationFrames), this[5] = Object.create(gaf.Tag.DefineNamedParts), this[6] = Object.create(gaf.Tag.DefineSequences), this[7] = Object.create(gaf.Tag.DefineTextFields), this[8] = Object.create(gaf.Tag.DefineAtlas2), this[9] = Object.create(gaf.Tag.DefineStage), this[10] = Object.create(gaf.Tag.DefineAnimationObjects2), this[11] = Object.create(gaf.Tag.DefineAnimationMasks2), this[12] = Object.create(gaf.Tag.DefineAnimationFrames2), this[13] = Object.create(gaf.Tag.DefineTimeline);
};
gaf.Tag.base = function() {
};
gaf.Tag.base.parse = function(t, e) {
  var n = t.Uint();
  t.startNestedBuffer(n);
  var r = (this || window).doParse(t);
  return t.endNestedBuffer(), r.tagName = (this || window).tagName, r.tagId = e, r;
};
gaf.Tag.base.doParse = function(t) {
  return {};
};
gaf.Tag.End = Object.create(gaf.Tag.base);
gaf.Tag.End.tagName = "TagEnd";
gaf.Tag.DefineAtlas = Object.create(gaf.Tag.base);
gaf.Tag.DefineAtlas.tagName = "TagDefineAtlas";
gaf.Tag.DefineAtlas.doParse = function(t) {
  var e = t.fields(
    "scale",
    "Float",
    "atlases",
    t.array("Ubyte", t.fields(
      "id",
      "Uint",
      "sources",
      t.array("Ubyte", t.fields(
        "source",
        "String",
        "csf",
        "Float"
      ))
    )),
    "elements",
    t.array("Uint", t.fields(
      "pivot",
      "Point",
      "origin",
      "Point",
      "scale",
      "Float",
      "size",
      "Point",
      "atlasId",
      "Uint",
      "elementAtlasId",
      "Uint"
    ))
  );
  return { content: e() };
};
gaf.Tag.DefineAnimationMasks = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationMasks.tagName = "TagDefineAnimationMasks";
gaf.Tag.DefineAnimationMasks.doParse = function(t) {
  var e = t.array("Uint", t.fields(
    "objectId",
    "Uint",
    "elementAtlasIdRef",
    "Uint"
  )), n = { content: e() };
  debugger;
  return n;
};
gaf.Tag.DefineAnimationObjects = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationObjects.tagName = "TagDefineAnimationObjects";
gaf.Tag.DefineAnimationObjects.doParse = function(t) {
  var e = t.array("Uint", t.fields(
    "objectId",
    "Uint",
    "elementAtlasIdRef",
    "Uint"
  ));
  return { content: e() };
};
gaf.Tag.DefineAnimationFrames = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationFrames.tagName = "TagDefineAnimationFrames";
gaf.Tag.DefineAnimationFrames.doParse = function(t) {
  var e = t.array("Uint", t.fields(
    "frame",
    "Uint",
    "state",
    t.array("Uint", t.fields(
      "hasColorTransform",
      "Ubyte",
      "hasMask",
      "Ubyte",
      "hasEffect",
      "Ubyte",
      "objectIdRef",
      "Uint",
      "depth",
      "Int",
      "alpha",
      "Float",
      "matrix",
      "Matrix",
      "colorTransform",
      t.condition("hasColorTransform", 1, t.fields(
        "alphaOffset",
        "Float",
        "redMultiplier",
        "Float",
        "redOffset",
        "Float",
        "greenMultiplier",
        "Float",
        "greenOffset",
        "Float",
        "blueMultiplier",
        "Float",
        "blueOffset",
        "Float"
      )),
      "effect",
      t.condition("hasEffect", 1, t.array("Ubyte", gaf.Tag._readFilter(t))),
      "maskObjectIdRef",
      t.condition("hasMask", 1, t.fields(
        "maskObjectIdRef",
        "Uint"
      ))
    ))
  ));
  return { content: e() };
};
gaf.Tag.DefineNamedParts = Object.create(gaf.Tag.base);
gaf.Tag.DefineNamedParts.tagName = "TagDefineNamedParts";
gaf.Tag.DefineNamedParts.doParse = function(t) {
  var e = t.array("Uint", t.fields(
    "objectId",
    "Uint",
    "name",
    "String"
  ));
  return { content: e() };
};
gaf.Tag.DefineSequences = Object.create(gaf.Tag.base);
gaf.Tag.DefineSequences.tagName = "TagDefineSequences";
gaf.Tag.DefineSequences.doParse = function(t) {
  var e = t.array("Uint", t.fields(
    "id",
    "String",
    "start",
    "Ushort",
    "end",
    "Ushort"
  ));
  return { content: e() };
};
gaf.Tag.DefineTextFields = Object.create(gaf.Tag.base);
gaf.Tag.DefineTextFields.tagName = "TagDefineTextFields";
gaf.Tag.DefineTextFields.doParse = function(t) {
  var e = t.array("Uint", t.fields(
    "id",
    "Uint",
    "pivot",
    "Point",
    "end",
    "Ushort",
    "width",
    "Float",
    "height",
    "Float",
    "text",
    "String",
    "embedFonts",
    "Boolean",
    "multiline",
    "Boolean",
    "wordWrap",
    "Boolean",
    "hasRestrict",
    "Boolean",
    "restrict",
    t.condition("hasRestrict", 1, function() {
      return t.String;
    }),
    "editable",
    "Boolean",
    "selectable",
    "Boolean",
    "displayAsPassword",
    "Boolean",
    "maxChars",
    "Uint",
    "align",
    "Uint",
    "blockIndent",
    "Uint",
    "bold",
    "Boolean",
    "bullet",
    "Boolean",
    "color",
    "color",
    "font",
    "String",
    "indent",
    "Uint",
    "italic",
    "Boolean",
    "kerning",
    "Boolean",
    "leading",
    "Uint",
    "leftMargin",
    "Uint",
    "letterSpacing",
    "Float",
    "rightMargin",
    "Uint",
    "size",
    "Uint",
    "tabStops",
    t.array("Uint", t.fields(
      "value",
      "Uint"
    )),
    "target",
    "string",
    "underline",
    "Boolean",
    "url",
    "String"
  ));
  return { content: e() };
};
gaf.Tag.DefineAtlas2 = Object.create(gaf.Tag.base);
gaf.Tag.DefineAtlas2.tagName = "TagDefineAtlas2";
gaf.Tag.DefineAtlas2.doParse = function(t) {
  var e = t.fields(
    "scale",
    "Float",
    "atlases",
    t.array("Ubyte", t.fields(
      "id",
      "Uint",
      "sources",
      t.array("Ubyte", t.fields(
        "source",
        "String",
        "csf",
        "Float"
      ))
    )),
    "elements",
    t.array("Uint", t.fields(
      "pivot",
      "Point",
      "origin",
      "Point",
      "scale",
      "Float",
      "size",
      "Point",
      "atlasId",
      "Uint",
      "elementAtlasId",
      "Uint",
      "hasScale9Grid",
      "Boolean",
      "scale9GridRect",
      t.condition("hasScale9Grid", 1, function() {
        return t.Rect();
      })
    ))
  );
  return { content: e() };
};
gaf.Tag.DefineStage = Object.create(gaf.Tag.base);
gaf.Tag.DefineStage.tagName = "TagDefineStage";
gaf.Tag.DefineStage.doParse = function(t) {
  var e = t.fields(
    "fps",
    "Ubyte",
    "color",
    "color",
    "width",
    "Ushort",
    "height",
    "Ushort"
  );
  return { content: e() };
};
gaf.Tag.DefineAnimationObjects2 = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationObjects2.tagName = "TagDefineAnimationObjects2";
gaf.Tag.DefineAnimationObjects2.doParse = function(t) {
  var e = t.array("Uint", t.fields(
    "objectId",
    "Uint",
    "elementAtlasIdRef",
    "Uint",
    "type",
    "Ushort"
  ));
  return { content: e() };
};
gaf.Tag.DefineAnimationMasks2 = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationMasks2.tagName = "TagDefineAnimationMasks2";
gaf.Tag.DefineAnimationMasks2.doParse = function(t) {
  var e = t.array("Uint", t.fields(
    "objectId",
    "Uint",
    "elementAtlasIdRef",
    "Uint",
    "type",
    "Ushort"
  ));
  return { content: e() };
};
gaf.Tag.DefineAnimationFrames2 = Object.create(gaf.Tag.base);
gaf.Tag.DefineAnimationFrames2.tagName = "TagDefineAnimationFrames2";
gaf.Tag.DefineAnimationFrames2.doParse = function(t) {
  var e = t.array("Uint", t.fields(
    "frame",
    "Uint",
    "hasChangesInDisplayList",
    "Boolean",
    "hasActions",
    "Boolean",
    "state",
    t.condition("hasChangesInDisplayList", 1, t.array("Uint", t.fields(
      "hasColorTransform",
      "Boolean",
      "hasMask",
      "Boolean",
      "hasEffect",
      "Boolean",
      "objectIdRef",
      "Uint",
      "depth",
      "Int",
      "alpha",
      "Float",
      "matrix",
      "Matrix",
      "colorTransform",
      t.condition("hasColorTransform", 1, t.fields(
        "alphaOffset",
        "Float",
        "redMultiplier",
        "Float",
        "redOffset",
        "Float",
        "greenMultiplier",
        "Float",
        "greenOffset",
        "Float",
        "blueMultiplier",
        "Float",
        "blueOffset",
        "Float"
      )),
      "effect",
      t.condition("hasEffect", 1, t.array("Ubyte", gaf.Tag._readFilter(t))),
      "maskObjectIdRef",
      t.condition("hasMask", 1, function() {
        return t.Uint();
      })
    ))),
    "actions",
    t.condition("hasActions", 1, t.array("Uint", t.fields(
      "type",
      "Uint",
      "scope",
      "String",
      "params",
      gaf.Tag._readActionArguments(t)
    )))
  ));
  return { content: e() };
};
gaf.Tag.DefineTimeline = Object.create(gaf.Tag.base);
gaf.Tag.DefineTimeline.tagName = "TagDefineTimeline";
gaf.Tag.DefineTimeline.doParse = function(t) {
  var e = t.fields(
    "id",
    "Uint",
    "animationFrameCount",
    "Uint",
    "boundingBox",
    "Rect",
    "pivotPoint",
    "Point",
    "hasLinkage",
    "Boolean",
    "linkageName",
    t.condition("hasLinkage", 1, function() {
      return t.String();
    })
  ), n = { content: e() };
  return n.content.tags = gaf.ReadTags(t), n;
};
gaf.Tag._readActionArguments = function(t) {
  return function() {
    var e = t.Uint(), n = [];
    for (t.startNestedBuffer(e); t.maxOffset() < t.tell(); )
      n.push(t.String());
    return t.endNestedBuffer(), n;
  };
};
gaf.Tag._readFilter = function(t) {
  return t.fields(
    "type",
    "Uint",
    "dropShadow",
    t.condition("type", gaf.EFFECT_DROP_SHADOW, t.fields(
      "color",
      "color",
      "blurX",
      "Float",
      "blurY",
      "Float",
      "angle",
      "Float",
      "distance",
      "Float",
      "strength",
      "Float",
      "inner",
      "Boolean",
      "knockout",
      "Boolean"
    )),
    "blur",
    t.condition("type", gaf.EFFECT_BLUR, t.fields(
      "blurX",
      "Float",
      "blurY",
      "Float"
    )),
    "glow",
    t.condition("type", gaf.EFFECT_GLOW, t.fields(
      "color",
      "color",
      "blurX",
      "Float",
      "blurY",
      "Float",
      "strength",
      "Float",
      "inner",
      "Boolean",
      "knockout",
      "Boolean"
    )),
    "colorMatrix",
    t.condition("type", gaf.EFFECT_COLOR_MATRIX, t.fields(
      "rr",
      "Float",
      "gr",
      "Float",
      "br",
      "Float",
      "ar",
      "Float",
      "r",
      "Float",
      "rg",
      "Float",
      "gg",
      "Float",
      "bg",
      "Float",
      "ag",
      "Float",
      "g",
      "Float",
      "rb",
      "Float",
      "gb",
      "Float",
      "bb",
      "Float",
      "ab",
      "Float",
      "b",
      "Float",
      "ra",
      "Float",
      "ga",
      "Float",
      "ba",
      "Float",
      "aa",
      "Float",
      "a",
      "Float"
    ))
  );
};
gaf.Tags = new gaf.Tag();
var gaf = gaf || {};
gaf.Loader = function() {
  var t = /* @__PURE__ */ H(function(r, s) {
    s.compression = r.Uint(), s.versionMajor = r.Ubyte(), s.versionMinor = r.Ubyte(), s.fileLength = r.Uint();
  }, "readHeaderBegin"), e = /* @__PURE__ */ H(function(r, s) {
    s.framesCount = r.Ushort(), s.frameSize = r.Rect(), s.pivot = r.Point();
  }, "readHeaderEndV3"), n = /* @__PURE__ */ H(function(r, s) {
    var o = r.Uint();
    s.scaleValues = [];
    for (var a = 0; a < o; ++a)
      s.scaleValues.push(r.Float());
    var c = r.Uint();
    s.csfValues = [];
    for (var a = 0; a < c; ++a)
      s.csfValues.push(r.Float());
  }, "readHeaderEndV4");
  this.LoadFile = function(r, s) {
    var o = new XMLHttpRequest();
    o.open("GET", r, !0);
    var a = (this || window);
    o.responseType = "arraybuffer", o.onload = function(c) {
      var l = new gaf.DataReader(o.response), h = a.LoadStream(l);
      s && s(h);
    }, o.send();
  }, this.LoadStream = function(r) {
    var s = {};
    if (t(r, s), s.compression != gaf.COMPRESSION_NONE)
      if (s.compression == gaf.COMPRESSION_ZIP) {
        var o = r.dataRaw.slice(r.tell()), a = new window.Zlib.Inflate(new Uint8Array(o)), c = a.decompress();
        r = new gaf.DataReader(c.buffer);
      } else
        throw new Error("GAF syntax error.");
    s.versionMajor < 4 ? e(r, s) : n(r, s);
    var l = gaf.ReadTags(r);
    return {
      header: s,
      tags: l
    };
  };
};
gaf.DataReader = function(t) {
  this.dataRaw = t, this.buf = new DataView(t), this.offset = [0];
};
gaf.DataReader.prototype.constructor = gaf.DataReader;
gaf.DataReader.prototype.newOffset = function(t) {
  if (this.offset[this.offset.length - 1] += t, this.getOffset() > this.maxOffset())
    throw new Error("GAF format error");
  return this.offset[this.offset.length - 1] - t;
};
gaf.DataReader.prototype.maxOffset = function() {
  return this.offset.length == 1 ? this.buf.byteLength : this.offset[this.offset.length - 2];
};
gaf.DataReader.prototype.getOffset = function(t) {
  return this.offset[this.offset.length - 1];
};
gaf.DataReader.prototype.Ubyte = function() {
  return this.buf.getUint8(this.newOffset(1));
};
gaf.DataReader.prototype.Boolean = function() {
  var t = (this || window).buf.getUint8(this.newOffset(1));
  if (t > 1)
    throw new Error("GAF format error");
  return t;
};
gaf.DataReader.prototype.Uint = function() {
  return this.buf.getUint32(this.newOffset(4), !0);
};
gaf.DataReader.prototype.Int = function() {
  return this.buf.getInt32(this.newOffset(4), !0);
};
gaf.DataReader.prototype.color = function() {
  return {
    b: this.Ubyte(),
    g: this.Ubyte(),
    r: this.Ubyte(),
    a: this.Ubyte()
  };
};
gaf.DataReader.prototype.Ushort = function() {
  return this.buf.getUint16(this.newOffset(2), !0);
};
gaf.DataReader.prototype.Float = function() {
  return this.buf.getFloat32(this.newOffset(4), !0);
};
gaf.DataReader.prototype.String = function() {
  var t = (this || window).Ushort(), e = (this || window).newOffset(t), n = (this || window).getOffset();
  try {
    var r = (this || window).dataRaw.slice(e, n);
  } catch (o) {
    if (o.message == "Object doesn't support property or method 'slice'") {
      r = [];
      for (var s = e; s < n; ++s)
        r.push(this.buf.getUint8(s));
    } else
      throw o;
  }
  return decodeURIComponent(escape(String.fromCharCode.apply(null, new Uint8Array(r))));
};
gaf.DataReader.prototype.startNestedBuffer = function(t) {
  this.offset.push(this.offset[this.offset.length - 1]), this.offset[this.offset.length - 2] += t;
};
gaf.DataReader.prototype.endNestedBuffer = function() {
  if (this.offset.length == 1)
    throw new Error("No nested buffer available");
  this.offset.pop();
};
gaf.DataReader.prototype.Point = function() {
  return {
    x: this.Float(),
    y: this.Float()
  };
};
gaf.DataReader.prototype.Rect = function() {
  return {
    x: this.Float(),
    y: this.Float(),
    width: this.Float(),
    height: this.Float()
  };
};
gaf.DataReader.prototype.Matrix = function() {
  return {
    a: this.Float(),
    b: this.Float(),
    c: this.Float(),
    d: this.Float(),
    tx: this.Float(),
    ty: this.Float()
  };
};
gaf.DataReader.prototype.seek = function(t) {
  this.offset[this.offset.length - 1] = t;
};
gaf.DataReader.prototype.tell = function() {
  return this.offset[this.offset.length - 1];
};
gaf.DataReader.prototype.fields = function() {
  var t = (this || window), e = arguments;
  return function() {
    arguments.callee.result = {};
    var n = 0;
    if (e.length % 2)
      throw new Error("Number of arguments is not even");
    for (; n < e.length; ) {
      var r = e[n++], s = e[n++];
      if (typeof s == "function")
        arguments.callee.result[r] = s();
      else if (s in t && typeof t[s] == "function")
        arguments.callee.result[r] = t[s].call(t);
      else
        throw new Error("Object DataReader has no function `" + s + "`");
    }
    return arguments.callee.result;
  };
};
gaf.DataReader.prototype.condition = function(t, e, n) {
  var r = arguments;
  return function() {
    if (r.length != 3)
      throw new Error("Condition function");
    var s = arguments.callee.caller;
    if (!("result" in s))
      throw new Error("Condition function caller has no key `result`");
    var o = s.result, a = r[0], c = r[1], l = r[2], h = null;
    return typeof c == "function" ? h = /* @__PURE__ */ H(function() {
      return c(o[a]);
    }, "evaluate") : h = /* @__PURE__ */ H(function() {
      return c == o[a];
    }, "evaluate"), h() ? l() : null;
  };
};
gaf.DataReader.prototype.array = function() {
  var t = (this || window), e = arguments;
  return function() {
    arguments.callee.result = [];
    for (var n = t[e[0]].call(t), r = 0; r < n; ++r) {
      var s = e[1].call();
      arguments.callee.result.push(s);
    }
    return arguments.callee.result;
  };
};
gaf.SHADER_GAUSSIAN_BLUR_FRAG = `varying mediump vec2 v_texCoord;
uniform mediump vec2 u_step;
void main()
{ 
    mediump vec4 sum = vec4(0.0);                                      
    sum += texture2D(CC_Texture0, v_texCoord - u_step * 4.0) * 0.05;   
    sum += texture2D(CC_Texture0, v_texCoord - u_step * 3.0) * 0.09;   
    sum += texture2D(CC_Texture0, v_texCoord - u_step * 2.0) * 0.12;   
    sum += texture2D(CC_Texture0, v_texCoord - u_step * 1.0) * 0.15;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 0.0) * 0.18;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 1.0) * 0.15;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 2.0) * 0.12;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 3.0) * 0.09;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 4.0) * 0.05;   
    gl_FragColor = sum;                                                
} 
`;
gaf.SHADER_GLOW_FRAG = `varying mediump vec2 v_texCoord;
uniform mediump vec2 u_step;
uniform mediump vec4 u_glowColor;
void main()
{ 
    mediump vec4 sum = vec4(0.0);                                      
    sum += texture2D(CC_Texture0, v_texCoord - u_step * 4.0) * 0.05;   
    sum += texture2D(CC_Texture0, v_texCoord - u_step * 3.0) * 0.09;   
    sum += texture2D(CC_Texture0, v_texCoord - u_step * 2.0) * 0.12;   
    sum += texture2D(CC_Texture0, v_texCoord - u_step * 1.0) * 0.15;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 0.0) * 0.18;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 1.0) * 0.15;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 2.0) * 0.12;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 3.0) * 0.09;   
    sum += texture2D(CC_Texture0, v_texCoord + u_step * 4.0) * 0.05;   
    gl_FragColor = sum * u_glowColor;                                  
} 
`;
gaf.SHADER_COLOR_MATRIX_FRAG = `varying mediump vec2 v_texCoord;
varying mediump vec4 v_fragmentColor;
uniform mediump vec4 colorTransformMult;
uniform mediump vec4 colorTransformOffsets;
uniform mediump mat4 colorMatrix;
uniform mediump vec4 colorMatrix2;
void main()
{ 
    vec4 texColor = texture2D(CC_Texture0, v_texCoord);                          
    const float kMinimalAlphaAllowed = 1.0e-8;                                   
    if (texColor.a > kMinimalAlphaAllowed)                                       
    {                                                                            
        texColor = vec4(texColor.rgb / texColor.a, texColor.a);                  
        vec4 ctxColor = texColor * colorTransformMult + colorTransformOffsets;   
        vec4 adjustColor = colorMatrix * ctxColor + colorMatrix2;                
        adjustColor *= v_fragmentColor;                                          
        texColor = vec4(adjustColor.rgb * adjustColor.a, adjustColor.a);         
    }                                                                            
    gl_FragColor = texColor;                                                     
}
`;
gaf._glShaderInit = function() {
  gaf._Uniforms = {
    ColorTransformMult: -1,
    ColorTransformOffset: -1,
    ColorMatrixBody: -1,
    ColorMatrixAppendix: -1,
    BlurTexelOffset: -1,
    GlowTexelOffset: -1,
    GlowColor: -1
  }, gaf._shaderCreate = function(t, e) {
    var n = new cc.GLProgram(), r = n.initWithVertexShaderByteArray(e, t);
    return cc.assert(r, "Shader init error"), n.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION), n.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR), n.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS), r = n.link(), cc.assert(r, "Shader linking error"), n.updateUniforms(), n;
  }, gaf._shaderCreateAlpha = function() {
    var t = gaf._shaderCreate(gaf.SHADER_COLOR_MATRIX_FRAG, cc.SHADER_POSITION_TEXTURE_COLOR_VERT);
    return gaf._Uniforms.ColorTransformMult = t.getUniformLocationForName(gaf.UNIFORM_ALPHA_TINT_MULT), gaf._Uniforms.ColorTransformOffset = t.getUniformLocationForName(gaf.UNIFORM_ALPHA_TINT_OFFSET), gaf._Uniforms.ColorMatrixBody = t.getUniformLocationForName(gaf.UNIFORM_ALPHA_COLOR_MATRIX_BODY), gaf._Uniforms.ColorMatrixAppendix = t.getUniformLocationForName(gaf.UNIFORM_ALPHA_COLOR_MATRIX_APPENDIX), t;
  }, gaf._shaderCreateBlur = function() {
    var t = gaf._shaderCreate(gaf.SHADER_GAUSSIAN_BLUR_FRAG, cc.SHADER_POSITION_TEXTURE_COLOR_VERT);
    return gaf._Uniforms.BlurTexelOffset = t._glContext.getUniformLocation(t._programObj, gaf.UNIFORM_BLUR_TEXEL_OFFSET), t;
  }, gaf._shaderCreateGlow = function() {
    var t = gaf._shaderCreate(gaf.SHADER_GLOW_FRAG, cc.SHADER_POSITION_TEXTURE_COLOR_VERT);
    return gaf._Uniforms.GlowTexelOffset = t._glContext.getUniformLocation(t._programObj, gaf.UNIFORM_GLOW_TEXEL_OFFSET), gaf._Uniforms.GlowColor = t._glContext.getUniformLocation(t._programObj, gaf.UNIFORM_GLOW_COLOR), t;
  }, gaf._Shaders = {
    Alpha: gaf._shaderCreateAlpha(),
    Blur: gaf._shaderCreateBlur(),
    Glow: gaf._shaderCreateGlow()
  };
};
gaf._setupShaders = function() {
  cc._renderType === cc.game.RENDER_TYPE_WEBGL ? gaf._glShaderInit() : delete gaf._glShaderInit;
};
gaf._AtlasLoader = {};
gaf._AtlasLoader.execute = function(t, e, n) {
  t() ? e() : n();
};
gaf._AtlasLoader.checkAtlas = function(t) {
  return function() {
    return t && typeof t != "string" && t.isLoaded();
  };
};
gaf._AtlasLoader.load = function(t, e, n) {
  cc.textureCache.addImage(t, function(r) {
    gaf._AtlasLoader.execute(
      gaf._AtlasLoader.checkAtlas(r),
      function() {
        e(r);
      },
      n
    );
  });
};
gaf._AtlasLoader.loadFront = function(t, e, n) {
  return function() {
    t.length > 0 ? gaf._AtlasLoader.load(
      t[0],
      e,
      gaf._AtlasLoader.loadFront(
        t.slice(1),
        e,
        n
      )
    ) : n();
  };
};
gaf._AtlasLoader.loadArray = function(t, e, n) {
  gaf._AtlasLoader.loadFront(t, e, n)();
};
var Box2D = {};
(function(t, e) {
  !(Object.defineProperty instanceof Function) && Object.prototype.__defineGetter__ instanceof Function && Object.prototype.__defineSetter__ instanceof Function && (Object.defineProperty = function(r, s, o) {
    o.get instanceof Function && r.__defineGetter__(s, o.get), o.set instanceof Function && r.__defineSetter__(s, o.set);
  });
  function n() {
  }
  H(n, "emptyFn"), t.inherit = function(r, s) {
    var o = r;
    n.prototype = s.prototype, r.prototype = new n(), r.prototype.constructor = o;
  }, t.generateCallback = /* @__PURE__ */ H(function(s, o) {
    return function() {
      o.apply(s, arguments);
    };
  }, "generateCallback"), t.NVector = /* @__PURE__ */ H(function(s) {
    s === e && (s = 0);
    for (var o = new Array(s || 0), a = 0; a < s; ++a)
      o[a] = 0;
    return o;
  }, "NVector"), t.is = /* @__PURE__ */ H(function(s, o) {
    return s === null ? !1 : !!(o instanceof Function && s instanceof o || s.constructor.__implements != e && s.constructor.__implements[o]);
  }, "is"), t.parseUInt = function(r) {
    return Math.abs(parseInt(r));
  };
})(Box2D);
var Vector = Array, Vector_a2j_Number = Box2D.NVector;
typeof Box2D == "undefined" && (Box2D = {});
typeof Box2D.Collision == "undefined" && (Box2D.Collision = {});
typeof Box2D.Collision.Shapes == "undefined" && (Box2D.Collision.Shapes = {});
typeof Box2D.Common == "undefined" && (Box2D.Common = {});
typeof Box2D.Common.Math == "undefined" && (Box2D.Common.Math = {});
typeof Box2D.Dynamics == "undefined" && (Box2D.Dynamics = {});
typeof Box2D.Dynamics.Contacts == "undefined" && (Box2D.Dynamics.Contacts = {});
typeof Box2D.Dynamics.Controllers == "undefined" && (Box2D.Dynamics.Controllers = {});
typeof Box2D.Dynamics.Joints == "undefined" && (Box2D.Dynamics.Joints = {});
(function() {
  Box2D.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase";
  function t() {
    t.b2AABB.apply(this, arguments);
  }
  H(t, "b2AABB"), Box2D.Collision.b2AABB = t;
  function e() {
    e.b2Bound.apply(this, arguments);
  }
  H(e, "b2Bound"), Box2D.Collision.b2Bound = e;
  function n() {
    n.b2BoundValues.apply(this, arguments), this.constructor === n && this.b2BoundValues.apply(this, arguments);
  }
  H(n, "b2BoundValues"), Box2D.Collision.b2BoundValues = n;
  function r() {
    r.b2Collision.apply(this, arguments);
  }
  H(r, "b2Collision"), Box2D.Collision.b2Collision = r;
  function s() {
    s.b2ContactID.apply(this, arguments), this.constructor === s && this.b2ContactID.apply(this, arguments);
  }
  H(s, "b2ContactID"), Box2D.Collision.b2ContactID = s;
  function o() {
    o.b2ContactPoint.apply(this, arguments);
  }
  H(o, "b2ContactPoint"), Box2D.Collision.b2ContactPoint = o;
  function a() {
    a.b2Distance.apply(this, arguments);
  }
  H(a, "b2Distance"), Box2D.Collision.b2Distance = a;
  function c() {
    c.b2DistanceInput.apply(this, arguments);
  }
  H(c, "b2DistanceInput"), Box2D.Collision.b2DistanceInput = c;
  function l() {
    l.b2DistanceOutput.apply(this, arguments);
  }
  H(l, "b2DistanceOutput"), Box2D.Collision.b2DistanceOutput = l;
  function h() {
    h.b2DistanceProxy.apply(this, arguments);
  }
  H(h, "b2DistanceProxy"), Box2D.Collision.b2DistanceProxy = h;
  function u() {
    u.b2DynamicTree.apply(this, arguments), this.constructor === u && this.b2DynamicTree.apply(this, arguments);
  }
  H(u, "b2DynamicTree"), Box2D.Collision.b2DynamicTree = u;
  function _() {
    _.b2DynamicTreeBroadPhase.apply(this, arguments);
  }
  H(_, "b2DynamicTreeBroadPhase"), Box2D.Collision.b2DynamicTreeBroadPhase = _;
  function d() {
    d.b2DynamicTreeNode.apply(this, arguments);
  }
  H(d, "b2DynamicTreeNode"), Box2D.Collision.b2DynamicTreeNode = d;
  function f() {
    f.b2DynamicTreePair.apply(this, arguments);
  }
  H(f, "b2DynamicTreePair"), Box2D.Collision.b2DynamicTreePair = f;
  function C() {
    C.b2Manifold.apply(this, arguments), this.constructor === C && this.b2Manifold.apply(this, arguments);
  }
  H(C, "b2Manifold"), Box2D.Collision.b2Manifold = C;
  function m() {
    m.b2ManifoldPoint.apply(this, arguments), this.constructor === m && this.b2ManifoldPoint.apply(this, arguments);
  }
  H(m, "b2ManifoldPoint"), Box2D.Collision.b2ManifoldPoint = m;
  function g() {
    g.b2Point.apply(this, arguments);
  }
  H(g, "b2Point"), Box2D.Collision.b2Point = g;
  function y() {
    y.b2RayCastInput.apply(this, arguments), this.constructor === y && this.b2RayCastInput.apply(this, arguments);
  }
  H(y, "b2RayCastInput"), Box2D.Collision.b2RayCastInput = y;
  function A() {
    A.b2RayCastOutput.apply(this, arguments);
  }
  H(A, "b2RayCastOutput"), Box2D.Collision.b2RayCastOutput = A;
  function D() {
    D.b2Segment.apply(this, arguments);
  }
  H(D, "b2Segment"), Box2D.Collision.b2Segment = D;
  function N() {
    N.b2SeparationFunction.apply(this, arguments);
  }
  H(N, "b2SeparationFunction"), Box2D.Collision.b2SeparationFunction = N;
  function z() {
    z.b2Simplex.apply(this, arguments), this.constructor === z && this.b2Simplex.apply(this, arguments);
  }
  H(z, "b2Simplex"), Box2D.Collision.b2Simplex = z;
  function M() {
    M.b2SimplexCache.apply(this, arguments);
  }
  H(M, "b2SimplexCache"), Box2D.Collision.b2SimplexCache = M;
  function Z() {
    Z.b2SimplexVertex.apply(this, arguments);
  }
  H(Z, "b2SimplexVertex"), Box2D.Collision.b2SimplexVertex = Z;
  function U() {
    U.b2TimeOfImpact.apply(this, arguments);
  }
  H(U, "b2TimeOfImpact"), Box2D.Collision.b2TimeOfImpact = U;
  function Q() {
    Q.b2TOIInput.apply(this, arguments);
  }
  H(Q, "b2TOIInput"), Box2D.Collision.b2TOIInput = Q;
  function et() {
    et.b2WorldManifold.apply(this, arguments), this.constructor === et && this.b2WorldManifold.apply(this, arguments);
  }
  H(et, "b2WorldManifold"), Box2D.Collision.b2WorldManifold = et;
  function rt() {
    rt.ClipVertex.apply(this, arguments);
  }
  H(rt, "ClipVertex"), Box2D.Collision.ClipVertex = rt;
  function w() {
    w.Features.apply(this, arguments);
  }
  H(w, "Features"), Box2D.Collision.Features = w;
  function L() {
    L.b2CircleShape.apply(this, arguments), this.constructor === L && this.b2CircleShape.apply(this, arguments);
  }
  H(L, "b2CircleShape"), Box2D.Collision.Shapes.b2CircleShape = L;
  function G() {
    G.b2EdgeChainDef.apply(this, arguments), this.constructor === G && this.b2EdgeChainDef.apply(this, arguments);
  }
  H(G, "b2EdgeChainDef"), Box2D.Collision.Shapes.b2EdgeChainDef = G;
  function I() {
    I.b2EdgeShape.apply(this, arguments), this.constructor === I && this.b2EdgeShape.apply(this, arguments);
  }
  H(I, "b2EdgeShape"), Box2D.Collision.Shapes.b2EdgeShape = I;
  function O() {
    O.b2MassData.apply(this, arguments);
  }
  H(O, "b2MassData"), Box2D.Collision.Shapes.b2MassData = O;
  function K() {
    K.b2PolygonShape.apply(this, arguments), this.constructor === K && this.b2PolygonShape.apply(this, arguments);
  }
  H(K, "b2PolygonShape"), Box2D.Collision.Shapes.b2PolygonShape = K;
  function $() {
    $.b2Shape.apply(this, arguments), this.constructor === $ && this.b2Shape.apply(this, arguments);
  }
  H($, "b2Shape"), Box2D.Collision.Shapes.b2Shape = $, Box2D.Common.b2internal = "Box2D.Common.b2internal";
  function S() {
    S.b2Color.apply(this, arguments), this.constructor === S && this.b2Color.apply(this, arguments);
  }
  H(S, "b2Color"), Box2D.Common.b2Color = S;
  function b() {
    b.b2Settings.apply(this, arguments);
  }
  H(b, "b2Settings"), Box2D.Common.b2Settings = b;
  function W() {
    W.b2Mat22.apply(this, arguments), this.constructor === W && this.b2Mat22.apply(this, arguments);
  }
  H(W, "b2Mat22"), Box2D.Common.Math.b2Mat22 = W;
  function x() {
    x.b2Mat33.apply(this, arguments), this.constructor === x && this.b2Mat33.apply(this, arguments);
  }
  H(x, "b2Mat33"), Box2D.Common.Math.b2Mat33 = x;
  function E() {
    E.b2Math.apply(this, arguments);
  }
  H(E, "b2Math"), Box2D.Common.Math.b2Math = E;
  function R() {
    R.b2Sweep.apply(this, arguments);
  }
  H(R, "b2Sweep"), Box2D.Common.Math.b2Sweep = R;
  function F() {
    F.b2Transform.apply(this, arguments), this.constructor === F && this.b2Transform.apply(this, arguments);
  }
  H(F, "b2Transform"), Box2D.Common.Math.b2Transform = F;
  function k() {
    k.b2Vec2.apply(this, arguments), this.constructor === k && this.b2Vec2.apply(this, arguments);
  }
  H(k, "b2Vec2"), Box2D.Common.Math.b2Vec2 = k;
  function X() {
    X.b2Vec3.apply(this, arguments), this.constructor === X && this.b2Vec3.apply(this, arguments);
  }
  H(X, "b2Vec3"), Box2D.Common.Math.b2Vec3 = X;
  function j() {
    j.b2Body.apply(this, arguments), this.constructor === j && this.b2Body.apply(this, arguments);
  }
  H(j, "b2Body"), Box2D.Dynamics.b2Body = j;
  function V() {
    V.b2BodyDef.apply(this, arguments), this.constructor === V && this.b2BodyDef.apply(this, arguments);
  }
  H(V, "b2BodyDef"), Box2D.Dynamics.b2BodyDef = V;
  function Y() {
    Y.b2ContactFilter.apply(this, arguments);
  }
  H(Y, "b2ContactFilter"), Box2D.Dynamics.b2ContactFilter = Y;
  function tt() {
    tt.b2ContactImpulse.apply(this, arguments);
  }
  H(tt, "b2ContactImpulse"), Box2D.Dynamics.b2ContactImpulse = tt;
  function it() {
    it.b2ContactListener.apply(this, arguments);
  }
  H(it, "b2ContactListener"), Box2D.Dynamics.b2ContactListener = it;
  function lt() {
    lt.b2ContactManager.apply(this, arguments), this.constructor === lt && this.b2ContactManager.apply(this, arguments);
  }
  H(lt, "b2ContactManager"), Box2D.Dynamics.b2ContactManager = lt;
  function ut() {
    ut.b2DebugDraw.apply(this, arguments), this.constructor === ut && this.b2DebugDraw.apply(this, arguments);
  }
  H(ut, "b2DebugDraw"), Box2D.Dynamics.b2DebugDraw = ut;
  function ft() {
    ft.b2DestructionListener.apply(this, arguments);
  }
  H(ft, "b2DestructionListener"), Box2D.Dynamics.b2DestructionListener = ft;
  function vt() {
    vt.b2FilterData.apply(this, arguments);
  }
  H(vt, "b2FilterData"), Box2D.Dynamics.b2FilterData = vt;
  function pt() {
    pt.b2Fixture.apply(this, arguments), this.constructor === pt && this.b2Fixture.apply(this, arguments);
  }
  H(pt, "b2Fixture"), Box2D.Dynamics.b2Fixture = pt;
  function gt() {
    gt.b2FixtureDef.apply(this, arguments), this.constructor === gt && this.b2FixtureDef.apply(this, arguments);
  }
  H(gt, "b2FixtureDef"), Box2D.Dynamics.b2FixtureDef = gt;
  function St() {
    St.b2Island.apply(this, arguments), this.constructor === St && this.b2Island.apply(this, arguments);
  }
  H(St, "b2Island"), Box2D.Dynamics.b2Island = St;
  function ht() {
    ht.b2TimeStep.apply(this, arguments);
  }
  H(ht, "b2TimeStep"), Box2D.Dynamics.b2TimeStep = ht;
  function ct() {
    ct.b2World.apply(this, arguments), this.constructor === ct && this.b2World.apply(this, arguments);
  }
  H(ct, "b2World"), Box2D.Dynamics.b2World = ct;
  function bt() {
    bt.b2CircleContact.apply(this, arguments);
  }
  H(bt, "b2CircleContact"), Box2D.Dynamics.Contacts.b2CircleContact = bt;
  function Et() {
    Et.b2Contact.apply(this, arguments), this.constructor === Et && this.b2Contact.apply(this, arguments);
  }
  H(Et, "b2Contact"), Box2D.Dynamics.Contacts.b2Contact = Et;
  function wt() {
    wt.b2ContactConstraint.apply(this, arguments), this.constructor === wt && this.b2ContactConstraint.apply(this, arguments);
  }
  H(wt, "b2ContactConstraint"), Box2D.Dynamics.Contacts.b2ContactConstraint = wt;
  function It() {
    It.b2ContactConstraintPoint.apply(this, arguments);
  }
  H(It, "b2ContactConstraintPoint"), Box2D.Dynamics.Contacts.b2ContactConstraintPoint = It;
  function Dt() {
    Dt.b2ContactEdge.apply(this, arguments);
  }
  H(Dt, "b2ContactEdge"), Box2D.Dynamics.Contacts.b2ContactEdge = Dt;
  function Ut() {
    Ut.b2ContactFactory.apply(this, arguments), this.constructor === Ut && this.b2ContactFactory.apply(this, arguments);
  }
  H(Ut, "b2ContactFactory"), Box2D.Dynamics.Contacts.b2ContactFactory = Ut;
  function Gt() {
    Gt.b2ContactRegister.apply(this, arguments);
  }
  H(Gt, "b2ContactRegister"), Box2D.Dynamics.Contacts.b2ContactRegister = Gt;
  function at() {
    at.b2ContactResult.apply(this, arguments);
  }
  H(at, "b2ContactResult"), Box2D.Dynamics.Contacts.b2ContactResult = at;
  function ot() {
    ot.b2ContactSolver.apply(this, arguments), this.constructor === ot && this.b2ContactSolver.apply(this, arguments);
  }
  H(ot, "b2ContactSolver"), Box2D.Dynamics.Contacts.b2ContactSolver = ot;
  function _t() {
    _t.b2EdgeAndCircleContact.apply(this, arguments);
  }
  H(_t, "b2EdgeAndCircleContact"), Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = _t;
  function mt() {
    mt.b2NullContact.apply(this, arguments), this.constructor === mt && this.b2NullContact.apply(this, arguments);
  }
  H(mt, "b2NullContact"), Box2D.Dynamics.Contacts.b2NullContact = mt;
  function Ct() {
    Ct.b2PolyAndCircleContact.apply(this, arguments);
  }
  H(Ct, "b2PolyAndCircleContact"), Box2D.Dynamics.Contacts.b2PolyAndCircleContact = Ct;
  function yt() {
    yt.b2PolyAndEdgeContact.apply(this, arguments);
  }
  H(yt, "b2PolyAndEdgeContact"), Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = yt;
  function At() {
    At.b2PolygonContact.apply(this, arguments);
  }
  H(At, "b2PolygonContact"), Box2D.Dynamics.Contacts.b2PolygonContact = At;
  function Pt() {
    Pt.b2PositionSolverManifold.apply(this, arguments), this.constructor === Pt && this.b2PositionSolverManifold.apply(this, arguments);
  }
  H(Pt, "b2PositionSolverManifold"), Box2D.Dynamics.Contacts.b2PositionSolverManifold = Pt;
  function kt() {
    kt.b2BuoyancyController.apply(this, arguments);
  }
  H(kt, "b2BuoyancyController"), Box2D.Dynamics.Controllers.b2BuoyancyController = kt;
  function Ot() {
    Ot.b2ConstantAccelController.apply(this, arguments);
  }
  H(Ot, "b2ConstantAccelController"), Box2D.Dynamics.Controllers.b2ConstantAccelController = Ot;
  function Xt() {
    Xt.b2ConstantForceController.apply(this, arguments);
  }
  H(Xt, "b2ConstantForceController"), Box2D.Dynamics.Controllers.b2ConstantForceController = Xt;
  function Vt() {
    Vt.b2Controller.apply(this, arguments);
  }
  H(Vt, "b2Controller"), Box2D.Dynamics.Controllers.b2Controller = Vt;
  function Lt() {
    Lt.b2ControllerEdge.apply(this, arguments);
  }
  H(Lt, "b2ControllerEdge"), Box2D.Dynamics.Controllers.b2ControllerEdge = Lt;
  function Nt() {
    Nt.b2GravityController.apply(this, arguments);
  }
  H(Nt, "b2GravityController"), Box2D.Dynamics.Controllers.b2GravityController = Nt;
  function Jt() {
    Jt.b2TensorDampingController.apply(this, arguments);
  }
  H(Jt, "b2TensorDampingController"), Box2D.Dynamics.Controllers.b2TensorDampingController = Jt;
  function Ht() {
    Ht.b2DistanceJoint.apply(this, arguments), this.constructor === Ht && this.b2DistanceJoint.apply(this, arguments);
  }
  H(Ht, "b2DistanceJoint"), Box2D.Dynamics.Joints.b2DistanceJoint = Ht;
  function Kt() {
    Kt.b2DistanceJointDef.apply(this, arguments), this.constructor === Kt && this.b2DistanceJointDef.apply(this, arguments);
  }
  H(Kt, "b2DistanceJointDef"), Box2D.Dynamics.Joints.b2DistanceJointDef = Kt;
  function ee() {
    ee.b2FrictionJoint.apply(this, arguments), this.constructor === ee && this.b2FrictionJoint.apply(this, arguments);
  }
  H(ee, "b2FrictionJoint"), Box2D.Dynamics.Joints.b2FrictionJoint = ee;
  function Zt() {
    Zt.b2FrictionJointDef.apply(this, arguments), this.constructor === Zt && this.b2FrictionJointDef.apply(this, arguments);
  }
  H(Zt, "b2FrictionJointDef"), Box2D.Dynamics.Joints.b2FrictionJointDef = Zt;
  function $t() {
    $t.b2GearJoint.apply(this, arguments), this.constructor === $t && this.b2GearJoint.apply(this, arguments);
  }
  H($t, "b2GearJoint"), Box2D.Dynamics.Joints.b2GearJoint = $t;
  function ie() {
    ie.b2GearJointDef.apply(this, arguments), this.constructor === ie && this.b2GearJointDef.apply(this, arguments);
  }
  H(ie, "b2GearJointDef"), Box2D.Dynamics.Joints.b2GearJointDef = ie;
  function Ft() {
    Ft.b2Jacobian.apply(this, arguments);
  }
  H(Ft, "b2Jacobian"), Box2D.Dynamics.Joints.b2Jacobian = Ft;
  function zt() {
    zt.b2Joint.apply(this, arguments), this.constructor === zt && this.b2Joint.apply(this, arguments);
  }
  H(zt, "b2Joint"), Box2D.Dynamics.Joints.b2Joint = zt;
  function Qt() {
    Qt.b2JointDef.apply(this, arguments), this.constructor === Qt && this.b2JointDef.apply(this, arguments);
  }
  H(Qt, "b2JointDef"), Box2D.Dynamics.Joints.b2JointDef = Qt;
  function le() {
    le.b2JointEdge.apply(this, arguments);
  }
  H(le, "b2JointEdge"), Box2D.Dynamics.Joints.b2JointEdge = le;
  function _e() {
    _e.b2LineJoint.apply(this, arguments), this.constructor === _e && this.b2LineJoint.apply(this, arguments);
  }
  H(_e, "b2LineJoint"), Box2D.Dynamics.Joints.b2LineJoint = _e;
  function he() {
    he.b2LineJointDef.apply(this, arguments), this.constructor === he && this.b2LineJointDef.apply(this, arguments);
  }
  H(he, "b2LineJointDef"), Box2D.Dynamics.Joints.b2LineJointDef = he;
  function Se() {
    Se.b2MouseJoint.apply(this, arguments), this.constructor === Se && this.b2MouseJoint.apply(this, arguments);
  }
  H(Se, "b2MouseJoint"), Box2D.Dynamics.Joints.b2MouseJoint = Se;
  function xe() {
    xe.b2MouseJointDef.apply(this, arguments), this.constructor === xe && this.b2MouseJointDef.apply(this, arguments);
  }
  H(xe, "b2MouseJointDef"), Box2D.Dynamics.Joints.b2MouseJointDef = xe;
  function Bt() {
    Bt.b2PrismaticJoint.apply(this, arguments), this.constructor === Bt && this.b2PrismaticJoint.apply(this, arguments);
  }
  H(Bt, "b2PrismaticJoint"), Box2D.Dynamics.Joints.b2PrismaticJoint = Bt;
  function ce() {
    ce.b2PrismaticJointDef.apply(this, arguments), this.constructor === ce && this.b2PrismaticJointDef.apply(this, arguments);
  }
  H(ce, "b2PrismaticJointDef"), Box2D.Dynamics.Joints.b2PrismaticJointDef = ce;
  function pe() {
    pe.b2PulleyJoint.apply(this, arguments), this.constructor === pe && this.b2PulleyJoint.apply(this, arguments);
  }
  H(pe, "b2PulleyJoint"), Box2D.Dynamics.Joints.b2PulleyJoint = pe;
  function de() {
    de.b2PulleyJointDef.apply(this, arguments), this.constructor === de && this.b2PulleyJointDef.apply(this, arguments);
  }
  H(de, "b2PulleyJointDef"), Box2D.Dynamics.Joints.b2PulleyJointDef = de;
  function jt() {
    jt.b2RevoluteJoint.apply(this, arguments), this.constructor === jt && this.b2RevoluteJoint.apply(this, arguments);
  }
  H(jt, "b2RevoluteJoint"), Box2D.Dynamics.Joints.b2RevoluteJoint = jt;
  function ve() {
    ve.b2RevoluteJointDef.apply(this, arguments), this.constructor === ve && this.b2RevoluteJointDef.apply(this, arguments);
  }
  H(ve, "b2RevoluteJointDef"), Box2D.Dynamics.Joints.b2RevoluteJointDef = ve;
  function re() {
    re.b2WeldJoint.apply(this, arguments), this.constructor === re && this.b2WeldJoint.apply(this, arguments);
  }
  H(re, "b2WeldJoint"), Box2D.Dynamics.Joints.b2WeldJoint = re;
  function Oe() {
    Oe.b2WeldJointDef.apply(this, arguments), this.constructor === Oe && this.b2WeldJointDef.apply(this, arguments);
  }
  H(Oe, "b2WeldJointDef"), Box2D.Dynamics.Joints.b2WeldJointDef = Oe;
})();
Box2D.postDefs = [];
(function() {
  var t = Box2D.Collision.Shapes.b2CircleShape;
  Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape, Box2D.Collision.Shapes.b2MassData;
  var e = Box2D.Collision.Shapes.b2PolygonShape, n = Box2D.Collision.Shapes.b2Shape;
  Box2D.Common.b2Color, Box2D.Common.b2internal;
  var r = Box2D.Common.b2Settings;
  Box2D.Common.Math.b2Mat22, Box2D.Common.Math.b2Mat33;
  var s = Box2D.Common.Math.b2Math, o = Box2D.Common.Math.b2Sweep, a = Box2D.Common.Math.b2Transform, c = Box2D.Common.Math.b2Vec2;
  Box2D.Common.Math.b2Vec3;
  var l = Box2D.Collision.b2AABB, h = Box2D.Collision.b2Bound, u = Box2D.Collision.b2BoundValues, _ = Box2D.Collision.b2Collision, d = Box2D.Collision.b2ContactID, f = Box2D.Collision.b2ContactPoint, C = Box2D.Collision.b2Distance, m = Box2D.Collision.b2DistanceInput, g = Box2D.Collision.b2DistanceOutput, y = Box2D.Collision.b2DistanceProxy, A = Box2D.Collision.b2DynamicTree, D = Box2D.Collision.b2DynamicTreeBroadPhase, N = Box2D.Collision.b2DynamicTreeNode, z = Box2D.Collision.b2DynamicTreePair, M = Box2D.Collision.b2Manifold, Z = Box2D.Collision.b2ManifoldPoint, U = Box2D.Collision.b2Point, Q = Box2D.Collision.b2RayCastInput, et = Box2D.Collision.b2RayCastOutput, rt = Box2D.Collision.b2Segment, w = Box2D.Collision.b2SeparationFunction, L = Box2D.Collision.b2Simplex, G = Box2D.Collision.b2SimplexCache, I = Box2D.Collision.b2SimplexVertex, O = Box2D.Collision.b2TimeOfImpact, K = Box2D.Collision.b2TOIInput, $ = Box2D.Collision.b2WorldManifold, S = Box2D.Collision.ClipVertex, b = Box2D.Collision.Features, W = Box2D.Collision.IBroadPhase;
  l.b2AABB = function() {
    this.lowerBound = new c(), this.upperBound = new c();
  }, l.prototype.IsValid = function() {
    var x = (this || window).upperBound.x - this.lowerBound.x, E = (this || window).upperBound.y - this.lowerBound.y, R = x >= 0 && E >= 0;
    return R = R && this.lowerBound.IsValid() && this.upperBound.IsValid(), R;
  }, l.prototype.GetCenter = function() {
    return new c((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
  }, l.prototype.GetExtents = function() {
    return new c((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
  }, l.prototype.Contains = function(x) {
    var E = !0;
    return E = E && this.lowerBound.x <= x.lowerBound.x, E = E && this.lowerBound.y <= x.lowerBound.y, E = E && x.upperBound.x <= (this || window).upperBound.x, E = E && x.upperBound.y <= (this || window).upperBound.y, E;
  }, l.prototype.RayCast = function(x, E) {
    var R = -Number.MAX_VALUE, F = Number.MAX_VALUE, k = E.p1.x, X = E.p1.y, j = E.p2.x - E.p1.x, V = E.p2.y - E.p1.y, Y = Math.abs(j), tt = Math.abs(V), it = x.normal, lt = 0, ut = 0, ft = 0, vt = 0, pt = 0;
    if (Y < Number.MIN_VALUE) {
      if (k < this.lowerBound.x || this.upperBound.x < k)
        return !1;
    } else if (lt = 1 / j, ut = (this.lowerBound.x - k) * lt, ft = (this.upperBound.x - k) * lt, pt = -1, ut > ft && (vt = ut, ut = ft, ft = vt, pt = 1), ut > R && (it.x = pt, it.y = 0, R = ut), F = Math.min(F, ft), R > F)
      return !1;
    if (tt < Number.MIN_VALUE) {
      if (X < this.lowerBound.y || this.upperBound.y < X)
        return !1;
    } else if (lt = 1 / V, ut = (this.lowerBound.y - X) * lt, ft = (this.upperBound.y - X) * lt, pt = -1, ut > ft && (vt = ut, ut = ft, ft = vt, pt = 1), ut > R && (it.y = pt, it.x = 0, R = ut), F = Math.min(F, ft), R > F)
      return !1;
    return x.fraction = R, !0;
  }, l.prototype.TestOverlap = function(x) {
    var E = x.lowerBound.x - this.upperBound.x, R = x.lowerBound.y - this.upperBound.y, F = (this || window).lowerBound.x - x.upperBound.x, k = (this || window).lowerBound.y - x.upperBound.y;
    return !(E > 0 || R > 0 || F > 0 || k > 0);
  }, l.Combine = function(x, E) {
    var R = new l();
    return R.Combine(x, E), R;
  }, l.prototype.Combine = function(x, E) {
    this.lowerBound.x = Math.min(x.lowerBound.x, E.lowerBound.x), this.lowerBound.y = Math.min(x.lowerBound.y, E.lowerBound.y), this.upperBound.x = Math.max(x.upperBound.x, E.upperBound.x), this.upperBound.y = Math.max(x.upperBound.y, E.upperBound.y);
  }, h.b2Bound = function() {
  }, h.prototype.IsLower = function() {
    return (this.value & 1) == 0;
  }, h.prototype.IsUpper = function() {
    return (this.value & 1) == 1;
  }, h.prototype.Swap = function(x) {
    var E = (this || window).value, R = (this || window).proxy, F = (this || window).stabbingCount;
    this.value = x.value, this.proxy = x.proxy, this.stabbingCount = x.stabbingCount, x.value = E, x.proxy = R, x.stabbingCount = F;
  }, u.b2BoundValues = function() {
  }, u.prototype.b2BoundValues = function() {
    this.lowerValues = new Vector_a2j_Number(), this.lowerValues[0] = 0, this.lowerValues[1] = 0, this.upperValues = new Vector_a2j_Number(), this.upperValues[0] = 0, this.upperValues[1] = 0;
  }, _.b2Collision = function() {
  }, _.ClipSegmentToLine = function(x, E, R, F) {
    F === void 0 && (F = 0);
    var k, X = 0;
    k = E[0];
    var j = k.v;
    k = E[1];
    var V = k.v, Y = R.x * j.x + R.y * j.y - F, tt = R.x * V.x + R.y * V.y - F;
    if (Y <= 0 && x[X++].Set(E[0]), tt <= 0 && x[X++].Set(E[1]), Y * tt < 0) {
      var it = Y / (Y - tt);
      k = x[X];
      var lt = k.v;
      lt.x = j.x + it * (V.x - j.x), lt.y = j.y + it * (V.y - j.y), k = x[X];
      var ut;
      Y > 0 ? (ut = E[0], k.id = ut.id) : (ut = E[1], k.id = ut.id), ++X;
    }
    return X;
  }, _.EdgeSeparation = function(x, E, R, F, k) {
    R === void 0 && (R = 0), parseInt(x.m_vertexCount);
    var X = x.m_vertices, j = x.m_normals, V = parseInt(F.m_vertexCount), Y = F.m_vertices, tt, it;
    tt = E.R, it = j[R];
    var lt = tt.col1.x * it.x + tt.col2.x * it.y, ut = tt.col1.y * it.x + tt.col2.y * it.y;
    tt = k.R;
    for (var ft = tt.col1.x * lt + tt.col1.y * ut, vt = tt.col2.x * lt + tt.col2.y * ut, pt = 0, gt = Number.MAX_VALUE, St = 0; St < V; ++St) {
      it = Y[St];
      var ht = it.x * ft + it.y * vt;
      ht < gt && (gt = ht, pt = St);
    }
    it = X[R], tt = E.R;
    var ct = E.position.x + (tt.col1.x * it.x + tt.col2.x * it.y), bt = E.position.y + (tt.col1.y * it.x + tt.col2.y * it.y);
    it = Y[pt], tt = k.R;
    var Et = k.position.x + (tt.col1.x * it.x + tt.col2.x * it.y), wt = k.position.y + (tt.col1.y * it.x + tt.col2.y * it.y);
    Et -= ct, wt -= bt;
    var It = Et * lt + wt * ut;
    return It;
  }, _.FindMaxSeparation = function(x, E, R, F, k) {
    var X = parseInt(E.m_vertexCount), j = E.m_normals, V, Y;
    Y = k.R, V = F.m_centroid;
    var tt = k.position.x + (Y.col1.x * V.x + Y.col2.x * V.y), it = k.position.y + (Y.col1.y * V.x + Y.col2.y * V.y);
    Y = R.R, V = E.m_centroid, tt -= R.position.x + (Y.col1.x * V.x + Y.col2.x * V.y), it -= R.position.y + (Y.col1.y * V.x + Y.col2.y * V.y);
    for (var lt = tt * R.R.col1.x + it * R.R.col1.y, ut = tt * R.R.col2.x + it * R.R.col2.y, ft = 0, vt = -Number.MAX_VALUE, pt = 0; pt < X; ++pt) {
      V = j[pt];
      var gt = V.x * lt + V.y * ut;
      gt > vt && (vt = gt, ft = pt);
    }
    var St = _.EdgeSeparation(E, R, ft, F, k), ht = parseInt(ft - 1 >= 0 ? ft - 1 : X - 1), ct = _.EdgeSeparation(E, R, ht, F, k), bt = parseInt(ft + 1 < X ? ft + 1 : 0), Et = _.EdgeSeparation(E, R, bt, F, k), wt = 0, It = 0, Dt = 0;
    if (ct > St && ct > Et)
      Dt = -1, wt = ht, It = ct;
    else if (Et > St)
      Dt = 1, wt = bt, It = Et;
    else
      return x[0] = ft, St;
    for (; Dt == -1 ? ft = wt - 1 >= 0 ? wt - 1 : X - 1 : ft = wt + 1 < X ? wt + 1 : 0, St = _.EdgeSeparation(E, R, ft, F, k), St > It; )
      wt = ft, It = St;
    return x[0] = wt, It;
  }, _.FindIncidentEdge = function(x, E, R, F, k, X) {
    F === void 0 && (F = 0), parseInt(E.m_vertexCount);
    var j = E.m_normals, V = parseInt(k.m_vertexCount), Y = k.m_vertices, tt = k.m_normals, it, lt;
    it = R.R, lt = j[F];
    var ut = it.col1.x * lt.x + it.col2.x * lt.y, ft = it.col1.y * lt.x + it.col2.y * lt.y;
    it = X.R;
    var vt = it.col1.x * ut + it.col1.y * ft;
    ft = it.col2.x * ut + it.col2.y * ft, ut = vt;
    for (var pt = 0, gt = Number.MAX_VALUE, St = 0; St < V; ++St) {
      lt = tt[St];
      var ht = ut * lt.x + ft * lt.y;
      ht < gt && (gt = ht, pt = St);
    }
    var ct, bt = parseInt(pt), Et = parseInt(bt + 1 < V ? bt + 1 : 0);
    ct = x[0], lt = Y[bt], it = X.R, ct.v.x = X.position.x + (it.col1.x * lt.x + it.col2.x * lt.y), ct.v.y = X.position.y + (it.col1.y * lt.x + it.col2.y * lt.y), ct.id.features.referenceEdge = F, ct.id.features.incidentEdge = bt, ct.id.features.incidentVertex = 0, ct = x[1], lt = Y[Et], it = X.R, ct.v.x = X.position.x + (it.col1.x * lt.x + it.col2.x * lt.y), ct.v.y = X.position.y + (it.col1.y * lt.x + it.col2.y * lt.y), ct.id.features.referenceEdge = F, ct.id.features.incidentEdge = Et, ct.id.features.incidentVertex = 1;
  }, _.MakeClipPointVector = function() {
    var x = new Vector(2);
    return x[0] = new S(), x[1] = new S(), x;
  }, _.CollidePolygons = function(x, E, R, F, k) {
    var X;
    x.m_pointCount = 0;
    var j = E.m_radius + F.m_radius, V = 0;
    _.s_edgeAO[0] = V;
    var Y = _.FindMaxSeparation(_.s_edgeAO, E, R, F, k);
    if (V = _.s_edgeAO[0], !(Y > j)) {
      var tt = 0;
      _.s_edgeBO[0] = tt;
      var it = _.FindMaxSeparation(_.s_edgeBO, F, k, E, R);
      if (tt = _.s_edgeBO[0], !(it > j)) {
        var lt, ut, ft, vt, pt = 0, gt = 0, St = 0.98, ht = 1e-3, ct;
        it > St * Y + ht ? (lt = F, ut = E, ft = k, vt = R, pt = tt, x.m_type = M.e_faceB, gt = 1) : (lt = E, ut = F, ft = R, vt = k, pt = V, x.m_type = M.e_faceA, gt = 0);
        var bt = _.s_incidentEdge;
        _.FindIncidentEdge(bt, lt, ft, pt, ut, vt);
        var Et = parseInt(lt.m_vertexCount), wt = lt.m_vertices, It = wt[pt], Dt;
        pt + 1 < Et ? Dt = wt[parseInt(pt + 1)] : Dt = wt[0];
        var Ut = _.s_localTangent;
        Ut.Set(Dt.x - It.x, Dt.y - It.y), Ut.Normalize();
        var Gt = _.s_localNormal;
        Gt.x = Ut.y, Gt.y = -Ut.x;
        var at = _.s_planePoint;
        at.Set(0.5 * (It.x + Dt.x), 0.5 * (It.y + Dt.y));
        var ot = _.s_tangent;
        ct = ft.R, ot.x = ct.col1.x * Ut.x + ct.col2.x * Ut.y, ot.y = ct.col1.y * Ut.x + ct.col2.y * Ut.y;
        var _t = _.s_tangent2;
        _t.x = -ot.x, _t.y = -ot.y;
        var mt = _.s_normal;
        mt.x = ot.y, mt.y = -ot.x;
        var Ct = _.s_v11, yt = _.s_v12;
        Ct.x = ft.position.x + (ct.col1.x * It.x + ct.col2.x * It.y), Ct.y = ft.position.y + (ct.col1.y * It.x + ct.col2.y * It.y), yt.x = ft.position.x + (ct.col1.x * Dt.x + ct.col2.x * Dt.y), yt.y = ft.position.y + (ct.col1.y * Dt.x + ct.col2.y * Dt.y);
        var At = mt.x * Ct.x + mt.y * Ct.y, Pt = -ot.x * Ct.x - ot.y * Ct.y + j, kt = ot.x * yt.x + ot.y * yt.y + j, Ot = _.s_clipPoints1, Xt = _.s_clipPoints2, Vt = 0;
        if (Vt = _.ClipSegmentToLine(Ot, bt, _t, Pt), !(Vt < 2) && (Vt = _.ClipSegmentToLine(Xt, Ot, ot, kt), !(Vt < 2))) {
          x.m_localPlaneNormal.SetV(Gt), x.m_localPoint.SetV(at);
          for (var Lt = 0, Nt = 0; Nt < r.b2_maxManifoldPoints; ++Nt) {
            X = Xt[Nt];
            var Jt = mt.x * X.v.x + mt.y * X.v.y - At;
            if (Jt <= j) {
              var Ht = x.m_points[Lt];
              ct = vt.R;
              var Kt = X.v.x - vt.position.x, ee = X.v.y - vt.position.y;
              Ht.m_localPoint.x = Kt * ct.col1.x + ee * ct.col1.y, Ht.m_localPoint.y = Kt * ct.col2.x + ee * ct.col2.y, Ht.m_id.Set(X.id), Ht.m_id.features.flip = gt, ++Lt;
            }
          }
          x.m_pointCount = Lt;
        }
      }
    }
  }, _.CollideCircles = function(x, E, R, F, k) {
    x.m_pointCount = 0;
    var X, j;
    X = R.R, j = E.m_p;
    var V = R.position.x + (X.col1.x * j.x + X.col2.x * j.y), Y = R.position.y + (X.col1.y * j.x + X.col2.y * j.y);
    X = k.R, j = F.m_p;
    var tt = k.position.x + (X.col1.x * j.x + X.col2.x * j.y), it = k.position.y + (X.col1.y * j.x + X.col2.y * j.y), lt = tt - V, ut = it - Y, ft = lt * lt + ut * ut, vt = E.m_radius + F.m_radius;
    ft > vt * vt || (x.m_type = M.e_circles, x.m_localPoint.SetV(E.m_p), x.m_localPlaneNormal.SetZero(), x.m_pointCount = 1, x.m_points[0].m_localPoint.SetV(F.m_p), x.m_points[0].m_id.key = 0);
  }, _.CollidePolygonAndCircle = function(x, E, R, F, k) {
    x.m_pointCount = 0;
    var X = 0, j = 0, V, Y;
    Y = k.R, V = F.m_p;
    var tt = k.position.x + (Y.col1.x * V.x + Y.col2.x * V.y), it = k.position.y + (Y.col1.y * V.x + Y.col2.y * V.y);
    X = tt - R.position.x, j = it - R.position.y, Y = R.R;
    for (var lt = X * Y.col1.x + j * Y.col1.y, ut = X * Y.col2.x + j * Y.col2.y, ft = 0, vt = -Number.MAX_VALUE, pt = E.m_radius + F.m_radius, gt = parseInt(E.m_vertexCount), St = E.m_vertices, ht = E.m_normals, ct = 0; ct < gt; ++ct) {
      V = St[ct], X = lt - V.x, j = ut - V.y, V = ht[ct];
      var bt = V.x * X + V.y * j;
      if (bt > pt)
        return;
      bt > vt && (vt = bt, ft = ct);
    }
    var Et = parseInt(ft), wt = parseInt(Et + 1 < gt ? Et + 1 : 0), It = St[Et], Dt = St[wt];
    if (vt < Number.MIN_VALUE) {
      x.m_pointCount = 1, x.m_type = M.e_faceA, x.m_localPlaneNormal.SetV(ht[ft]), x.m_localPoint.x = 0.5 * (It.x + Dt.x), x.m_localPoint.y = 0.5 * (It.y + Dt.y), x.m_points[0].m_localPoint.SetV(F.m_p), x.m_points[0].m_id.key = 0;
      return;
    }
    var Ut = (lt - It.x) * (Dt.x - It.x) + (ut - It.y) * (Dt.y - It.y), Gt = (lt - Dt.x) * (It.x - Dt.x) + (ut - Dt.y) * (It.y - Dt.y);
    if (Ut <= 0) {
      if ((lt - It.x) * (lt - It.x) + (ut - It.y) * (ut - It.y) > pt * pt)
        return;
      x.m_pointCount = 1, x.m_type = M.e_faceA, x.m_localPlaneNormal.x = lt - It.x, x.m_localPlaneNormal.y = ut - It.y, x.m_localPlaneNormal.Normalize(), x.m_localPoint.SetV(It), x.m_points[0].m_localPoint.SetV(F.m_p), x.m_points[0].m_id.key = 0;
    } else if (Gt <= 0) {
      if ((lt - Dt.x) * (lt - Dt.x) + (ut - Dt.y) * (ut - Dt.y) > pt * pt)
        return;
      x.m_pointCount = 1, x.m_type = M.e_faceA, x.m_localPlaneNormal.x = lt - Dt.x, x.m_localPlaneNormal.y = ut - Dt.y, x.m_localPlaneNormal.Normalize(), x.m_localPoint.SetV(Dt), x.m_points[0].m_localPoint.SetV(F.m_p), x.m_points[0].m_id.key = 0;
    } else {
      var at = 0.5 * (It.x + Dt.x), ot = 0.5 * (It.y + Dt.y);
      if (vt = (lt - at) * ht[Et].x + (ut - ot) * ht[Et].y, vt > pt)
        return;
      x.m_pointCount = 1, x.m_type = M.e_faceA, x.m_localPlaneNormal.x = ht[Et].x, x.m_localPlaneNormal.y = ht[Et].y, x.m_localPlaneNormal.Normalize(), x.m_localPoint.Set(at, ot), x.m_points[0].m_localPoint.SetV(F.m_p), x.m_points[0].m_id.key = 0;
    }
  }, _.TestOverlap = function(x, E) {
    var R = E.lowerBound, F = x.upperBound, k = R.x - F.x, X = R.y - F.y;
    R = x.lowerBound, F = E.upperBound;
    var j = R.x - F.x, V = R.y - F.y;
    return !(k > 0 || X > 0 || j > 0 || V > 0);
  }, Box2D.postDefs.push(function() {
    Box2D.Collision.b2Collision.s_incidentEdge = _.MakeClipPointVector(), Box2D.Collision.b2Collision.s_clipPoints1 = _.MakeClipPointVector(), Box2D.Collision.b2Collision.s_clipPoints2 = _.MakeClipPointVector(), Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1), Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1), Box2D.Collision.b2Collision.s_localTangent = new c(), Box2D.Collision.b2Collision.s_localNormal = new c(), Box2D.Collision.b2Collision.s_planePoint = new c(), Box2D.Collision.b2Collision.s_normal = new c(), Box2D.Collision.b2Collision.s_tangent = new c(), Box2D.Collision.b2Collision.s_tangent2 = new c(), Box2D.Collision.b2Collision.s_v11 = new c(), Box2D.Collision.b2Collision.s_v12 = new c(), Box2D.Collision.b2Collision.b2CollidePolyTempVec = new c(), Box2D.Collision.b2Collision.b2_nullFeature = 255;
  }), d.b2ContactID = function() {
    this.features = new b();
  }, d.prototype.b2ContactID = function() {
    this.features._m_id = (this || window);
  }, d.prototype.Set = function(x) {
    this.key = x._key;
  }, d.prototype.Copy = function() {
    var x = new d();
    return x.key = (this || window).key, x;
  }, Object.defineProperty(d.prototype, "key", {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this._key;
    }
  }), Object.defineProperty(d.prototype, "key", {
    enumerable: !1,
    configurable: !0,
    set: function(x) {
      x === void 0 && (x = 0), this._key = x, this.features._referenceEdge = (this || window)._key & 255, this.features._incidentEdge = (this._key & 65280) >> 8 & 255, this.features._incidentVertex = (this._key & 16711680) >> 16 & 255, this.features._flip = (this._key & 4278190080) >> 24 & 255;
    }
  }), f.b2ContactPoint = function() {
    this.position = new c(), this.velocity = new c(), this.normal = new c(), this.id = new d();
  }, C.b2Distance = function() {
  }, C.Distance = function(x, E, R) {
    ++C.b2_gjkCalls;
    var F = R.proxyA, k = R.proxyB, X = R.transformA, j = R.transformB, V = C.s_simplex;
    V.ReadCache(E, F, X, k, j);
    var Y = V.m_vertices, tt = 20, it = C.s_saveA, lt = C.s_saveB, ut = 0, ft = V.GetClosestPoint();
    ft.LengthSquared();
    for (var vt = 0, pt, gt = 0; gt < tt; ) {
      for (ut = V.m_count, vt = 0; vt < ut; vt++)
        it[vt] = Y[vt].indexA, lt[vt] = Y[vt].indexB;
      switch (V.m_count) {
        case 1:
          break;
        case 2:
          V.Solve2();
          break;
        case 3:
          V.Solve3();
          break;
        default:
          r.b2Assert(!1);
      }
      if (V.m_count == 3)
        break;
      pt = V.GetClosestPoint(), pt.LengthSquared();
      var St = V.GetSearchDirection();
      if (St.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE)
        break;
      var ht = Y[V.m_count];
      ht.indexA = F.GetSupport(s.MulTMV(X.R, St.GetNegative())), ht.wA = s.MulX(X, F.GetVertex(ht.indexA)), ht.indexB = k.GetSupport(s.MulTMV(j.R, St)), ht.wB = s.MulX(j, k.GetVertex(ht.indexB)), ht.w = s.SubtractVV(ht.wB, ht.wA), ++gt, ++C.b2_gjkIters;
      var ct = !1;
      for (vt = 0; vt < ut; vt++)
        if (ht.indexA == it[vt] && ht.indexB == lt[vt]) {
          ct = !0;
          break;
        }
      if (ct)
        break;
      ++V.m_count;
    }
    if (C.b2_gjkMaxIters = s.Max(C.b2_gjkMaxIters, gt), V.GetWitnessPoints(x.pointA, x.pointB), x.distance = s.SubtractVV(x.pointA, x.pointB).Length(), x.iterations = gt, V.WriteCache(E), R.useRadii) {
      var bt = F.m_radius, Et = k.m_radius;
      if (x.distance > bt + Et && x.distance > Number.MIN_VALUE) {
        x.distance -= bt + Et;
        var wt = s.SubtractVV(x.pointB, x.pointA);
        wt.Normalize(), x.pointA.x += bt * wt.x, x.pointA.y += bt * wt.y, x.pointB.x -= Et * wt.x, x.pointB.y -= Et * wt.y;
      } else
        pt = new c(), pt.x = 0.5 * (x.pointA.x + x.pointB.x), pt.y = 0.5 * (x.pointA.y + x.pointB.y), x.pointA.x = x.pointB.x = pt.x, x.pointA.y = x.pointB.y = pt.y, x.distance = 0;
    }
  }, Box2D.postDefs.push(function() {
    Box2D.Collision.b2Distance.s_simplex = new L(), Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3), Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
  }), m.b2DistanceInput = function() {
  }, g.b2DistanceOutput = function() {
    this.pointA = new c(), this.pointB = new c();
  }, y.b2DistanceProxy = function() {
  }, y.prototype.Set = function(x) {
    switch (x.GetType()) {
      case n.e_circleShape:
        {
          var E = x instanceof t ? x : null;
          this.m_vertices = new Vector(1, !0), this.m_vertices[0] = E.m_p, this.m_count = 1, this.m_radius = E.m_radius;
        }
        break;
      case n.e_polygonShape:
        {
          var R = x instanceof e ? x : null;
          this.m_vertices = R.m_vertices, this.m_count = R.m_vertexCount, this.m_radius = R.m_radius;
        }
        break;
      default:
        r.b2Assert(!1);
    }
  }, y.prototype.GetSupport = function(x) {
    for (var E = 0, R = (this || window).m_vertices[0].x * x.x + this.m_vertices[0].y * x.y, F = 1; F < this.m_count; ++F) {
      var k = (this || window).m_vertices[F].x * x.x + this.m_vertices[F].y * x.y;
      k > R && (E = F, R = k);
    }
    return E;
  }, y.prototype.GetSupportVertex = function(x) {
    for (var E = 0, R = (this || window).m_vertices[0].x * x.x + this.m_vertices[0].y * x.y, F = 1; F < this.m_count; ++F) {
      var k = (this || window).m_vertices[F].x * x.x + this.m_vertices[F].y * x.y;
      k > R && (E = F, R = k);
    }
    return this.m_vertices[E];
  }, y.prototype.GetVertexCount = function() {
    return this.m_count;
  }, y.prototype.GetVertex = function(x) {
    return x === void 0 && (x = 0), r.b2Assert(0 <= x && x < this.m_count), this.m_vertices[x];
  }, A.b2DynamicTree = function() {
  }, A.prototype.b2DynamicTree = function() {
    this.m_root = null, this.m_freeList = null, this.m_path = 0, this.m_insertionCount = 0;
  }, A.prototype.CreateProxy = function(x, E) {
    var R = (this || window).AllocateNode(), F = r.b2_aabbExtension, k = r.b2_aabbExtension;
    return R.aabb.lowerBound.x = x.lowerBound.x - F, R.aabb.lowerBound.y = x.lowerBound.y - k, R.aabb.upperBound.x = x.upperBound.x + F, R.aabb.upperBound.y = x.upperBound.y + k, R.userData = E, this.InsertLeaf(R), R;
  }, A.prototype.DestroyProxy = function(x) {
    this.RemoveLeaf(x), this.FreeNode(x);
  }, A.prototype.MoveProxy = function(x, E, R) {
    if (r.b2Assert(x.IsLeaf()), x.aabb.Contains(E))
      return !1;
    this.RemoveLeaf(x);
    var F = r.b2_aabbExtension + r.b2_aabbMultiplier * (R.x > 0 ? R.x : -R.x), k = r.b2_aabbExtension + r.b2_aabbMultiplier * (R.y > 0 ? R.y : -R.y);
    return x.aabb.lowerBound.x = E.lowerBound.x - F, x.aabb.lowerBound.y = E.lowerBound.y - k, x.aabb.upperBound.x = E.upperBound.x + F, x.aabb.upperBound.y = E.upperBound.y + k, this.InsertLeaf(x), !0;
  }, A.prototype.Rebalance = function(x) {
    if (x === void 0 && (x = 0), this.m_root != null)
      for (var E = 0; E < x; E++) {
        for (var R = (this || window).m_root, F = 0; R.IsLeaf() == !1; )
          R = (this || window).m_path >> F & 1 ? R.child2 : R.child1, F = F + 1 & 31;
        ++this.m_path, this.RemoveLeaf(R), this.InsertLeaf(R);
      }
  }, A.prototype.GetFatAABB = function(x) {
    return x.aabb;
  }, A.prototype.GetUserData = function(x) {
    return x.userData;
  }, A.prototype.Query = function(x, E) {
    if (this.m_root != null) {
      var R = new Vector(), F = 0;
      for (R[F++] = (this || window).m_root; F > 0; ) {
        var k = R[--F];
        if (k.aabb.TestOverlap(E))
          if (k.IsLeaf()) {
            var X = x(k);
            if (!X)
              return;
          } else
            R[F++] = k.child1, R[F++] = k.child2;
      }
    }
  }, A.prototype.RayCast = function(x, E) {
    if (this.m_root != null) {
      var R = E.p1, F = E.p2, k = s.SubtractVV(R, F);
      k.Normalize();
      var X = s.CrossFV(1, k), j = s.AbsV(X), V = E.maxFraction, Y = new l(), tt = 0, it = 0;
      tt = R.x + V * (F.x - R.x), it = R.y + V * (F.y - R.y), Y.lowerBound.x = Math.min(R.x, tt), Y.lowerBound.y = Math.min(R.y, it), Y.upperBound.x = Math.max(R.x, tt), Y.upperBound.y = Math.max(R.y, it);
      var lt = new Vector(), ut = 0;
      for (lt[ut++] = (this || window).m_root; ut > 0; ) {
        var ft = lt[--ut];
        if (ft.aabb.TestOverlap(Y) != !1) {
          var vt = ft.aabb.GetCenter(), pt = ft.aabb.GetExtents(), gt = Math.abs(X.x * (R.x - vt.x) + X.y * (R.y - vt.y)) - j.x * pt.x - j.y * pt.y;
          if (!(gt > 0))
            if (ft.IsLeaf()) {
              var St = new Q();
              if (St.p1 = E.p1, St.p2 = E.p2, St.maxFraction = E.maxFraction, V = x(St, ft), V == 0)
                return;
              V > 0 && (tt = R.x + V * (F.x - R.x), it = R.y + V * (F.y - R.y), Y.lowerBound.x = Math.min(R.x, tt), Y.lowerBound.y = Math.min(R.y, it), Y.upperBound.x = Math.max(R.x, tt), Y.upperBound.y = Math.max(R.y, it));
            } else
              lt[ut++] = ft.child1, lt[ut++] = ft.child2;
        }
      }
    }
  }, A.prototype.AllocateNode = function() {
    if (this.m_freeList) {
      var x = (this || window).m_freeList;
      return this.m_freeList = x.parent, x.parent = null, x.child1 = null, x.child2 = null, x;
    }
    return new N();
  }, A.prototype.FreeNode = function(x) {
    x.parent = (this || window).m_freeList, this.m_freeList = x;
  }, A.prototype.InsertLeaf = function(x) {
    if (++this.m_insertionCount, this.m_root == null) {
      this.m_root = x, this.m_root.parent = null;
      return;
    }
    var E = x.aabb.GetCenter(), R = (this || window).m_root;
    if (R.IsLeaf() == !1)
      do {
        var F = R.child1, k = R.child2, X = Math.abs((F.aabb.lowerBound.x + F.aabb.upperBound.x) / 2 - E.x) + Math.abs((F.aabb.lowerBound.y + F.aabb.upperBound.y) / 2 - E.y), j = Math.abs((k.aabb.lowerBound.x + k.aabb.upperBound.x) / 2 - E.x) + Math.abs((k.aabb.lowerBound.y + k.aabb.upperBound.y) / 2 - E.y);
        X < j ? R = F : R = k;
      } while (R.IsLeaf() == !1);
    var V = R.parent, Y = (this || window).AllocateNode();
    if (Y.parent = V, Y.userData = null, Y.aabb.Combine(x.aabb, R.aabb), V) {
      R.parent.child1 == R ? V.child1 = Y : V.child2 = Y, Y.child1 = R, Y.child2 = x, R.parent = Y, x.parent = Y;
      do {
        if (V.aabb.Contains(Y.aabb))
          break;
        V.aabb.Combine(V.child1.aabb, V.child2.aabb), Y = V, V = V.parent;
      } while (V);
    } else
      Y.child1 = R, Y.child2 = x, R.parent = Y, x.parent = Y, this.m_root = Y;
  }, A.prototype.RemoveLeaf = function(x) {
    if (x == (this || window).m_root) {
      this.m_root = null;
      return;
    }
    var E = x.parent, R = E.parent, F;
    if (E.child1 == x ? F = E.child2 : F = E.child1, R)
      for (R.child1 == E ? R.child1 = F : R.child2 = F, F.parent = R, this.FreeNode(E); R; ) {
        var k = R.aabb;
        if (R.aabb = l.Combine(R.child1.aabb, R.child2.aabb), k.Contains(R.aabb))
          break;
        R = R.parent;
      }
    else
      this.m_root = F, F.parent = null, this.FreeNode(E);
  }, D.b2DynamicTreeBroadPhase = function() {
    this.m_tree = new A(), this.m_moveBuffer = new Vector(), this.m_pairBuffer = new Vector(), this.m_pairCount = 0;
  }, D.prototype.CreateProxy = function(x, E) {
    var R = (this || window).m_tree.CreateProxy(x, E);
    return ++this.m_proxyCount, this.BufferMove(R), R;
  }, D.prototype.DestroyProxy = function(x) {
    this.UnBufferMove(x), --this.m_proxyCount, this.m_tree.DestroyProxy(x);
  }, D.prototype.MoveProxy = function(x, E, R) {
    var F = (this || window).m_tree.MoveProxy(x, E, R);
    F && this.BufferMove(x);
  }, D.prototype.TestOverlap = function(x, E) {
    var R = (this || window).m_tree.GetFatAABB(x), F = (this || window).m_tree.GetFatAABB(E);
    return R.TestOverlap(F);
  }, D.prototype.GetUserData = function(x) {
    return this.m_tree.GetUserData(x);
  }, D.prototype.GetFatAABB = function(x) {
    return this.m_tree.GetFatAABB(x);
  }, D.prototype.GetProxyCount = function() {
    return this.m_proxyCount;
  }, D.prototype.UpdatePairs = function(x) {
    var E = (this || window);
    E.m_pairCount = 0;
    var R = 0, F;
    for (R = 0; R < E.m_moveBuffer.length; ++R) {
      let tt = function(it) {
        if (it == F)
          return !0;
        E.m_pairCount == E.m_pairBuffer.length && (E.m_pairBuffer[E.m_pairCount] = new z());
        var lt = E.m_pairBuffer[E.m_pairCount];
        return lt.proxyA = it < F ? it : F, lt.proxyB = it >= F ? it : F, ++E.m_pairCount, !0;
      };
      H(tt, "QueryCallback"), F = E.m_moveBuffer[R];
      var k = E.m_tree.GetFatAABB(F);
      E.m_tree.Query(tt, k);
    }
    E.m_moveBuffer.length = 0;
    for (var R = 0; R < E.m_pairCount; ) {
      var X = E.m_pairBuffer[R], j = E.m_tree.GetUserData(X.proxyA), V = E.m_tree.GetUserData(X.proxyB);
      for (x(j, V), ++R; R < E.m_pairCount; ) {
        var Y = E.m_pairBuffer[R];
        if (Y.proxyA != X.proxyA || Y.proxyB != X.proxyB)
          break;
        ++R;
      }
    }
  }, D.prototype.Query = function(x, E) {
    this.m_tree.Query(x, E);
  }, D.prototype.RayCast = function(x, E) {
    this.m_tree.RayCast(x, E);
  }, D.prototype.Validate = function() {
  }, D.prototype.Rebalance = function(x) {
    x === void 0 && (x = 0), this.m_tree.Rebalance(x);
  }, D.prototype.BufferMove = function(x) {
    this.m_moveBuffer[this.m_moveBuffer.length] = x;
  }, D.prototype.UnBufferMove = function(x) {
    var E = parseInt(this.m_moveBuffer.indexOf(x));
    this.m_moveBuffer.splice(E, 1);
  }, D.prototype.ComparePairs = function(x, E) {
    return 0;
  }, D.__implements = {}, D.__implements[W] = !0, N.b2DynamicTreeNode = function() {
    this.aabb = new l();
  }, N.prototype.IsLeaf = function() {
    return this.child1 == null;
  }, z.b2DynamicTreePair = function() {
  }, M.b2Manifold = function() {
    this.m_pointCount = 0;
  }, M.prototype.b2Manifold = function() {
    this.m_points = new Vector(r.b2_maxManifoldPoints);
    for (var x = 0; x < r.b2_maxManifoldPoints; x++)
      this.m_points[x] = new Z();
    this.m_localPlaneNormal = new c(), this.m_localPoint = new c();
  }, M.prototype.Reset = function() {
    for (var x = 0; x < r.b2_maxManifoldPoints; x++)
      (this.m_points[x] instanceof Z ? this.m_points[x] : null).Reset();
    this.m_localPlaneNormal.SetZero(), this.m_localPoint.SetZero(), this.m_type = 0, this.m_pointCount = 0;
  }, M.prototype.Set = function(x) {
    this.m_pointCount = x.m_pointCount;
    for (var E = 0; E < r.b2_maxManifoldPoints; E++)
      (this.m_points[E] instanceof Z ? this.m_points[E] : null).Set(x.m_points[E]);
    this.m_localPlaneNormal.SetV(x.m_localPlaneNormal), this.m_localPoint.SetV(x.m_localPoint), this.m_type = x.m_type;
  }, M.prototype.Copy = function() {
    var x = new M();
    return x.Set(this), x;
  }, Box2D.postDefs.push(function() {
    Box2D.Collision.b2Manifold.e_circles = 1, Box2D.Collision.b2Manifold.e_faceA = 2, Box2D.Collision.b2Manifold.e_faceB = 4;
  }), Z.b2ManifoldPoint = function() {
    this.m_localPoint = new c(), this.m_id = new d();
  }, Z.prototype.b2ManifoldPoint = function() {
    this.Reset();
  }, Z.prototype.Reset = function() {
    this.m_localPoint.SetZero(), this.m_normalImpulse = 0, this.m_tangentImpulse = 0, this.m_id.key = 0;
  }, Z.prototype.Set = function(x) {
    this.m_localPoint.SetV(x.m_localPoint), this.m_normalImpulse = x.m_normalImpulse, this.m_tangentImpulse = x.m_tangentImpulse, this.m_id.Set(x.m_id);
  }, U.b2Point = function() {
    this.p = new c();
  }, U.prototype.Support = function(x, E, R) {
    return this.p;
  }, U.prototype.GetFirstVertex = function(x) {
    return this.p;
  }, Q.b2RayCastInput = function() {
    this.p1 = new c(), this.p2 = new c();
  }, Q.prototype.b2RayCastInput = function(x, E, R) {
    x === void 0 && (x = null), E === void 0 && (E = null), R === void 0 && (R = 1), x && this.p1.SetV(x), E && this.p2.SetV(E), this.maxFraction = R;
  }, et.b2RayCastOutput = function() {
    this.normal = new c();
  }, rt.b2Segment = function() {
    this.p1 = new c(), this.p2 = new c();
  }, rt.prototype.TestSegment = function(x, E, R, F) {
    F === void 0 && (F = 0);
    var k = R.p1, X = R.p2.x - k.x, j = R.p2.y - k.y, V = (this || window).p2.x - this.p1.x, Y = (this || window).p2.y - this.p1.y, tt = Y, it = -V, lt = 100 * Number.MIN_VALUE, ut = -(X * tt + j * it);
    if (ut > lt) {
      var ft = k.x - this.p1.x, vt = k.y - this.p1.y, pt = ft * tt + vt * it;
      if (0 <= pt && pt <= F * ut) {
        var gt = -X * vt + j * ft;
        if (-lt * ut <= gt && gt <= ut * (1 + lt)) {
          pt /= ut;
          var St = Math.sqrt(tt * tt + it * it);
          return tt /= St, it /= St, x[0] = pt, E.Set(tt, it), !0;
        }
      }
    }
    return !1;
  }, rt.prototype.Extend = function(x) {
    this.ExtendForward(x), this.ExtendBackward(x);
  }, rt.prototype.ExtendForward = function(x) {
    var E = (this || window).p2.x - this.p1.x, R = (this || window).p2.y - this.p1.y, F = Math.min(
      E > 0 ? (x.upperBound.x - this.p1.x) / E : E < 0 ? (x.lowerBound.x - this.p1.x) / E : Number.POSITIVE_INFINITY,
      R > 0 ? (x.upperBound.y - this.p1.y) / R : R < 0 ? (x.lowerBound.y - this.p1.y) / R : Number.POSITIVE_INFINITY
    );
    this.p2.x = (this || window).p1.x + E * F, this.p2.y = (this || window).p1.y + R * F;
  }, rt.prototype.ExtendBackward = function(x) {
    var E = -this.p2.x + this.p1.x, R = -this.p2.y + this.p1.y, F = Math.min(
      E > 0 ? (x.upperBound.x - this.p2.x) / E : E < 0 ? (x.lowerBound.x - this.p2.x) / E : Number.POSITIVE_INFINITY,
      R > 0 ? (x.upperBound.y - this.p2.y) / R : R < 0 ? (x.lowerBound.y - this.p2.y) / R : Number.POSITIVE_INFINITY
    );
    this.p1.x = (this || window).p2.x + E * F, this.p1.y = (this || window).p2.y + R * F;
  }, w.b2SeparationFunction = function() {
    this.m_localPoint = new c(), this.m_axis = new c();
  }, w.prototype.Initialize = function(x, E, R, F, k) {
    this.m_proxyA = E, this.m_proxyB = F;
    var X = parseInt(x.count);
    r.b2Assert(0 < X && X < 3);
    var j, V, Y, tt, it, lt, ut = 0, ft = 0, vt = 0, pt = 0, gt = 0, St = 0, ht, ct, bt = 0;
    if (X == 1)
      this.m_type = w.e_points, j = (this || window).m_proxyA.GetVertex(x.indexA[0]), tt = (this || window).m_proxyB.GetVertex(x.indexB[0]), ct = j, ht = R.R, ut = R.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), ft = R.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), ct = tt, ht = k.R, vt = k.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), pt = k.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), this.m_axis.x = vt - ut, this.m_axis.y = pt - ft, this.m_axis.Normalize();
    else if (x.indexB[0] == x.indexB[1])
      this.m_type = w.e_faceA, V = (this || window).m_proxyA.GetVertex(x.indexA[0]), Y = (this || window).m_proxyA.GetVertex(x.indexA[1]), tt = (this || window).m_proxyB.GetVertex(x.indexB[0]), this.m_localPoint.x = 0.5 * (V.x + Y.x), this.m_localPoint.y = 0.5 * (V.y + Y.y), this.m_axis = s.CrossVF(s.SubtractVV(Y, V), 1), this.m_axis.Normalize(), ct = (this || window).m_axis, ht = R.R, gt = ht.col1.x * ct.x + ht.col2.x * ct.y, St = ht.col1.y * ct.x + ht.col2.y * ct.y, ct = (this || window).m_localPoint, ht = R.R, ut = R.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), ft = R.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), ct = tt, ht = k.R, vt = k.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), pt = k.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), bt = (vt - ut) * gt + (pt - ft) * St, bt < 0 && this.m_axis.NegativeSelf();
    else if (x.indexA[0] == x.indexA[0])
      this.m_type = w.e_faceB, it = (this || window).m_proxyB.GetVertex(x.indexB[0]), lt = (this || window).m_proxyB.GetVertex(x.indexB[1]), j = (this || window).m_proxyA.GetVertex(x.indexA[0]), this.m_localPoint.x = 0.5 * (it.x + lt.x), this.m_localPoint.y = 0.5 * (it.y + lt.y), this.m_axis = s.CrossVF(s.SubtractVV(lt, it), 1), this.m_axis.Normalize(), ct = (this || window).m_axis, ht = k.R, gt = ht.col1.x * ct.x + ht.col2.x * ct.y, St = ht.col1.y * ct.x + ht.col2.y * ct.y, ct = (this || window).m_localPoint, ht = k.R, vt = k.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), pt = k.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), ct = j, ht = R.R, ut = R.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), ft = R.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), bt = (ut - vt) * gt + (ft - pt) * St, bt < 0 && this.m_axis.NegativeSelf();
    else {
      V = (this || window).m_proxyA.GetVertex(x.indexA[0]), Y = (this || window).m_proxyA.GetVertex(x.indexA[1]), it = (this || window).m_proxyB.GetVertex(x.indexB[0]), lt = (this || window).m_proxyB.GetVertex(x.indexB[1]), s.MulX(R, j);
      var Et = s.MulMV(R.R, s.SubtractVV(Y, V));
      s.MulX(k, tt);
      var wt = s.MulMV(k.R, s.SubtractVV(lt, it)), It = Et.x * Et.x + Et.y * Et.y, Dt = wt.x * wt.x + wt.y * wt.y, Ut = s.SubtractVV(wt, Et), Gt = Et.x * Ut.x + Et.y * Ut.y, at = wt.x * Ut.x + wt.y * Ut.y, ot = Et.x * wt.x + Et.y * wt.y, _t = It * Dt - ot * ot;
      bt = 0, _t != 0 && (bt = s.Clamp((ot * at - Gt * Dt) / _t, 0, 1));
      var mt = (ot * bt + at) / Dt;
      mt < 0 && (mt = 0, bt = s.Clamp((ot - Gt) / It, 0, 1)), j = new c(), j.x = V.x + bt * (Y.x - V.x), j.y = V.y + bt * (Y.y - V.y), tt = new c(), tt.x = it.x + bt * (lt.x - it.x), tt.y = it.y + bt * (lt.y - it.y), bt == 0 || bt == 1 ? (this.m_type = w.e_faceB, this.m_axis = s.CrossVF(s.SubtractVV(lt, it), 1), this.m_axis.Normalize(), this.m_localPoint = tt, ct = (this || window).m_axis, ht = k.R, gt = ht.col1.x * ct.x + ht.col2.x * ct.y, St = ht.col1.y * ct.x + ht.col2.y * ct.y, ct = (this || window).m_localPoint, ht = k.R, vt = k.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), pt = k.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), ct = j, ht = R.R, ut = R.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), ft = R.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), bt < 0 && this.m_axis.NegativeSelf()) : (this.m_type = w.e_faceA, this.m_axis = s.CrossVF(s.SubtractVV(Y, V), 1), this.m_localPoint = j, ct = (this || window).m_axis, ht = R.R, gt = ht.col1.x * ct.x + ht.col2.x * ct.y, St = ht.col1.y * ct.x + ht.col2.y * ct.y, ct = (this || window).m_localPoint, ht = R.R, ut = R.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), ft = R.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), ct = tt, ht = k.R, vt = k.position.x + (ht.col1.x * ct.x + ht.col2.x * ct.y), pt = k.position.y + (ht.col1.y * ct.x + ht.col2.y * ct.y), bt < 0 && this.m_axis.NegativeSelf());
    }
  }, w.prototype.Evaluate = function(x, E) {
    var R, F, k, X, j, V, Y = 0, tt;
    switch (this.m_type) {
      case w.e_points:
        return R = s.MulTMV(x.R, this.m_axis), F = s.MulTMV(E.R, this.m_axis.GetNegative()), k = (this || window).m_proxyA.GetSupportVertex(R), X = (this || window).m_proxyB.GetSupportVertex(F), j = s.MulX(x, k), V = s.MulX(E, X), Y = (V.x - j.x) * this.m_axis.x + (V.y - j.y) * this.m_axis.y, Y;
      case w.e_faceA:
        return tt = s.MulMV(x.R, this.m_axis), j = s.MulX(x, this.m_localPoint), F = s.MulTMV(E.R, tt.GetNegative()), X = (this || window).m_proxyB.GetSupportVertex(F), V = s.MulX(E, X), Y = (V.x - j.x) * tt.x + (V.y - j.y) * tt.y, Y;
      case w.e_faceB:
        return tt = s.MulMV(E.R, this.m_axis), V = s.MulX(E, this.m_localPoint), R = s.MulTMV(x.R, tt.GetNegative()), k = (this || window).m_proxyA.GetSupportVertex(R), j = s.MulX(x, k), Y = (j.x - V.x) * tt.x + (j.y - V.y) * tt.y, Y;
      default:
        return r.b2Assert(!1), 0;
    }
  }, Box2D.postDefs.push(function() {
    Box2D.Collision.b2SeparationFunction.e_points = 1, Box2D.Collision.b2SeparationFunction.e_faceA = 2, Box2D.Collision.b2SeparationFunction.e_faceB = 4;
  }), L.b2Simplex = function() {
    this.m_v1 = new I(), this.m_v2 = new I(), this.m_v3 = new I(), this.m_vertices = new Vector(3);
  }, L.prototype.b2Simplex = function() {
    this.m_vertices[0] = (this || window).m_v1, this.m_vertices[1] = (this || window).m_v2, this.m_vertices[2] = (this || window).m_v3;
  }, L.prototype.ReadCache = function(x, E, R, F, k) {
    r.b2Assert(0 <= x.count && x.count <= 3);
    var X, j;
    this.m_count = x.count;
    for (var V = (this || window).m_vertices, Y = 0; Y < this.m_count; Y++) {
      var tt = V[Y];
      tt.indexA = x.indexA[Y], tt.indexB = x.indexB[Y], X = E.GetVertex(tt.indexA), j = F.GetVertex(tt.indexB), tt.wA = s.MulX(R, X), tt.wB = s.MulX(k, j), tt.w = s.SubtractVV(tt.wB, tt.wA), tt.a = 0;
    }
    if (this.m_count > 1) {
      var it = x.metric, lt = (this || window).GetMetric();
      (lt < 0.5 * it || 2 * it < lt || lt < Number.MIN_VALUE) && (this.m_count = 0);
    }
    this.m_count == 0 && (tt = V[0], tt.indexA = 0, tt.indexB = 0, X = E.GetVertex(0), j = F.GetVertex(0), tt.wA = s.MulX(R, X), tt.wB = s.MulX(k, j), tt.w = s.SubtractVV(tt.wB, tt.wA), this.m_count = 1);
  }, L.prototype.WriteCache = function(x) {
    x.metric = (this || window).GetMetric(), x.count = Box2D.parseUInt(this.m_count);
    for (var E = (this || window).m_vertices, R = 0; R < this.m_count; R++)
      x.indexA[R] = Box2D.parseUInt(E[R].indexA), x.indexB[R] = Box2D.parseUInt(E[R].indexB);
  }, L.prototype.GetSearchDirection = function() {
    switch (this.m_count) {
      case 1:
        return this.m_v1.w.GetNegative();
      case 2: {
        var x = s.SubtractVV(this.m_v2.w, this.m_v1.w), E = s.CrossVV(x, this.m_v1.w.GetNegative());
        return E > 0 ? s.CrossFV(1, x) : s.CrossVF(x, 1);
      }
      default:
        return r.b2Assert(!1), new c();
    }
  }, L.prototype.GetClosestPoint = function() {
    switch (this.m_count) {
      case 0:
        return r.b2Assert(!1), new c();
      case 1:
        return this.m_v1.w;
      case 2:
        return new c(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
      default:
        return r.b2Assert(!1), new c();
    }
  }, L.prototype.GetWitnessPoints = function(x, E) {
    switch (this.m_count) {
      case 0:
        r.b2Assert(!1);
        break;
      case 1:
        x.SetV(this.m_v1.wA), E.SetV(this.m_v1.wB);
        break;
      case 2:
        x.x = (this || window).m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, x.y = (this || window).m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, E.x = (this || window).m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, E.y = (this || window).m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
        break;
      case 3:
        E.x = x.x = (this || window).m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, E.y = x.y = (this || window).m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
        break;
      default:
        r.b2Assert(!1);
        break;
    }
  }, L.prototype.GetMetric = function() {
    switch (this.m_count) {
      case 0:
        return r.b2Assert(!1), 0;
      case 1:
        return 0;
      case 2:
        return s.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
      case 3:
        return s.CrossVV(s.SubtractVV(this.m_v2.w, this.m_v1.w), s.SubtractVV(this.m_v3.w, this.m_v1.w));
      default:
        return r.b2Assert(!1), 0;
    }
  }, L.prototype.Solve2 = function() {
    var x = (this || window).m_v1.w, E = (this || window).m_v2.w, R = s.SubtractVV(E, x), F = -(x.x * R.x + x.y * R.y);
    if (F <= 0) {
      this.m_v1.a = 1, this.m_count = 1;
      return;
    }
    var k = E.x * R.x + E.y * R.y;
    if (k <= 0) {
      this.m_v2.a = 1, this.m_count = 1, this.m_v1.Set(this.m_v2);
      return;
    }
    var X = 1 / (k + F);
    this.m_v1.a = k * X, this.m_v2.a = F * X, this.m_count = 2;
  }, L.prototype.Solve3 = function() {
    var x = (this || window).m_v1.w, E = (this || window).m_v2.w, R = (this || window).m_v3.w, F = s.SubtractVV(E, x), k = s.Dot(x, F), X = s.Dot(E, F), j = X, V = -k, Y = s.SubtractVV(R, x), tt = s.Dot(x, Y), it = s.Dot(R, Y), lt = it, ut = -tt, ft = s.SubtractVV(R, E), vt = s.Dot(E, ft), pt = s.Dot(R, ft), gt = pt, St = -vt, ht = s.CrossVV(F, Y), ct = ht * s.CrossVV(E, R), bt = ht * s.CrossVV(R, x), Et = ht * s.CrossVV(x, E);
    if (V <= 0 && ut <= 0) {
      this.m_v1.a = 1, this.m_count = 1;
      return;
    }
    if (j > 0 && V > 0 && Et <= 0) {
      var wt = 1 / (j + V);
      this.m_v1.a = j * wt, this.m_v2.a = V * wt, this.m_count = 2;
      return;
    }
    if (lt > 0 && ut > 0 && bt <= 0) {
      var It = 1 / (lt + ut);
      this.m_v1.a = lt * It, this.m_v3.a = ut * It, this.m_count = 2, this.m_v2.Set(this.m_v3);
      return;
    }
    if (j <= 0 && St <= 0) {
      this.m_v2.a = 1, this.m_count = 1, this.m_v1.Set(this.m_v2);
      return;
    }
    if (lt <= 0 && gt <= 0) {
      this.m_v3.a = 1, this.m_count = 1, this.m_v1.Set(this.m_v3);
      return;
    }
    if (gt > 0 && St > 0 && ct <= 0) {
      var Dt = 1 / (gt + St);
      this.m_v2.a = gt * Dt, this.m_v3.a = St * Dt, this.m_count = 2, this.m_v1.Set(this.m_v3);
      return;
    }
    var Ut = 1 / (ct + bt + Et);
    this.m_v1.a = ct * Ut, this.m_v2.a = bt * Ut, this.m_v3.a = Et * Ut, this.m_count = 3;
  }, G.b2SimplexCache = function() {
    this.indexA = new Vector_a2j_Number(3), this.indexB = new Vector_a2j_Number(3);
  }, I.b2SimplexVertex = function() {
  }, I.prototype.Set = function(x) {
    this.wA.SetV(x.wA), this.wB.SetV(x.wB), this.w.SetV(x.w), this.a = x.a, this.indexA = x.indexA, this.indexB = x.indexB;
  }, O.b2TimeOfImpact = function() {
  }, O.TimeOfImpact = function(x) {
    ++O.b2_toiCalls;
    var E = x.proxyA, R = x.proxyB, F = x.sweepA, k = x.sweepB;
    r.b2Assert(F.t0 == k.t0), r.b2Assert(1 - F.t0 > Number.MIN_VALUE);
    var X = E.m_radius + R.m_radius, j = x.tolerance, V = 0, Y = 1e3, tt = 0, it = 0;
    for (O.s_cache.count = 0, O.s_distanceInput.useRadii = !1; ; ) {
      if (F.GetTransform(O.s_xfA, V), k.GetTransform(O.s_xfB, V), O.s_distanceInput.proxyA = E, O.s_distanceInput.proxyB = R, O.s_distanceInput.transformA = O.s_xfA, O.s_distanceInput.transformB = O.s_xfB, C.Distance(O.s_distanceOutput, O.s_cache, O.s_distanceInput), O.s_distanceOutput.distance <= 0) {
        V = 1;
        break;
      }
      O.s_fcn.Initialize(O.s_cache, E, O.s_xfA, R, O.s_xfB);
      var lt = O.s_fcn.Evaluate(O.s_xfA, O.s_xfB);
      if (lt <= 0) {
        V = 1;
        break;
      }
      if (tt == 0 && (lt > X ? it = s.Max(X - j, 0.75 * X) : it = s.Max(lt - j, 0.02 * X)), lt - it < 0.5 * j) {
        if (tt == 0) {
          V = 1;
          break;
        }
        break;
      }
      var ut = V;
      {
        var ft = V, vt = 1, pt = lt;
        F.GetTransform(O.s_xfA, vt), k.GetTransform(O.s_xfB, vt);
        var gt = O.s_fcn.Evaluate(O.s_xfA, O.s_xfB);
        if (gt >= it) {
          V = 1;
          break;
        }
        for (var St = 0; ; ) {
          var ht = 0;
          St & 1 ? ht = ft + (it - pt) * (vt - ft) / (gt - pt) : ht = 0.5 * (ft + vt), F.GetTransform(O.s_xfA, ht), k.GetTransform(O.s_xfB, ht);
          var ct = O.s_fcn.Evaluate(O.s_xfA, O.s_xfB);
          if (s.Abs(ct - it) < 0.025 * j) {
            ut = ht;
            break;
          }
          if (ct > it ? (ft = ht, pt = ct) : (vt = ht, gt = ct), ++St, ++O.b2_toiRootIters, St == 50)
            break;
        }
        O.b2_toiMaxRootIters = s.Max(O.b2_toiMaxRootIters, St);
      }
      if (ut < (1 + 100 * Number.MIN_VALUE) * V || (V = ut, tt++, ++O.b2_toiIters, tt == Y))
        break;
    }
    return O.b2_toiMaxIters = s.Max(O.b2_toiMaxIters, tt), V;
  }, Box2D.postDefs.push(function() {
    Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0, Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0, Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0, Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0, Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0, Box2D.Collision.b2TimeOfImpact.s_cache = new G(), Box2D.Collision.b2TimeOfImpact.s_distanceInput = new m(), Box2D.Collision.b2TimeOfImpact.s_xfA = new a(), Box2D.Collision.b2TimeOfImpact.s_xfB = new a(), Box2D.Collision.b2TimeOfImpact.s_fcn = new w(), Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new g();
  }), K.b2TOIInput = function() {
    this.proxyA = new y(), this.proxyB = new y(), this.sweepA = new o(), this.sweepB = new o();
  }, $.b2WorldManifold = function() {
    this.m_normal = new c();
  }, $.prototype.b2WorldManifold = function() {
    this.m_points = new Vector(r.b2_maxManifoldPoints);
    for (var x = 0; x < r.b2_maxManifoldPoints; x++)
      this.m_points[x] = new c();
  }, $.prototype.Initialize = function(x, E, R, F, k) {
    if (R === void 0 && (R = 0), k === void 0 && (k = 0), x.m_pointCount != 0) {
      var X = 0, j, V, Y = 0, tt = 0, it = 0, lt = 0, ut = 0, ft = 0;
      switch (x.m_type) {
        case M.e_circles:
          {
            V = E.R, j = x.m_localPoint;
            var vt = E.position.x + V.col1.x * j.x + V.col2.x * j.y, pt = E.position.y + V.col1.y * j.x + V.col2.y * j.y;
            V = F.R, j = x.m_points[0].m_localPoint;
            var gt = F.position.x + V.col1.x * j.x + V.col2.x * j.y, St = F.position.y + V.col1.y * j.x + V.col2.y * j.y, ht = gt - vt, ct = St - pt, bt = ht * ht + ct * ct;
            if (bt > Number.MIN_VALUE * Number.MIN_VALUE) {
              var Et = Math.sqrt(bt);
              this.m_normal.x = ht / Et, this.m_normal.y = ct / Et;
            } else
              this.m_normal.x = 1, this.m_normal.y = 0;
            var wt = vt + R * this.m_normal.x, It = pt + R * this.m_normal.y, Dt = gt - k * this.m_normal.x, Ut = St - k * this.m_normal.y;
            this.m_points[0].x = 0.5 * (wt + Dt), this.m_points[0].y = 0.5 * (It + Ut);
          }
          break;
        case M.e_faceA:
          for (V = E.R, j = x.m_localPlaneNormal, Y = V.col1.x * j.x + V.col2.x * j.y, tt = V.col1.y * j.x + V.col2.y * j.y, V = E.R, j = x.m_localPoint, it = E.position.x + V.col1.x * j.x + V.col2.x * j.y, lt = E.position.y + V.col1.y * j.x + V.col2.y * j.y, this.m_normal.x = Y, this.m_normal.y = tt, X = 0; X < x.m_pointCount; X++)
            V = F.R, j = x.m_points[X].m_localPoint, ut = F.position.x + V.col1.x * j.x + V.col2.x * j.y, ft = F.position.y + V.col1.y * j.x + V.col2.y * j.y, this.m_points[X].x = ut + 0.5 * (R - (ut - it) * Y - (ft - lt) * tt - k) * Y, this.m_points[X].y = ft + 0.5 * (R - (ut - it) * Y - (ft - lt) * tt - k) * tt;
          break;
        case M.e_faceB:
          for (V = F.R, j = x.m_localPlaneNormal, Y = V.col1.x * j.x + V.col2.x * j.y, tt = V.col1.y * j.x + V.col2.y * j.y, V = F.R, j = x.m_localPoint, it = F.position.x + V.col1.x * j.x + V.col2.x * j.y, lt = F.position.y + V.col1.y * j.x + V.col2.y * j.y, this.m_normal.x = -Y, this.m_normal.y = -tt, X = 0; X < x.m_pointCount; X++)
            V = E.R, j = x.m_points[X].m_localPoint, ut = E.position.x + V.col1.x * j.x + V.col2.x * j.y, ft = E.position.y + V.col1.y * j.x + V.col2.y * j.y, this.m_points[X].x = ut + 0.5 * (k - (ut - it) * Y - (ft - lt) * tt - R) * Y, this.m_points[X].y = ft + 0.5 * (k - (ut - it) * Y - (ft - lt) * tt - R) * tt;
          break;
      }
    }
  }, S.ClipVertex = function() {
    this.v = new c(), this.id = new d();
  }, S.prototype.Set = function(x) {
    this.v.SetV(x.v), this.id.Set(x.id);
  }, b.Features = function() {
  }, Object.defineProperty(b.prototype, "referenceEdge", {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this._referenceEdge;
    }
  }), Object.defineProperty(b.prototype, "referenceEdge", {
    enumerable: !1,
    configurable: !0,
    set: function(x) {
      x === void 0 && (x = 0), this._referenceEdge = x, this._m_id._key = (this || window)._m_id._key & 4294967040 | this._referenceEdge & 255;
    }
  }), Object.defineProperty(b.prototype, "incidentEdge", {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this._incidentEdge;
    }
  }), Object.defineProperty(b.prototype, "incidentEdge", {
    enumerable: !1,
    configurable: !0,
    set: function(x) {
      x === void 0 && (x = 0), this._incidentEdge = x, this._m_id._key = (this || window)._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280;
    }
  }), Object.defineProperty(b.prototype, "incidentVertex", {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this._incidentVertex;
    }
  }), Object.defineProperty(b.prototype, "incidentVertex", {
    enumerable: !1,
    configurable: !0,
    set: function(x) {
      x === void 0 && (x = 0), this._incidentVertex = x, this._m_id._key = (this || window)._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680;
    }
  }), Object.defineProperty(b.prototype, "flip", {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this._flip;
    }
  }), Object.defineProperty(b.prototype, "flip", {
    enumerable: !1,
    configurable: !0,
    set: function(x) {
      x === void 0 && (x = 0), this._flip = x, this._m_id._key = (this || window)._m_id._key & 16777215 | this._flip << 24 & 4278190080;
    }
  });
})();
(function() {
  Box2D.Common.b2Color, Box2D.Common.b2internal;
  var t = Box2D.Common.b2Settings, e = Box2D.Collision.Shapes.b2CircleShape, n = Box2D.Collision.Shapes.b2EdgeChainDef, r = Box2D.Collision.Shapes.b2EdgeShape, s = Box2D.Collision.Shapes.b2MassData, o = Box2D.Collision.Shapes.b2PolygonShape, a = Box2D.Collision.Shapes.b2Shape, c = Box2D.Common.Math.b2Mat22;
  Box2D.Common.Math.b2Mat33;
  var l = Box2D.Common.Math.b2Math;
  Box2D.Common.Math.b2Sweep;
  var h = Box2D.Common.Math.b2Transform, u = Box2D.Common.Math.b2Vec2;
  Box2D.Common.Math.b2Vec3, Box2D.Dynamics.b2Body, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep, Box2D.Dynamics.b2World, Box2D.Collision.b2AABB, Box2D.Collision.b2Bound, Box2D.Collision.b2BoundValues, Box2D.Collision.b2Collision, Box2D.Collision.b2ContactID, Box2D.Collision.b2ContactPoint;
  var _ = Box2D.Collision.b2Distance, d = Box2D.Collision.b2DistanceInput, f = Box2D.Collision.b2DistanceOutput, C = Box2D.Collision.b2DistanceProxy;
  Box2D.Collision.b2DynamicTree, Box2D.Collision.b2DynamicTreeBroadPhase, Box2D.Collision.b2DynamicTreeNode, Box2D.Collision.b2DynamicTreePair, Box2D.Collision.b2Manifold, Box2D.Collision.b2ManifoldPoint, Box2D.Collision.b2Point, Box2D.Collision.b2RayCastInput, Box2D.Collision.b2RayCastOutput, Box2D.Collision.b2Segment, Box2D.Collision.b2SeparationFunction, Box2D.Collision.b2Simplex;
  var m = Box2D.Collision.b2SimplexCache;
  Box2D.Collision.b2SimplexVertex, Box2D.Collision.b2TimeOfImpact, Box2D.Collision.b2TOIInput, Box2D.Collision.b2WorldManifold, Box2D.Collision.ClipVertex, Box2D.Collision.Features, Box2D.Collision.IBroadPhase, Box2D.inherit(e, Box2D.Collision.Shapes.b2Shape), e.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype, e.b2CircleShape = function() {
    Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.m_p = new u();
  }, e.prototype.Copy = function() {
    var g = new e();
    return g.Set(this), g;
  }, e.prototype.Set = function(g) {
    if (this.__super.Set.call(this, g), Box2D.is(g, e)) {
      var y = g instanceof e ? g : null;
      this.m_p.SetV(y.m_p);
    }
  }, e.prototype.TestPoint = function(g, y) {
    var A = g.R, D = g.position.x + (A.col1.x * this.m_p.x + A.col2.x * this.m_p.y), N = g.position.y + (A.col1.y * this.m_p.x + A.col2.y * this.m_p.y);
    return D = y.x - D, N = y.y - N, D * D + N * N <= (this || window).m_radius * this.m_radius;
  }, e.prototype.RayCast = function(g, y, A) {
    var D = A.R, N = A.position.x + (D.col1.x * this.m_p.x + D.col2.x * this.m_p.y), z = A.position.y + (D.col1.y * this.m_p.x + D.col2.y * this.m_p.y), M = y.p1.x - N, Z = y.p1.y - z, U = M * M + Z * Z - this.m_radius * this.m_radius, Q = y.p2.x - y.p1.x, et = y.p2.y - y.p1.y, rt = M * Q + Z * et, w = Q * Q + et * et, L = rt * rt - w * U;
    if (L < 0 || w < Number.MIN_VALUE)
      return !1;
    var G = -(rt + Math.sqrt(L));
    return 0 <= G && G <= y.maxFraction * w ? (G /= w, g.fraction = G, g.normal.x = M + G * Q, g.normal.y = Z + G * et, g.normal.Normalize(), !0) : !1;
  }, e.prototype.ComputeAABB = function(g, y) {
    var A = y.R, D = y.position.x + (A.col1.x * this.m_p.x + A.col2.x * this.m_p.y), N = y.position.y + (A.col1.y * this.m_p.x + A.col2.y * this.m_p.y);
    g.lowerBound.Set(D - this.m_radius, N - this.m_radius), g.upperBound.Set(D + this.m_radius, N + this.m_radius);
  }, e.prototype.ComputeMass = function(g, y) {
    y === void 0 && (y = 0), g.mass = y * t.b2_pi * this.m_radius * this.m_radius, g.center.SetV(this.m_p), g.I = g.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
  }, e.prototype.ComputeSubmergedArea = function(g, y, A, D) {
    y === void 0 && (y = 0);
    var N = l.MulX(A, this.m_p), z = -(l.Dot(g, N) - y);
    if (z < -this.m_radius + Number.MIN_VALUE)
      return 0;
    if (z > this.m_radius)
      return D.SetV(N), Math.PI * this.m_radius * this.m_radius;
    var M = (this || window).m_radius * this.m_radius, Z = z * z, U = M * (Math.asin(z / this.m_radius) + Math.PI / 2) + z * Math.sqrt(M - Z), Q = -2 / 3 * Math.pow(M - Z, 1.5) / U;
    return D.x = N.x + g.x * Q, D.y = N.y + g.y * Q, U;
  }, e.prototype.GetLocalPosition = function() {
    return this.m_p;
  }, e.prototype.SetLocalPosition = function(g) {
    this.m_p.SetV(g);
  }, e.prototype.GetRadius = function() {
    return this.m_radius;
  }, e.prototype.SetRadius = function(g) {
    g === void 0 && (g = 0), this.m_radius = g;
  }, e.prototype.b2CircleShape = function(g) {
    g === void 0 && (g = 0), this.__super.b2Shape.call(this), this.m_type = a.e_circleShape, this.m_radius = g;
  }, n.b2EdgeChainDef = function() {
  }, n.prototype.b2EdgeChainDef = function() {
    this.vertexCount = 0, this.isALoop = !0, this.vertices = [];
  }, Box2D.inherit(r, Box2D.Collision.Shapes.b2Shape), r.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype, r.b2EdgeShape = function() {
    Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments), this.s_supportVec = new u(), this.m_v1 = new u(), this.m_v2 = new u(), this.m_coreV1 = new u(), this.m_coreV2 = new u(), this.m_normal = new u(), this.m_direction = new u(), this.m_cornerDir1 = new u(), this.m_cornerDir2 = new u();
  }, r.prototype.TestPoint = function(g, y) {
    return !1;
  }, r.prototype.RayCast = function(g, y, A) {
    var D, N = y.p2.x - y.p1.x, z = y.p2.y - y.p1.y;
    D = A.R;
    var M = A.position.x + (D.col1.x * this.m_v1.x + D.col2.x * this.m_v1.y), Z = A.position.y + (D.col1.y * this.m_v1.x + D.col2.y * this.m_v1.y), U = A.position.y + (D.col1.y * this.m_v2.x + D.col2.y * this.m_v2.y) - Z, Q = -(A.position.x + (D.col1.x * this.m_v2.x + D.col2.x * this.m_v2.y) - M), et = 100 * Number.MIN_VALUE, rt = -(N * U + z * Q);
    if (rt > et) {
      var w = y.p1.x - M, L = y.p1.y - Z, G = w * U + L * Q;
      if (0 <= G && G <= y.maxFraction * rt) {
        var I = -N * L + z * w;
        if (-et * rt <= I && I <= rt * (1 + et)) {
          G /= rt, g.fraction = G;
          var O = Math.sqrt(U * U + Q * Q);
          return g.normal.x = U / O, g.normal.y = Q / O, !0;
        }
      }
    }
    return !1;
  }, r.prototype.ComputeAABB = function(g, y) {
    var A = y.R, D = y.position.x + (A.col1.x * this.m_v1.x + A.col2.x * this.m_v1.y), N = y.position.y + (A.col1.y * this.m_v1.x + A.col2.y * this.m_v1.y), z = y.position.x + (A.col1.x * this.m_v2.x + A.col2.x * this.m_v2.y), M = y.position.y + (A.col1.y * this.m_v2.x + A.col2.y * this.m_v2.y);
    D < z ? (g.lowerBound.x = D, g.upperBound.x = z) : (g.lowerBound.x = z, g.upperBound.x = D), N < M ? (g.lowerBound.y = N, g.upperBound.y = M) : (g.lowerBound.y = M, g.upperBound.y = N);
  }, r.prototype.ComputeMass = function(g, y) {
    g.mass = 0, g.center.SetV(this.m_v1), g.I = 0;
  }, r.prototype.ComputeSubmergedArea = function(g, y, A, D) {
    y === void 0 && (y = 0);
    var N = new u(g.x * y, g.y * y), z = l.MulX(A, this.m_v1), M = l.MulX(A, this.m_v2), Z = l.Dot(g, z) - y, U = l.Dot(g, M) - y;
    if (Z > 0) {
      if (U > 0)
        return 0;
      z.x = -U / (Z - U) * z.x + Z / (Z - U) * M.x, z.y = -U / (Z - U) * z.y + Z / (Z - U) * M.y;
    } else
      U > 0 && (M.x = -U / (Z - U) * z.x + Z / (Z - U) * M.x, M.y = -U / (Z - U) * z.y + Z / (Z - U) * M.y);
    return D.x = (N.x + z.x + M.x) / 3, D.y = (N.y + z.y + M.y) / 3, 0.5 * ((z.x - N.x) * (M.y - N.y) - (z.y - N.y) * (M.x - N.x));
  }, r.prototype.GetLength = function() {
    return this.m_length;
  }, r.prototype.GetVertex1 = function() {
    return this.m_v1;
  }, r.prototype.GetVertex2 = function() {
    return this.m_v2;
  }, r.prototype.GetCoreVertex1 = function() {
    return this.m_coreV1;
  }, r.prototype.GetCoreVertex2 = function() {
    return this.m_coreV2;
  }, r.prototype.GetNormalVector = function() {
    return this.m_normal;
  }, r.prototype.GetDirectionVector = function() {
    return this.m_direction;
  }, r.prototype.GetCorner1Vector = function() {
    return this.m_cornerDir1;
  }, r.prototype.GetCorner2Vector = function() {
    return this.m_cornerDir2;
  }, r.prototype.Corner1IsConvex = function() {
    return this.m_cornerConvex1;
  }, r.prototype.Corner2IsConvex = function() {
    return this.m_cornerConvex2;
  }, r.prototype.GetFirstVertex = function(g) {
    var y = g.R;
    return new u(g.position.x + (y.col1.x * this.m_coreV1.x + y.col2.x * this.m_coreV1.y), g.position.y + (y.col1.y * this.m_coreV1.x + y.col2.y * this.m_coreV1.y));
  }, r.prototype.GetNextEdge = function() {
    return this.m_nextEdge;
  }, r.prototype.GetPrevEdge = function() {
    return this.m_prevEdge;
  }, r.prototype.Support = function(g, y, A) {
    y === void 0 && (y = 0), A === void 0 && (A = 0);
    var D = g.R, N = g.position.x + (D.col1.x * this.m_coreV1.x + D.col2.x * this.m_coreV1.y), z = g.position.y + (D.col1.y * this.m_coreV1.x + D.col2.y * this.m_coreV1.y), M = g.position.x + (D.col1.x * this.m_coreV2.x + D.col2.x * this.m_coreV2.y), Z = g.position.y + (D.col1.y * this.m_coreV2.x + D.col2.y * this.m_coreV2.y);
    return N * y + z * A > M * y + Z * A ? (this.s_supportVec.x = N, this.s_supportVec.y = z) : (this.s_supportVec.x = M, this.s_supportVec.y = Z), this.s_supportVec;
  }, r.prototype.b2EdgeShape = function(g, y) {
    this.__super.b2Shape.call(this), this.m_type = a.e_edgeShape, this.m_prevEdge = null, this.m_nextEdge = null, this.m_v1 = g, this.m_v2 = y, this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y), this.m_length = (this || window).m_direction.Normalize(), this.m_normal.Set(this.m_direction.y, -this.m_direction.x), this.m_coreV1.Set(-t.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -t.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y), this.m_coreV2.Set(-t.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -t.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y), this.m_cornerDir1 = (this || window).m_normal, this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y);
  }, r.prototype.SetPrevEdge = function(g, y, A, D) {
    this.m_prevEdge = g, this.m_coreV1 = y, this.m_cornerDir1 = A, this.m_cornerConvex1 = D;
  }, r.prototype.SetNextEdge = function(g, y, A, D) {
    this.m_nextEdge = g, this.m_coreV2 = y, this.m_cornerDir2 = A, this.m_cornerConvex2 = D;
  }, s.b2MassData = function() {
    this.mass = 0, this.center = new u(0, 0), this.I = 0;
  }, Box2D.inherit(o, Box2D.Collision.Shapes.b2Shape), o.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype, o.b2PolygonShape = function() {
    Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
  }, o.prototype.Copy = function() {
    var g = new o();
    return g.Set(this), g;
  }, o.prototype.Set = function(g) {
    if (this.__super.Set.call(this, g), Box2D.is(g, o)) {
      var y = g instanceof o ? g : null;
      this.m_centroid.SetV(y.m_centroid), this.m_vertexCount = y.m_vertexCount, this.Reserve(this.m_vertexCount);
      for (var A = 0; A < this.m_vertexCount; A++)
        this.m_vertices[A].SetV(y.m_vertices[A]), this.m_normals[A].SetV(y.m_normals[A]);
    }
  }, o.prototype.SetAsArray = function(g, y) {
    y === void 0 && (y = 0);
    var A = new Vector(), D = 0, N;
    for (D = 0; D < g.length; ++D)
      N = g[D], A.push(N);
    this.SetAsVector(A, y);
  }, o.AsArray = function(g, y) {
    y === void 0 && (y = 0);
    var A = new o();
    return A.SetAsArray(g, y), A;
  }, o.prototype.SetAsVector = function(g, y) {
    y === void 0 && (y = 0), y == 0 && (y = g.length), t.b2Assert(2 <= y), this.m_vertexCount = y, this.Reserve(y);
    var A = 0;
    for (A = 0; A < this.m_vertexCount; A++)
      this.m_vertices[A].SetV(g[A]);
    for (A = 0; A < this.m_vertexCount; ++A) {
      var D = parseInt(A), N = parseInt(A + 1 < this.m_vertexCount ? A + 1 : 0), z = l.SubtractVV(this.m_vertices[N], this.m_vertices[D]);
      t.b2Assert(z.LengthSquared() > Number.MIN_VALUE), this.m_normals[A].SetV(l.CrossVF(z, 1)), this.m_normals[A].Normalize();
    }
    this.m_centroid = o.ComputeCentroid(this.m_vertices, this.m_vertexCount);
  }, o.AsVector = function(g, y) {
    y === void 0 && (y = 0);
    var A = new o();
    return A.SetAsVector(g, y), A;
  }, o.prototype.SetAsBox = function(g, y) {
    g === void 0 && (g = 0), y === void 0 && (y = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-g, -y), this.m_vertices[1].Set(g, -y), this.m_vertices[2].Set(g, y), this.m_vertices[3].Set(-g, y), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid.SetZero();
  }, o.AsBox = function(g, y) {
    g === void 0 && (g = 0), y === void 0 && (y = 0);
    var A = new o();
    return A.SetAsBox(g, y), A;
  }, o.prototype.SetAsOrientedBox = function(g, y, A, D) {
    g === void 0 && (g = 0), y === void 0 && (y = 0), A === void 0 && (A = null), D === void 0 && (D = 0), this.m_vertexCount = 4, this.Reserve(4), this.m_vertices[0].Set(-g, -y), this.m_vertices[1].Set(g, -y), this.m_vertices[2].Set(g, y), this.m_vertices[3].Set(-g, y), this.m_normals[0].Set(0, -1), this.m_normals[1].Set(1, 0), this.m_normals[2].Set(0, 1), this.m_normals[3].Set(-1, 0), this.m_centroid = A;
    var N = new h();
    N.position = A, N.R.Set(D);
    for (var z = 0; z < this.m_vertexCount; ++z)
      this.m_vertices[z] = l.MulX(N, this.m_vertices[z]), this.m_normals[z] = l.MulMV(N.R, this.m_normals[z]);
  }, o.AsOrientedBox = function(g, y, A, D) {
    g === void 0 && (g = 0), y === void 0 && (y = 0), A === void 0 && (A = null), D === void 0 && (D = 0);
    var N = new o();
    return N.SetAsOrientedBox(g, y, A, D), N;
  }, o.prototype.SetAsEdge = function(g, y) {
    this.m_vertexCount = 2, this.Reserve(2), this.m_vertices[0].SetV(g), this.m_vertices[1].SetV(y), this.m_centroid.x = 0.5 * (g.x + y.x), this.m_centroid.y = 0.5 * (g.y + y.y), this.m_normals[0] = l.CrossVF(l.SubtractVV(y, g), 1), this.m_normals[0].Normalize(), this.m_normals[1].x = -this.m_normals[0].x, this.m_normals[1].y = -this.m_normals[0].y;
  }, o.AsEdge = function(g, y) {
    var A = new o();
    return A.SetAsEdge(g, y), A;
  }, o.prototype.TestPoint = function(g, y) {
    for (var A, D = g.R, N = y.x - g.position.x, z = y.y - g.position.y, M = N * D.col1.x + z * D.col1.y, Z = N * D.col2.x + z * D.col2.y, U = 0; U < this.m_vertexCount; ++U) {
      A = (this || window).m_vertices[U], N = M - A.x, z = Z - A.y, A = (this || window).m_normals[U];
      var Q = A.x * N + A.y * z;
      if (Q > 0)
        return !1;
    }
    return !0;
  }, o.prototype.RayCast = function(g, y, A) {
    var D = 0, N = y.maxFraction, z = 0, M = 0, Z, U;
    z = y.p1.x - A.position.x, M = y.p1.y - A.position.y, Z = A.R;
    var Q = z * Z.col1.x + M * Z.col1.y, et = z * Z.col2.x + M * Z.col2.y;
    z = y.p2.x - A.position.x, M = y.p2.y - A.position.y, Z = A.R;
    for (var rt = z * Z.col1.x + M * Z.col1.y, w = z * Z.col2.x + M * Z.col2.y, L = rt - Q, G = w - et, I = parseInt(-1), O = 0; O < this.m_vertexCount; ++O) {
      U = (this || window).m_vertices[O], z = U.x - Q, M = U.y - et, U = (this || window).m_normals[O];
      var K = U.x * z + U.y * M, $ = U.x * L + U.y * G;
      if ($ == 0) {
        if (K < 0)
          return !1;
      } else
        $ < 0 && K < D * $ ? (D = K / $, I = O) : $ > 0 && K < N * $ && (N = K / $);
      if (N < D - Number.MIN_VALUE)
        return !1;
    }
    return I >= 0 ? (g.fraction = D, Z = A.R, U = (this || window).m_normals[I], g.normal.x = Z.col1.x * U.x + Z.col2.x * U.y, g.normal.y = Z.col1.y * U.x + Z.col2.y * U.y, !0) : !1;
  }, o.prototype.ComputeAABB = function(g, y) {
    for (var A = y.R, D = (this || window).m_vertices[0], N = y.position.x + (A.col1.x * D.x + A.col2.x * D.y), z = y.position.y + (A.col1.y * D.x + A.col2.y * D.y), M = N, Z = z, U = 1; U < this.m_vertexCount; ++U) {
      D = (this || window).m_vertices[U];
      var Q = y.position.x + (A.col1.x * D.x + A.col2.x * D.y), et = y.position.y + (A.col1.y * D.x + A.col2.y * D.y);
      N = N < Q ? N : Q, z = z < et ? z : et, M = M > Q ? M : Q, Z = Z > et ? Z : et;
    }
    g.lowerBound.x = N - this.m_radius, g.lowerBound.y = z - this.m_radius, g.upperBound.x = M + this.m_radius, g.upperBound.y = Z + this.m_radius;
  }, o.prototype.ComputeMass = function(g, y) {
    if (y === void 0 && (y = 0), this.m_vertexCount == 2) {
      g.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x), g.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y), g.mass = 0, g.I = 0;
      return;
    }
    for (var A = 0, D = 0, N = 0, z = 0, M = 0, Z = 0, U = 1 / 3, Q = 0; Q < this.m_vertexCount; ++Q) {
      var et = (this || window).m_vertices[Q], rt = Q + 1 < this.m_vertexCount ? this.m_vertices[parseInt(Q + 1)] : this.m_vertices[0], w = et.x - M, L = et.y - Z, G = rt.x - M, I = rt.y - Z, O = w * I - L * G, K = 0.5 * O;
      N += K, A += K * U * (M + et.x + rt.x), D += K * U * (Z + et.y + rt.y);
      var $ = M, S = Z, b = w, W = L, x = G, E = I, R = U * (0.25 * (b * b + x * b + x * x) + ($ * b + $ * x)) + 0.5 * $ * $, F = U * (0.25 * (W * W + E * W + E * E) + (S * W + S * E)) + 0.5 * S * S;
      z += O * (R + F);
    }
    g.mass = y * N, A *= 1 / N, D *= 1 / N, g.center.Set(A, D), g.I = y * z;
  }, o.prototype.ComputeSubmergedArea = function(g, y, A, D) {
    y === void 0 && (y = 0);
    var N = l.MulTMV(A.R, g), z = y - l.Dot(g, A.position), M = new Vector_a2j_Number(), Z = 0, U = parseInt(-1), Q = parseInt(-1), et = !1, rt = 0;
    for (rt = 0; rt < this.m_vertexCount; ++rt) {
      M[rt] = l.Dot(N, this.m_vertices[rt]) - z;
      var w = M[rt] < -Number.MIN_VALUE;
      rt > 0 && (w ? et || (U = rt - 1, Z++) : et && (Q = rt - 1, Z++)), et = w;
    }
    switch (Z) {
      case 0:
        if (et) {
          var L = new s();
          return this.ComputeMass(L, 1), D.SetV(l.MulX(A, L.center)), L.mass;
        } else
          return 0;
      case 1:
        U == -1 ? U = (this || window).m_vertexCount - 1 : Q = (this || window).m_vertexCount - 1;
        break;
    }
    var G = parseInt((U + 1) % this.m_vertexCount), I = parseInt((Q + 1) % this.m_vertexCount), O = (0 - M[U]) / (M[G] - M[U]), K = (0 - M[Q]) / (M[I] - M[Q]), $ = new u(this.m_vertices[U].x * (1 - O) + this.m_vertices[G].x * O, this.m_vertices[U].y * (1 - O) + this.m_vertices[G].y * O), S = new u(this.m_vertices[Q].x * (1 - K) + this.m_vertices[I].x * K, this.m_vertices[Q].y * (1 - K) + this.m_vertices[I].y * K), b = 0, W = new u(), x = (this || window).m_vertices[G], E;
    for (rt = G; rt != I; ) {
      rt = (rt + 1) % this.m_vertexCount, rt == I ? E = S : E = (this || window).m_vertices[rt];
      var R = 0.5 * ((x.x - $.x) * (E.y - $.y) - (x.y - $.y) * (E.x - $.x));
      b += R, W.x += R * ($.x + x.x + E.x) / 3, W.y += R * ($.y + x.y + E.y) / 3, x = E;
    }
    return W.Multiply(1 / b), D.SetV(l.MulX(A, W)), b;
  }, o.prototype.GetVertexCount = function() {
    return this.m_vertexCount;
  }, o.prototype.GetVertices = function() {
    return this.m_vertices;
  }, o.prototype.GetNormals = function() {
    return this.m_normals;
  }, o.prototype.GetSupport = function(g) {
    for (var y = 0, A = (this || window).m_vertices[0].x * g.x + this.m_vertices[0].y * g.y, D = 1; D < this.m_vertexCount; ++D) {
      var N = (this || window).m_vertices[D].x * g.x + this.m_vertices[D].y * g.y;
      N > A && (y = D, A = N);
    }
    return y;
  }, o.prototype.GetSupportVertex = function(g) {
    for (var y = 0, A = (this || window).m_vertices[0].x * g.x + this.m_vertices[0].y * g.y, D = 1; D < this.m_vertexCount; ++D) {
      var N = (this || window).m_vertices[D].x * g.x + this.m_vertices[D].y * g.y;
      N > A && (y = D, A = N);
    }
    return this.m_vertices[y];
  }, o.prototype.Validate = function() {
    return !1;
  }, o.prototype.b2PolygonShape = function() {
    this.__super.b2Shape.call(this), this.m_type = a.e_polygonShape, this.m_centroid = new u(), this.m_vertices = new Vector(), this.m_normals = new Vector();
  }, o.prototype.Reserve = function(g) {
    g === void 0 && (g = 0);
    for (var y = parseInt(this.m_vertices.length); y < g; y++)
      this.m_vertices[y] = new u(), this.m_normals[y] = new u();
  }, o.ComputeCentroid = function(g, y) {
    y === void 0 && (y = 0);
    for (var A = new u(), D = 0, N = 0, z = 0, M = 1 / 3, Z = 0; Z < y; ++Z) {
      var U = g[Z], Q = Z + 1 < y ? g[parseInt(Z + 1)] : g[0], et = U.x - N, rt = U.y - z, w = Q.x - N, L = Q.y - z, G = et * L - rt * w, I = 0.5 * G;
      D += I, A.x += I * M * (N + U.x + Q.x), A.y += I * M * (z + U.y + Q.y);
    }
    return A.x *= 1 / D, A.y *= 1 / D, A;
  }, o.ComputeOBB = function(g, y, A) {
    A === void 0 && (A = 0);
    var D = 0, N = new Vector(A + 1);
    for (D = 0; D < A; ++D)
      N[D] = y[D];
    N[A] = N[0];
    var z = Number.MAX_VALUE;
    for (D = 1; D <= A; ++D) {
      var M = N[parseInt(D - 1)], Z = N[D].x - M.x, U = N[D].y - M.y, Q = Math.sqrt(Z * Z + U * U);
      Z /= Q, U /= Q;
      for (var et = -U, rt = Z, w = Number.MAX_VALUE, L = Number.MAX_VALUE, G = -Number.MAX_VALUE, I = -Number.MAX_VALUE, O = 0; O < A; ++O) {
        var K = N[O].x - M.x, $ = N[O].y - M.y, S = Z * K + U * $, b = et * K + rt * $;
        S < w && (w = S), b < L && (L = b), S > G && (G = S), b > I && (I = b);
      }
      var W = (G - w) * (I - L);
      if (W < 0.95 * z) {
        z = W, g.R.col1.x = Z, g.R.col1.y = U, g.R.col2.x = et, g.R.col2.y = rt;
        var x = 0.5 * (w + G), E = 0.5 * (L + I), R = g.R;
        g.center.x = M.x + (R.col1.x * x + R.col2.x * E), g.center.y = M.y + (R.col1.y * x + R.col2.y * E), g.extents.x = 0.5 * (G - w), g.extents.y = 0.5 * (I - L);
      }
    }
  }, Box2D.postDefs.push(function() {
    Box2D.Collision.Shapes.b2PolygonShape.s_mat = new c();
  }), a.b2Shape = function() {
  }, a.prototype.Copy = function() {
    return null;
  }, a.prototype.Set = function(g) {
    this.m_radius = g.m_radius;
  }, a.prototype.GetType = function() {
    return this.m_type;
  }, a.prototype.TestPoint = function(g, y) {
    return !1;
  }, a.prototype.RayCast = function(g, y, A) {
    return !1;
  }, a.prototype.ComputeAABB = function(g, y) {
  }, a.prototype.ComputeMass = function(g, y) {
  }, a.prototype.ComputeSubmergedArea = function(g, y, A, D) {
    return 0;
  }, a.TestOverlap = function(g, y, A, D) {
    var N = new d();
    N.proxyA = new C(), N.proxyA.Set(g), N.proxyB = new C(), N.proxyB.Set(A), N.transformA = y, N.transformB = D, N.useRadii = !0;
    var z = new m();
    z.count = 0;
    var M = new f();
    return _.Distance(M, z, N), M.distance < 10 * Number.MIN_VALUE;
  }, a.prototype.b2Shape = function() {
    this.m_type = a.e_unknownShape, this.m_radius = t.b2_linearSlop;
  }, Box2D.postDefs.push(function() {
    Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt(-1), Box2D.Collision.Shapes.b2Shape.e_circleShape = 0, Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1, Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2, Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3, Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1, Box2D.Collision.Shapes.b2Shape.e_missCollide = 0, Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt(-1);
  });
})();
(function() {
  var t = Box2D.Common.b2Color;
  Box2D.Common.b2internal;
  var e = Box2D.Common.b2Settings;
  Box2D.Common.Math.b2Mat22, Box2D.Common.Math.b2Mat33;
  var n = Box2D.Common.Math.b2Math;
  Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform, Box2D.Common.Math.b2Vec2, Box2D.Common.Math.b2Vec3, t.b2Color = function() {
    this._r = 0, this._g = 0, this._b = 0;
  }, t.prototype.b2Color = function(r, s, o) {
    r === void 0 && (r = 0), s === void 0 && (s = 0), o === void 0 && (o = 0), this._r = Box2D.parseUInt(255 * n.Clamp(r, 0, 1)), this._g = Box2D.parseUInt(255 * n.Clamp(s, 0, 1)), this._b = Box2D.parseUInt(255 * n.Clamp(o, 0, 1));
  }, t.prototype.Set = function(r, s, o) {
    r === void 0 && (r = 0), s === void 0 && (s = 0), o === void 0 && (o = 0), this._r = Box2D.parseUInt(255 * n.Clamp(r, 0, 1)), this._g = Box2D.parseUInt(255 * n.Clamp(s, 0, 1)), this._b = Box2D.parseUInt(255 * n.Clamp(o, 0, 1));
  }, Object.defineProperty(t.prototype, "r", {
    enumerable: !1,
    configurable: !0,
    set: function(r) {
      r === void 0 && (r = 0), this._r = Box2D.parseUInt(255 * n.Clamp(r, 0, 1));
    }
  }), Object.defineProperty(t.prototype, "g", {
    enumerable: !1,
    configurable: !0,
    set: function(r) {
      r === void 0 && (r = 0), this._g = Box2D.parseUInt(255 * n.Clamp(r, 0, 1));
    }
  }), Object.defineProperty(t.prototype, "b", {
    enumerable: !1,
    configurable: !0,
    set: function(r) {
      r === void 0 && (r = 0), this._b = Box2D.parseUInt(255 * n.Clamp(r, 0, 1));
    }
  }), Object.defineProperty(t.prototype, "color", {
    enumerable: !1,
    configurable: !0,
    get: function() {
      return this._r << 16 | this._g << 8 | this._b;
    }
  }), e.b2Settings = function() {
  }, e.b2MixFriction = function(r, s) {
    return r === void 0 && (r = 0), s === void 0 && (s = 0), Math.sqrt(r * s);
  }, e.b2MixRestitution = function(r, s) {
    return r === void 0 && (r = 0), s === void 0 && (s = 0), r > s ? r : s;
  }, e.b2Assert = function(r) {
    if (!r)
      throw "Assertion Failed";
  }, Box2D.postDefs.push(function() {
    Box2D.Common.b2Settings.VERSION = "2.1alpha", Box2D.Common.b2Settings.USHRT_MAX = 65535, Box2D.Common.b2Settings.b2_pi = Math.PI, Box2D.Common.b2Settings.b2_maxManifoldPoints = 2, Box2D.Common.b2Settings.b2_aabbExtension = 0.1, Box2D.Common.b2Settings.b2_aabbMultiplier = 2, Box2D.Common.b2Settings.b2_polygonRadius = 2 * e.b2_linearSlop, Box2D.Common.b2Settings.b2_linearSlop = 5e-3, Box2D.Common.b2Settings.b2_angularSlop = 2 / 180 * e.b2_pi, Box2D.Common.b2Settings.b2_toiSlop = 8 * e.b2_linearSlop, Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32, Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32, Box2D.Common.b2Settings.b2_velocityThreshold = 1, Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2, Box2D.Common.b2Settings.b2_maxAngularCorrection = 8 / 180 * e.b2_pi, Box2D.Common.b2Settings.b2_maxTranslation = 2, Box2D.Common.b2Settings.b2_maxTranslationSquared = e.b2_maxTranslation * e.b2_maxTranslation, Box2D.Common.b2Settings.b2_maxRotation = 0.5 * e.b2_pi, Box2D.Common.b2Settings.b2_maxRotationSquared = e.b2_maxRotation * e.b2_maxRotation, Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2, Box2D.Common.b2Settings.b2_timeToSleep = 0.5, Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01, Box2D.Common.b2Settings.b2_angularSleepTolerance = 2 / 180 * e.b2_pi;
  });
})();
(function() {
  Box2D.Collision.b2AABB, Box2D.Common.b2Color, Box2D.Common.b2internal, Box2D.Common.b2Settings;
  var t = Box2D.Common.Math.b2Mat22, e = Box2D.Common.Math.b2Mat33, n = Box2D.Common.Math.b2Math, r = Box2D.Common.Math.b2Sweep, s = Box2D.Common.Math.b2Transform, o = Box2D.Common.Math.b2Vec2, a = Box2D.Common.Math.b2Vec3;
  t.b2Mat22 = function() {
    this.col1 = new o(), this.col2 = new o();
  }, t.prototype.b2Mat22 = function() {
    this.SetIdentity();
  }, t.FromAngle = function(c) {
    c === void 0 && (c = 0);
    var l = new t();
    return l.Set(c), l;
  }, t.FromVV = function(c, l) {
    var h = new t();
    return h.SetVV(c, l), h;
  }, t.prototype.Set = function(c) {
    c === void 0 && (c = 0);
    var l = Math.cos(c), h = Math.sin(c);
    this.col1.x = l, this.col2.x = -h, this.col1.y = h, this.col2.y = l;
  }, t.prototype.SetVV = function(c, l) {
    this.col1.SetV(c), this.col2.SetV(l);
  }, t.prototype.Copy = function() {
    var c = new t();
    return c.SetM(this), c;
  }, t.prototype.SetM = function(c) {
    this.col1.SetV(c.col1), this.col2.SetV(c.col2);
  }, t.prototype.AddM = function(c) {
    this.col1.x += c.col1.x, this.col1.y += c.col1.y, this.col2.x += c.col2.x, this.col2.y += c.col2.y;
  }, t.prototype.SetIdentity = function() {
    this.col1.x = 1, this.col2.x = 0, this.col1.y = 0, this.col2.y = 1;
  }, t.prototype.SetZero = function() {
    this.col1.x = 0, this.col2.x = 0, this.col1.y = 0, this.col2.y = 0;
  }, t.prototype.GetAngle = function() {
    return Math.atan2(this.col1.y, this.col1.x);
  }, t.prototype.GetInverse = function(c) {
    var l = (this || window).col1.x, h = (this || window).col2.x, u = (this || window).col1.y, _ = (this || window).col2.y, d = l * _ - h * u;
    return d != 0 && (d = 1 / d), c.col1.x = d * _, c.col2.x = -d * h, c.col1.y = -d * u, c.col2.y = d * l, c;
  }, t.prototype.Solve = function(c, l, h) {
    l === void 0 && (l = 0), h === void 0 && (h = 0);
    var u = (this || window).col1.x, _ = (this || window).col2.x, d = (this || window).col1.y, f = (this || window).col2.y, C = u * f - _ * d;
    return C != 0 && (C = 1 / C), c.x = C * (f * l - _ * h), c.y = C * (u * h - d * l), c;
  }, t.prototype.Abs = function() {
    this.col1.Abs(), this.col2.Abs();
  }, e.b2Mat33 = function() {
    this.col1 = new a(), this.col2 = new a(), this.col3 = new a();
  }, e.prototype.b2Mat33 = function(c, l, h) {
    c === void 0 && (c = null), l === void 0 && (l = null), h === void 0 && (h = null), !c && !l && !h ? (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero()) : (this.col1.SetV(c), this.col2.SetV(l), this.col3.SetV(h));
  }, e.prototype.SetVVV = function(c, l, h) {
    this.col1.SetV(c), this.col2.SetV(l), this.col3.SetV(h);
  }, e.prototype.Copy = function() {
    return new e(this.col1, this.col2, this.col3);
  }, e.prototype.SetM = function(c) {
    this.col1.SetV(c.col1), this.col2.SetV(c.col2), this.col3.SetV(c.col3);
  }, e.prototype.AddM = function(c) {
    this.col1.x += c.col1.x, this.col1.y += c.col1.y, this.col1.z += c.col1.z, this.col2.x += c.col2.x, this.col2.y += c.col2.y, this.col2.z += c.col2.z, this.col3.x += c.col3.x, this.col3.y += c.col3.y, this.col3.z += c.col3.z;
  }, e.prototype.SetIdentity = function() {
    this.col1.x = 1, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 1, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 1;
  }, e.prototype.SetZero = function() {
    this.col1.x = 0, this.col2.x = 0, this.col3.x = 0, this.col1.y = 0, this.col2.y = 0, this.col3.y = 0, this.col1.z = 0, this.col2.z = 0, this.col3.z = 0;
  }, e.prototype.Solve22 = function(c, l, h) {
    l === void 0 && (l = 0), h === void 0 && (h = 0);
    var u = (this || window).col1.x, _ = (this || window).col2.x, d = (this || window).col1.y, f = (this || window).col2.y, C = u * f - _ * d;
    return C != 0 && (C = 1 / C), c.x = C * (f * l - _ * h), c.y = C * (u * h - d * l), c;
  }, e.prototype.Solve33 = function(c, l, h, u) {
    l === void 0 && (l = 0), h === void 0 && (h = 0), u === void 0 && (u = 0);
    var _ = (this || window).col1.x, d = (this || window).col1.y, f = (this || window).col1.z, C = (this || window).col2.x, m = (this || window).col2.y, g = (this || window).col2.z, y = (this || window).col3.x, A = (this || window).col3.y, D = (this || window).col3.z, N = _ * (m * D - g * A) + d * (g * y - C * D) + f * (C * A - m * y);
    return N != 0 && (N = 1 / N), c.x = N * (l * (m * D - g * A) + h * (g * y - C * D) + u * (C * A - m * y)), c.y = N * (_ * (h * D - u * A) + d * (u * y - l * D) + f * (l * A - h * y)), c.z = N * (_ * (m * u - g * h) + d * (g * l - C * u) + f * (C * h - m * l)), c;
  }, n.b2Math = function() {
  }, n.IsValid = function(c) {
    return c === void 0 && (c = 0), isFinite(c);
  }, n.Dot = function(c, l) {
    return c.x * l.x + c.y * l.y;
  }, n.CrossVV = function(c, l) {
    return c.x * l.y - c.y * l.x;
  }, n.CrossVF = function(c, l) {
    l === void 0 && (l = 0);
    var h = new o(l * c.y, -l * c.x);
    return h;
  }, n.CrossFV = function(c, l) {
    c === void 0 && (c = 0);
    var h = new o(-c * l.y, c * l.x);
    return h;
  }, n.MulMV = function(c, l) {
    var h = new o(c.col1.x * l.x + c.col2.x * l.y, c.col1.y * l.x + c.col2.y * l.y);
    return h;
  }, n.MulTMV = function(c, l) {
    var h = new o(n.Dot(l, c.col1), n.Dot(l, c.col2));
    return h;
  }, n.MulX = function(c, l) {
    var h = n.MulMV(c.R, l);
    return h.x += c.position.x, h.y += c.position.y, h;
  }, n.MulXT = function(c, l) {
    var h = n.SubtractVV(l, c.position), u = h.x * c.R.col1.x + h.y * c.R.col1.y;
    return h.y = h.x * c.R.col2.x + h.y * c.R.col2.y, h.x = u, h;
  }, n.AddVV = function(c, l) {
    var h = new o(c.x + l.x, c.y + l.y);
    return h;
  }, n.SubtractVV = function(c, l) {
    var h = new o(c.x - l.x, c.y - l.y);
    return h;
  }, n.Distance = function(c, l) {
    var h = c.x - l.x, u = c.y - l.y;
    return Math.sqrt(h * h + u * u);
  }, n.DistanceSquared = function(c, l) {
    var h = c.x - l.x, u = c.y - l.y;
    return h * h + u * u;
  }, n.MulFV = function(c, l) {
    c === void 0 && (c = 0);
    var h = new o(c * l.x, c * l.y);
    return h;
  }, n.AddMM = function(c, l) {
    var h = t.FromVV(n.AddVV(c.col1, l.col1), n.AddVV(c.col2, l.col2));
    return h;
  }, n.MulMM = function(c, l) {
    var h = t.FromVV(n.MulMV(c, l.col1), n.MulMV(c, l.col2));
    return h;
  }, n.MulTMM = function(c, l) {
    var h = new o(n.Dot(c.col1, l.col1), n.Dot(c.col2, l.col1)), u = new o(n.Dot(c.col1, l.col2), n.Dot(c.col2, l.col2)), _ = t.FromVV(h, u);
    return _;
  }, n.Abs = function(c) {
    return c === void 0 && (c = 0), c > 0 ? c : -c;
  }, n.AbsV = function(c) {
    var l = new o(n.Abs(c.x), n.Abs(c.y));
    return l;
  }, n.AbsM = function(c) {
    var l = t.FromVV(n.AbsV(c.col1), n.AbsV(c.col2));
    return l;
  }, n.Min = function(c, l) {
    return c === void 0 && (c = 0), l === void 0 && (l = 0), c < l ? c : l;
  }, n.MinV = function(c, l) {
    var h = new o(n.Min(c.x, l.x), n.Min(c.y, l.y));
    return h;
  }, n.Max = function(c, l) {
    return c === void 0 && (c = 0), l === void 0 && (l = 0), c > l ? c : l;
  }, n.MaxV = function(c, l) {
    var h = new o(n.Max(c.x, l.x), n.Max(c.y, l.y));
    return h;
  }, n.Clamp = function(c, l, h) {
    return c === void 0 && (c = 0), l === void 0 && (l = 0), h === void 0 && (h = 0), c < l ? l : c > h ? h : c;
  }, n.ClampV = function(c, l, h) {
    return n.MaxV(l, n.MinV(c, h));
  }, n.Swap = function(c, l) {
    var h = c[0];
    c[0] = l[0], l[0] = h;
  }, n.Random = function() {
    return Math.random() * 2 - 1;
  }, n.RandomRange = function(c, l) {
    c === void 0 && (c = 0), l === void 0 && (l = 0);
    var h = Math.random();
    return h = (l - c) * h + c, h;
  }, n.NextPowerOfTwo = function(c) {
    return c === void 0 && (c = 0), c |= c >> 1 & 2147483647, c |= c >> 2 & 1073741823, c |= c >> 4 & 268435455, c |= c >> 8 & 16777215, c |= c >> 16 & 65535, c + 1;
  }, n.IsPowerOfTwo = function(c) {
    c === void 0 && (c = 0);
    var l = c > 0 && (c & c - 1) == 0;
    return l;
  }, Box2D.postDefs.push(function() {
    Box2D.Common.Math.b2Math.b2Vec2_zero = new o(0, 0), Box2D.Common.Math.b2Math.b2Mat22_identity = t.FromVV(new o(1, 0), new o(0, 1)), Box2D.Common.Math.b2Math.b2Transform_identity = new s(n.b2Vec2_zero, n.b2Mat22_identity);
  }), r.b2Sweep = function() {
    this.localCenter = new o(), this.c0 = new o(), this.c = new o();
  }, r.prototype.Set = function(c) {
    this.localCenter.SetV(c.localCenter), this.c0.SetV(c.c0), this.c.SetV(c.c), this.a0 = c.a0, this.a = c.a, this.t0 = c.t0;
  }, r.prototype.Copy = function() {
    var c = new r();
    return c.localCenter.SetV(this.localCenter), c.c0.SetV(this.c0), c.c.SetV(this.c), c.a0 = (this || window).a0, c.a = (this || window).a, c.t0 = (this || window).t0, c;
  }, r.prototype.GetTransform = function(c, l) {
    l === void 0 && (l = 0), c.position.x = (1 - l) * this.c0.x + l * this.c.x, c.position.y = (1 - l) * this.c0.y + l * this.c.y;
    var h = (1 - l) * this.a0 + l * this.a;
    c.R.Set(h);
    var u = c.R;
    c.position.x -= u.col1.x * this.localCenter.x + u.col2.x * this.localCenter.y, c.position.y -= u.col1.y * this.localCenter.x + u.col2.y * this.localCenter.y;
  }, r.prototype.Advance = function(c) {
    if (c === void 0 && (c = 0), this.t0 < c && 1 - this.t0 > Number.MIN_VALUE) {
      var l = (c - this.t0) / (1 - this.t0);
      this.c0.x = (1 - l) * this.c0.x + l * this.c.x, this.c0.y = (1 - l) * this.c0.y + l * this.c.y, this.a0 = (1 - l) * this.a0 + l * this.a, this.t0 = c;
    }
  }, s.b2Transform = function() {
    this.position = new o(), this.R = new t();
  }, s.prototype.b2Transform = function(c, l) {
    c === void 0 && (c = null), l === void 0 && (l = null), c && (this.position.SetV(c), this.R.SetM(l));
  }, s.prototype.Initialize = function(c, l) {
    this.position.SetV(c), this.R.SetM(l);
  }, s.prototype.SetIdentity = function() {
    this.position.SetZero(), this.R.SetIdentity();
  }, s.prototype.Set = function(c) {
    this.position.SetV(c.position), this.R.SetM(c.R);
  }, s.prototype.GetAngle = function() {
    return Math.atan2(this.R.col1.y, this.R.col1.x);
  }, o.b2Vec2 = function() {
  }, o.prototype.b2Vec2 = function(c, l) {
    c === void 0 && (c = 0), l === void 0 && (l = 0), this.x = c, this.y = l;
  }, o.prototype.SetZero = function() {
    this.x = 0, this.y = 0;
  }, o.prototype.Set = function(c, l) {
    c === void 0 && (c = 0), l === void 0 && (l = 0), this.x = c, this.y = l;
  }, o.prototype.SetV = function(c) {
    this.x = c.x, this.y = c.y;
  }, o.prototype.GetNegative = function() {
    return new o(-this.x, -this.y);
  }, o.prototype.NegativeSelf = function() {
    this.x = -this.x, this.y = -this.y;
  }, o.Make = function(c, l) {
    return c === void 0 && (c = 0), l === void 0 && (l = 0), new o(c, l);
  }, o.prototype.Copy = function() {
    return new o(this.x, this.y);
  }, o.prototype.Add = function(c) {
    this.x += c.x, this.y += c.y;
  }, o.prototype.Subtract = function(c) {
    this.x -= c.x, this.y -= c.y;
  }, o.prototype.Multiply = function(c) {
    c === void 0 && (c = 0), this.x *= c, this.y *= c;
  }, o.prototype.MulM = function(c) {
    var l = (this || window).x;
    this.x = c.col1.x * l + c.col2.x * this.y, this.y = c.col1.y * l + c.col2.y * this.y;
  }, o.prototype.MulTM = function(c) {
    var l = n.Dot(this, c.col1);
    this.y = n.Dot(this, c.col2), this.x = l;
  }, o.prototype.CrossVF = function(c) {
    c === void 0 && (c = 0);
    var l = (this || window).x;
    this.x = c * this.y, this.y = -c * l;
  }, o.prototype.CrossFV = function(c) {
    c === void 0 && (c = 0);
    var l = (this || window).x;
    this.x = -c * this.y, this.y = c * l;
  }, o.prototype.MinV = function(c) {
    this.x = (this || window).x < c.x ? this.x : c.x, this.y = (this || window).y < c.y ? this.y : c.y;
  }, o.prototype.MaxV = function(c) {
    this.x = (this || window).x > c.x ? this.x : c.x, this.y = (this || window).y > c.y ? this.y : c.y;
  }, o.prototype.Abs = function() {
    this.x < 0 && (this.x = -this.x), this.y < 0 && (this.y = -this.y);
  }, o.prototype.Length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, o.prototype.LengthSquared = function() {
    return this.x * this.x + this.y * this.y;
  }, o.prototype.Normalize = function() {
    var c = Math.sqrt(this.x * this.x + this.y * this.y);
    if (c < Number.MIN_VALUE)
      return 0;
    var l = 1 / c;
    return this.x *= l, this.y *= l, c;
  }, o.prototype.IsValid = function() {
    return n.IsValid(this.x) && n.IsValid(this.y);
  }, a.b2Vec3 = function() {
  }, a.prototype.b2Vec3 = function(c, l, h) {
    c === void 0 && (c = 0), l === void 0 && (l = 0), h === void 0 && (h = 0), this.x = c, this.y = l, this.z = h;
  }, a.prototype.SetZero = function() {
    this.x = (this || window).y = (this || window).z = 0;
  }, a.prototype.Set = function(c, l, h) {
    c === void 0 && (c = 0), l === void 0 && (l = 0), h === void 0 && (h = 0), this.x = c, this.y = l, this.z = h;
  }, a.prototype.SetV = function(c) {
    this.x = c.x, this.y = c.y, this.z = c.z;
  }, a.prototype.GetNegative = function() {
    return new a(-this.x, -this.y, -this.z);
  }, a.prototype.NegativeSelf = function() {
    this.x = -this.x, this.y = -this.y, this.z = -this.z;
  }, a.prototype.Copy = function() {
    return new a(this.x, this.y, this.z);
  }, a.prototype.Add = function(c) {
    this.x += c.x, this.y += c.y, this.z += c.z;
  }, a.prototype.Subtract = function(c) {
    this.x -= c.x, this.y -= c.y, this.z -= c.z;
  }, a.prototype.Multiply = function(c) {
    c === void 0 && (c = 0), this.x *= c, this.y *= c, this.z *= c;
  };
})();
(function() {
  Box2D.Dynamics.Controllers.b2ControllerEdge, Box2D.Common.Math.b2Mat22, Box2D.Common.Math.b2Mat33;
  var t = Box2D.Common.Math.b2Math, e = Box2D.Common.Math.b2Sweep, n = Box2D.Common.Math.b2Transform, r = Box2D.Common.Math.b2Vec2;
  Box2D.Common.Math.b2Vec3;
  var s = Box2D.Common.b2Color;
  Box2D.Common.b2internal;
  var o = Box2D.Common.b2Settings, a = Box2D.Collision.b2AABB;
  Box2D.Collision.b2Bound, Box2D.Collision.b2BoundValues, Box2D.Collision.b2Collision, Box2D.Collision.b2ContactID;
  var c = Box2D.Collision.b2ContactPoint;
  Box2D.Collision.b2Distance, Box2D.Collision.b2DistanceInput, Box2D.Collision.b2DistanceOutput, Box2D.Collision.b2DistanceProxy, Box2D.Collision.b2DynamicTree;
  var l = Box2D.Collision.b2DynamicTreeBroadPhase;
  Box2D.Collision.b2DynamicTreeNode, Box2D.Collision.b2DynamicTreePair, Box2D.Collision.b2Manifold, Box2D.Collision.b2ManifoldPoint, Box2D.Collision.b2Point;
  var h = Box2D.Collision.b2RayCastInput, u = Box2D.Collision.b2RayCastOutput;
  Box2D.Collision.b2Segment, Box2D.Collision.b2SeparationFunction, Box2D.Collision.b2Simplex, Box2D.Collision.b2SimplexCache, Box2D.Collision.b2SimplexVertex, Box2D.Collision.b2TimeOfImpact, Box2D.Collision.b2TOIInput, Box2D.Collision.b2WorldManifold, Box2D.Collision.ClipVertex, Box2D.Collision.Features, Box2D.Collision.IBroadPhase;
  var _ = Box2D.Collision.Shapes.b2CircleShape;
  Box2D.Collision.Shapes.b2EdgeChainDef;
  var d = Box2D.Collision.Shapes.b2EdgeShape, f = Box2D.Collision.Shapes.b2MassData, C = Box2D.Collision.Shapes.b2PolygonShape, m = Box2D.Collision.Shapes.b2Shape, g = Box2D.Dynamics.b2Body, y = Box2D.Dynamics.b2BodyDef, A = Box2D.Dynamics.b2ContactFilter, D = Box2D.Dynamics.b2ContactImpulse, N = Box2D.Dynamics.b2ContactListener, z = Box2D.Dynamics.b2ContactManager, M = Box2D.Dynamics.b2DebugDraw, Z = Box2D.Dynamics.b2DestructionListener, U = Box2D.Dynamics.b2FilterData, Q = Box2D.Dynamics.b2Fixture, et = Box2D.Dynamics.b2FixtureDef, rt = Box2D.Dynamics.b2Island, w = Box2D.Dynamics.b2TimeStep, L = Box2D.Dynamics.b2World;
  Box2D.Dynamics.Contacts.b2CircleContact;
  var G = Box2D.Dynamics.Contacts.b2Contact;
  Box2D.Dynamics.Contacts.b2ContactConstraint, Box2D.Dynamics.Contacts.b2ContactConstraintPoint, Box2D.Dynamics.Contacts.b2ContactEdge;
  var I = Box2D.Dynamics.Contacts.b2ContactFactory;
  Box2D.Dynamics.Contacts.b2ContactRegister, Box2D.Dynamics.Contacts.b2ContactResult;
  var O = Box2D.Dynamics.Contacts.b2ContactSolver;
  Box2D.Dynamics.Contacts.b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2NullContact, Box2D.Dynamics.Contacts.b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2PolygonContact, Box2D.Dynamics.Contacts.b2PositionSolverManifold, Box2D.Dynamics.Controllers.b2Controller, Box2D.Dynamics.Joints.b2DistanceJoint, Box2D.Dynamics.Joints.b2DistanceJointDef, Box2D.Dynamics.Joints.b2FrictionJoint, Box2D.Dynamics.Joints.b2FrictionJointDef, Box2D.Dynamics.Joints.b2GearJoint, Box2D.Dynamics.Joints.b2GearJointDef, Box2D.Dynamics.Joints.b2Jacobian;
  var K = Box2D.Dynamics.Joints.b2Joint;
  Box2D.Dynamics.Joints.b2JointDef, Box2D.Dynamics.Joints.b2JointEdge, Box2D.Dynamics.Joints.b2LineJoint, Box2D.Dynamics.Joints.b2LineJointDef, Box2D.Dynamics.Joints.b2MouseJoint, Box2D.Dynamics.Joints.b2MouseJointDef, Box2D.Dynamics.Joints.b2PrismaticJoint, Box2D.Dynamics.Joints.b2PrismaticJointDef;
  var $ = Box2D.Dynamics.Joints.b2PulleyJoint;
  Box2D.Dynamics.Joints.b2PulleyJointDef, Box2D.Dynamics.Joints.b2RevoluteJoint, Box2D.Dynamics.Joints.b2RevoluteJointDef, Box2D.Dynamics.Joints.b2WeldJoint, Box2D.Dynamics.Joints.b2WeldJointDef, g.b2Body = function() {
    this.m_xf = new n(), this.m_sweep = new e(), this.m_linearVelocity = new r(), this.m_force = new r();
  }, g.prototype.connectEdges = function(S, b, W) {
    W === void 0 && (W = 0);
    var x = Math.atan2(b.GetDirectionVector().y, b.GetDirectionVector().x), E = Math.tan((x - W) * 0.5), R = t.MulFV(E, b.GetDirectionVector());
    R = t.SubtractVV(R, b.GetNormalVector()), R = t.MulFV(o.b2_toiSlop, R), R = t.AddVV(R, b.GetVertex1());
    var F = t.AddVV(S.GetDirectionVector(), b.GetDirectionVector());
    F.Normalize();
    var k = t.Dot(S.GetDirectionVector(), b.GetNormalVector()) > 0;
    return S.SetNextEdge(b, R, F, k), b.SetPrevEdge(S, R, F, k), x;
  }, g.prototype.CreateFixture = function(S) {
    if (this.m_world.IsLocked() == !0)
      return null;
    var b = new Q();
    if (b.Create(this, this.m_xf, S), this.m_flags & g.e_activeFlag) {
      var W = (this || window).m_world.m_contactManager.m_broadPhase;
      b.CreateProxy(W, this.m_xf);
    }
    return b.m_next = (this || window).m_fixtureList, this.m_fixtureList = b, ++this.m_fixtureCount, b.m_body = (this || window), b.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= L.e_newFixture, b;
  }, g.prototype.CreateFixture2 = function(S, b) {
    b === void 0 && (b = 0);
    var W = new et();
    return W.shape = S, W.density = b, this.CreateFixture(W);
  }, g.prototype.DestroyFixture = function(S) {
    if (this.m_world.IsLocked() != !0) {
      for (var b = (this || window).m_fixtureList, W = null; b != null; ) {
        if (b == S) {
          W ? W.m_next = S.m_next : this.m_fixtureList = S.m_next;
          break;
        }
        W = b, b = b.m_next;
      }
      for (var x = (this || window).m_contactList; x; ) {
        var E = x.contact;
        x = x.next;
        var R = E.GetFixtureA(), F = E.GetFixtureB();
        (S == R || S == F) && this.m_world.m_contactManager.Destroy(E);
      }
      if (this.m_flags & g.e_activeFlag) {
        var k = (this || window).m_world.m_contactManager.m_broadPhase;
        S.DestroyProxy(k);
      }
      S.Destroy(), S.m_body = null, S.m_next = null, --this.m_fixtureCount, this.ResetMassData();
    }
  }, g.prototype.SetPositionAndAngle = function(S, b) {
    b === void 0 && (b = 0);
    var W;
    if (this.m_world.IsLocked() != !0) {
      this.m_xf.R.Set(b), this.m_xf.position.SetV(S);
      var x = (this || window).m_xf.R, E = (this || window).m_sweep.localCenter;
      this.m_sweep.c.x = x.col1.x * E.x + x.col2.x * E.y, this.m_sweep.c.y = x.col1.y * E.x + x.col2.y * E.y, this.m_sweep.c.x += (this || window).m_xf.position.x, this.m_sweep.c.y += (this || window).m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_sweep.a0 = (this || window).m_sweep.a = b;
      var R = (this || window).m_world.m_contactManager.m_broadPhase;
      for (W = (this || window).m_fixtureList; W; W = W.m_next)
        W.Synchronize(R, this.m_xf, this.m_xf);
      this.m_world.m_contactManager.FindNewContacts();
    }
  }, g.prototype.SetTransform = function(S) {
    this.SetPositionAndAngle(S.position, S.GetAngle());
  }, g.prototype.GetTransform = function() {
    return this.m_xf;
  }, g.prototype.GetPosition = function() {
    return this.m_xf.position;
  }, g.prototype.SetPosition = function(S) {
    this.SetPositionAndAngle(S, this.GetAngle());
  }, g.prototype.GetAngle = function() {
    return this.m_sweep.a;
  }, g.prototype.SetAngle = function(S) {
    S === void 0 && (S = 0), this.SetPositionAndAngle(this.GetPosition(), S);
  }, g.prototype.GetWorldCenter = function() {
    return this.m_sweep.c;
  }, g.prototype.GetLocalCenter = function() {
    return this.m_sweep.localCenter;
  }, g.prototype.SetLinearVelocity = function(S) {
    this.m_type != g.b2_staticBody && this.m_linearVelocity.SetV(S);
  }, g.prototype.GetLinearVelocity = function() {
    return this.m_linearVelocity;
  }, g.prototype.SetAngularVelocity = function(S) {
    S === void 0 && (S = 0), this.m_type != g.b2_staticBody && (this.m_angularVelocity = S);
  }, g.prototype.GetAngularVelocity = function() {
    return this.m_angularVelocity;
  }, g.prototype.GetDefinition = function() {
    var S = new y();
    return S.type = (this || window).GetType(), S.allowSleep = (this.m_flags & g.e_allowSleepFlag) == g.e_allowSleepFlag, S.angle = (this || window).GetAngle(), S.angularDamping = (this || window).m_angularDamping, S.angularVelocity = (this || window).m_angularVelocity, S.fixedRotation = (this.m_flags & g.e_fixedRotationFlag) == g.e_fixedRotationFlag, S.bullet = (this.m_flags & g.e_bulletFlag) == g.e_bulletFlag, S.awake = (this.m_flags & g.e_awakeFlag) == g.e_awakeFlag, S.linearDamping = (this || window).m_linearDamping, S.linearVelocity.SetV(this.GetLinearVelocity()), S.position = (this || window).GetPosition(), S.userData = (this || window).GetUserData(), S;
  }, g.prototype.ApplyForce = function(S, b) {
    this.m_type == g.b2_dynamicBody && (this.IsAwake() == !1 && this.SetAwake(!0), this.m_force.x += S.x, this.m_force.y += S.y, this.m_torque += (b.x - this.m_sweep.c.x) * S.y - (b.y - this.m_sweep.c.y) * S.x);
  }, g.prototype.ApplyTorque = function(S) {
    S === void 0 && (S = 0), this.m_type == g.b2_dynamicBody && (this.IsAwake() == !1 && this.SetAwake(!0), this.m_torque += S);
  }, g.prototype.ApplyImpulse = function(S, b) {
    this.m_type == g.b2_dynamicBody && (this.IsAwake() == !1 && this.SetAwake(!0), this.m_linearVelocity.x += (this || window).m_invMass * S.x, this.m_linearVelocity.y += (this || window).m_invMass * S.y, this.m_angularVelocity += (this || window).m_invI * ((b.x - this.m_sweep.c.x) * S.y - (b.y - this.m_sweep.c.y) * S.x));
  }, g.prototype.Split = function(S) {
    for (var b = (this || window).GetLinearVelocity().Copy(), W = (this || window).GetAngularVelocity(), x = (this || window).GetWorldCenter(), E = (this || window), R = (this || window).m_world.CreateBody(this.GetDefinition()), F, k = E.m_fixtureList; k; )
      if (S(k)) {
        var X = k.m_next;
        F ? F.m_next = X : E.m_fixtureList = X, E.m_fixtureCount--, k.m_next = R.m_fixtureList, R.m_fixtureList = k, R.m_fixtureCount++, k.m_body = R, k = X;
      } else
        F = k, k = k.m_next;
    E.ResetMassData(), R.ResetMassData();
    var j = E.GetWorldCenter(), V = R.GetWorldCenter(), Y = t.AddVV(b, t.CrossFV(W, t.SubtractVV(j, x))), tt = t.AddVV(b, t.CrossFV(W, t.SubtractVV(V, x)));
    return E.SetLinearVelocity(Y), R.SetLinearVelocity(tt), E.SetAngularVelocity(W), R.SetAngularVelocity(W), E.SynchronizeFixtures(), R.SynchronizeFixtures(), R;
  }, g.prototype.Merge = function(S) {
    var b;
    for (b = S.m_fixtureList; b; ) {
      var W = b.m_next;
      S.m_fixtureCount--, b.m_next = (this || window).m_fixtureList, this.m_fixtureList = b, this.m_fixtureCount++, b.m_body = E, b = W;
    }
    x.m_fixtureCount = 0;
    var x = (this || window), E = S;
    x.GetWorldCenter(), E.GetWorldCenter(), x.GetLinearVelocity().Copy(), E.GetLinearVelocity().Copy(), x.GetAngularVelocity(), E.GetAngularVelocity(), x.ResetMassData(), this.SynchronizeFixtures();
  }, g.prototype.GetMass = function() {
    return this.m_mass;
  }, g.prototype.GetInertia = function() {
    return this.m_I;
  }, g.prototype.GetMassData = function(S) {
    S.mass = (this || window).m_mass, S.I = (this || window).m_I, S.center.SetV(this.m_sweep.localCenter);
  }, g.prototype.SetMassData = function(S) {
    if (o.b2Assert(this.m_world.IsLocked() == !1), this.m_world.IsLocked() != !0 && this.m_type == g.b2_dynamicBody) {
      this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = S.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, S.I > 0 && !(this.m_flags & g.e_fixedRotationFlag) && (this.m_I = S.I - this.m_mass * (S.center.x * S.center.x + S.center.y * S.center.y), this.m_invI = 1 / this.m_I);
      var b = (this || window).m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(S.center), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += (this || window).m_angularVelocity * -(this.m_sweep.c.y - b.y), this.m_linearVelocity.y += (this || window).m_angularVelocity * +(this.m_sweep.c.x - b.x);
    }
  }, g.prototype.ResetMassData = function() {
    if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), !(this.m_type == g.b2_staticBody || this.m_type == g.b2_kinematicBody)) {
      for (var S = r.Make(0, 0), b = (this || window).m_fixtureList; b; b = b.m_next)
        if (b.m_density != 0) {
          var W = b.GetMassData();
          this.m_mass += W.mass, S.x += W.center.x * W.mass, S.y += W.center.y * W.mass, this.m_I += W.I;
        }
      this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, S.x *= (this || window).m_invMass, S.y *= (this || window).m_invMass) : (this.m_mass = 1, this.m_invMass = 1), this.m_I > 0 && !(this.m_flags & g.e_fixedRotationFlag) ? (this.m_I -= (this || window).m_mass * (S.x * S.x + S.y * S.y), this.m_I *= (this || window).m_inertiaScale, o.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0);
      var x = (this || window).m_sweep.c.Copy();
      this.m_sweep.localCenter.SetV(S), this.m_sweep.c0.SetV(t.MulX(this.m_xf, this.m_sweep.localCenter)), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_linearVelocity.x += (this || window).m_angularVelocity * -(this.m_sweep.c.y - x.y), this.m_linearVelocity.y += (this || window).m_angularVelocity * +(this.m_sweep.c.x - x.x);
    }
  }, g.prototype.GetWorldPoint = function(S) {
    var b = (this || window).m_xf.R, W = new r(b.col1.x * S.x + b.col2.x * S.y, b.col1.y * S.x + b.col2.y * S.y);
    return W.x += (this || window).m_xf.position.x, W.y += (this || window).m_xf.position.y, W;
  }, g.prototype.GetWorldVector = function(S) {
    return t.MulMV(this.m_xf.R, S);
  }, g.prototype.GetLocalPoint = function(S) {
    return t.MulXT(this.m_xf, S);
  }, g.prototype.GetLocalVector = function(S) {
    return t.MulTMV(this.m_xf.R, S);
  }, g.prototype.GetLinearVelocityFromWorldPoint = function(S) {
    return new r(this.m_linearVelocity.x - this.m_angularVelocity * (S.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (S.x - this.m_sweep.c.x));
  }, g.prototype.GetLinearVelocityFromLocalPoint = function(S) {
    var b = (this || window).m_xf.R, W = new r(b.col1.x * S.x + b.col2.x * S.y, b.col1.y * S.x + b.col2.y * S.y);
    return W.x += (this || window).m_xf.position.x, W.y += (this || window).m_xf.position.y, new r(this.m_linearVelocity.x - this.m_angularVelocity * (W.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (W.x - this.m_sweep.c.x));
  }, g.prototype.GetLinearDamping = function() {
    return this.m_linearDamping;
  }, g.prototype.SetLinearDamping = function(S) {
    S === void 0 && (S = 0), this.m_linearDamping = S;
  }, g.prototype.GetAngularDamping = function() {
    return this.m_angularDamping;
  }, g.prototype.SetAngularDamping = function(S) {
    S === void 0 && (S = 0), this.m_angularDamping = S;
  }, g.prototype.SetType = function(S) {
    if (S === void 0 && (S = 0), this.m_type != S) {
      this.m_type = S, this.ResetMassData(), this.m_type == g.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0;
      for (var b = (this || window).m_contactList; b; b = b.next)
        b.contact.FlagForFiltering();
    }
  }, g.prototype.GetType = function() {
    return this.m_type;
  }, g.prototype.SetBullet = function(S) {
    S ? this.m_flags |= g.e_bulletFlag : this.m_flags &= ~g.e_bulletFlag;
  }, g.prototype.IsBullet = function() {
    return (this.m_flags & g.e_bulletFlag) == g.e_bulletFlag;
  }, g.prototype.SetSleepingAllowed = function(S) {
    S ? this.m_flags |= g.e_allowSleepFlag : (this.m_flags &= ~g.e_allowSleepFlag, this.SetAwake(!0));
  }, g.prototype.SetAwake = function(S) {
    S ? (this.m_flags |= g.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~g.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0);
  }, g.prototype.IsAwake = function() {
    return (this.m_flags & g.e_awakeFlag) == g.e_awakeFlag;
  }, g.prototype.SetFixedRotation = function(S) {
    S ? this.m_flags |= g.e_fixedRotationFlag : this.m_flags &= ~g.e_fixedRotationFlag, this.ResetMassData();
  }, g.prototype.IsFixedRotation = function() {
    return (this.m_flags & g.e_fixedRotationFlag) == g.e_fixedRotationFlag;
  }, g.prototype.SetActive = function(S) {
    if (S != (this || window).IsActive()) {
      var b, W;
      if (S)
        for (this.m_flags |= g.e_activeFlag, b = (this || window).m_world.m_contactManager.m_broadPhase, W = (this || window).m_fixtureList; W; W = W.m_next)
          W.CreateProxy(b, this.m_xf);
      else {
        for (this.m_flags &= ~g.e_activeFlag, b = (this || window).m_world.m_contactManager.m_broadPhase, W = (this || window).m_fixtureList; W; W = W.m_next)
          W.DestroyProxy(b);
        for (var x = (this || window).m_contactList; x; ) {
          var E = x;
          x = x.next, this.m_world.m_contactManager.Destroy(E.contact);
        }
        this.m_contactList = null;
      }
    }
  }, g.prototype.IsActive = function() {
    return (this.m_flags & g.e_activeFlag) == g.e_activeFlag;
  }, g.prototype.IsSleepingAllowed = function() {
    return (this.m_flags & g.e_allowSleepFlag) == g.e_allowSleepFlag;
  }, g.prototype.GetFixtureList = function() {
    return this.m_fixtureList;
  }, g.prototype.GetJointList = function() {
    return this.m_jointList;
  }, g.prototype.GetControllerList = function() {
    return this.m_controllerList;
  }, g.prototype.GetContactList = function() {
    return this.m_contactList;
  }, g.prototype.GetNext = function() {
    return this.m_next;
  }, g.prototype.GetUserData = function() {
    return this.m_userData;
  }, g.prototype.SetUserData = function(S) {
    this.m_userData = S;
  }, g.prototype.GetWorld = function() {
    return this.m_world;
  }, g.prototype.b2Body = function(S, b) {
    this.m_flags = 0, S.bullet && (this.m_flags |= g.e_bulletFlag), S.fixedRotation && (this.m_flags |= g.e_fixedRotationFlag), S.allowSleep && (this.m_flags |= g.e_allowSleepFlag), S.awake && (this.m_flags |= g.e_awakeFlag), S.active && (this.m_flags |= g.e_activeFlag), this.m_world = b, this.m_xf.position.SetV(S.position), this.m_xf.R.Set(S.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.t0 = 1, this.m_sweep.a0 = (this || window).m_sweep.a = S.angle;
    var W = (this || window).m_xf.R, x = (this || window).m_sweep.localCenter;
    this.m_sweep.c.x = W.col1.x * x.x + W.col2.x * x.y, this.m_sweep.c.y = W.col1.y * x.x + W.col2.y * x.y, this.m_sweep.c.x += (this || window).m_xf.position.x, this.m_sweep.c.y += (this || window).m_xf.position.y, this.m_sweep.c0.SetV(this.m_sweep.c), this.m_jointList = null, this.m_controllerList = null, this.m_contactList = null, this.m_controllerCount = 0, this.m_prev = null, this.m_next = null, this.m_linearVelocity.SetV(S.linearVelocity), this.m_angularVelocity = S.angularVelocity, this.m_linearDamping = S.linearDamping, this.m_angularDamping = S.angularDamping, this.m_force.Set(0, 0), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = S.type, this.m_type == g.b2_dynamicBody ? (this.m_mass = 1, this.m_invMass = 1) : (this.m_mass = 0, this.m_invMass = 0), this.m_I = 0, this.m_invI = 0, this.m_inertiaScale = S.inertiaScale, this.m_userData = S.userData, this.m_fixtureList = null, this.m_fixtureCount = 0;
  }, g.prototype.SynchronizeFixtures = function() {
    var S = g.s_xf1;
    S.R.Set(this.m_sweep.a0);
    var b = S.R, W = (this || window).m_sweep.localCenter;
    S.position.x = (this || window).m_sweep.c0.x - (b.col1.x * W.x + b.col2.x * W.y), S.position.y = (this || window).m_sweep.c0.y - (b.col1.y * W.x + b.col2.y * W.y);
    var x, E = (this || window).m_world.m_contactManager.m_broadPhase;
    for (x = (this || window).m_fixtureList; x; x = x.m_next)
      x.Synchronize(E, S, this.m_xf);
  }, g.prototype.SynchronizeTransform = function() {
    this.m_xf.R.Set(this.m_sweep.a);
    var S = (this || window).m_xf.R, b = (this || window).m_sweep.localCenter;
    this.m_xf.position.x = (this || window).m_sweep.c.x - (S.col1.x * b.x + S.col2.x * b.y), this.m_xf.position.y = (this || window).m_sweep.c.y - (S.col1.y * b.x + S.col2.y * b.y);
  }, g.prototype.ShouldCollide = function(S) {
    if (this.m_type != g.b2_dynamicBody && S.m_type != g.b2_dynamicBody)
      return !1;
    for (var b = (this || window).m_jointList; b; b = b.next)
      if (b.other == S && b.joint.m_collideConnected == !1)
        return !1;
    return !0;
  }, g.prototype.Advance = function(S) {
    S === void 0 && (S = 0), this.m_sweep.Advance(S), this.m_sweep.c.SetV(this.m_sweep.c0), this.m_sweep.a = (this || window).m_sweep.a0, this.SynchronizeTransform();
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.b2Body.s_xf1 = new n(), Box2D.Dynamics.b2Body.e_islandFlag = 1, Box2D.Dynamics.b2Body.e_awakeFlag = 2, Box2D.Dynamics.b2Body.e_allowSleepFlag = 4, Box2D.Dynamics.b2Body.e_bulletFlag = 8, Box2D.Dynamics.b2Body.e_fixedRotationFlag = 16, Box2D.Dynamics.b2Body.e_activeFlag = 32, Box2D.Dynamics.b2Body.b2_staticBody = 0, Box2D.Dynamics.b2Body.b2_kinematicBody = 1, Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
  }), y.b2BodyDef = function() {
    this.position = new r(), this.linearVelocity = new r();
  }, y.prototype.b2BodyDef = function() {
    this.userData = null, this.position.Set(0, 0), this.angle = 0, this.linearVelocity.Set(0, 0), this.angularVelocity = 0, this.linearDamping = 0, this.angularDamping = 0, this.allowSleep = !0, this.awake = !0, this.fixedRotation = !1, this.bullet = !1, this.type = g.b2_staticBody, this.active = !0, this.inertiaScale = 1;
  }, A.b2ContactFilter = function() {
  }, A.prototype.ShouldCollide = function(S, b) {
    var W = S.GetFilterData(), x = b.GetFilterData();
    if (W.groupIndex == x.groupIndex && W.groupIndex != 0)
      return W.groupIndex > 0;
    var E = (W.maskBits & x.categoryBits) != 0 && (W.categoryBits & x.maskBits) != 0;
    return E;
  }, A.prototype.RayCollide = function(S, b) {
    return S ? this.ShouldCollide(S instanceof Q ? S : null, b) : !0;
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new A();
  }), D.b2ContactImpulse = function() {
    this.normalImpulses = new Vector_a2j_Number(o.b2_maxManifoldPoints), this.tangentImpulses = new Vector_a2j_Number(o.b2_maxManifoldPoints);
  }, N.b2ContactListener = function() {
  }, N.prototype.BeginContact = function(S) {
  }, N.prototype.EndContact = function(S) {
  }, N.prototype.PreSolve = function(S, b) {
  }, N.prototype.PostSolve = function(S, b) {
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.b2ContactListener.b2_defaultListener = new N();
  }), z.b2ContactManager = function() {
  }, z.prototype.b2ContactManager = function() {
    this.m_world = null, this.m_contactCount = 0, this.m_contactFilter = A.b2_defaultFilter, this.m_contactListener = N.b2_defaultListener, this.m_contactFactory = new I(this.m_allocator), this.m_broadPhase = new l();
  }, z.prototype.AddPair = function(S, b) {
    var W = S instanceof Q ? S : null, x = b instanceof Q ? b : null, E = W.GetBody(), R = x.GetBody();
    if (E != R) {
      for (var F = R.GetContactList(); F; ) {
        if (F.other == E) {
          var k = F.contact.GetFixtureA(), X = F.contact.GetFixtureB();
          if (k == W && X == x || k == x && X == W)
            return;
        }
        F = F.next;
      }
      if (R.ShouldCollide(E) != !1 && this.m_contactFilter.ShouldCollide(W, x) != !1) {
        var j = (this || window).m_contactFactory.Create(W, x);
        W = j.GetFixtureA(), x = j.GetFixtureB(), E = W.m_body, R = x.m_body, j.m_prev = null, j.m_next = (this || window).m_world.m_contactList, this.m_world.m_contactList != null && (this.m_world.m_contactList.m_prev = j), this.m_world.m_contactList = j, j.m_nodeA.contact = j, j.m_nodeA.other = R, j.m_nodeA.prev = null, j.m_nodeA.next = E.m_contactList, E.m_contactList != null && (E.m_contactList.prev = j.m_nodeA), E.m_contactList = j.m_nodeA, j.m_nodeB.contact = j, j.m_nodeB.other = E, j.m_nodeB.prev = null, j.m_nodeB.next = R.m_contactList, R.m_contactList != null && (R.m_contactList.prev = j.m_nodeB), R.m_contactList = j.m_nodeB, ++this.m_world.m_contactCount;
      }
    }
  }, z.prototype.FindNewContacts = function() {
    this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
  }, z.prototype.Destroy = function(S) {
    var b = S.GetFixtureA(), W = S.GetFixtureB(), x = b.GetBody(), E = W.GetBody();
    S.IsTouching() && this.m_contactListener.EndContact(S), S.m_prev && (S.m_prev.m_next = S.m_next), S.m_next && (S.m_next.m_prev = S.m_prev), S == (this || window).m_world.m_contactList && (this.m_world.m_contactList = S.m_next), S.m_nodeA.prev && (S.m_nodeA.prev.next = S.m_nodeA.next), S.m_nodeA.next && (S.m_nodeA.next.prev = S.m_nodeA.prev), S.m_nodeA == x.m_contactList && (x.m_contactList = S.m_nodeA.next), S.m_nodeB.prev && (S.m_nodeB.prev.next = S.m_nodeB.next), S.m_nodeB.next && (S.m_nodeB.next.prev = S.m_nodeB.prev), S.m_nodeB == E.m_contactList && (E.m_contactList = S.m_nodeB.next), this.m_contactFactory.Destroy(S), --this.m_contactCount;
  }, z.prototype.Collide = function() {
    for (var S = (this || window).m_world.m_contactList; S; ) {
      var b = S.GetFixtureA(), W = S.GetFixtureB(), x = b.GetBody(), E = W.GetBody();
      if (x.IsAwake() == !1 && E.IsAwake() == !1) {
        S = S.GetNext();
        continue;
      }
      if (S.m_flags & G.e_filterFlag) {
        if (E.ShouldCollide(x) == !1) {
          var R = S;
          S = R.GetNext(), this.Destroy(R);
          continue;
        }
        if (this.m_contactFilter.ShouldCollide(b, W) == !1) {
          R = S, S = R.GetNext(), this.Destroy(R);
          continue;
        }
        S.m_flags &= ~G.e_filterFlag;
      }
      var F = b.m_proxy, k = W.m_proxy, X = (this || window).m_broadPhase.TestOverlap(F, k);
      if (X == !1) {
        R = S, S = R.GetNext(), this.Destroy(R);
        continue;
      }
      S.Update(this.m_contactListener), S = S.GetNext();
    }
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.b2ContactManager.s_evalCP = new c();
  }), M.b2DebugDraw = function() {
  }, M.prototype.b2DebugDraw = function() {
  }, M.prototype.SetFlags = function(S) {
  }, M.prototype.GetFlags = function() {
  }, M.prototype.AppendFlags = function(S) {
  }, M.prototype.ClearFlags = function(S) {
  }, M.prototype.SetSprite = function(S) {
  }, M.prototype.GetSprite = function() {
  }, M.prototype.SetDrawScale = function(S) {
  }, M.prototype.GetDrawScale = function() {
  }, M.prototype.SetLineThickness = function(S) {
  }, M.prototype.GetLineThickness = function() {
  }, M.prototype.SetAlpha = function(S) {
  }, M.prototype.GetAlpha = function() {
  }, M.prototype.SetFillAlpha = function(S) {
  }, M.prototype.GetFillAlpha = function() {
  }, M.prototype.SetXFormScale = function(S) {
  }, M.prototype.GetXFormScale = function() {
  }, M.prototype.DrawPolygon = function(S, b, W) {
  }, M.prototype.DrawSolidPolygon = function(S, b, W) {
  }, M.prototype.DrawCircle = function(S, b, W) {
  }, M.prototype.DrawSolidCircle = function(S, b, W, x) {
  }, M.prototype.DrawSegment = function(S, b, W) {
  }, M.prototype.DrawTransform = function(S) {
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.b2DebugDraw.e_shapeBit = 1, Box2D.Dynamics.b2DebugDraw.e_jointBit = 2, Box2D.Dynamics.b2DebugDraw.e_aabbBit = 4, Box2D.Dynamics.b2DebugDraw.e_pairBit = 8, Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 16, Box2D.Dynamics.b2DebugDraw.e_controllerBit = 32;
  }), Z.b2DestructionListener = function() {
  }, Z.prototype.SayGoodbyeJoint = function(S) {
  }, Z.prototype.SayGoodbyeFixture = function(S) {
  }, U.b2FilterData = function() {
    this.categoryBits = 1, this.maskBits = 65535, this.groupIndex = 0;
  }, U.prototype.Copy = function() {
    var S = new U();
    return S.categoryBits = (this || window).categoryBits, S.maskBits = (this || window).maskBits, S.groupIndex = (this || window).groupIndex, S;
  }, Q.b2Fixture = function() {
    this.m_filter = new U();
  }, Q.prototype.GetType = function() {
    return this.m_shape.GetType();
  }, Q.prototype.GetShape = function() {
    return this.m_shape;
  }, Q.prototype.SetSensor = function(S) {
    if (this.m_isSensor != S && (this.m_isSensor = S, this.m_body != null))
      for (var b = (this || window).m_body.GetContactList(); b; ) {
        var W = b.contact, x = W.GetFixtureA(), E = W.GetFixtureB();
        (x == (this || window) || E == (this || window)) && W.SetSensor(x.IsSensor() || E.IsSensor()), b = b.next;
      }
  }, Q.prototype.IsSensor = function() {
    return this.m_isSensor;
  }, Q.prototype.SetFilterData = function(S) {
    if (this.m_filter = S.Copy(), !this.m_body)
      for (var b = (this || window).m_body.GetContactList(); b; ) {
        var W = b.contact, x = W.GetFixtureA(), E = W.GetFixtureB();
        (x == (this || window) || E == (this || window)) && W.FlagForFiltering(), b = b.next;
      }
  }, Q.prototype.GetFilterData = function() {
    return this.m_filter.Copy();
  }, Q.prototype.GetBody = function() {
    return this.m_body;
  }, Q.prototype.GetNext = function() {
    return this.m_next;
  }, Q.prototype.GetUserData = function() {
    return this.m_userData;
  }, Q.prototype.SetUserData = function(S) {
    this.m_userData = S;
  }, Q.prototype.TestPoint = function(S) {
    return this.m_shape.TestPoint(this.m_body.GetTransform(), S);
  }, Q.prototype.RayCast = function(S, b) {
    return this.m_shape.RayCast(S, b, this.m_body.GetTransform());
  }, Q.prototype.GetMassData = function(S) {
    return S === void 0 && (S = null), S == null && (S = new f()), this.m_shape.ComputeMass(S, this.m_density), S;
  }, Q.prototype.SetDensity = function(S) {
    S === void 0 && (S = 0), this.m_density = S;
  }, Q.prototype.GetDensity = function() {
    return this.m_density;
  }, Q.prototype.GetFriction = function() {
    return this.m_friction;
  }, Q.prototype.SetFriction = function(S) {
    S === void 0 && (S = 0), this.m_friction = S;
  }, Q.prototype.GetRestitution = function() {
    return this.m_restitution;
  }, Q.prototype.SetRestitution = function(S) {
    S === void 0 && (S = 0), this.m_restitution = S;
  }, Q.prototype.GetAABB = function() {
    return this.m_aabb;
  }, Q.prototype.b2Fixture = function() {
    this.m_aabb = new a(), this.m_userData = null, this.m_body = null, this.m_next = null, this.m_shape = null, this.m_density = 0, this.m_friction = 0, this.m_restitution = 0;
  }, Q.prototype.Create = function(S, b, W) {
    this.m_userData = W.userData, this.m_friction = W.friction, this.m_restitution = W.restitution, this.m_body = S, this.m_next = null, this.m_filter = W.filter.Copy(), this.m_isSensor = W.isSensor, this.m_shape = W.shape.Copy(), this.m_density = W.density;
  }, Q.prototype.Destroy = function() {
    this.m_shape = null;
  }, Q.prototype.CreateProxy = function(S, b) {
    this.m_shape.ComputeAABB(this.m_aabb, b), this.m_proxy = S.CreateProxy(this.m_aabb, this);
  }, Q.prototype.DestroyProxy = function(S) {
    this.m_proxy != null && (S.DestroyProxy(this.m_proxy), this.m_proxy = null);
  }, Q.prototype.Synchronize = function(S, b, W) {
    if (this.m_proxy) {
      var x = new a(), E = new a();
      this.m_shape.ComputeAABB(x, b), this.m_shape.ComputeAABB(E, W), this.m_aabb.Combine(x, E);
      var R = t.SubtractVV(W.position, b.position);
      S.MoveProxy(this.m_proxy, this.m_aabb, R);
    }
  }, et.b2FixtureDef = function() {
    this.filter = new U();
  }, et.prototype.b2FixtureDef = function() {
    this.shape = null, this.userData = null, this.friction = 0.2, this.restitution = 0, this.density = 0, this.filter.categoryBits = 1, this.filter.maskBits = 65535, this.filter.groupIndex = 0, this.isSensor = !1;
  }, rt.b2Island = function() {
  }, rt.prototype.b2Island = function() {
    this.m_bodies = new Vector(), this.m_contacts = new Vector(), this.m_joints = new Vector();
  }, rt.prototype.Initialize = function(S, b, W, x, E, R) {
    S === void 0 && (S = 0), b === void 0 && (b = 0), W === void 0 && (W = 0);
    var F = 0;
    for (this.m_bodyCapacity = S, this.m_contactCapacity = b, this.m_jointCapacity = W, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_allocator = x, this.m_listener = E, this.m_contactSolver = R, F = (this || window).m_bodies.length; F < S; F++)
      this.m_bodies[F] = null;
    for (F = (this || window).m_contacts.length; F < b; F++)
      this.m_contacts[F] = null;
    for (F = (this || window).m_joints.length; F < W; F++)
      this.m_joints[F] = null;
  }, rt.prototype.Clear = function() {
    this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0;
  }, rt.prototype.Solve = function(S, b, W) {
    var x = 0, E = 0, R, F;
    for (x = 0; x < this.m_bodyCount; ++x)
      R = (this || window).m_bodies[x], R.GetType() == g.b2_dynamicBody && (R.m_linearVelocity.x += S.dt * (b.x + R.m_invMass * R.m_force.x), R.m_linearVelocity.y += S.dt * (b.y + R.m_invMass * R.m_force.y), R.m_angularVelocity += S.dt * R.m_invI * R.m_torque, R.m_linearVelocity.Multiply(t.Clamp(1 - S.dt * R.m_linearDamping, 0, 1)), R.m_angularVelocity *= t.Clamp(1 - S.dt * R.m_angularDamping, 0, 1));
    this.m_contactSolver.Initialize(S, this.m_contacts, this.m_contactCount, this.m_allocator);
    var k = (this || window).m_contactSolver;
    for (k.InitVelocityConstraints(S), x = 0; x < this.m_jointCount; ++x)
      F = (this || window).m_joints[x], F.InitVelocityConstraints(S);
    for (x = 0; x < S.velocityIterations; ++x) {
      for (E = 0; E < this.m_jointCount; ++E)
        F = (this || window).m_joints[E], F.SolveVelocityConstraints(S);
      k.SolveVelocityConstraints();
    }
    for (x = 0; x < this.m_jointCount; ++x)
      F = (this || window).m_joints[x], F.FinalizeVelocityConstraints();
    for (k.FinalizeVelocityConstraints(), x = 0; x < this.m_bodyCount; ++x)
      if (R = (this || window).m_bodies[x], R.GetType() != g.b2_staticBody) {
        var X = S.dt * R.m_linearVelocity.x, j = S.dt * R.m_linearVelocity.y;
        X * X + j * j > o.b2_maxTranslationSquared && (R.m_linearVelocity.Normalize(), R.m_linearVelocity.x *= o.b2_maxTranslation * S.inv_dt, R.m_linearVelocity.y *= o.b2_maxTranslation * S.inv_dt);
        var V = S.dt * R.m_angularVelocity;
        V * V > o.b2_maxRotationSquared && (R.m_angularVelocity < 0 ? R.m_angularVelocity = -o.b2_maxRotation * S.inv_dt : R.m_angularVelocity = o.b2_maxRotation * S.inv_dt), R.m_sweep.c0.SetV(R.m_sweep.c), R.m_sweep.a0 = R.m_sweep.a, R.m_sweep.c.x += S.dt * R.m_linearVelocity.x, R.m_sweep.c.y += S.dt * R.m_linearVelocity.y, R.m_sweep.a += S.dt * R.m_angularVelocity, R.SynchronizeTransform();
      }
    for (x = 0; x < S.positionIterations; ++x) {
      var Y = k.SolvePositionConstraints(o.b2_contactBaumgarte), tt = !0;
      for (E = 0; E < this.m_jointCount; ++E) {
        F = (this || window).m_joints[E];
        var it = F.SolvePositionConstraints(o.b2_contactBaumgarte);
        tt = tt && it;
      }
      if (Y && tt)
        break;
    }
    if (this.Report(k.m_constraints), W) {
      var lt = Number.MAX_VALUE, ut = o.b2_linearSleepTolerance * o.b2_linearSleepTolerance, ft = o.b2_angularSleepTolerance * o.b2_angularSleepTolerance;
      for (x = 0; x < this.m_bodyCount; ++x)
        R = (this || window).m_bodies[x], R.GetType() != g.b2_staticBody && (R.m_flags & g.e_allowSleepFlag || (R.m_sleepTime = 0, lt = 0), !(R.m_flags & g.e_allowSleepFlag) || R.m_angularVelocity * R.m_angularVelocity > ft || t.Dot(R.m_linearVelocity, R.m_linearVelocity) > ut ? (R.m_sleepTime = 0, lt = 0) : (R.m_sleepTime += S.dt, lt = t.Min(lt, R.m_sleepTime)));
      if (lt >= o.b2_timeToSleep)
        for (x = 0; x < this.m_bodyCount; ++x)
          R = (this || window).m_bodies[x], R.SetAwake(!1);
    }
  }, rt.prototype.SolveTOI = function(S) {
    var b = 0, W = 0;
    this.m_contactSolver.Initialize(S, this.m_contacts, this.m_contactCount, this.m_allocator);
    var x = (this || window).m_contactSolver;
    for (b = 0; b < this.m_jointCount; ++b)
      this.m_joints[b].InitVelocityConstraints(S);
    for (b = 0; b < S.velocityIterations; ++b)
      for (x.SolveVelocityConstraints(), W = 0; W < this.m_jointCount; ++W)
        this.m_joints[W].SolveVelocityConstraints(S);
    for (b = 0; b < this.m_bodyCount; ++b) {
      var E = (this || window).m_bodies[b];
      if (E.GetType() != g.b2_staticBody) {
        var R = S.dt * E.m_linearVelocity.x, F = S.dt * E.m_linearVelocity.y;
        R * R + F * F > o.b2_maxTranslationSquared && (E.m_linearVelocity.Normalize(), E.m_linearVelocity.x *= o.b2_maxTranslation * S.inv_dt, E.m_linearVelocity.y *= o.b2_maxTranslation * S.inv_dt);
        var k = S.dt * E.m_angularVelocity;
        k * k > o.b2_maxRotationSquared && (E.m_angularVelocity < 0 ? E.m_angularVelocity = -o.b2_maxRotation * S.inv_dt : E.m_angularVelocity = o.b2_maxRotation * S.inv_dt), E.m_sweep.c0.SetV(E.m_sweep.c), E.m_sweep.a0 = E.m_sweep.a, E.m_sweep.c.x += S.dt * E.m_linearVelocity.x, E.m_sweep.c.y += S.dt * E.m_linearVelocity.y, E.m_sweep.a += S.dt * E.m_angularVelocity, E.SynchronizeTransform();
      }
    }
    var X = 0.75;
    for (b = 0; b < S.positionIterations; ++b) {
      var j = x.SolvePositionConstraints(X), V = !0;
      for (W = 0; W < this.m_jointCount; ++W) {
        var Y = (this || window).m_joints[W].SolvePositionConstraints(o.b2_contactBaumgarte);
        V = V && Y;
      }
      if (j && V)
        break;
    }
    this.Report(x.m_constraints);
  }, rt.prototype.Report = function(S) {
    if (this.m_listener != null)
      for (var b = 0; b < this.m_contactCount; ++b) {
        for (var W = (this || window).m_contacts[b], x = S[b], E = 0; E < x.pointCount; ++E)
          rt.s_impulse.normalImpulses[E] = x.points[E].normalImpulse, rt.s_impulse.tangentImpulses[E] = x.points[E].tangentImpulse;
        this.m_listener.PostSolve(W, rt.s_impulse);
      }
  }, rt.prototype.AddBody = function(S) {
    S.m_islandIndex = (this || window).m_bodyCount, this.m_bodies[this.m_bodyCount++] = S;
  }, rt.prototype.AddContact = function(S) {
    this.m_contacts[this.m_contactCount++] = S;
  }, rt.prototype.AddJoint = function(S) {
    this.m_joints[this.m_jointCount++] = S;
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.b2Island.s_impulse = new D();
  }), w.b2TimeStep = function() {
  }, w.prototype.Set = function(S) {
    this.dt = S.dt, this.inv_dt = S.inv_dt, this.positionIterations = S.positionIterations, this.velocityIterations = S.velocityIterations, this.warmStarting = S.warmStarting;
  }, L.b2World = function() {
    this.s_stack = new Vector(), this.m_contactManager = new z(), this.m_contactSolver = new O(), this.m_island = new rt();
  }, L.prototype.b2World = function(S, b) {
    this.m_destructionListener = null, this.m_debugDraw = null, this.m_bodyList = null, this.m_contactList = null, this.m_jointList = null, this.m_controllerList = null, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_controllerCount = 0, L.m_warmStarting = !0, L.m_continuousPhysics = !0, this.m_allowSleep = b, S.y = S.y, this.m_gravity = S, this.m_inv_dt0 = 0, this.m_contactManager.m_world = (this || window);
    var W = new y();
    this.m_groundBody = (this || window).CreateBody(W);
  }, L.prototype.SetDestructionListener = function(S) {
    this.m_destructionListener = S;
  }, L.prototype.SetContactFilter = function(S) {
    this.m_contactManager.m_contactFilter = S;
  }, L.prototype.SetContactListener = function(S) {
    this.m_contactManager.m_contactListener = S;
  }, L.prototype.SetDebugDraw = function(S) {
    this.m_debugDraw = S;
  }, L.prototype.SetBroadPhase = function(S) {
    var b = (this || window).m_contactManager.m_broadPhase;
    this.m_contactManager.m_broadPhase = S;
    for (var W = (this || window).m_bodyList; W; W = W.m_next)
      for (var x = W.m_fixtureList; x; x = x.m_next)
        x.m_proxy = S.CreateProxy(b.GetFatAABB(x.m_proxy), x);
  }, L.prototype.Validate = function() {
    this.m_contactManager.m_broadPhase.Validate();
  }, L.prototype.GetProxyCount = function() {
    return this.m_contactManager.m_broadPhase.GetProxyCount();
  }, L.prototype.CreateBody = function(S) {
    if (this.IsLocked() == !0)
      return null;
    var b = new g(S, this);
    return b.m_prev = null, b.m_next = (this || window).m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = b), this.m_bodyList = b, ++this.m_bodyCount, b;
  }, L.prototype.DestroyBody = function(S) {
    if (this.IsLocked() != !0) {
      for (var b = S.m_jointList; b; ) {
        var W = b;
        b = b.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(W.joint), this.DestroyJoint(W.joint);
      }
      for (var x = S.m_controllerList; x; ) {
        var E = x;
        x = x.nextController, E.controller.RemoveBody(S);
      }
      for (var R = S.m_contactList; R; ) {
        var F = R;
        R = R.next, this.m_contactManager.Destroy(F.contact);
      }
      S.m_contactList = null;
      for (var k = S.m_fixtureList; k; ) {
        var X = k;
        k = k.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(X), X.DestroyProxy(this.m_contactManager.m_broadPhase), X.Destroy();
      }
      S.m_fixtureList = null, S.m_fixtureCount = 0, S.m_prev && (S.m_prev.m_next = S.m_next), S.m_next && (S.m_next.m_prev = S.m_prev), S == (this || window).m_bodyList && (this.m_bodyList = S.m_next), --this.m_bodyCount;
    }
  }, L.prototype.CreateJoint = function(S) {
    var b = K.Create(S, null);
    b.m_prev = null, b.m_next = (this || window).m_jointList, this.m_jointList && (this.m_jointList.m_prev = b), this.m_jointList = b, ++this.m_jointCount, b.m_edgeA.joint = b, b.m_edgeA.other = b.m_bodyB, b.m_edgeA.prev = null, b.m_edgeA.next = b.m_bodyA.m_jointList, b.m_bodyA.m_jointList && (b.m_bodyA.m_jointList.prev = b.m_edgeA), b.m_bodyA.m_jointList = b.m_edgeA, b.m_edgeB.joint = b, b.m_edgeB.other = b.m_bodyA, b.m_edgeB.prev = null, b.m_edgeB.next = b.m_bodyB.m_jointList, b.m_bodyB.m_jointList && (b.m_bodyB.m_jointList.prev = b.m_edgeB), b.m_bodyB.m_jointList = b.m_edgeB;
    var W = S.bodyA, x = S.bodyB;
    if (S.collideConnected == !1)
      for (var E = x.GetContactList(); E; )
        E.other == W && E.contact.FlagForFiltering(), E = E.next;
    return b;
  }, L.prototype.DestroyJoint = function(S) {
    var b = S.m_collideConnected;
    S.m_prev && (S.m_prev.m_next = S.m_next), S.m_next && (S.m_next.m_prev = S.m_prev), S == (this || window).m_jointList && (this.m_jointList = S.m_next);
    var W = S.m_bodyA, x = S.m_bodyB;
    if (W.SetAwake(!0), x.SetAwake(!0), S.m_edgeA.prev && (S.m_edgeA.prev.next = S.m_edgeA.next), S.m_edgeA.next && (S.m_edgeA.next.prev = S.m_edgeA.prev), S.m_edgeA == W.m_jointList && (W.m_jointList = S.m_edgeA.next), S.m_edgeA.prev = null, S.m_edgeA.next = null, S.m_edgeB.prev && (S.m_edgeB.prev.next = S.m_edgeB.next), S.m_edgeB.next && (S.m_edgeB.next.prev = S.m_edgeB.prev), S.m_edgeB == x.m_jointList && (x.m_jointList = S.m_edgeB.next), S.m_edgeB.prev = null, S.m_edgeB.next = null, K.Destroy(S, null), --this.m_jointCount, b == !1)
      for (var E = x.GetContactList(); E; )
        E.other == W && E.contact.FlagForFiltering(), E = E.next;
  }, L.prototype.AddController = function(S) {
    return S.m_next = (this || window).m_controllerList, S.m_prev = null, this.m_controllerList = S, S.m_world = (this || window), this.m_controllerCount++, S;
  }, L.prototype.RemoveController = function(S) {
    S.m_prev && (S.m_prev.m_next = S.m_next), S.m_next && (S.m_next.m_prev = S.m_prev), this.m_controllerList == S && (this.m_controllerList = S.m_next), this.m_controllerCount--;
  }, L.prototype.CreateController = function(S) {
    if (S.m_world != (this || window))
      throw new Error("Controller can only be a member of one world");
    return S.m_next = (this || window).m_controllerList, S.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = S), this.m_controllerList = S, ++this.m_controllerCount, S.m_world = (this || window), S;
  }, L.prototype.DestroyController = function(S) {
    S.Clear(), S.m_next && (S.m_next.m_prev = S.m_prev), S.m_prev && (S.m_prev.m_next = S.m_next), S == (this || window).m_controllerList && (this.m_controllerList = S.m_next), --this.m_controllerCount;
  }, L.prototype.SetWarmStarting = function(S) {
    L.m_warmStarting = S;
  }, L.prototype.SetContinuousPhysics = function(S) {
    L.m_continuousPhysics = S;
  }, L.prototype.GetBodyCount = function() {
    return this.m_bodyCount;
  }, L.prototype.GetJointCount = function() {
    return this.m_jointCount;
  }, L.prototype.GetContactCount = function() {
    return this.m_contactCount;
  }, L.prototype.SetGravity = function(S) {
    this.m_gravity = S;
  }, L.prototype.GetGravity = function() {
    return this.m_gravity;
  }, L.prototype.GetGroundBody = function() {
    return this.m_groundBody;
  }, L.prototype.Step = function(S, b, W) {
    S === void 0 && (S = 0), b === void 0 && (b = 0), W === void 0 && (W = 0), this.m_flags & L.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~L.e_newFixture), this.m_flags |= L.e_locked;
    var x = L.s_timestep2;
    x.dt = S, x.velocityIterations = b, x.positionIterations = W, S > 0 ? x.inv_dt = 1 / S : x.inv_dt = 0, x.dtRatio = (this || window).m_inv_dt0 * S, x.warmStarting = L.m_warmStarting, this.m_contactManager.Collide(), x.dt > 0 && this.Solve(x), L.m_continuousPhysics && x.dt > 0 && this.SolveTOI(x), x.dt > 0 && (this.m_inv_dt0 = x.inv_dt), this.m_flags &= ~L.e_locked;
  }, L.prototype.ClearForces = function() {
    for (var S = (this || window).m_bodyList; S; S = S.m_next)
      S.m_force.SetZero(), S.m_torque = 0;
  }, L.prototype.DrawDebugData = function() {
    if (this.m_debugDraw != null) {
      this.m_debugDraw.m_sprite.graphics.clear();
      var S = (this || window).m_debugDraw.GetFlags(), b, W, x, E, R;
      new r(), new r(), new r();
      var F;
      new a(), new a();
      var k = [new r(), new r(), new r(), new r()], X = new s(0, 0, 0);
      if (S & M.e_shapeBit)
        for (b = (this || window).m_bodyList; b; b = b.m_next)
          for (F = b.m_xf, W = b.GetFixtureList(); W; W = W.m_next)
            x = W.GetShape(), b.IsActive() == !1 ? (X.Set(0.5, 0.5, 0.3), this.DrawShape(x, F, X)) : b.GetType() == g.b2_staticBody ? (X.Set(0.5, 0.9, 0.5), this.DrawShape(x, F, X)) : b.GetType() == g.b2_kinematicBody ? (X.Set(0.5, 0.5, 0.9), this.DrawShape(x, F, X)) : b.IsAwake() == !1 ? (X.Set(0.6, 0.6, 0.6), this.DrawShape(x, F, X)) : (X.Set(0.9, 0.7, 0.7), this.DrawShape(x, F, X));
      if (S & M.e_jointBit)
        for (E = (this || window).m_jointList; E; E = E.m_next)
          this.DrawJoint(E);
      if (S & M.e_controllerBit)
        for (var j = (this || window).m_controllerList; j; j = j.m_next)
          j.Draw(this.m_debugDraw);
      if (S & M.e_pairBit) {
        X.Set(0.3, 0.9, 0.9);
        for (var V = (this || window).m_contactManager.m_contactList; V; V = V.GetNext()) {
          var Y = V.GetFixtureA(), tt = V.GetFixtureB(), it = Y.GetAABB().GetCenter(), lt = tt.GetAABB().GetCenter();
          this.m_debugDraw.DrawSegment(it, lt, X);
        }
      }
      if (S & M.e_aabbBit) {
        for (R = (this || window).m_contactManager.m_broadPhase, k = [new r(), new r(), new r(), new r()], b = (this || window).m_bodyList; b; b = b.GetNext())
          if (b.IsActive() != !1)
            for (W = b.GetFixtureList(); W; W = W.GetNext()) {
              var ut = R.GetFatAABB(W.m_proxy);
              k[0].Set(ut.lowerBound.x, ut.lowerBound.y), k[1].Set(ut.upperBound.x, ut.lowerBound.y), k[2].Set(ut.upperBound.x, ut.upperBound.y), k[3].Set(ut.lowerBound.x, ut.upperBound.y), this.m_debugDraw.DrawPolygon(k, 4, X);
            }
      }
      if (S & M.e_centerOfMassBit)
        for (b = (this || window).m_bodyList; b; b = b.m_next)
          F = L.s_xf, F.R = b.m_xf.R, F.position = b.GetWorldCenter(), this.m_debugDraw.DrawTransform(F);
    }
  }, L.prototype.QueryAABB = function(S, b) {
    var W = (this || window), x = W.m_contactManager.m_broadPhase;
    function E(R) {
      return S(x.GetUserData(R));
    }
    H(E, "WorldQueryWrapper"), x.Query(E, b);
  }, L.prototype.QueryShape = function(S, b, W) {
    var x = (this || window);
    W === void 0 && (W = null), W == null && (W = new n(), W.SetIdentity());
    var E = x.m_contactManager.m_broadPhase;
    function R(k) {
      var X = E.GetUserData(k) instanceof Q ? E.GetUserData(k) : null;
      return m.TestOverlap(b, W, X.GetShape(), X.GetBody().GetTransform()) ? S(X) : !0;
    }
    H(R, "WorldQueryWrapper");
    var F = new a();
    b.ComputeAABB(F, W), E.Query(R, F);
  }, L.prototype.QueryPoint = function(S, b) {
    var W = (this || window), x = W.m_contactManager.m_broadPhase;
    function E(F) {
      var k = x.GetUserData(F) instanceof Q ? x.GetUserData(F) : null;
      return k.TestPoint(b) ? S(k) : !0;
    }
    H(E, "WorldQueryWrapper");
    var R = new a();
    R.lowerBound.Set(b.x - o.b2_linearSlop, b.y - o.b2_linearSlop), R.upperBound.Set(b.x + o.b2_linearSlop, b.y + o.b2_linearSlop), x.Query(E, R);
  }, L.prototype.RayCast = function(S, b, W) {
    var x = (this || window), E = x.m_contactManager.m_broadPhase, R = new u();
    function F(X, j) {
      var V = E.GetUserData(j), Y = V instanceof Q ? V : null, tt = Y.RayCast(R, X);
      if (tt) {
        var it = R.fraction, lt = new r((1 - it) * b.x + it * W.x, (1 - it) * b.y + it * W.y);
        return S(Y, lt, R.normal, it);
      }
      return X.maxFraction;
    }
    H(F, "RayCastWrapper");
    var k = new h(b, W);
    E.RayCast(F, k);
  }, L.prototype.RayCastOne = function(S, b) {
    var W = (this || window), x;
    function E(R, F, k, X) {
      return X === void 0 && (X = 0), x = R, X;
    }
    return H(E, "RayCastOneWrapper"), W.RayCast(E, S, b), x;
  }, L.prototype.RayCastAll = function(S, b) {
    var W = (this || window), x = new Vector();
    function E(R, F, k, X) {
      return x[x.length] = R, 1;
    }
    return H(E, "RayCastAllWrapper"), W.RayCast(E, S, b), x;
  }, L.prototype.GetBodyList = function() {
    return this.m_bodyList;
  }, L.prototype.GetJointList = function() {
    return this.m_jointList;
  }, L.prototype.GetContactList = function() {
    return this.m_contactList;
  }, L.prototype.IsLocked = function() {
    return (this.m_flags & L.e_locked) > 0;
  }, L.prototype.Solve = function(S) {
    for (var b, W = (this || window).m_controllerList; W; W = W.m_next)
      W.Step(S);
    var x = (this || window).m_island;
    for (x.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver), b = (this || window).m_bodyList; b; b = b.m_next)
      b.m_flags &= ~g.e_islandFlag;
    for (var E = (this || window).m_contactList; E; E = E.m_next)
      E.m_flags &= ~G.e_islandFlag;
    for (var R = (this || window).m_jointList; R; R = R.m_next)
      R.m_islandFlag = !1;
    parseInt(this.m_bodyCount);
    for (var F = (this || window).s_stack, k = (this || window).m_bodyList; k; k = k.m_next)
      if (!(k.m_flags & g.e_islandFlag) && !(k.IsAwake() == !1 || k.IsActive() == !1) && k.GetType() != g.b2_staticBody) {
        x.Clear();
        var X = 0;
        for (F[X++] = k, k.m_flags |= g.e_islandFlag; X > 0; )
          if (b = F[--X], x.AddBody(b), b.IsAwake() == !1 && b.SetAwake(!0), b.GetType() != g.b2_staticBody) {
            for (var j, V = b.m_contactList; V; V = V.next)
              V.contact.m_flags & G.e_islandFlag || V.contact.IsSensor() == !0 || V.contact.IsEnabled() == !1 || V.contact.IsTouching() == !1 || (x.AddContact(V.contact), V.contact.m_flags |= G.e_islandFlag, j = V.other, !(j.m_flags & g.e_islandFlag) && (F[X++] = j, j.m_flags |= g.e_islandFlag));
            for (var Y = b.m_jointList; Y; Y = Y.next)
              Y.joint.m_islandFlag != !0 && (j = Y.other, j.IsActive() != !1 && (x.AddJoint(Y.joint), Y.joint.m_islandFlag = !0, !(j.m_flags & g.e_islandFlag) && (F[X++] = j, j.m_flags |= g.e_islandFlag)));
          }
        x.Solve(S, this.m_gravity, this.m_allowSleep);
        for (var tt = 0; tt < x.m_bodyCount; ++tt)
          b = x.m_bodies[tt], b.GetType() == g.b2_staticBody && (b.m_flags &= ~g.e_islandFlag);
      }
    for (tt = 0; tt < F.length && F[tt]; ++tt)
      F[tt] = null;
    for (b = (this || window).m_bodyList; b; b = b.m_next)
      b.IsAwake() == !1 || b.IsActive() == !1 || b.GetType() != g.b2_staticBody && b.SynchronizeFixtures();
    this.m_contactManager.FindNewContacts();
  }, L.prototype.SolveTOI = function(S) {
    var b, W, x, E, R, F, k, X = (this || window).m_island;
    X.Initialize(this.m_bodyCount, o.b2_maxTOIContactsPerIsland, o.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
    var j = L.s_queue;
    for (b = (this || window).m_bodyList; b; b = b.m_next)
      b.m_flags &= ~g.e_islandFlag, b.m_sweep.t0 = 0;
    var V;
    for (V = (this || window).m_contactList; V; V = V.m_next)
      V.m_flags &= ~(G.e_toiFlag | G.e_islandFlag);
    for (k = (this || window).m_jointList; k; k = k.m_next)
      k.m_islandFlag = !1;
    for (; ; ) {
      var Y = null, tt = 1;
      for (V = (this || window).m_contactList; V; V = V.m_next)
        if (!(V.IsSensor() == !0 || V.IsEnabled() == !1 || V.IsContinuous() == !1)) {
          var it = 1;
          if (V.m_flags & G.e_toiFlag)
            it = V.m_toi;
          else {
            if (W = V.m_fixtureA, x = V.m_fixtureB, E = W.m_body, R = x.m_body, (E.GetType() != g.b2_dynamicBody || E.IsAwake() == !1) && (R.GetType() != g.b2_dynamicBody || R.IsAwake() == !1))
              continue;
            var lt = E.m_sweep.t0;
            E.m_sweep.t0 < R.m_sweep.t0 ? (lt = R.m_sweep.t0, E.m_sweep.Advance(lt)) : R.m_sweep.t0 < E.m_sweep.t0 && (lt = E.m_sweep.t0, R.m_sweep.Advance(lt)), it = V.ComputeTOI(E.m_sweep, R.m_sweep), o.b2Assert(0 <= it && it <= 1), it > 0 && it < 1 && (it = (1 - it) * lt + it, it > 1 && (it = 1)), V.m_toi = it, V.m_flags |= G.e_toiFlag;
          }
          Number.MIN_VALUE < it && it < tt && (Y = V, tt = it);
        }
      if (Y == null || 1 - 100 * Number.MIN_VALUE < tt)
        break;
      if (W = Y.m_fixtureA, x = Y.m_fixtureB, E = W.m_body, R = x.m_body, L.s_backupA.Set(E.m_sweep), L.s_backupB.Set(R.m_sweep), E.Advance(tt), R.Advance(tt), Y.Update(this.m_contactManager.m_contactListener), Y.m_flags &= ~G.e_toiFlag, Y.IsSensor() == !0 || Y.IsEnabled() == !1) {
        E.m_sweep.Set(L.s_backupA), R.m_sweep.Set(L.s_backupB), E.SynchronizeTransform(), R.SynchronizeTransform();
        continue;
      }
      if (Y.IsTouching() != !1) {
        var ut = E;
        ut.GetType() != g.b2_dynamicBody && (ut = R), X.Clear();
        var ft = 0, vt = 0;
        for (j[ft + vt++] = ut, ut.m_flags |= g.e_islandFlag; vt > 0; )
          if (b = j[ft++], --vt, X.AddBody(b), b.IsAwake() == !1 && b.SetAwake(!0), b.GetType() == g.b2_dynamicBody) {
            for (F = b.m_contactList; F && X.m_contactCount != X.m_contactCapacity; F = F.next)
              if (!(F.contact.m_flags & G.e_islandFlag) && !(F.contact.IsSensor() == !0 || F.contact.IsEnabled() == !1 || F.contact.IsTouching() == !1)) {
                X.AddContact(F.contact), F.contact.m_flags |= G.e_islandFlag;
                var pt = F.other;
                pt.m_flags & g.e_islandFlag || (pt.GetType() != g.b2_staticBody && (pt.Advance(tt), pt.SetAwake(!0)), j[ft + vt] = pt, ++vt, pt.m_flags |= g.e_islandFlag);
              }
            for (var gt = b.m_jointList; gt; gt = gt.next)
              X.m_jointCount != X.m_jointCapacity && gt.joint.m_islandFlag != !0 && (pt = gt.other, pt.IsActive() != !1 && (X.AddJoint(gt.joint), gt.joint.m_islandFlag = !0, !(pt.m_flags & g.e_islandFlag) && (pt.GetType() != g.b2_staticBody && (pt.Advance(tt), pt.SetAwake(!0)), j[ft + vt] = pt, ++vt, pt.m_flags |= g.e_islandFlag)));
          }
        var St = L.s_timestep;
        St.warmStarting = !1, St.dt = (1 - tt) * S.dt, St.inv_dt = 1 / St.dt, St.dtRatio = 0, St.velocityIterations = S.velocityIterations, St.positionIterations = S.positionIterations, X.SolveTOI(St);
        var ht = 0;
        for (ht = 0; ht < X.m_bodyCount; ++ht)
          if (b = X.m_bodies[ht], b.m_flags &= ~g.e_islandFlag, b.IsAwake() != !1 && b.GetType() == g.b2_dynamicBody)
            for (b.SynchronizeFixtures(), F = b.m_contactList; F; F = F.next)
              F.contact.m_flags &= ~G.e_toiFlag;
        for (ht = 0; ht < X.m_contactCount; ++ht)
          V = X.m_contacts[ht], V.m_flags &= ~(G.e_toiFlag | G.e_islandFlag);
        for (ht = 0; ht < X.m_jointCount; ++ht)
          k = X.m_joints[ht], k.m_islandFlag = !1;
        this.m_contactManager.FindNewContacts();
      }
    }
  }, L.prototype.DrawJoint = function(S) {
    var b = S.GetBodyA(), W = S.GetBodyB(), x = b.m_xf, E = W.m_xf, R = x.position, F = E.position, k = S.GetAnchorA(), X = S.GetAnchorB(), j = L.s_jointColor;
    switch (S.m_type) {
      case K.e_distanceJoint:
        this.m_debugDraw.DrawSegment(k, X, j);
        break;
      case K.e_pulleyJoint:
        {
          var V = S instanceof $ ? S : null, Y = V.GetGroundAnchorA(), tt = V.GetGroundAnchorB();
          this.m_debugDraw.DrawSegment(Y, k, j), this.m_debugDraw.DrawSegment(tt, X, j), this.m_debugDraw.DrawSegment(Y, tt, j);
        }
        break;
      case K.e_mouseJoint:
        this.m_debugDraw.DrawSegment(k, X, j);
        break;
      default:
        b != (this || window).m_groundBody && this.m_debugDraw.DrawSegment(R, k, j), this.m_debugDraw.DrawSegment(k, X, j), W != (this || window).m_groundBody && this.m_debugDraw.DrawSegment(F, X, j);
    }
  }, L.prototype.DrawShape = function(S, b, W) {
    switch (S.m_type) {
      case m.e_circleShape:
        {
          var x = S instanceof _ ? S : null, E = t.MulX(b, x.m_p), R = x.m_radius, F = b.R.col1;
          this.m_debugDraw.DrawSolidCircle(E, R, F, W);
        }
        break;
      case m.e_polygonShape:
        {
          var k = 0, X = S instanceof C ? S : null, j = parseInt(X.GetVertexCount()), V = X.GetVertices(), Y = new Vector(j);
          for (k = 0; k < j; ++k)
            Y[k] = t.MulX(b, V[k]);
          this.m_debugDraw.DrawSolidPolygon(Y, j, W);
        }
        break;
      case m.e_edgeShape:
        {
          var tt = S instanceof d ? S : null;
          this.m_debugDraw.DrawSegment(t.MulX(b, tt.GetVertex1()), t.MulX(b, tt.GetVertex2()), W);
        }
        break;
    }
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.b2World.s_timestep2 = new w(), Box2D.Dynamics.b2World.s_xf = new n(), Box2D.Dynamics.b2World.s_backupA = new e(), Box2D.Dynamics.b2World.s_backupB = new e(), Box2D.Dynamics.b2World.s_timestep = new w(), Box2D.Dynamics.b2World.s_queue = new Vector(), Box2D.Dynamics.b2World.s_jointColor = new s(0.5, 0.8, 0.8), Box2D.Dynamics.b2World.e_newFixture = 1, Box2D.Dynamics.b2World.e_locked = 2;
  });
})();
(function() {
  var t = Box2D.Collision.Shapes.b2CircleShape;
  Box2D.Collision.Shapes.b2EdgeChainDef;
  var e = Box2D.Collision.Shapes.b2EdgeShape;
  Box2D.Collision.Shapes.b2MassData;
  var n = Box2D.Collision.Shapes.b2PolygonShape, r = Box2D.Collision.Shapes.b2Shape, s = Box2D.Dynamics.Contacts.b2CircleContact, o = Box2D.Dynamics.Contacts.b2Contact, a = Box2D.Dynamics.Contacts.b2ContactConstraint, c = Box2D.Dynamics.Contacts.b2ContactConstraintPoint, l = Box2D.Dynamics.Contacts.b2ContactEdge, h = Box2D.Dynamics.Contacts.b2ContactFactory, u = Box2D.Dynamics.Contacts.b2ContactRegister, _ = Box2D.Dynamics.Contacts.b2ContactResult, d = Box2D.Dynamics.Contacts.b2ContactSolver, f = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact, C = Box2D.Dynamics.Contacts.b2NullContact, m = Box2D.Dynamics.Contacts.b2PolyAndCircleContact, g = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact, y = Box2D.Dynamics.Contacts.b2PolygonContact, A = Box2D.Dynamics.Contacts.b2PositionSolverManifold, D = Box2D.Dynamics.b2Body;
  Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island;
  var N = Box2D.Dynamics.b2TimeStep;
  Box2D.Dynamics.b2World, Box2D.Common.b2Color, Box2D.Common.b2internal;
  var z = Box2D.Common.b2Settings, M = Box2D.Common.Math.b2Mat22;
  Box2D.Common.Math.b2Mat33;
  var Z = Box2D.Common.Math.b2Math;
  Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform;
  var U = Box2D.Common.Math.b2Vec2;
  Box2D.Common.Math.b2Vec3, Box2D.Collision.b2AABB, Box2D.Collision.b2Bound, Box2D.Collision.b2BoundValues;
  var Q = Box2D.Collision.b2Collision, et = Box2D.Collision.b2ContactID;
  Box2D.Collision.b2ContactPoint, Box2D.Collision.b2Distance, Box2D.Collision.b2DistanceInput, Box2D.Collision.b2DistanceOutput, Box2D.Collision.b2DistanceProxy, Box2D.Collision.b2DynamicTree, Box2D.Collision.b2DynamicTreeBroadPhase, Box2D.Collision.b2DynamicTreeNode, Box2D.Collision.b2DynamicTreePair;
  var rt = Box2D.Collision.b2Manifold;
  Box2D.Collision.b2ManifoldPoint, Box2D.Collision.b2Point, Box2D.Collision.b2RayCastInput, Box2D.Collision.b2RayCastOutput, Box2D.Collision.b2Segment, Box2D.Collision.b2SeparationFunction, Box2D.Collision.b2Simplex, Box2D.Collision.b2SimplexCache, Box2D.Collision.b2SimplexVertex;
  var w = Box2D.Collision.b2TimeOfImpact, L = Box2D.Collision.b2TOIInput, G = Box2D.Collision.b2WorldManifold;
  Box2D.Collision.ClipVertex, Box2D.Collision.Features, Box2D.Collision.IBroadPhase, Box2D.inherit(s, Box2D.Dynamics.Contacts.b2Contact), s.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, s.b2CircleContact = function() {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  }, s.Create = function(I) {
    return new s();
  }, s.Destroy = function(I, O) {
  }, s.prototype.Reset = function(I, O) {
    this.__super.Reset.call(this, I, O);
  }, s.prototype.Evaluate = function() {
    var I = (this || window).m_fixtureA.GetBody(), O = (this || window).m_fixtureB.GetBody();
    Q.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof t ? this.m_fixtureA.GetShape() : null, I.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, O.m_xf);
  }, o.b2Contact = function() {
    this.m_nodeA = new l(), this.m_nodeB = new l(), this.m_manifold = new rt(), this.m_oldManifold = new rt();
  }, o.prototype.GetManifold = function() {
    return this.m_manifold;
  }, o.prototype.GetWorldManifold = function(I) {
    var O = (this || window).m_fixtureA.GetBody(), K = (this || window).m_fixtureB.GetBody(), $ = (this || window).m_fixtureA.GetShape(), S = (this || window).m_fixtureB.GetShape();
    I.Initialize(this.m_manifold, O.GetTransform(), $.m_radius, K.GetTransform(), S.m_radius);
  }, o.prototype.IsTouching = function() {
    return (this.m_flags & o.e_touchingFlag) == o.e_touchingFlag;
  }, o.prototype.IsContinuous = function() {
    return (this.m_flags & o.e_continuousFlag) == o.e_continuousFlag;
  }, o.prototype.SetSensor = function(I) {
    I ? this.m_flags |= o.e_sensorFlag : this.m_flags &= ~o.e_sensorFlag;
  }, o.prototype.IsSensor = function() {
    return (this.m_flags & o.e_sensorFlag) == o.e_sensorFlag;
  }, o.prototype.SetEnabled = function(I) {
    I ? this.m_flags |= o.e_enabledFlag : this.m_flags &= ~o.e_enabledFlag;
  }, o.prototype.IsEnabled = function() {
    return (this.m_flags & o.e_enabledFlag) == o.e_enabledFlag;
  }, o.prototype.GetNext = function() {
    return this.m_next;
  }, o.prototype.GetFixtureA = function() {
    return this.m_fixtureA;
  }, o.prototype.GetFixtureB = function() {
    return this.m_fixtureB;
  }, o.prototype.FlagForFiltering = function() {
    this.m_flags |= o.e_filterFlag;
  }, o.prototype.b2Contact = function() {
  }, o.prototype.Reset = function(I, O) {
    if (I === void 0 && (I = null), O === void 0 && (O = null), this.m_flags = o.e_enabledFlag, !I || !O) {
      this.m_fixtureA = null, this.m_fixtureB = null;
      return;
    }
    (I.IsSensor() || O.IsSensor()) && (this.m_flags |= o.e_sensorFlag);
    var K = I.GetBody(), $ = O.GetBody();
    (K.GetType() != D.b2_dynamicBody || K.IsBullet() || $.GetType() != D.b2_dynamicBody || $.IsBullet()) && (this.m_flags |= o.e_continuousFlag), this.m_fixtureA = I, this.m_fixtureB = O, this.m_manifold.m_pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null;
  }, o.prototype.Update = function(I) {
    var O = (this || window).m_oldManifold;
    this.m_oldManifold = (this || window).m_manifold, this.m_manifold = O, this.m_flags |= o.e_enabledFlag;
    var K = !1, $ = (this.m_flags & o.e_touchingFlag) == o.e_touchingFlag, S = (this || window).m_fixtureA.m_body, b = (this || window).m_fixtureB.m_body, W = (this || window).m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
    if (this.m_flags & o.e_sensorFlag) {
      if (W) {
        var x = (this || window).m_fixtureA.GetShape(), E = (this || window).m_fixtureB.GetShape(), R = S.GetTransform(), F = b.GetTransform();
        K = r.TestOverlap(x, R, E, F);
      }
      this.m_manifold.m_pointCount = 0;
    } else {
      if (S.GetType() != D.b2_dynamicBody || S.IsBullet() || b.GetType() != D.b2_dynamicBody || b.IsBullet() ? this.m_flags |= o.e_continuousFlag : this.m_flags &= ~o.e_continuousFlag, W) {
        this.Evaluate(), K = (this || window).m_manifold.m_pointCount > 0;
        for (var k = 0; k < this.m_manifold.m_pointCount; ++k) {
          var X = (this || window).m_manifold.m_points[k];
          X.m_normalImpulse = 0, X.m_tangentImpulse = 0;
          for (var j = X.m_id, V = 0; V < this.m_oldManifold.m_pointCount; ++V) {
            var Y = (this || window).m_oldManifold.m_points[V];
            if (Y.m_id.key == j.key) {
              X.m_normalImpulse = Y.m_normalImpulse, X.m_tangentImpulse = Y.m_tangentImpulse;
              break;
            }
          }
        }
      } else
        this.m_manifold.m_pointCount = 0;
      K != $ && (S.SetAwake(!0), b.SetAwake(!0));
    }
    K ? this.m_flags |= o.e_touchingFlag : this.m_flags &= ~o.e_touchingFlag, $ == !1 && K == !0 && I.BeginContact(this), $ == !0 && K == !1 && I.EndContact(this), this.m_flags & o.e_sensorFlag || I.PreSolve(this, this.m_oldManifold);
  }, o.prototype.Evaluate = function() {
  }, o.prototype.ComputeTOI = function(I, O) {
    return o.s_input.proxyA.Set(this.m_fixtureA.GetShape()), o.s_input.proxyB.Set(this.m_fixtureB.GetShape()), o.s_input.sweepA = I, o.s_input.sweepB = O, o.s_input.tolerance = z.b2_linearSlop, w.TimeOfImpact(o.s_input);
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 1, Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 2, Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 4, Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 8, Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 16, Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 32, Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 64, Box2D.Dynamics.Contacts.b2Contact.s_input = new L();
  }), a.b2ContactConstraint = function() {
    this.localPlaneNormal = new U(), this.localPoint = new U(), this.normal = new U(), this.normalMass = new M(), this.K = new M();
  }, a.prototype.b2ContactConstraint = function() {
    this.points = new Vector(z.b2_maxManifoldPoints);
    for (var I = 0; I < z.b2_maxManifoldPoints; I++)
      this.points[I] = new c();
  }, c.b2ContactConstraintPoint = function() {
    this.localPoint = new U(), this.rA = new U(), this.rB = new U();
  }, l.b2ContactEdge = function() {
  }, h.b2ContactFactory = function() {
  }, h.prototype.b2ContactFactory = function(I) {
    this.m_allocator = I, this.InitializeRegisters();
  }, h.prototype.AddType = function(I, O, K, $) {
    K === void 0 && (K = 0), $ === void 0 && ($ = 0), this.m_registers[K][$].createFcn = I, this.m_registers[K][$].destroyFcn = O, this.m_registers[K][$].primary = !0, K != $ && (this.m_registers[$][K].createFcn = I, this.m_registers[$][K].destroyFcn = O, this.m_registers[$][K].primary = !1);
  }, h.prototype.InitializeRegisters = function() {
    this.m_registers = new Vector(r.e_shapeTypeCount);
    for (var I = 0; I < r.e_shapeTypeCount; I++) {
      this.m_registers[I] = new Vector(r.e_shapeTypeCount);
      for (var O = 0; O < r.e_shapeTypeCount; O++)
        this.m_registers[I][O] = new u();
    }
    this.AddType(s.Create, s.Destroy, r.e_circleShape, r.e_circleShape), this.AddType(m.Create, m.Destroy, r.e_polygonShape, r.e_circleShape), this.AddType(y.Create, y.Destroy, r.e_polygonShape, r.e_polygonShape), this.AddType(f.Create, f.Destroy, r.e_edgeShape, r.e_circleShape), this.AddType(g.Create, g.Destroy, r.e_polygonShape, r.e_edgeShape);
  }, h.prototype.Create = function(I, O) {
    var K = parseInt(I.GetType()), $ = parseInt(O.GetType()), S = (this || window).m_registers[K][$], b;
    if (S.pool)
      return b = S.pool, S.pool = b.m_next, S.poolCount--, b.Reset(I, O), b;
    var W = S.createFcn;
    return W != null ? S.primary ? (b = W(this.m_allocator), b.Reset(I, O), b) : (b = W(this.m_allocator), b.Reset(O, I), b) : null;
  }, h.prototype.Destroy = function(I) {
    I.m_manifold.m_pointCount > 0 && (I.m_fixtureA.m_body.SetAwake(!0), I.m_fixtureB.m_body.SetAwake(!0));
    var O = parseInt(I.m_fixtureA.GetType()), K = parseInt(I.m_fixtureB.GetType()), $ = (this || window).m_registers[O][K];
    $.poolCount++, I.m_next = $.pool, $.pool = I;
    var S = $.destroyFcn;
    S(I, this.m_allocator);
  }, u.b2ContactRegister = function() {
  }, _.b2ContactResult = function() {
    this.position = new U(), this.normal = new U(), this.id = new et();
  }, d.b2ContactSolver = function() {
    this.m_step = new N(), this.m_constraints = new Vector();
  }, d.prototype.b2ContactSolver = function() {
  }, d.prototype.Initialize = function(I, O, K, $) {
    K === void 0 && (K = 0);
    var S;
    this.m_step.Set(I), this.m_allocator = $;
    var b = 0;
    for (this.m_constraintCount = K; this.m_constraints.length < this.m_constraintCount; )
      this.m_constraints[this.m_constraints.length] = new a();
    for (b = 0; b < K; ++b) {
      S = O[b];
      var W = S.m_fixtureA, x = S.m_fixtureB, E = W.m_shape, R = x.m_shape, F = E.m_radius, k = R.m_radius, X = W.m_body, j = x.m_body, V = S.GetManifold(), Y = z.b2MixFriction(W.GetFriction(), x.GetFriction()), tt = z.b2MixRestitution(W.GetRestitution(), x.GetRestitution()), it = X.m_linearVelocity.x, lt = X.m_linearVelocity.y, ut = j.m_linearVelocity.x, ft = j.m_linearVelocity.y, vt = X.m_angularVelocity, pt = j.m_angularVelocity;
      z.b2Assert(V.m_pointCount > 0), d.s_worldManifold.Initialize(V, X.m_xf, F, j.m_xf, k);
      var gt = d.s_worldManifold.m_normal.x, St = d.s_worldManifold.m_normal.y, ht = (this || window).m_constraints[b];
      ht.bodyA = X, ht.bodyB = j, ht.manifold = V, ht.normal.x = gt, ht.normal.y = St, ht.pointCount = V.m_pointCount, ht.friction = Y, ht.restitution = tt, ht.localPlaneNormal.x = V.m_localPlaneNormal.x, ht.localPlaneNormal.y = V.m_localPlaneNormal.y, ht.localPoint.x = V.m_localPoint.x, ht.localPoint.y = V.m_localPoint.y, ht.radius = F + k, ht.type = V.m_type;
      for (var ct = 0; ct < ht.pointCount; ++ct) {
        var bt = V.m_points[ct], Et = ht.points[ct];
        Et.normalImpulse = bt.m_normalImpulse, Et.tangentImpulse = bt.m_tangentImpulse, Et.localPoint.SetV(bt.m_localPoint);
        var wt = Et.rA.x = d.s_worldManifold.m_points[ct].x - X.m_sweep.c.x, It = Et.rA.y = d.s_worldManifold.m_points[ct].y - X.m_sweep.c.y, Dt = Et.rB.x = d.s_worldManifold.m_points[ct].x - j.m_sweep.c.x, Ut = Et.rB.y = d.s_worldManifold.m_points[ct].y - j.m_sweep.c.y, Gt = wt * St - It * gt, at = Dt * St - Ut * gt;
        Gt *= Gt, at *= at;
        var ot = X.m_invMass + j.m_invMass + X.m_invI * Gt + j.m_invI * at;
        Et.normalMass = 1 / ot;
        var _t = X.m_mass * X.m_invMass + j.m_mass * j.m_invMass;
        _t += X.m_mass * X.m_invI * Gt + j.m_mass * j.m_invI * at, Et.equalizedMass = 1 / _t;
        var mt = St, Ct = -gt, yt = wt * Ct - It * mt, At = Dt * Ct - Ut * mt;
        yt *= yt, At *= At;
        var Pt = X.m_invMass + j.m_invMass + X.m_invI * yt + j.m_invI * At;
        Et.tangentMass = 1 / Pt, Et.velocityBias = 0;
        var kt = ut + -pt * Ut - it - -vt * It, Ot = ft + pt * Dt - lt - vt * wt, Xt = ht.normal.x * kt + ht.normal.y * Ot;
        Xt < -z.b2_velocityThreshold && (Et.velocityBias += -ht.restitution * Xt);
      }
      if (ht.pointCount == 2) {
        var Vt = ht.points[0], Lt = ht.points[1], Nt = X.m_invMass, Jt = X.m_invI, Ht = j.m_invMass, Kt = j.m_invI, ee = Vt.rA.x * St - Vt.rA.y * gt, Zt = Vt.rB.x * St - Vt.rB.y * gt, $t = Lt.rA.x * St - Lt.rA.y * gt, ie = Lt.rB.x * St - Lt.rB.y * gt, Ft = Nt + Ht + Jt * ee * ee + Kt * Zt * Zt, zt = Nt + Ht + Jt * $t * $t + Kt * ie * ie, Qt = Nt + Ht + Jt * ee * $t + Kt * Zt * ie, le = 100;
        Ft * Ft < le * (Ft * zt - Qt * Qt) ? (ht.K.col1.Set(Ft, Qt), ht.K.col2.Set(Qt, zt), ht.K.GetInverse(ht.normalMass)) : ht.pointCount = 1;
      }
    }
  }, d.prototype.InitVelocityConstraints = function(I) {
    for (var O = 0; O < this.m_constraintCount; ++O) {
      var K = (this || window).m_constraints[O], $ = K.bodyA, S = K.bodyB, b = $.m_invMass, W = $.m_invI, x = S.m_invMass, E = S.m_invI, R = K.normal.x, F = K.normal.y, k = F, X = -R, j = 0, V = 0;
      if (I.warmStarting)
        for (V = K.pointCount, j = 0; j < V; ++j) {
          var Y = K.points[j];
          Y.normalImpulse *= I.dtRatio, Y.tangentImpulse *= I.dtRatio;
          var tt = Y.normalImpulse * R + Y.tangentImpulse * k, it = Y.normalImpulse * F + Y.tangentImpulse * X;
          $.m_angularVelocity -= W * (Y.rA.x * it - Y.rA.y * tt), $.m_linearVelocity.x -= b * tt, $.m_linearVelocity.y -= b * it, S.m_angularVelocity += E * (Y.rB.x * it - Y.rB.y * tt), S.m_linearVelocity.x += x * tt, S.m_linearVelocity.y += x * it;
        }
      else
        for (V = K.pointCount, j = 0; j < V; ++j) {
          var lt = K.points[j];
          lt.normalImpulse = 0, lt.tangentImpulse = 0;
        }
    }
  }, d.prototype.SolveVelocityConstraints = function() {
    for (var I = 0, O, K = 0, $ = 0, S = 0, b = 0, W = 0, x = 0, E = 0, R = 0, F = 0, k = 0, X = 0, j = 0, V = 0, Y = 0, tt = 0, it, lt = 0; lt < this.m_constraintCount; ++lt) {
      var ut = (this || window).m_constraints[lt], ft = ut.bodyA, vt = ut.bodyB, pt = ft.m_angularVelocity, gt = vt.m_angularVelocity, St = ft.m_linearVelocity, ht = vt.m_linearVelocity, ct = ft.m_invMass, bt = ft.m_invI, Et = vt.m_invMass, wt = vt.m_invI, It = ut.normal.x, Dt = ut.normal.y, Ut = Dt, Gt = -It, at = ut.friction;
      for (I = 0; I < ut.pointCount; I++)
        O = ut.points[I], K = ht.x - gt * O.rB.y - St.x + pt * O.rA.y, $ = ht.y + gt * O.rB.x - St.y - pt * O.rA.x, b = K * Ut + $ * Gt, W = O.tangentMass * -b, x = at * O.normalImpulse, E = Z.Clamp(O.tangentImpulse + W, -x, x), W = E - O.tangentImpulse, R = W * Ut, F = W * Gt, St.x -= ct * R, St.y -= ct * F, pt -= bt * (O.rA.x * F - O.rA.y * R), ht.x += Et * R, ht.y += Et * F, gt += wt * (O.rB.x * F - O.rB.y * R), O.tangentImpulse = E;
      if (parseInt(ut.pointCount), ut.pointCount == 1)
        O = ut.points[0], K = ht.x + -gt * O.rB.y - St.x - -pt * O.rA.y, $ = ht.y + gt * O.rB.x - St.y - pt * O.rA.x, S = K * It + $ * Dt, W = -O.normalMass * (S - O.velocityBias), E = O.normalImpulse + W, E = E > 0 ? E : 0, W = E - O.normalImpulse, R = W * It, F = W * Dt, St.x -= ct * R, St.y -= ct * F, pt -= bt * (O.rA.x * F - O.rA.y * R), ht.x += Et * R, ht.y += Et * F, gt += wt * (O.rB.x * F - O.rB.y * R), O.normalImpulse = E;
      else {
        var ot = ut.points[0], _t = ut.points[1], mt = ot.normalImpulse, Ct = _t.normalImpulse, yt = ht.x - gt * ot.rB.y - St.x + pt * ot.rA.y, At = ht.y + gt * ot.rB.x - St.y - pt * ot.rA.x, Pt = ht.x - gt * _t.rB.y - St.x + pt * _t.rA.y, kt = ht.y + gt * _t.rB.x - St.y - pt * _t.rA.x, Ot = yt * It + At * Dt, Xt = Pt * It + kt * Dt, Vt = Ot - ot.velocityBias, Lt = Xt - _t.velocityBias;
        for (it = ut.K, Vt -= it.col1.x * mt + it.col2.x * Ct, Lt -= it.col1.y * mt + it.col2.y * Ct; ; ) {
          it = ut.normalMass;
          var Nt = -(it.col1.x * Vt + it.col2.x * Lt), Jt = -(it.col1.y * Vt + it.col2.y * Lt);
          if (Nt >= 0 && Jt >= 0) {
            k = Nt - mt, X = Jt - Ct, j = k * It, V = k * Dt, Y = X * It, tt = X * Dt, St.x -= ct * (j + Y), St.y -= ct * (V + tt), pt -= bt * (ot.rA.x * V - ot.rA.y * j + _t.rA.x * tt - _t.rA.y * Y), ht.x += Et * (j + Y), ht.y += Et * (V + tt), gt += wt * (ot.rB.x * V - ot.rB.y * j + _t.rB.x * tt - _t.rB.y * Y), ot.normalImpulse = Nt, _t.normalImpulse = Jt;
            break;
          }
          if (Nt = -ot.normalMass * Vt, Jt = 0, Ot = 0, Xt = ut.K.col1.y * Nt + Lt, Nt >= 0 && Xt >= 0) {
            k = Nt - mt, X = Jt - Ct, j = k * It, V = k * Dt, Y = X * It, tt = X * Dt, St.x -= ct * (j + Y), St.y -= ct * (V + tt), pt -= bt * (ot.rA.x * V - ot.rA.y * j + _t.rA.x * tt - _t.rA.y * Y), ht.x += Et * (j + Y), ht.y += Et * (V + tt), gt += wt * (ot.rB.x * V - ot.rB.y * j + _t.rB.x * tt - _t.rB.y * Y), ot.normalImpulse = Nt, _t.normalImpulse = Jt;
            break;
          }
          if (Nt = 0, Jt = -_t.normalMass * Lt, Ot = ut.K.col2.x * Jt + Vt, Xt = 0, Jt >= 0 && Ot >= 0) {
            k = Nt - mt, X = Jt - Ct, j = k * It, V = k * Dt, Y = X * It, tt = X * Dt, St.x -= ct * (j + Y), St.y -= ct * (V + tt), pt -= bt * (ot.rA.x * V - ot.rA.y * j + _t.rA.x * tt - _t.rA.y * Y), ht.x += Et * (j + Y), ht.y += Et * (V + tt), gt += wt * (ot.rB.x * V - ot.rB.y * j + _t.rB.x * tt - _t.rB.y * Y), ot.normalImpulse = Nt, _t.normalImpulse = Jt;
            break;
          }
          if (Nt = 0, Jt = 0, Ot = Vt, Xt = Lt, Ot >= 0 && Xt >= 0) {
            k = Nt - mt, X = Jt - Ct, j = k * It, V = k * Dt, Y = X * It, tt = X * Dt, St.x -= ct * (j + Y), St.y -= ct * (V + tt), pt -= bt * (ot.rA.x * V - ot.rA.y * j + _t.rA.x * tt - _t.rA.y * Y), ht.x += Et * (j + Y), ht.y += Et * (V + tt), gt += wt * (ot.rB.x * V - ot.rB.y * j + _t.rB.x * tt - _t.rB.y * Y), ot.normalImpulse = Nt, _t.normalImpulse = Jt;
            break;
          }
          break;
        }
      }
      ft.m_angularVelocity = pt, vt.m_angularVelocity = gt;
    }
  }, d.prototype.FinalizeVelocityConstraints = function() {
    for (var I = 0; I < this.m_constraintCount; ++I)
      for (var O = (this || window).m_constraints[I], K = O.manifold, $ = 0; $ < O.pointCount; ++$) {
        var S = K.m_points[$], b = O.points[$];
        S.m_normalImpulse = b.normalImpulse, S.m_tangentImpulse = b.tangentImpulse;
      }
  }, d.prototype.SolvePositionConstraints = function(I) {
    I === void 0 && (I = 0);
    for (var O = 0, K = 0; K < this.m_constraintCount; K++) {
      var $ = (this || window).m_constraints[K], S = $.bodyA, b = $.bodyB, W = S.m_mass * S.m_invMass, x = S.m_mass * S.m_invI, E = b.m_mass * b.m_invMass, R = b.m_mass * b.m_invI;
      d.s_psm.Initialize($);
      for (var F = d.s_psm.m_normal, k = 0; k < $.pointCount; k++) {
        var X = $.points[k], j = d.s_psm.m_points[k], V = d.s_psm.m_separations[k], Y = j.x - S.m_sweep.c.x, tt = j.y - S.m_sweep.c.y, it = j.x - b.m_sweep.c.x, lt = j.y - b.m_sweep.c.y;
        O = O < V ? O : V;
        var ut = Z.Clamp(I * (V + z.b2_linearSlop), -z.b2_maxLinearCorrection, 0), ft = -X.equalizedMass * ut, vt = ft * F.x, pt = ft * F.y;
        S.m_sweep.c.x -= W * vt, S.m_sweep.c.y -= W * pt, S.m_sweep.a -= x * (Y * pt - tt * vt), S.SynchronizeTransform(), b.m_sweep.c.x += E * vt, b.m_sweep.c.y += E * pt, b.m_sweep.a += R * (it * pt - lt * vt), b.SynchronizeTransform();
      }
    }
    return O > -1.5 * z.b2_linearSlop;
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new G(), Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new A();
  }), Box2D.inherit(f, Box2D.Dynamics.Contacts.b2Contact), f.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, f.b2EdgeAndCircleContact = function() {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  }, f.Create = function(I) {
    return new f();
  }, f.Destroy = function(I, O) {
  }, f.prototype.Reset = function(I, O) {
    this.__super.Reset.call(this, I, O);
  }, f.prototype.Evaluate = function() {
    var I = (this || window).m_fixtureA.GetBody(), O = (this || window).m_fixtureB.GetBody();
    this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof e ? this.m_fixtureA.GetShape() : null, I.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, O.m_xf);
  }, f.prototype.b2CollideEdgeAndCircle = function(I, O, K, $, S) {
  }, Box2D.inherit(C, Box2D.Dynamics.Contacts.b2Contact), C.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, C.b2NullContact = function() {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  }, C.prototype.b2NullContact = function() {
    this.__super.b2Contact.call(this);
  }, C.prototype.Evaluate = function() {
  }, Box2D.inherit(m, Box2D.Dynamics.Contacts.b2Contact), m.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, m.b2PolyAndCircleContact = function() {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  }, m.Create = function(I) {
    return new m();
  }, m.Destroy = function(I, O) {
  }, m.prototype.Reset = function(I, O) {
    this.__super.Reset.call(this, I, O), z.b2Assert(I.GetType() == r.e_polygonShape), z.b2Assert(O.GetType() == r.e_circleShape);
  }, m.prototype.Evaluate = function() {
    var I = (this || window).m_fixtureA.m_body, O = (this || window).m_fixtureB.m_body;
    Q.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof n ? this.m_fixtureA.GetShape() : null, I.m_xf, this.m_fixtureB.GetShape() instanceof t ? this.m_fixtureB.GetShape() : null, O.m_xf);
  }, Box2D.inherit(g, Box2D.Dynamics.Contacts.b2Contact), g.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, g.b2PolyAndEdgeContact = function() {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  }, g.Create = function(I) {
    return new g();
  }, g.Destroy = function(I, O) {
  }, g.prototype.Reset = function(I, O) {
    this.__super.Reset.call(this, I, O), z.b2Assert(I.GetType() == r.e_polygonShape), z.b2Assert(O.GetType() == r.e_edgeShape);
  }, g.prototype.Evaluate = function() {
    var I = (this || window).m_fixtureA.GetBody(), O = (this || window).m_fixtureB.GetBody();
    this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof n ? this.m_fixtureA.GetShape() : null, I.m_xf, this.m_fixtureB.GetShape() instanceof e ? this.m_fixtureB.GetShape() : null, O.m_xf);
  }, g.prototype.b2CollidePolyAndEdge = function(I, O, K, $, S) {
  }, Box2D.inherit(y, Box2D.Dynamics.Contacts.b2Contact), y.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype, y.b2PolygonContact = function() {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  }, y.Create = function(I) {
    return new y();
  }, y.Destroy = function(I, O) {
  }, y.prototype.Reset = function(I, O) {
    this.__super.Reset.call(this, I, O);
  }, y.prototype.Evaluate = function() {
    var I = (this || window).m_fixtureA.GetBody(), O = (this || window).m_fixtureB.GetBody();
    Q.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof n ? this.m_fixtureA.GetShape() : null, I.m_xf, this.m_fixtureB.GetShape() instanceof n ? this.m_fixtureB.GetShape() : null, O.m_xf);
  }, A.b2PositionSolverManifold = function() {
  }, A.prototype.b2PositionSolverManifold = function() {
    this.m_normal = new U(), this.m_separations = new Vector_a2j_Number(z.b2_maxManifoldPoints), this.m_points = new Vector(z.b2_maxManifoldPoints);
    for (var I = 0; I < z.b2_maxManifoldPoints; I++)
      this.m_points[I] = new U();
  }, A.prototype.Initialize = function(I) {
    z.b2Assert(I.pointCount > 0);
    var O = 0, K = 0, $ = 0, S, b, W = 0, x = 0;
    switch (I.type) {
      case rt.e_circles:
        {
          S = I.bodyA.m_xf.R, b = I.localPoint;
          var E = I.bodyA.m_xf.position.x + (S.col1.x * b.x + S.col2.x * b.y), R = I.bodyA.m_xf.position.y + (S.col1.y * b.x + S.col2.y * b.y);
          S = I.bodyB.m_xf.R, b = I.points[0].localPoint;
          var F = I.bodyB.m_xf.position.x + (S.col1.x * b.x + S.col2.x * b.y), k = I.bodyB.m_xf.position.y + (S.col1.y * b.x + S.col2.y * b.y), X = F - E, j = k - R, V = X * X + j * j;
          if (V > Number.MIN_VALUE * Number.MIN_VALUE) {
            var Y = Math.sqrt(V);
            this.m_normal.x = X / Y, this.m_normal.y = j / Y;
          } else
            this.m_normal.x = 1, this.m_normal.y = 0;
          this.m_points[0].x = 0.5 * (E + F), this.m_points[0].y = 0.5 * (R + k), this.m_separations[0] = X * this.m_normal.x + j * this.m_normal.y - I.radius;
        }
        break;
      case rt.e_faceA:
        for (S = I.bodyA.m_xf.R, b = I.localPlaneNormal, this.m_normal.x = S.col1.x * b.x + S.col2.x * b.y, this.m_normal.y = S.col1.y * b.x + S.col2.y * b.y, S = I.bodyA.m_xf.R, b = I.localPoint, W = I.bodyA.m_xf.position.x + (S.col1.x * b.x + S.col2.x * b.y), x = I.bodyA.m_xf.position.y + (S.col1.y * b.x + S.col2.y * b.y), S = I.bodyB.m_xf.R, O = 0; O < I.pointCount; ++O)
          b = I.points[O].localPoint, K = I.bodyB.m_xf.position.x + (S.col1.x * b.x + S.col2.x * b.y), $ = I.bodyB.m_xf.position.y + (S.col1.y * b.x + S.col2.y * b.y), this.m_separations[O] = (K - W) * this.m_normal.x + ($ - x) * this.m_normal.y - I.radius, this.m_points[O].x = K, this.m_points[O].y = $;
        break;
      case rt.e_faceB:
        {
          for (S = I.bodyB.m_xf.R, b = I.localPlaneNormal, this.m_normal.x = S.col1.x * b.x + S.col2.x * b.y, this.m_normal.y = S.col1.y * b.x + S.col2.y * b.y, S = I.bodyB.m_xf.R, b = I.localPoint, W = I.bodyB.m_xf.position.x + (S.col1.x * b.x + S.col2.x * b.y), x = I.bodyB.m_xf.position.y + (S.col1.y * b.x + S.col2.y * b.y), S = I.bodyA.m_xf.R, O = 0; O < I.pointCount; ++O)
            b = I.points[O].localPoint, K = I.bodyA.m_xf.position.x + (S.col1.x * b.x + S.col2.x * b.y), $ = I.bodyA.m_xf.position.y + (S.col1.y * b.x + S.col2.y * b.y), this.m_separations[O] = (K - W) * this.m_normal.x + ($ - x) * this.m_normal.y - I.radius, this.m_points[O].Set(K, $);
          this.m_normal.x *= -1, this.m_normal.y *= -1;
        }
        break;
    }
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new U(), Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new U();
  });
})();
(function() {
  Box2D.Dynamics.b2Body, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep, Box2D.Dynamics.b2World;
  var t = Box2D.Common.Math.b2Mat22;
  Box2D.Common.Math.b2Mat33;
  var e = Box2D.Common.Math.b2Math;
  Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform;
  var n = Box2D.Common.Math.b2Vec2;
  Box2D.Common.Math.b2Vec3;
  var r = Box2D.Common.b2Color;
  Box2D.Common.b2internal, Box2D.Common.b2Settings, Box2D.Collision.Shapes.b2CircleShape, Box2D.Collision.Shapes.b2EdgeChainDef, Box2D.Collision.Shapes.b2EdgeShape, Box2D.Collision.Shapes.b2MassData, Box2D.Collision.Shapes.b2PolygonShape, Box2D.Collision.Shapes.b2Shape;
  var s = Box2D.Dynamics.Controllers.b2BuoyancyController, o = Box2D.Dynamics.Controllers.b2ConstantAccelController, a = Box2D.Dynamics.Controllers.b2ConstantForceController, c = Box2D.Dynamics.Controllers.b2Controller, l = Box2D.Dynamics.Controllers.b2ControllerEdge, h = Box2D.Dynamics.Controllers.b2GravityController, u = Box2D.Dynamics.Controllers.b2TensorDampingController;
  Box2D.inherit(s, Box2D.Dynamics.Controllers.b2Controller), s.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, s.b2BuoyancyController = function() {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.normal = new n(0, -1), this.offset = 0, this.density = 0, this.velocity = new n(0, 0), this.linearDrag = 2, this.angularDrag = 1, this.useDensity = !1, this.useWorldGravity = !0, this.gravity = null;
  }, s.prototype.Step = function(_) {
    if (this.m_bodyList) {
      this.useWorldGravity && (this.gravity = (this || window).GetWorld().GetGravity().Copy());
      for (var d = (this || window).m_bodyList; d; d = d.nextBody) {
        var f = d.body;
        if (f.IsAwake() != !1) {
          for (var C = new n(), m = new n(), g = 0, y = 0, A = f.GetFixtureList(); A; A = A.GetNext()) {
            var D = new n(), N = A.GetShape().ComputeSubmergedArea(this.normal, this.offset, f.GetTransform(), D);
            g += N, C.x += N * D.x, C.y += N * D.y;
            var z = 0;
            this.useDensity, z = 1, y += N * z, m.x += N * D.x * z, m.y += N * D.y * z;
          }
          if (C.x /= g, C.y /= g, m.x /= y, m.y /= y, !(g < Number.MIN_VALUE)) {
            var M = (this || window).gravity.GetNegative();
            M.Multiply(this.density * g), f.ApplyForce(M, m);
            var Z = f.GetLinearVelocityFromWorldPoint(C);
            Z.Subtract(this.velocity), Z.Multiply(-this.linearDrag * g), f.ApplyForce(Z, C), f.ApplyTorque(-f.GetInertia() / f.GetMass() * g * f.GetAngularVelocity() * this.angularDrag);
          }
        }
      }
    }
  }, s.prototype.Draw = function(_) {
    var d = 1e3, f = new n(), C = new n();
    f.x = (this || window).normal.x * this.offset + this.normal.y * d, f.y = (this || window).normal.y * this.offset - this.normal.x * d, C.x = (this || window).normal.x * this.offset - this.normal.y * d, C.y = (this || window).normal.y * this.offset + this.normal.x * d;
    var m = new r(0, 0, 1);
    _.DrawSegment(f, C, m);
  }, Box2D.inherit(o, Box2D.Dynamics.Controllers.b2Controller), o.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, o.b2ConstantAccelController = function() {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.A = new n(0, 0);
  }, o.prototype.Step = function(_) {
    for (var d = new n(this.A.x * _.dt, this.A.y * _.dt), f = (this || window).m_bodyList; f; f = f.nextBody) {
      var C = f.body;
      C.IsAwake() && C.SetLinearVelocity(new n(C.GetLinearVelocity().x + d.x, C.GetLinearVelocity().y + d.y));
    }
  }, Box2D.inherit(a, Box2D.Dynamics.Controllers.b2Controller), a.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, a.b2ConstantForceController = function() {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.F = new n(0, 0);
  }, a.prototype.Step = function(_) {
    for (var d = (this || window).m_bodyList; d; d = d.nextBody) {
      var f = d.body;
      f.IsAwake() && f.ApplyForce(this.F, f.GetWorldCenter());
    }
  }, c.b2Controller = function() {
  }, c.prototype.Step = function(_) {
  }, c.prototype.Draw = function(_) {
  }, c.prototype.AddBody = function(_) {
    var d = new l();
    d.controller = (this || window), d.body = _, d.nextBody = (this || window).m_bodyList, d.prevBody = null, this.m_bodyList = d, d.nextBody && (d.nextBody.prevBody = d), this.m_bodyCount++, d.nextController = _.m_controllerList, d.prevController = null, _.m_controllerList = d, d.nextController && (d.nextController.prevController = d), _.m_controllerCount++;
  }, c.prototype.RemoveBody = function(_) {
    for (var d = _.m_controllerList; d && d.controller != (this || window); )
      d = d.nextController;
    d.prevBody && (d.prevBody.nextBody = d.nextBody), d.nextBody && (d.nextBody.prevBody = d.prevBody), d.nextController && (d.nextController.prevController = d.prevController), d.prevController && (d.prevController.nextController = d.nextController), this.m_bodyList == d && (this.m_bodyList = d.nextBody), _.m_controllerList == d && (_.m_controllerList = d.nextController), _.m_controllerCount--, this.m_bodyCount--;
  }, c.prototype.Clear = function() {
    for (; this.m_bodyList; )
      this.RemoveBody(this.m_bodyList.body);
  }, c.prototype.GetNext = function() {
    return this.m_next;
  }, c.prototype.GetWorld = function() {
    return this.m_world;
  }, c.prototype.GetBodyList = function() {
    return this.m_bodyList;
  }, l.b2ControllerEdge = function() {
  }, Box2D.inherit(h, Box2D.Dynamics.Controllers.b2Controller), h.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, h.b2GravityController = function() {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.G = 1, this.invSqr = !0;
  }, h.prototype.Step = function(_) {
    var d = null, f = null, C = null, m = 0, g = null, y = null, A = null, D = 0, N = 0, z = 0, M = null;
    if (this.invSqr)
      for (d = (this || window).m_bodyList; d; d = d.nextBody)
        for (f = d.body, C = f.GetWorldCenter(), m = f.GetMass(), g = (this || window).m_bodyList; g != d; g = g.nextBody)
          y = g.body, A = y.GetWorldCenter(), D = A.x - C.x, N = A.y - C.y, z = D * D + N * N, !(z < Number.MIN_VALUE) && (M = new n(D, N), M.Multiply(this.G / z / Math.sqrt(z) * m * y.GetMass()), f.IsAwake() && f.ApplyForce(M, C), M.Multiply(-1), y.IsAwake() && y.ApplyForce(M, A));
    else
      for (d = (this || window).m_bodyList; d; d = d.nextBody)
        for (f = d.body, C = f.GetWorldCenter(), m = f.GetMass(), g = (this || window).m_bodyList; g != d; g = g.nextBody)
          y = g.body, A = y.GetWorldCenter(), D = A.x - C.x, N = A.y - C.y, z = D * D + N * N, !(z < Number.MIN_VALUE) && (M = new n(D, N), M.Multiply(this.G / z * m * y.GetMass()), f.IsAwake() && f.ApplyForce(M, C), M.Multiply(-1), y.IsAwake() && y.ApplyForce(M, A));
  }, Box2D.inherit(u, Box2D.Dynamics.Controllers.b2Controller), u.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype, u.b2TensorDampingController = function() {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments), this.T = new t(), this.maxTimestep = 0;
  }, u.prototype.SetAxisAligned = function(_, d) {
    _ === void 0 && (_ = 0), d === void 0 && (d = 0), this.T.col1.x = -_, this.T.col1.y = 0, this.T.col2.x = 0, this.T.col2.y = -d, _ > 0 || d > 0 ? this.maxTimestep = 1 / Math.max(_, d) : this.maxTimestep = 0;
  }, u.prototype.Step = function(_) {
    var d = _.dt;
    if (!(d <= Number.MIN_VALUE)) {
      d > this.maxTimestep && this.maxTimestep > 0 && (d = (this || window).maxTimestep);
      for (var f = (this || window).m_bodyList; f; f = f.nextBody) {
        var C = f.body;
        if (C.IsAwake()) {
          var m = C.GetWorldVector(e.MulMV(this.T, C.GetLocalVector(C.GetLinearVelocity())));
          C.SetLinearVelocity(new n(C.GetLinearVelocity().x + m.x * d, C.GetLinearVelocity().y + m.y * d));
        }
      }
    }
  };
})();
(function() {
  Box2D.Common.b2Color, Box2D.Common.b2internal;
  var t = Box2D.Common.b2Settings, e = Box2D.Common.Math.b2Mat22, n = Box2D.Common.Math.b2Mat33, r = Box2D.Common.Math.b2Math;
  Box2D.Common.Math.b2Sweep, Box2D.Common.Math.b2Transform;
  var s = Box2D.Common.Math.b2Vec2, o = Box2D.Common.Math.b2Vec3, a = Box2D.Dynamics.Joints.b2DistanceJoint, c = Box2D.Dynamics.Joints.b2DistanceJointDef, l = Box2D.Dynamics.Joints.b2FrictionJoint, h = Box2D.Dynamics.Joints.b2FrictionJointDef, u = Box2D.Dynamics.Joints.b2GearJoint, _ = Box2D.Dynamics.Joints.b2GearJointDef, d = Box2D.Dynamics.Joints.b2Jacobian, f = Box2D.Dynamics.Joints.b2Joint, C = Box2D.Dynamics.Joints.b2JointDef, m = Box2D.Dynamics.Joints.b2JointEdge, g = Box2D.Dynamics.Joints.b2LineJoint, y = Box2D.Dynamics.Joints.b2LineJointDef, A = Box2D.Dynamics.Joints.b2MouseJoint, D = Box2D.Dynamics.Joints.b2MouseJointDef, N = Box2D.Dynamics.Joints.b2PrismaticJoint, z = Box2D.Dynamics.Joints.b2PrismaticJointDef, M = Box2D.Dynamics.Joints.b2PulleyJoint, Z = Box2D.Dynamics.Joints.b2PulleyJointDef, U = Box2D.Dynamics.Joints.b2RevoluteJoint, Q = Box2D.Dynamics.Joints.b2RevoluteJointDef, et = Box2D.Dynamics.Joints.b2WeldJoint, rt = Box2D.Dynamics.Joints.b2WeldJointDef;
  Box2D.Dynamics.b2Body, Box2D.Dynamics.b2BodyDef, Box2D.Dynamics.b2ContactFilter, Box2D.Dynamics.b2ContactImpulse, Box2D.Dynamics.b2ContactListener, Box2D.Dynamics.b2ContactManager, Box2D.Dynamics.b2DebugDraw, Box2D.Dynamics.b2DestructionListener, Box2D.Dynamics.b2FilterData, Box2D.Dynamics.b2Fixture, Box2D.Dynamics.b2FixtureDef, Box2D.Dynamics.b2Island, Box2D.Dynamics.b2TimeStep, Box2D.Dynamics.b2World, Box2D.inherit(a, Box2D.Dynamics.Joints.b2Joint), a.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, a.b2DistanceJoint = function() {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new s(), this.m_localAnchor2 = new s(), this.m_u = new s();
  }, a.prototype.GetAnchorA = function() {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  }, a.prototype.GetAnchorB = function() {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  }, a.prototype.GetReactionForce = function(w) {
    return w === void 0 && (w = 0), new s(w * this.m_impulse * this.m_u.x, w * this.m_impulse * this.m_u.y);
  }, a.prototype.GetReactionTorque = function(w) {
    return 0;
  }, a.prototype.GetLength = function() {
    return this.m_length;
  }, a.prototype.SetLength = function(w) {
    w === void 0 && (w = 0), this.m_length = w;
  }, a.prototype.GetFrequency = function() {
    return this.m_frequencyHz;
  }, a.prototype.SetFrequency = function(w) {
    w === void 0 && (w = 0), this.m_frequencyHz = w;
  }, a.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio;
  }, a.prototype.SetDampingRatio = function(w) {
    w === void 0 && (w = 0), this.m_dampingRatio = w;
  }, a.prototype.b2DistanceJoint = function(w) {
    this.__super.b2Joint.call(this, w), this.m_localAnchor1.SetV(w.localAnchorA), this.m_localAnchor2.SetV(w.localAnchorB), this.m_length = w.length, this.m_frequencyHz = w.frequencyHz, this.m_dampingRatio = w.dampingRatio, this.m_impulse = 0, this.m_gamma = 0, this.m_bias = 0;
  }, a.prototype.InitVelocityConstraints = function(w) {
    var L, G = 0, I = (this || window).m_bodyA, O = (this || window).m_bodyB;
    L = I.m_xf.R;
    var K = (this || window).m_localAnchor1.x - I.m_sweep.localCenter.x, $ = (this || window).m_localAnchor1.y - I.m_sweep.localCenter.y;
    G = L.col1.x * K + L.col2.x * $, $ = L.col1.y * K + L.col2.y * $, K = G, L = O.m_xf.R;
    var S = (this || window).m_localAnchor2.x - O.m_sweep.localCenter.x, b = (this || window).m_localAnchor2.y - O.m_sweep.localCenter.y;
    G = L.col1.x * S + L.col2.x * b, b = L.col1.y * S + L.col2.y * b, S = G, this.m_u.x = O.m_sweep.c.x + S - I.m_sweep.c.x - K, this.m_u.y = O.m_sweep.c.y + b - I.m_sweep.c.y - $;
    var W = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
    W > t.b2_linearSlop ? this.m_u.Multiply(1 / W) : this.m_u.SetZero();
    var x = K * this.m_u.y - $ * this.m_u.x, E = S * this.m_u.y - b * this.m_u.x, R = I.m_invMass + I.m_invI * x * x + O.m_invMass + O.m_invI * E * E;
    if (this.m_mass = R != 0 ? 1 / R : 0, this.m_frequencyHz > 0) {
      var F = W - this.m_length, k = 2 * Math.PI * this.m_frequencyHz, X = 2 * this.m_mass * this.m_dampingRatio * k, j = (this || window).m_mass * k * k;
      this.m_gamma = w.dt * (X + w.dt * j), this.m_gamma = (this || window).m_gamma != 0 ? 1 / this.m_gamma : 0, this.m_bias = F * w.dt * j * this.m_gamma, this.m_mass = R + this.m_gamma, this.m_mass = (this || window).m_mass != 0 ? 1 / this.m_mass : 0;
    }
    if (w.warmStarting) {
      this.m_impulse *= w.dtRatio;
      var V = (this || window).m_impulse * this.m_u.x, Y = (this || window).m_impulse * this.m_u.y;
      I.m_linearVelocity.x -= I.m_invMass * V, I.m_linearVelocity.y -= I.m_invMass * Y, I.m_angularVelocity -= I.m_invI * (K * Y - $ * V), O.m_linearVelocity.x += O.m_invMass * V, O.m_linearVelocity.y += O.m_invMass * Y, O.m_angularVelocity += O.m_invI * (S * Y - b * V);
    } else
      this.m_impulse = 0;
  }, a.prototype.SolveVelocityConstraints = function(w) {
    var L, G = (this || window).m_bodyA, I = (this || window).m_bodyB;
    L = G.m_xf.R;
    var O = (this || window).m_localAnchor1.x - G.m_sweep.localCenter.x, K = (this || window).m_localAnchor1.y - G.m_sweep.localCenter.y, $ = L.col1.x * O + L.col2.x * K;
    K = L.col1.y * O + L.col2.y * K, O = $, L = I.m_xf.R;
    var S = (this || window).m_localAnchor2.x - I.m_sweep.localCenter.x, b = (this || window).m_localAnchor2.y - I.m_sweep.localCenter.y;
    $ = L.col1.x * S + L.col2.x * b, b = L.col1.y * S + L.col2.y * b, S = $;
    var W = G.m_linearVelocity.x + -G.m_angularVelocity * K, x = G.m_linearVelocity.y + G.m_angularVelocity * O, E = I.m_linearVelocity.x + -I.m_angularVelocity * b, R = I.m_linearVelocity.y + I.m_angularVelocity * S, F = (this || window).m_u.x * (E - W) + this.m_u.y * (R - x), k = -this.m_mass * (F + this.m_bias + this.m_gamma * this.m_impulse);
    this.m_impulse += k;
    var X = k * this.m_u.x, j = k * this.m_u.y;
    G.m_linearVelocity.x -= G.m_invMass * X, G.m_linearVelocity.y -= G.m_invMass * j, G.m_angularVelocity -= G.m_invI * (O * j - K * X), I.m_linearVelocity.x += I.m_invMass * X, I.m_linearVelocity.y += I.m_invMass * j, I.m_angularVelocity += I.m_invI * (S * j - b * X);
  }, a.prototype.SolvePositionConstraints = function(w) {
    var L;
    if (this.m_frequencyHz > 0)
      return !0;
    var G = (this || window).m_bodyA, I = (this || window).m_bodyB;
    L = G.m_xf.R;
    var O = (this || window).m_localAnchor1.x - G.m_sweep.localCenter.x, K = (this || window).m_localAnchor1.y - G.m_sweep.localCenter.y, $ = L.col1.x * O + L.col2.x * K;
    K = L.col1.y * O + L.col2.y * K, O = $, L = I.m_xf.R;
    var S = (this || window).m_localAnchor2.x - I.m_sweep.localCenter.x, b = (this || window).m_localAnchor2.y - I.m_sweep.localCenter.y;
    $ = L.col1.x * S + L.col2.x * b, b = L.col1.y * S + L.col2.y * b, S = $;
    var W = I.m_sweep.c.x + S - G.m_sweep.c.x - O, x = I.m_sweep.c.y + b - G.m_sweep.c.y - K, E = Math.sqrt(W * W + x * x);
    W /= E, x /= E;
    var R = E - this.m_length;
    R = r.Clamp(R, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection);
    var F = -this.m_mass * R;
    this.m_u.Set(W, x);
    var k = F * this.m_u.x, X = F * this.m_u.y;
    return G.m_sweep.c.x -= G.m_invMass * k, G.m_sweep.c.y -= G.m_invMass * X, G.m_sweep.a -= G.m_invI * (O * X - K * k), I.m_sweep.c.x += I.m_invMass * k, I.m_sweep.c.y += I.m_invMass * X, I.m_sweep.a += I.m_invI * (S * X - b * k), G.SynchronizeTransform(), I.SynchronizeTransform(), r.Abs(R) < t.b2_linearSlop;
  }, Box2D.inherit(c, Box2D.Dynamics.Joints.b2JointDef), c.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, c.b2DistanceJointDef = function() {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s(), this.localAnchorB = new s();
  }, c.prototype.b2DistanceJointDef = function() {
    this.__super.b2JointDef.call(this), this.type = f.e_distanceJoint, this.length = 1, this.frequencyHz = 0, this.dampingRatio = 0;
  }, c.prototype.Initialize = function(w, L, G, I) {
    this.bodyA = w, this.bodyB = L, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(G)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(I));
    var O = I.x - G.x, K = I.y - G.y;
    this.length = Math.sqrt(O * O + K * K), this.frequencyHz = 0, this.dampingRatio = 0;
  }, Box2D.inherit(l, Box2D.Dynamics.Joints.b2Joint), l.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, l.b2FrictionJoint = function() {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new s(), this.m_localAnchorB = new s(), this.m_linearMass = new e(), this.m_linearImpulse = new s();
  }, l.prototype.GetAnchorA = function() {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
  }, l.prototype.GetAnchorB = function() {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
  }, l.prototype.GetReactionForce = function(w) {
    return w === void 0 && (w = 0), new s(w * this.m_linearImpulse.x, w * this.m_linearImpulse.y);
  }, l.prototype.GetReactionTorque = function(w) {
    return w === void 0 && (w = 0), w * this.m_angularImpulse;
  }, l.prototype.SetMaxForce = function(w) {
    w === void 0 && (w = 0), this.m_maxForce = w;
  }, l.prototype.GetMaxForce = function() {
    return this.m_maxForce;
  }, l.prototype.SetMaxTorque = function(w) {
    w === void 0 && (w = 0), this.m_maxTorque = w;
  }, l.prototype.GetMaxTorque = function() {
    return this.m_maxTorque;
  }, l.prototype.b2FrictionJoint = function(w) {
    this.__super.b2Joint.call(this, w), this.m_localAnchorA.SetV(w.localAnchorA), this.m_localAnchorB.SetV(w.localAnchorB), this.m_linearMass.SetZero(), this.m_angularMass = 0, this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0, this.m_maxForce = w.maxForce, this.m_maxTorque = w.maxTorque;
  }, l.prototype.InitVelocityConstraints = function(w) {
    var L, G = 0, I = (this || window).m_bodyA, O = (this || window).m_bodyB;
    L = I.m_xf.R;
    var K = (this || window).m_localAnchorA.x - I.m_sweep.localCenter.x, $ = (this || window).m_localAnchorA.y - I.m_sweep.localCenter.y;
    G = L.col1.x * K + L.col2.x * $, $ = L.col1.y * K + L.col2.y * $, K = G, L = O.m_xf.R;
    var S = (this || window).m_localAnchorB.x - O.m_sweep.localCenter.x, b = (this || window).m_localAnchorB.y - O.m_sweep.localCenter.y;
    G = L.col1.x * S + L.col2.x * b, b = L.col1.y * S + L.col2.y * b, S = G;
    var W = I.m_invMass, x = O.m_invMass, E = I.m_invI, R = O.m_invI, F = new e();
    if (F.col1.x = W + x, F.col2.x = 0, F.col1.y = 0, F.col2.y = W + x, F.col1.x += E * $ * $, F.col2.x += -E * K * $, F.col1.y += -E * K * $, F.col2.y += E * K * K, F.col1.x += R * b * b, F.col2.x += -R * S * b, F.col1.y += -R * S * b, F.col2.y += R * S * S, F.GetInverse(this.m_linearMass), this.m_angularMass = E + R, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), w.warmStarting) {
      this.m_linearImpulse.x *= w.dtRatio, this.m_linearImpulse.y *= w.dtRatio, this.m_angularImpulse *= w.dtRatio;
      var k = (this || window).m_linearImpulse;
      I.m_linearVelocity.x -= W * k.x, I.m_linearVelocity.y -= W * k.y, I.m_angularVelocity -= E * (K * k.y - $ * k.x + this.m_angularImpulse), O.m_linearVelocity.x += x * k.x, O.m_linearVelocity.y += x * k.y, O.m_angularVelocity += R * (S * k.y - b * k.x + this.m_angularImpulse);
    } else
      this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
  }, l.prototype.SolveVelocityConstraints = function(w) {
    var L, G = 0, I = (this || window).m_bodyA, O = (this || window).m_bodyB, K = I.m_linearVelocity, $ = I.m_angularVelocity, S = O.m_linearVelocity, b = O.m_angularVelocity, W = I.m_invMass, x = O.m_invMass, E = I.m_invI, R = O.m_invI;
    L = I.m_xf.R;
    var F = (this || window).m_localAnchorA.x - I.m_sweep.localCenter.x, k = (this || window).m_localAnchorA.y - I.m_sweep.localCenter.y;
    G = L.col1.x * F + L.col2.x * k, k = L.col1.y * F + L.col2.y * k, F = G, L = O.m_xf.R;
    var X = (this || window).m_localAnchorB.x - O.m_sweep.localCenter.x, j = (this || window).m_localAnchorB.y - O.m_sweep.localCenter.y;
    G = L.col1.x * X + L.col2.x * j, j = L.col1.y * X + L.col2.y * j, X = G;
    var V = 0;
    {
      var Y = b - $, tt = -this.m_angularMass * Y, it = (this || window).m_angularImpulse;
      V = w.dt * this.m_maxTorque, this.m_angularImpulse = r.Clamp(this.m_angularImpulse + tt, -V, V), tt = (this || window).m_angularImpulse - it, $ -= E * tt, b += R * tt;
    }
    {
      var lt = S.x - b * j - K.x + $ * k, ut = S.y + b * X - K.y - $ * F, ft = r.MulMV(this.m_linearMass, new s(-lt, -ut)), vt = (this || window).m_linearImpulse.Copy();
      this.m_linearImpulse.Add(ft), V = w.dt * this.m_maxForce, this.m_linearImpulse.LengthSquared() > V * V && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(V)), ft = r.SubtractVV(this.m_linearImpulse, vt), K.x -= W * ft.x, K.y -= W * ft.y, $ -= E * (F * ft.y - k * ft.x), S.x += x * ft.x, S.y += x * ft.y, b += R * (X * ft.y - j * ft.x);
    }
    I.m_angularVelocity = $, O.m_angularVelocity = b;
  }, l.prototype.SolvePositionConstraints = function(w) {
    return !0;
  }, Box2D.inherit(h, Box2D.Dynamics.Joints.b2JointDef), h.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, h.b2FrictionJointDef = function() {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s(), this.localAnchorB = new s();
  }, h.prototype.b2FrictionJointDef = function() {
    this.__super.b2JointDef.call(this), this.type = f.e_frictionJoint, this.maxForce = 0, this.maxTorque = 0;
  }, h.prototype.Initialize = function(w, L, G) {
    this.bodyA = w, this.bodyB = L, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(G)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(G));
  }, Box2D.inherit(u, Box2D.Dynamics.Joints.b2Joint), u.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, u.b2GearJoint = function() {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new s(), this.m_groundAnchor2 = new s(), this.m_localAnchor1 = new s(), this.m_localAnchor2 = new s(), this.m_J = new d();
  }, u.prototype.GetAnchorA = function() {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  }, u.prototype.GetAnchorB = function() {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  }, u.prototype.GetReactionForce = function(w) {
    return w === void 0 && (w = 0), new s(w * this.m_impulse * this.m_J.linearB.x, w * this.m_impulse * this.m_J.linearB.y);
  }, u.prototype.GetReactionTorque = function(w) {
    w === void 0 && (w = 0);
    var L = (this || window).m_bodyB.m_xf.R, G = (this || window).m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x, I = (this || window).m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y, O = L.col1.x * G + L.col2.x * I;
    I = L.col1.y * G + L.col2.y * I, G = O;
    var K = (this || window).m_impulse * this.m_J.linearB.x, $ = (this || window).m_impulse * this.m_J.linearB.y;
    return w * (this.m_impulse * this.m_J.angularB - G * $ + I * K);
  }, u.prototype.GetRatio = function() {
    return this.m_ratio;
  }, u.prototype.SetRatio = function(w) {
    w === void 0 && (w = 0), this.m_ratio = w;
  }, u.prototype.b2GearJoint = function(w) {
    this.__super.b2Joint.call(this, w);
    var L = parseInt(w.joint1.m_type), G = parseInt(w.joint2.m_type);
    this.m_revolute1 = null, this.m_prismatic1 = null, this.m_revolute2 = null, this.m_prismatic2 = null;
    var I = 0, O = 0;
    this.m_ground1 = w.joint1.GetBodyA(), this.m_bodyA = w.joint1.GetBodyB(), L == f.e_revoluteJoint ? (this.m_revolute1 = w.joint1 instanceof U ? w.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), I = (this || window).m_revolute1.GetJointAngle()) : (this.m_prismatic1 = w.joint1 instanceof N ? w.joint1 : null, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), I = (this || window).m_prismatic1.GetJointTranslation()), this.m_ground2 = w.joint2.GetBodyA(), this.m_bodyB = w.joint2.GetBodyB(), G == f.e_revoluteJoint ? (this.m_revolute2 = w.joint2 instanceof U ? w.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), O = (this || window).m_revolute2.GetJointAngle()) : (this.m_prismatic2 = w.joint2 instanceof N ? w.joint2 : null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), O = (this || window).m_prismatic2.GetJointTranslation()), this.m_ratio = w.ratio, this.m_constant = I + this.m_ratio * O, this.m_impulse = 0;
  }, u.prototype.InitVelocityConstraints = function(w) {
    var L = (this || window).m_ground1, G = (this || window).m_ground2, I = (this || window).m_bodyA, O = (this || window).m_bodyB, K = 0, $ = 0, S = 0, b = 0, W, x, E = 0, R = 0, F = 0;
    this.m_J.SetZero(), this.m_revolute1 ? (this.m_J.angularA = -1, F += I.m_invI) : (W = L.m_xf.R, x = (this || window).m_prismatic1.m_localXAxis1, K = W.col1.x * x.x + W.col2.x * x.y, $ = W.col1.y * x.x + W.col2.y * x.y, W = I.m_xf.R, S = (this || window).m_localAnchor1.x - I.m_sweep.localCenter.x, b = (this || window).m_localAnchor1.y - I.m_sweep.localCenter.y, R = W.col1.x * S + W.col2.x * b, b = W.col1.y * S + W.col2.y * b, S = R, E = S * $ - b * K, this.m_J.linearA.Set(-K, -$), this.m_J.angularA = -E, F += I.m_invMass + I.m_invI * E * E), this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, F += (this || window).m_ratio * this.m_ratio * O.m_invI) : (W = G.m_xf.R, x = (this || window).m_prismatic2.m_localXAxis1, K = W.col1.x * x.x + W.col2.x * x.y, $ = W.col1.y * x.x + W.col2.y * x.y, W = O.m_xf.R, S = (this || window).m_localAnchor2.x - O.m_sweep.localCenter.x, b = (this || window).m_localAnchor2.y - O.m_sweep.localCenter.y, R = W.col1.x * S + W.col2.x * b, b = W.col1.y * S + W.col2.y * b, S = R, E = S * $ - b * K, this.m_J.linearB.Set(-this.m_ratio * K, -this.m_ratio * $), this.m_J.angularB = -this.m_ratio * E, F += (this || window).m_ratio * this.m_ratio * (O.m_invMass + O.m_invI * E * E)), this.m_mass = F > 0 ? 1 / F : 0, w.warmStarting ? (I.m_linearVelocity.x += I.m_invMass * this.m_impulse * this.m_J.linearA.x, I.m_linearVelocity.y += I.m_invMass * this.m_impulse * this.m_J.linearA.y, I.m_angularVelocity += I.m_invI * this.m_impulse * this.m_J.angularA, O.m_linearVelocity.x += O.m_invMass * this.m_impulse * this.m_J.linearB.x, O.m_linearVelocity.y += O.m_invMass * this.m_impulse * this.m_J.linearB.y, O.m_angularVelocity += O.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0;
  }, u.prototype.SolveVelocityConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I = (this || window).m_J.Compute(L.m_linearVelocity, L.m_angularVelocity, G.m_linearVelocity, G.m_angularVelocity), O = -this.m_mass * I;
    this.m_impulse += O, L.m_linearVelocity.x += L.m_invMass * O * this.m_J.linearA.x, L.m_linearVelocity.y += L.m_invMass * O * this.m_J.linearA.y, L.m_angularVelocity += L.m_invI * O * this.m_J.angularA, G.m_linearVelocity.x += G.m_invMass * O * this.m_J.linearB.x, G.m_linearVelocity.y += G.m_invMass * O * this.m_J.linearB.y, G.m_angularVelocity += G.m_invI * O * this.m_J.angularB;
  }, u.prototype.SolvePositionConstraints = function(w) {
    var L = 0, G = (this || window).m_bodyA, I = (this || window).m_bodyB, O = 0, K = 0;
    this.m_revolute1 ? O = (this || window).m_revolute1.GetJointAngle() : O = (this || window).m_prismatic1.GetJointTranslation(), this.m_revolute2 ? K = (this || window).m_revolute2.GetJointAngle() : K = (this || window).m_prismatic2.GetJointTranslation();
    var $ = (this || window).m_constant - (O + this.m_ratio * K), S = -this.m_mass * $;
    return G.m_sweep.c.x += G.m_invMass * S * this.m_J.linearA.x, G.m_sweep.c.y += G.m_invMass * S * this.m_J.linearA.y, G.m_sweep.a += G.m_invI * S * this.m_J.angularA, I.m_sweep.c.x += I.m_invMass * S * this.m_J.linearB.x, I.m_sweep.c.y += I.m_invMass * S * this.m_J.linearB.y, I.m_sweep.a += I.m_invI * S * this.m_J.angularB, G.SynchronizeTransform(), I.SynchronizeTransform(), L < t.b2_linearSlop;
  }, Box2D.inherit(_, Box2D.Dynamics.Joints.b2JointDef), _.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, _.b2GearJointDef = function() {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
  }, _.prototype.b2GearJointDef = function() {
    this.__super.b2JointDef.call(this), this.type = f.e_gearJoint, this.joint1 = null, this.joint2 = null, this.ratio = 1;
  }, d.b2Jacobian = function() {
    this.linearA = new s(), this.linearB = new s();
  }, d.prototype.SetZero = function() {
    this.linearA.SetZero(), this.angularA = 0, this.linearB.SetZero(), this.angularB = 0;
  }, d.prototype.Set = function(w, L, G, I) {
    L === void 0 && (L = 0), I === void 0 && (I = 0), this.linearA.SetV(w), this.angularA = L, this.linearB.SetV(G), this.angularB = I;
  }, d.prototype.Compute = function(w, L, G, I) {
    return L === void 0 && (L = 0), I === void 0 && (I = 0), this.linearA.x * w.x + this.linearA.y * w.y + this.angularA * L + (this.linearB.x * G.x + this.linearB.y * G.y) + this.angularB * I;
  }, f.b2Joint = function() {
    this.m_edgeA = new m(), this.m_edgeB = new m(), this.m_localCenterA = new s(), this.m_localCenterB = new s();
  }, f.prototype.GetType = function() {
    return this.m_type;
  }, f.prototype.GetAnchorA = function() {
    return null;
  }, f.prototype.GetAnchorB = function() {
    return null;
  }, f.prototype.GetReactionForce = function(w) {
    return null;
  }, f.prototype.GetReactionTorque = function(w) {
    return 0;
  }, f.prototype.GetBodyA = function() {
    return this.m_bodyA;
  }, f.prototype.GetBodyB = function() {
    return this.m_bodyB;
  }, f.prototype.GetNext = function() {
    return this.m_next;
  }, f.prototype.GetUserData = function() {
    return this.m_userData;
  }, f.prototype.SetUserData = function(w) {
    this.m_userData = w;
  }, f.prototype.IsActive = function() {
    return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
  }, f.Create = function(w, L) {
    var G = null;
    switch (w.type) {
      case f.e_distanceJoint:
        G = new a(w instanceof c ? w : null);
        break;
      case f.e_mouseJoint:
        G = new A(w instanceof D ? w : null);
        break;
      case f.e_prismaticJoint:
        G = new N(w instanceof z ? w : null);
        break;
      case f.e_revoluteJoint:
        G = new U(w instanceof Q ? w : null);
        break;
      case f.e_pulleyJoint:
        G = new M(w instanceof Z ? w : null);
        break;
      case f.e_gearJoint:
        G = new u(w instanceof _ ? w : null);
        break;
      case f.e_lineJoint:
        G = new g(w instanceof y ? w : null);
        break;
      case f.e_weldJoint:
        G = new et(w instanceof rt ? w : null);
        break;
      case f.e_frictionJoint:
        G = new l(w instanceof h ? w : null);
        break;
    }
    return G;
  }, f.Destroy = function(w, L) {
  }, f.prototype.b2Joint = function(w) {
    t.b2Assert(w.bodyA != w.bodyB), this.m_type = w.type, this.m_prev = null, this.m_next = null, this.m_bodyA = w.bodyA, this.m_bodyB = w.bodyB, this.m_collideConnected = w.collideConnected, this.m_islandFlag = !1, this.m_userData = w.userData;
  }, f.prototype.InitVelocityConstraints = function(w) {
  }, f.prototype.SolveVelocityConstraints = function(w) {
  }, f.prototype.FinalizeVelocityConstraints = function() {
  }, f.prototype.SolvePositionConstraints = function(w) {
    return !1;
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0, Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1, Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2, Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3, Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4, Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5, Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6, Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7, Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8, Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9, Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0, Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1, Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2, Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
  }), C.b2JointDef = function() {
  }, C.prototype.b2JointDef = function() {
    this.type = f.e_unknownJoint, this.userData = null, this.bodyA = null, this.bodyB = null, this.collideConnected = !1;
  }, m.b2JointEdge = function() {
  }, Box2D.inherit(g, Box2D.Dynamics.Joints.b2Joint), g.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, g.b2LineJoint = function() {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new s(), this.m_localAnchor2 = new s(), this.m_localXAxis1 = new s(), this.m_localYAxis1 = new s(), this.m_axis = new s(), this.m_perp = new s(), this.m_K = new e(), this.m_impulse = new s();
  }, g.prototype.GetAnchorA = function() {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  }, g.prototype.GetAnchorB = function() {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  }, g.prototype.GetReactionForce = function(w) {
    return w === void 0 && (w = 0), new s(w * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), w * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
  }, g.prototype.GetReactionTorque = function(w) {
    return w === void 0 && (w = 0), w * this.m_impulse.y;
  }, g.prototype.GetJointTranslation = function() {
    var w = (this || window).m_bodyA, L = (this || window).m_bodyB, G = w.GetWorldPoint(this.m_localAnchor1), I = L.GetWorldPoint(this.m_localAnchor2), O = I.x - G.x, K = I.y - G.y, $ = w.GetWorldVector(this.m_localXAxis1), S = $.x * O + $.y * K;
    return S;
  }, g.prototype.GetJointSpeed = function() {
    var w = (this || window).m_bodyA, L = (this || window).m_bodyB, G;
    G = w.m_xf.R;
    var I = (this || window).m_localAnchor1.x - w.m_sweep.localCenter.x, O = (this || window).m_localAnchor1.y - w.m_sweep.localCenter.y, K = G.col1.x * I + G.col2.x * O;
    O = G.col1.y * I + G.col2.y * O, I = K, G = L.m_xf.R;
    var $ = (this || window).m_localAnchor2.x - L.m_sweep.localCenter.x, S = (this || window).m_localAnchor2.y - L.m_sweep.localCenter.y;
    K = G.col1.x * $ + G.col2.x * S, S = G.col1.y * $ + G.col2.y * S, $ = K;
    var b = w.m_sweep.c.x + I, W = w.m_sweep.c.y + O, x = L.m_sweep.c.x + $, E = L.m_sweep.c.y + S, R = x - b, F = E - W, k = w.GetWorldVector(this.m_localXAxis1), X = w.m_linearVelocity, j = L.m_linearVelocity, V = w.m_angularVelocity, Y = L.m_angularVelocity, tt = R * (-V * k.y) + F * (V * k.x) + (k.x * (j.x + -Y * S - X.x - -V * O) + k.y * (j.y + Y * $ - X.y - V * I));
    return tt;
  }, g.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit;
  }, g.prototype.EnableLimit = function(w) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = w;
  }, g.prototype.GetLowerLimit = function() {
    return this.m_lowerTranslation;
  }, g.prototype.GetUpperLimit = function() {
    return this.m_upperTranslation;
  }, g.prototype.SetLimits = function(w, L) {
    w === void 0 && (w = 0), L === void 0 && (L = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = w, this.m_upperTranslation = L;
  }, g.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor;
  }, g.prototype.EnableMotor = function(w) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = w;
  }, g.prototype.SetMotorSpeed = function(w) {
    w === void 0 && (w = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = w;
  }, g.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed;
  }, g.prototype.SetMaxMotorForce = function(w) {
    w === void 0 && (w = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = w;
  }, g.prototype.GetMaxMotorForce = function() {
    return this.m_maxMotorForce;
  }, g.prototype.GetMotorForce = function() {
    return this.m_motorImpulse;
  }, g.prototype.b2LineJoint = function(w) {
    this.__super.b2Joint.call(this, w), this.m_localAnchor1.SetV(w.localAnchorA), this.m_localAnchor2.SetV(w.localAnchorB), this.m_localXAxis1.SetV(w.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = (this || window).m_localXAxis1.x, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = w.lowerTranslation, this.m_upperTranslation = w.upperTranslation, this.m_maxMotorForce = w.maxMotorForce, this.m_motorSpeed = w.motorSpeed, this.m_enableLimit = w.enableLimit, this.m_enableMotor = w.enableMotor, this.m_limitState = f.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero();
  }, g.prototype.InitVelocityConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I, O = 0;
    this.m_localCenterA.SetV(L.GetLocalCenter()), this.m_localCenterB.SetV(G.GetLocalCenter());
    var K = L.GetTransform();
    G.GetTransform(), I = L.m_xf.R;
    var $ = (this || window).m_localAnchor1.x - this.m_localCenterA.x, S = (this || window).m_localAnchor1.y - this.m_localCenterA.y;
    O = I.col1.x * $ + I.col2.x * S, S = I.col1.y * $ + I.col2.y * S, $ = O, I = G.m_xf.R;
    var b = (this || window).m_localAnchor2.x - this.m_localCenterB.x, W = (this || window).m_localAnchor2.y - this.m_localCenterB.y;
    O = I.col1.x * b + I.col2.x * W, W = I.col1.y * b + I.col2.y * W, b = O;
    var x = G.m_sweep.c.x + b - L.m_sweep.c.x - $, E = G.m_sweep.c.y + W - L.m_sweep.c.y - S;
    this.m_invMassA = L.m_invMass, this.m_invMassB = G.m_invMass, this.m_invIA = L.m_invI, this.m_invIB = G.m_invI, this.m_axis.SetV(r.MulMV(K.R, this.m_localXAxis1)), this.m_a1 = (x + $) * this.m_axis.y - (E + S) * this.m_axis.x, this.m_a2 = b * this.m_axis.y - W * this.m_axis.x, this.m_motorMass = (this || window).m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass = (this || window).m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;
    {
      this.m_perp.SetV(r.MulMV(K.R, this.m_localYAxis1)), this.m_s1 = (x + $) * this.m_perp.y - (E + S) * this.m_perp.x, this.m_s2 = b * this.m_perp.y - W * this.m_perp.x;
      var R = (this || window).m_invMassA, F = (this || window).m_invMassB, k = (this || window).m_invIA, X = (this || window).m_invIB;
      this.m_K.col1.x = R + F + k * this.m_s1 * this.m_s1 + X * this.m_s2 * this.m_s2, this.m_K.col1.y = k * this.m_s1 * this.m_a1 + X * this.m_s2 * this.m_a2, this.m_K.col2.x = (this || window).m_K.col1.y, this.m_K.col2.y = R + F + k * this.m_a1 * this.m_a1 + X * this.m_a2 * this.m_a2;
    }
    if (this.m_enableLimit) {
      var j = (this || window).m_axis.x * x + this.m_axis.y * E;
      r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = f.e_equalLimits : j <= (this || window).m_lowerTranslation ? this.m_limitState != f.e_atLowerLimit && (this.m_limitState = f.e_atLowerLimit, this.m_impulse.y = 0) : j >= (this || window).m_upperTranslation ? this.m_limitState != f.e_atUpperLimit && (this.m_limitState = f.e_atUpperLimit, this.m_impulse.y = 0) : (this.m_limitState = f.e_inactiveLimit, this.m_impulse.y = 0);
    } else
      this.m_limitState = f.e_inactiveLimit;
    if (this.m_enableMotor == !1 && (this.m_motorImpulse = 0), w.warmStarting) {
      this.m_impulse.x *= w.dtRatio, this.m_impulse.y *= w.dtRatio, this.m_motorImpulse *= w.dtRatio;
      var V = (this || window).m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x, Y = (this || window).m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y, tt = (this || window).m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1, it = (this || window).m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
      L.m_linearVelocity.x -= (this || window).m_invMassA * V, L.m_linearVelocity.y -= (this || window).m_invMassA * Y, L.m_angularVelocity -= (this || window).m_invIA * tt, G.m_linearVelocity.x += (this || window).m_invMassB * V, G.m_linearVelocity.y += (this || window).m_invMassB * Y, G.m_angularVelocity += (this || window).m_invIB * it;
    } else
      this.m_impulse.SetZero(), this.m_motorImpulse = 0;
  }, g.prototype.SolveVelocityConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I = L.m_linearVelocity, O = L.m_angularVelocity, K = G.m_linearVelocity, $ = G.m_angularVelocity, S = 0, b = 0, W = 0, x = 0;
    if (this.m_enableMotor && this.m_limitState != f.e_equalLimits) {
      var E = (this || window).m_axis.x * (K.x - I.x) + this.m_axis.y * (K.y - I.y) + this.m_a2 * $ - this.m_a1 * O, R = (this || window).m_motorMass * (this.m_motorSpeed - E), F = (this || window).m_motorImpulse, k = w.dt * this.m_maxMotorForce;
      this.m_motorImpulse = r.Clamp(this.m_motorImpulse + R, -k, k), R = (this || window).m_motorImpulse - F, S = R * this.m_axis.x, b = R * this.m_axis.y, W = R * this.m_a1, x = R * this.m_a2, I.x -= (this || window).m_invMassA * S, I.y -= (this || window).m_invMassA * b, O -= (this || window).m_invIA * W, K.x += (this || window).m_invMassB * S, K.y += (this || window).m_invMassB * b, $ += (this || window).m_invIB * x;
    }
    var X = (this || window).m_perp.x * (K.x - I.x) + this.m_perp.y * (K.y - I.y) + this.m_s2 * $ - this.m_s1 * O;
    if (this.m_enableLimit && this.m_limitState != f.e_inactiveLimit) {
      var j = (this || window).m_axis.x * (K.x - I.x) + this.m_axis.y * (K.y - I.y) + this.m_a2 * $ - this.m_a1 * O, V = (this || window).m_impulse.Copy(), Y = (this || window).m_K.Solve(new s(), -X, -j);
      this.m_impulse.Add(Y), this.m_limitState == f.e_atLowerLimit ? this.m_impulse.y = r.Max(this.m_impulse.y, 0) : this.m_limitState == f.e_atUpperLimit && (this.m_impulse.y = r.Min(this.m_impulse.y, 0));
      var tt = -X - (this.m_impulse.y - V.y) * this.m_K.col2.x, it = 0;
      this.m_K.col1.x != 0 ? it = tt / this.m_K.col1.x + V.x : it = V.x, this.m_impulse.x = it, Y.x = (this || window).m_impulse.x - V.x, Y.y = (this || window).m_impulse.y - V.y, S = Y.x * this.m_perp.x + Y.y * this.m_axis.x, b = Y.x * this.m_perp.y + Y.y * this.m_axis.y, W = Y.x * this.m_s1 + Y.y * this.m_a1, x = Y.x * this.m_s2 + Y.y * this.m_a2, I.x -= (this || window).m_invMassA * S, I.y -= (this || window).m_invMassA * b, O -= (this || window).m_invIA * W, K.x += (this || window).m_invMassB * S, K.y += (this || window).m_invMassB * b, $ += (this || window).m_invIB * x;
    } else {
      var lt = 0;
      this.m_K.col1.x != 0 ? lt = -X / this.m_K.col1.x : lt = 0, this.m_impulse.x += lt, S = lt * this.m_perp.x, b = lt * this.m_perp.y, W = lt * this.m_s1, x = lt * this.m_s2, I.x -= (this || window).m_invMassA * S, I.y -= (this || window).m_invMassA * b, O -= (this || window).m_invIA * W, K.x += (this || window).m_invMassB * S, K.y += (this || window).m_invMassB * b, $ += (this || window).m_invIB * x;
    }
    L.m_linearVelocity.SetV(I), L.m_angularVelocity = O, G.m_linearVelocity.SetV(K), G.m_angularVelocity = $;
  }, g.prototype.SolvePositionConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I = L.m_sweep.c, O = L.m_sweep.a, K = G.m_sweep.c, $ = G.m_sweep.a, S, b = 0, W = 0, x = 0, E = 0, R = 0, F = 0, k = 0, X = !1, j = 0, V = e.FromAngle(O), Y = e.FromAngle($);
    S = V;
    var tt = (this || window).m_localAnchor1.x - this.m_localCenterA.x, it = (this || window).m_localAnchor1.y - this.m_localCenterA.y;
    b = S.col1.x * tt + S.col2.x * it, it = S.col1.y * tt + S.col2.y * it, tt = b, S = Y;
    var lt = (this || window).m_localAnchor2.x - this.m_localCenterB.x, ut = (this || window).m_localAnchor2.y - this.m_localCenterB.y;
    b = S.col1.x * lt + S.col2.x * ut, ut = S.col1.y * lt + S.col2.y * ut, lt = b;
    var ft = K.x + lt - I.x - tt, vt = K.y + ut - I.y - it;
    if (this.m_enableLimit) {
      this.m_axis = r.MulMV(V, this.m_localXAxis1), this.m_a1 = (ft + tt) * this.m_axis.y - (vt + it) * this.m_axis.x, this.m_a2 = lt * this.m_axis.y - ut * this.m_axis.x;
      var pt = (this || window).m_axis.x * ft + this.m_axis.y * vt;
      r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (j = r.Clamp(pt, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), F = r.Abs(pt), X = !0) : pt <= (this || window).m_lowerTranslation ? (j = r.Clamp(pt - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), F = (this || window).m_lowerTranslation - pt, X = !0) : pt >= (this || window).m_upperTranslation && (j = r.Clamp(pt - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), F = pt - this.m_upperTranslation, X = !0);
    }
    this.m_perp = r.MulMV(V, this.m_localYAxis1), this.m_s1 = (ft + tt) * this.m_perp.y - (vt + it) * this.m_perp.x, this.m_s2 = lt * this.m_perp.y - ut * this.m_perp.x;
    var gt = new s(), St = (this || window).m_perp.x * ft + this.m_perp.y * vt;
    if (F = r.Max(F, r.Abs(St)), k = 0, X)
      W = (this || window).m_invMassA, x = (this || window).m_invMassB, E = (this || window).m_invIA, R = (this || window).m_invIB, this.m_K.col1.x = W + x + E * this.m_s1 * this.m_s1 + R * this.m_s2 * this.m_s2, this.m_K.col1.y = E * this.m_s1 * this.m_a1 + R * this.m_s2 * this.m_a2, this.m_K.col2.x = (this || window).m_K.col1.y, this.m_K.col2.y = W + x + E * this.m_a1 * this.m_a1 + R * this.m_a2 * this.m_a2, this.m_K.Solve(gt, -St, -j);
    else {
      W = (this || window).m_invMassA, x = (this || window).m_invMassB, E = (this || window).m_invIA, R = (this || window).m_invIB;
      var ht = W + x + E * this.m_s1 * this.m_s1 + R * this.m_s2 * this.m_s2, ct = 0;
      ht != 0 ? ct = -St / ht : ct = 0, gt.x = ct, gt.y = 0;
    }
    var bt = gt.x * this.m_perp.x + gt.y * this.m_axis.x, Et = gt.x * this.m_perp.y + gt.y * this.m_axis.y, wt = gt.x * this.m_s1 + gt.y * this.m_a1, It = gt.x * this.m_s2 + gt.y * this.m_a2;
    return I.x -= (this || window).m_invMassA * bt, I.y -= (this || window).m_invMassA * Et, O -= (this || window).m_invIA * wt, K.x += (this || window).m_invMassB * bt, K.y += (this || window).m_invMassB * Et, $ += (this || window).m_invIB * It, L.m_sweep.a = O, G.m_sweep.a = $, L.SynchronizeTransform(), G.SynchronizeTransform(), F <= t.b2_linearSlop && k <= t.b2_angularSlop;
  }, Box2D.inherit(y, Box2D.Dynamics.Joints.b2JointDef), y.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, y.b2LineJointDef = function() {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s(), this.localAnchorB = new s(), this.localAxisA = new s();
  }, y.prototype.b2LineJointDef = function() {
    this.__super.b2JointDef.call(this), this.type = f.e_lineJoint, this.localAxisA.Set(1, 0), this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorForce = 0, this.motorSpeed = 0;
  }, y.prototype.Initialize = function(w, L, G, I) {
    this.bodyA = w, this.bodyB = L, this.localAnchorA = (this || window).bodyA.GetLocalPoint(G), this.localAnchorB = (this || window).bodyB.GetLocalPoint(G), this.localAxisA = (this || window).bodyA.GetLocalVector(I);
  }, Box2D.inherit(A, Box2D.Dynamics.Joints.b2Joint), A.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, A.b2MouseJoint = function() {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new e(), this.K1 = new e(), this.K2 = new e(), this.m_localAnchor = new s(), this.m_target = new s(), this.m_impulse = new s(), this.m_mass = new e(), this.m_C = new s();
  }, A.prototype.GetAnchorA = function() {
    return this.m_target;
  }, A.prototype.GetAnchorB = function() {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
  }, A.prototype.GetReactionForce = function(w) {
    return w === void 0 && (w = 0), new s(w * this.m_impulse.x, w * this.m_impulse.y);
  }, A.prototype.GetReactionTorque = function(w) {
    return 0;
  }, A.prototype.GetTarget = function() {
    return this.m_target;
  }, A.prototype.SetTarget = function(w) {
    this.m_bodyB.IsAwake() == !1 && this.m_bodyB.SetAwake(!0), this.m_target = w;
  }, A.prototype.GetMaxForce = function() {
    return this.m_maxForce;
  }, A.prototype.SetMaxForce = function(w) {
    w === void 0 && (w = 0), this.m_maxForce = w;
  }, A.prototype.GetFrequency = function() {
    return this.m_frequencyHz;
  }, A.prototype.SetFrequency = function(w) {
    w === void 0 && (w = 0), this.m_frequencyHz = w;
  }, A.prototype.GetDampingRatio = function() {
    return this.m_dampingRatio;
  }, A.prototype.SetDampingRatio = function(w) {
    w === void 0 && (w = 0), this.m_dampingRatio = w;
  }, A.prototype.b2MouseJoint = function(w) {
    this.__super.b2Joint.call(this, w), this.m_target.SetV(w.target);
    var L = (this || window).m_target.x - this.m_bodyB.m_xf.position.x, G = (this || window).m_target.y - this.m_bodyB.m_xf.position.y, I = (this || window).m_bodyB.m_xf.R;
    this.m_localAnchor.x = L * I.col1.x + G * I.col1.y, this.m_localAnchor.y = L * I.col2.x + G * I.col2.y, this.m_maxForce = w.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = w.frequencyHz, this.m_dampingRatio = w.dampingRatio, this.m_beta = 0, this.m_gamma = 0;
  }, A.prototype.InitVelocityConstraints = function(w) {
    var L = (this || window).m_bodyB, G = L.GetMass(), I = 2 * Math.PI * this.m_frequencyHz, O = 2 * G * this.m_dampingRatio * I, K = G * I * I;
    this.m_gamma = w.dt * (O + w.dt * K), this.m_gamma = (this || window).m_gamma != 0 ? 1 / this.m_gamma : 0, this.m_beta = w.dt * K * this.m_gamma;
    var $;
    $ = L.m_xf.R;
    var S = (this || window).m_localAnchor.x - L.m_sweep.localCenter.x, b = (this || window).m_localAnchor.y - L.m_sweep.localCenter.y, W = $.col1.x * S + $.col2.x * b;
    b = $.col1.y * S + $.col2.y * b, S = W;
    var x = L.m_invMass, E = L.m_invI;
    this.K1.col1.x = x, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = x, this.K2.col1.x = E * b * b, this.K2.col2.x = -E * S * b, this.K2.col1.y = -E * S * b, this.K2.col2.y = E * S * S, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.col1.x += (this || window).m_gamma, this.K.col2.y += (this || window).m_gamma, this.K.GetInverse(this.m_mass), this.m_C.x = L.m_sweep.c.x + S - this.m_target.x, this.m_C.y = L.m_sweep.c.y + b - this.m_target.y, L.m_angularVelocity *= 0.98, this.m_impulse.x *= w.dtRatio, this.m_impulse.y *= w.dtRatio, L.m_linearVelocity.x += x * this.m_impulse.x, L.m_linearVelocity.y += x * this.m_impulse.y, L.m_angularVelocity += E * (S * this.m_impulse.y - b * this.m_impulse.x);
  }, A.prototype.SolveVelocityConstraints = function(w) {
    var L = (this || window).m_bodyB, G, I = 0, O = 0;
    G = L.m_xf.R;
    var K = (this || window).m_localAnchor.x - L.m_sweep.localCenter.x, $ = (this || window).m_localAnchor.y - L.m_sweep.localCenter.y;
    I = G.col1.x * K + G.col2.x * $, $ = G.col1.y * K + G.col2.y * $, K = I;
    var S = L.m_linearVelocity.x + -L.m_angularVelocity * $, b = L.m_linearVelocity.y + L.m_angularVelocity * K;
    G = (this || window).m_mass, I = S + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x, O = b + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
    var W = -(G.col1.x * I + G.col2.x * O), x = -(G.col1.y * I + G.col2.y * O), E = (this || window).m_impulse.x, R = (this || window).m_impulse.y;
    this.m_impulse.x += W, this.m_impulse.y += x;
    var F = w.dt * this.m_maxForce;
    this.m_impulse.LengthSquared() > F * F && this.m_impulse.Multiply(F / this.m_impulse.Length()), W = (this || window).m_impulse.x - E, x = (this || window).m_impulse.y - R, L.m_linearVelocity.x += L.m_invMass * W, L.m_linearVelocity.y += L.m_invMass * x, L.m_angularVelocity += L.m_invI * (K * x - $ * W);
  }, A.prototype.SolvePositionConstraints = function(w) {
    return !0;
  }, Box2D.inherit(D, Box2D.Dynamics.Joints.b2JointDef), D.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, D.b2MouseJointDef = function() {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.target = new s();
  }, D.prototype.b2MouseJointDef = function() {
    this.__super.b2JointDef.call(this), this.type = f.e_mouseJoint, this.maxForce = 0, this.frequencyHz = 5, this.dampingRatio = 0.7;
  }, Box2D.inherit(N, Box2D.Dynamics.Joints.b2Joint), N.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, N.b2PrismaticJoint = function() {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchor1 = new s(), this.m_localAnchor2 = new s(), this.m_localXAxis1 = new s(), this.m_localYAxis1 = new s(), this.m_axis = new s(), this.m_perp = new s(), this.m_K = new n(), this.m_impulse = new o();
  }, N.prototype.GetAnchorA = function() {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  }, N.prototype.GetAnchorB = function() {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  }, N.prototype.GetReactionForce = function(w) {
    return w === void 0 && (w = 0), new s(w * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), w * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
  }, N.prototype.GetReactionTorque = function(w) {
    return w === void 0 && (w = 0), w * this.m_impulse.y;
  }, N.prototype.GetJointTranslation = function() {
    var w = (this || window).m_bodyA, L = (this || window).m_bodyB, G = w.GetWorldPoint(this.m_localAnchor1), I = L.GetWorldPoint(this.m_localAnchor2), O = I.x - G.x, K = I.y - G.y, $ = w.GetWorldVector(this.m_localXAxis1), S = $.x * O + $.y * K;
    return S;
  }, N.prototype.GetJointSpeed = function() {
    var w = (this || window).m_bodyA, L = (this || window).m_bodyB, G;
    G = w.m_xf.R;
    var I = (this || window).m_localAnchor1.x - w.m_sweep.localCenter.x, O = (this || window).m_localAnchor1.y - w.m_sweep.localCenter.y, K = G.col1.x * I + G.col2.x * O;
    O = G.col1.y * I + G.col2.y * O, I = K, G = L.m_xf.R;
    var $ = (this || window).m_localAnchor2.x - L.m_sweep.localCenter.x, S = (this || window).m_localAnchor2.y - L.m_sweep.localCenter.y;
    K = G.col1.x * $ + G.col2.x * S, S = G.col1.y * $ + G.col2.y * S, $ = K;
    var b = w.m_sweep.c.x + I, W = w.m_sweep.c.y + O, x = L.m_sweep.c.x + $, E = L.m_sweep.c.y + S, R = x - b, F = E - W, k = w.GetWorldVector(this.m_localXAxis1), X = w.m_linearVelocity, j = L.m_linearVelocity, V = w.m_angularVelocity, Y = L.m_angularVelocity, tt = R * (-V * k.y) + F * (V * k.x) + (k.x * (j.x + -Y * S - X.x - -V * O) + k.y * (j.y + Y * $ - X.y - V * I));
    return tt;
  }, N.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit;
  }, N.prototype.EnableLimit = function(w) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = w;
  }, N.prototype.GetLowerLimit = function() {
    return this.m_lowerTranslation;
  }, N.prototype.GetUpperLimit = function() {
    return this.m_upperTranslation;
  }, N.prototype.SetLimits = function(w, L) {
    w === void 0 && (w = 0), L === void 0 && (L = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = w, this.m_upperTranslation = L;
  }, N.prototype.IsMotorEnabled = function() {
    return this.m_enableMotor;
  }, N.prototype.EnableMotor = function(w) {
    this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = w;
  }, N.prototype.SetMotorSpeed = function(w) {
    w === void 0 && (w = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = w;
  }, N.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed;
  }, N.prototype.SetMaxMotorForce = function(w) {
    w === void 0 && (w = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = w;
  }, N.prototype.GetMotorForce = function() {
    return this.m_motorImpulse;
  }, N.prototype.b2PrismaticJoint = function(w) {
    this.__super.b2Joint.call(this, w), this.m_localAnchor1.SetV(w.localAnchorA), this.m_localAnchor2.SetV(w.localAnchorB), this.m_localXAxis1.SetV(w.localAxisA), this.m_localYAxis1.x = -this.m_localXAxis1.y, this.m_localYAxis1.y = (this || window).m_localXAxis1.x, this.m_refAngle = w.referenceAngle, this.m_impulse.SetZero(), this.m_motorMass = 0, this.m_motorImpulse = 0, this.m_lowerTranslation = w.lowerTranslation, this.m_upperTranslation = w.upperTranslation, this.m_maxMotorForce = w.maxMotorForce, this.m_motorSpeed = w.motorSpeed, this.m_enableLimit = w.enableLimit, this.m_enableMotor = w.enableMotor, this.m_limitState = f.e_inactiveLimit, this.m_axis.SetZero(), this.m_perp.SetZero();
  }, N.prototype.InitVelocityConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I, O = 0;
    this.m_localCenterA.SetV(L.GetLocalCenter()), this.m_localCenterB.SetV(G.GetLocalCenter());
    var K = L.GetTransform();
    G.GetTransform(), I = L.m_xf.R;
    var $ = (this || window).m_localAnchor1.x - this.m_localCenterA.x, S = (this || window).m_localAnchor1.y - this.m_localCenterA.y;
    O = I.col1.x * $ + I.col2.x * S, S = I.col1.y * $ + I.col2.y * S, $ = O, I = G.m_xf.R;
    var b = (this || window).m_localAnchor2.x - this.m_localCenterB.x, W = (this || window).m_localAnchor2.y - this.m_localCenterB.y;
    O = I.col1.x * b + I.col2.x * W, W = I.col1.y * b + I.col2.y * W, b = O;
    var x = G.m_sweep.c.x + b - L.m_sweep.c.x - $, E = G.m_sweep.c.y + W - L.m_sweep.c.y - S;
    this.m_invMassA = L.m_invMass, this.m_invMassB = G.m_invMass, this.m_invIA = L.m_invI, this.m_invIB = G.m_invI, this.m_axis.SetV(r.MulMV(K.R, this.m_localXAxis1)), this.m_a1 = (x + $) * this.m_axis.y - (E + S) * this.m_axis.x, this.m_a2 = b * this.m_axis.y - W * this.m_axis.x, this.m_motorMass = (this || window).m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2, this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass);
    {
      this.m_perp.SetV(r.MulMV(K.R, this.m_localYAxis1)), this.m_s1 = (x + $) * this.m_perp.y - (E + S) * this.m_perp.x, this.m_s2 = b * this.m_perp.y - W * this.m_perp.x;
      var R = (this || window).m_invMassA, F = (this || window).m_invMassB, k = (this || window).m_invIA, X = (this || window).m_invIB;
      this.m_K.col1.x = R + F + k * this.m_s1 * this.m_s1 + X * this.m_s2 * this.m_s2, this.m_K.col1.y = k * this.m_s1 + X * this.m_s2, this.m_K.col1.z = k * this.m_s1 * this.m_a1 + X * this.m_s2 * this.m_a2, this.m_K.col2.x = (this || window).m_K.col1.y, this.m_K.col2.y = k + X, this.m_K.col2.z = k * this.m_a1 + X * this.m_a2, this.m_K.col3.x = (this || window).m_K.col1.z, this.m_K.col3.y = (this || window).m_K.col2.z, this.m_K.col3.z = R + F + k * this.m_a1 * this.m_a1 + X * this.m_a2 * this.m_a2;
    }
    if (this.m_enableLimit) {
      var j = (this || window).m_axis.x * x + this.m_axis.y * E;
      r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? this.m_limitState = f.e_equalLimits : j <= (this || window).m_lowerTranslation ? this.m_limitState != f.e_atLowerLimit && (this.m_limitState = f.e_atLowerLimit, this.m_impulse.z = 0) : j >= (this || window).m_upperTranslation ? this.m_limitState != f.e_atUpperLimit && (this.m_limitState = f.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = f.e_inactiveLimit, this.m_impulse.z = 0);
    } else
      this.m_limitState = f.e_inactiveLimit;
    if (this.m_enableMotor == !1 && (this.m_motorImpulse = 0), w.warmStarting) {
      this.m_impulse.x *= w.dtRatio, this.m_impulse.y *= w.dtRatio, this.m_motorImpulse *= w.dtRatio;
      var V = (this || window).m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x, Y = (this || window).m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y, tt = (this || window).m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1, it = (this || window).m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
      L.m_linearVelocity.x -= (this || window).m_invMassA * V, L.m_linearVelocity.y -= (this || window).m_invMassA * Y, L.m_angularVelocity -= (this || window).m_invIA * tt, G.m_linearVelocity.x += (this || window).m_invMassB * V, G.m_linearVelocity.y += (this || window).m_invMassB * Y, G.m_angularVelocity += (this || window).m_invIB * it;
    } else
      this.m_impulse.SetZero(), this.m_motorImpulse = 0;
  }, N.prototype.SolveVelocityConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I = L.m_linearVelocity, O = L.m_angularVelocity, K = G.m_linearVelocity, $ = G.m_angularVelocity, S = 0, b = 0, W = 0, x = 0;
    if (this.m_enableMotor && this.m_limitState != f.e_equalLimits) {
      var E = (this || window).m_axis.x * (K.x - I.x) + this.m_axis.y * (K.y - I.y) + this.m_a2 * $ - this.m_a1 * O, R = (this || window).m_motorMass * (this.m_motorSpeed - E), F = (this || window).m_motorImpulse, k = w.dt * this.m_maxMotorForce;
      this.m_motorImpulse = r.Clamp(this.m_motorImpulse + R, -k, k), R = (this || window).m_motorImpulse - F, S = R * this.m_axis.x, b = R * this.m_axis.y, W = R * this.m_a1, x = R * this.m_a2, I.x -= (this || window).m_invMassA * S, I.y -= (this || window).m_invMassA * b, O -= (this || window).m_invIA * W, K.x += (this || window).m_invMassB * S, K.y += (this || window).m_invMassB * b, $ += (this || window).m_invIB * x;
    }
    var X = (this || window).m_perp.x * (K.x - I.x) + this.m_perp.y * (K.y - I.y) + this.m_s2 * $ - this.m_s1 * O, j = $ - O;
    if (this.m_enableLimit && this.m_limitState != f.e_inactiveLimit) {
      var V = (this || window).m_axis.x * (K.x - I.x) + this.m_axis.y * (K.y - I.y) + this.m_a2 * $ - this.m_a1 * O, Y = (this || window).m_impulse.Copy(), tt = (this || window).m_K.Solve33(new o(), -X, -j, -V);
      this.m_impulse.Add(tt), this.m_limitState == f.e_atLowerLimit ? this.m_impulse.z = r.Max(this.m_impulse.z, 0) : this.m_limitState == f.e_atUpperLimit && (this.m_impulse.z = r.Min(this.m_impulse.z, 0));
      var it = -X - (this.m_impulse.z - Y.z) * this.m_K.col3.x, lt = -j - (this.m_impulse.z - Y.z) * this.m_K.col3.y, ut = (this || window).m_K.Solve22(new s(), it, lt);
      ut.x += Y.x, ut.y += Y.y, this.m_impulse.x = ut.x, this.m_impulse.y = ut.y, tt.x = (this || window).m_impulse.x - Y.x, tt.y = (this || window).m_impulse.y - Y.y, tt.z = (this || window).m_impulse.z - Y.z, S = tt.x * this.m_perp.x + tt.z * this.m_axis.x, b = tt.x * this.m_perp.y + tt.z * this.m_axis.y, W = tt.x * this.m_s1 + tt.y + tt.z * this.m_a1, x = tt.x * this.m_s2 + tt.y + tt.z * this.m_a2, I.x -= (this || window).m_invMassA * S, I.y -= (this || window).m_invMassA * b, O -= (this || window).m_invIA * W, K.x += (this || window).m_invMassB * S, K.y += (this || window).m_invMassB * b, $ += (this || window).m_invIB * x;
    } else {
      var ft = (this || window).m_K.Solve22(new s(), -X, -j);
      this.m_impulse.x += ft.x, this.m_impulse.y += ft.y, S = ft.x * this.m_perp.x, b = ft.x * this.m_perp.y, W = ft.x * this.m_s1 + ft.y, x = ft.x * this.m_s2 + ft.y, I.x -= (this || window).m_invMassA * S, I.y -= (this || window).m_invMassA * b, O -= (this || window).m_invIA * W, K.x += (this || window).m_invMassB * S, K.y += (this || window).m_invMassB * b, $ += (this || window).m_invIB * x;
    }
    L.m_linearVelocity.SetV(I), L.m_angularVelocity = O, G.m_linearVelocity.SetV(K), G.m_angularVelocity = $;
  }, N.prototype.SolvePositionConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I = L.m_sweep.c, O = L.m_sweep.a, K = G.m_sweep.c, $ = G.m_sweep.a, S, b = 0, W = 0, x = 0, E = 0, R = 0, F = 0, k = 0, X = !1, j = 0, V = e.FromAngle(O), Y = e.FromAngle($);
    S = V;
    var tt = (this || window).m_localAnchor1.x - this.m_localCenterA.x, it = (this || window).m_localAnchor1.y - this.m_localCenterA.y;
    b = S.col1.x * tt + S.col2.x * it, it = S.col1.y * tt + S.col2.y * it, tt = b, S = Y;
    var lt = (this || window).m_localAnchor2.x - this.m_localCenterB.x, ut = (this || window).m_localAnchor2.y - this.m_localCenterB.y;
    b = S.col1.x * lt + S.col2.x * ut, ut = S.col1.y * lt + S.col2.y * ut, lt = b;
    var ft = K.x + lt - I.x - tt, vt = K.y + ut - I.y - it;
    if (this.m_enableLimit) {
      this.m_axis = r.MulMV(V, this.m_localXAxis1), this.m_a1 = (ft + tt) * this.m_axis.y - (vt + it) * this.m_axis.x, this.m_a2 = lt * this.m_axis.y - ut * this.m_axis.x;
      var pt = (this || window).m_axis.x * ft + this.m_axis.y * vt;
      r.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * t.b2_linearSlop ? (j = r.Clamp(pt, -t.b2_maxLinearCorrection, t.b2_maxLinearCorrection), F = r.Abs(pt), X = !0) : pt <= (this || window).m_lowerTranslation ? (j = r.Clamp(pt - this.m_lowerTranslation + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), F = (this || window).m_lowerTranslation - pt, X = !0) : pt >= (this || window).m_upperTranslation && (j = r.Clamp(pt - this.m_upperTranslation + t.b2_linearSlop, 0, t.b2_maxLinearCorrection), F = pt - this.m_upperTranslation, X = !0);
    }
    this.m_perp = r.MulMV(V, this.m_localYAxis1), this.m_s1 = (ft + tt) * this.m_perp.y - (vt + it) * this.m_perp.x, this.m_s2 = lt * this.m_perp.y - ut * this.m_perp.x;
    var gt = new o(), St = (this || window).m_perp.x * ft + this.m_perp.y * vt, ht = $ - O - this.m_refAngle;
    if (F = r.Max(F, r.Abs(St)), k = r.Abs(ht), X)
      W = (this || window).m_invMassA, x = (this || window).m_invMassB, E = (this || window).m_invIA, R = (this || window).m_invIB, this.m_K.col1.x = W + x + E * this.m_s1 * this.m_s1 + R * this.m_s2 * this.m_s2, this.m_K.col1.y = E * this.m_s1 + R * this.m_s2, this.m_K.col1.z = E * this.m_s1 * this.m_a1 + R * this.m_s2 * this.m_a2, this.m_K.col2.x = (this || window).m_K.col1.y, this.m_K.col2.y = E + R, this.m_K.col2.z = E * this.m_a1 + R * this.m_a2, this.m_K.col3.x = (this || window).m_K.col1.z, this.m_K.col3.y = (this || window).m_K.col2.z, this.m_K.col3.z = W + x + E * this.m_a1 * this.m_a1 + R * this.m_a2 * this.m_a2, this.m_K.Solve33(gt, -St, -ht, -j);
    else {
      W = (this || window).m_invMassA, x = (this || window).m_invMassB, E = (this || window).m_invIA, R = (this || window).m_invIB;
      var ct = W + x + E * this.m_s1 * this.m_s1 + R * this.m_s2 * this.m_s2, bt = E * this.m_s1 + R * this.m_s2, Et = E + R;
      this.m_K.col1.Set(ct, bt, 0), this.m_K.col2.Set(bt, Et, 0);
      var wt = (this || window).m_K.Solve22(new s(), -St, -ht);
      gt.x = wt.x, gt.y = wt.y, gt.z = 0;
    }
    var It = gt.x * this.m_perp.x + gt.z * this.m_axis.x, Dt = gt.x * this.m_perp.y + gt.z * this.m_axis.y, Ut = gt.x * this.m_s1 + gt.y + gt.z * this.m_a1, Gt = gt.x * this.m_s2 + gt.y + gt.z * this.m_a2;
    return I.x -= (this || window).m_invMassA * It, I.y -= (this || window).m_invMassA * Dt, O -= (this || window).m_invIA * Ut, K.x += (this || window).m_invMassB * It, K.y += (this || window).m_invMassB * Dt, $ += (this || window).m_invIB * Gt, L.m_sweep.a = O, G.m_sweep.a = $, L.SynchronizeTransform(), G.SynchronizeTransform(), F <= t.b2_linearSlop && k <= t.b2_angularSlop;
  }, Box2D.inherit(z, Box2D.Dynamics.Joints.b2JointDef), z.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, z.b2PrismaticJointDef = function() {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s(), this.localAnchorB = new s(), this.localAxisA = new s();
  }, z.prototype.b2PrismaticJointDef = function() {
    this.__super.b2JointDef.call(this), this.type = f.e_prismaticJoint, this.localAxisA.Set(1, 0), this.referenceAngle = 0, this.enableLimit = !1, this.lowerTranslation = 0, this.upperTranslation = 0, this.enableMotor = !1, this.maxMotorForce = 0, this.motorSpeed = 0;
  }, z.prototype.Initialize = function(w, L, G, I) {
    this.bodyA = w, this.bodyB = L, this.localAnchorA = (this || window).bodyA.GetLocalPoint(G), this.localAnchorB = (this || window).bodyB.GetLocalPoint(G), this.localAxisA = (this || window).bodyA.GetLocalVector(I), this.referenceAngle = (this || window).bodyB.GetAngle() - this.bodyA.GetAngle();
  }, Box2D.inherit(M, Box2D.Dynamics.Joints.b2Joint), M.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, M.b2PulleyJoint = function() {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_groundAnchor1 = new s(), this.m_groundAnchor2 = new s(), this.m_localAnchor1 = new s(), this.m_localAnchor2 = new s(), this.m_u1 = new s(), this.m_u2 = new s();
  }, M.prototype.GetAnchorA = function() {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  }, M.prototype.GetAnchorB = function() {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  }, M.prototype.GetReactionForce = function(w) {
    return w === void 0 && (w = 0), new s(w * this.m_impulse * this.m_u2.x, w * this.m_impulse * this.m_u2.y);
  }, M.prototype.GetReactionTorque = function(w) {
    return 0;
  }, M.prototype.GetGroundAnchorA = function() {
    var w = (this || window).m_ground.m_xf.position.Copy();
    return w.Add(this.m_groundAnchor1), w;
  }, M.prototype.GetGroundAnchorB = function() {
    var w = (this || window).m_ground.m_xf.position.Copy();
    return w.Add(this.m_groundAnchor2), w;
  }, M.prototype.GetLength1 = function() {
    var w = (this || window).m_bodyA.GetWorldPoint(this.m_localAnchor1), L = (this || window).m_ground.m_xf.position.x + this.m_groundAnchor1.x, G = (this || window).m_ground.m_xf.position.y + this.m_groundAnchor1.y, I = w.x - L, O = w.y - G;
    return Math.sqrt(I * I + O * O);
  }, M.prototype.GetLength2 = function() {
    var w = (this || window).m_bodyB.GetWorldPoint(this.m_localAnchor2), L = (this || window).m_ground.m_xf.position.x + this.m_groundAnchor2.x, G = (this || window).m_ground.m_xf.position.y + this.m_groundAnchor2.y, I = w.x - L, O = w.y - G;
    return Math.sqrt(I * I + O * O);
  }, M.prototype.GetRatio = function() {
    return this.m_ratio;
  }, M.prototype.b2PulleyJoint = function(w) {
    this.__super.b2Joint.call(this, w), this.m_ground = (this || window).m_bodyA.m_world.m_groundBody, this.m_groundAnchor1.x = w.groundAnchorA.x - this.m_ground.m_xf.position.x, this.m_groundAnchor1.y = w.groundAnchorA.y - this.m_ground.m_xf.position.y, this.m_groundAnchor2.x = w.groundAnchorB.x - this.m_ground.m_xf.position.x, this.m_groundAnchor2.y = w.groundAnchorB.y - this.m_ground.m_xf.position.y, this.m_localAnchor1.SetV(w.localAnchorA), this.m_localAnchor2.SetV(w.localAnchorB), this.m_ratio = w.ratio, this.m_constant = w.lengthA + this.m_ratio * w.lengthB, this.m_maxLength1 = r.Min(w.maxLengthA, this.m_constant - this.m_ratio * M.b2_minPulleyLength), this.m_maxLength2 = r.Min(w.maxLengthB, (this.m_constant - M.b2_minPulleyLength) / this.m_ratio), this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0;
  }, M.prototype.InitVelocityConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I;
    I = L.m_xf.R;
    var O = (this || window).m_localAnchor1.x - L.m_sweep.localCenter.x, K = (this || window).m_localAnchor1.y - L.m_sweep.localCenter.y, $ = I.col1.x * O + I.col2.x * K;
    K = I.col1.y * O + I.col2.y * K, O = $, I = G.m_xf.R;
    var S = (this || window).m_localAnchor2.x - G.m_sweep.localCenter.x, b = (this || window).m_localAnchor2.y - G.m_sweep.localCenter.y;
    $ = I.col1.x * S + I.col2.x * b, b = I.col1.y * S + I.col2.y * b, S = $;
    var W = L.m_sweep.c.x + O, x = L.m_sweep.c.y + K, E = G.m_sweep.c.x + S, R = G.m_sweep.c.y + b, F = (this || window).m_ground.m_xf.position.x + this.m_groundAnchor1.x, k = (this || window).m_ground.m_xf.position.y + this.m_groundAnchor1.y, X = (this || window).m_ground.m_xf.position.x + this.m_groundAnchor2.x, j = (this || window).m_ground.m_xf.position.y + this.m_groundAnchor2.y;
    this.m_u1.Set(W - F, x - k), this.m_u2.Set(E - X, R - j);
    var V = (this || window).m_u1.Length(), Y = (this || window).m_u2.Length();
    V > t.b2_linearSlop ? this.m_u1.Multiply(1 / V) : this.m_u1.SetZero(), Y > t.b2_linearSlop ? this.m_u2.Multiply(1 / Y) : this.m_u2.SetZero();
    var tt = (this || window).m_constant - V - this.m_ratio * Y;
    tt > 0 ? (this.m_state = f.e_inactiveLimit, this.m_impulse = 0) : this.m_state = f.e_atUpperLimit, V < this.m_maxLength1 ? (this.m_limitState1 = f.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = f.e_atUpperLimit, Y < this.m_maxLength2 ? (this.m_limitState2 = f.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = f.e_atUpperLimit;
    var it = O * this.m_u1.y - K * this.m_u1.x, lt = S * this.m_u2.y - b * this.m_u2.x;
    if (this.m_limitMass1 = L.m_invMass + L.m_invI * it * it, this.m_limitMass2 = G.m_invMass + G.m_invI * lt * lt, this.m_pulleyMass = (this || window).m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2, this.m_limitMass1 = 1 / this.m_limitMass1, this.m_limitMass2 = 1 / this.m_limitMass2, this.m_pulleyMass = 1 / this.m_pulleyMass, w.warmStarting) {
      this.m_impulse *= w.dtRatio, this.m_limitImpulse1 *= w.dtRatio, this.m_limitImpulse2 *= w.dtRatio;
      var ut = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x, ft = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y, vt = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x, pt = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
      L.m_linearVelocity.x += L.m_invMass * ut, L.m_linearVelocity.y += L.m_invMass * ft, L.m_angularVelocity += L.m_invI * (O * ft - K * ut), G.m_linearVelocity.x += G.m_invMass * vt, G.m_linearVelocity.y += G.m_invMass * pt, G.m_angularVelocity += G.m_invI * (S * pt - b * vt);
    } else
      this.m_impulse = 0, this.m_limitImpulse1 = 0, this.m_limitImpulse2 = 0;
  }, M.prototype.SolveVelocityConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I;
    I = L.m_xf.R;
    var O = (this || window).m_localAnchor1.x - L.m_sweep.localCenter.x, K = (this || window).m_localAnchor1.y - L.m_sweep.localCenter.y, $ = I.col1.x * O + I.col2.x * K;
    K = I.col1.y * O + I.col2.y * K, O = $, I = G.m_xf.R;
    var S = (this || window).m_localAnchor2.x - G.m_sweep.localCenter.x, b = (this || window).m_localAnchor2.y - G.m_sweep.localCenter.y;
    $ = I.col1.x * S + I.col2.x * b, b = I.col1.y * S + I.col2.y * b, S = $;
    var W = 0, x = 0, E = 0, R = 0, F = 0, k = 0, X = 0, j = 0, V = 0, Y = 0, tt = 0;
    this.m_state == f.e_atUpperLimit && (W = L.m_linearVelocity.x + -L.m_angularVelocity * K, x = L.m_linearVelocity.y + L.m_angularVelocity * O, E = G.m_linearVelocity.x + -G.m_angularVelocity * b, R = G.m_linearVelocity.y + G.m_angularVelocity * S, V = -(this.m_u1.x * W + this.m_u1.y * x) - this.m_ratio * (this.m_u2.x * E + this.m_u2.y * R), Y = (this || window).m_pulleyMass * -V, tt = (this || window).m_impulse, this.m_impulse = r.Max(0, this.m_impulse + Y), Y = (this || window).m_impulse - tt, F = -Y * this.m_u1.x, k = -Y * this.m_u1.y, X = -this.m_ratio * Y * this.m_u2.x, j = -this.m_ratio * Y * this.m_u2.y, L.m_linearVelocity.x += L.m_invMass * F, L.m_linearVelocity.y += L.m_invMass * k, L.m_angularVelocity += L.m_invI * (O * k - K * F), G.m_linearVelocity.x += G.m_invMass * X, G.m_linearVelocity.y += G.m_invMass * j, G.m_angularVelocity += G.m_invI * (S * j - b * X)), this.m_limitState1 == f.e_atUpperLimit && (W = L.m_linearVelocity.x + -L.m_angularVelocity * K, x = L.m_linearVelocity.y + L.m_angularVelocity * O, V = -(this.m_u1.x * W + this.m_u1.y * x), Y = -this.m_limitMass1 * V, tt = (this || window).m_limitImpulse1, this.m_limitImpulse1 = r.Max(0, this.m_limitImpulse1 + Y), Y = (this || window).m_limitImpulse1 - tt, F = -Y * this.m_u1.x, k = -Y * this.m_u1.y, L.m_linearVelocity.x += L.m_invMass * F, L.m_linearVelocity.y += L.m_invMass * k, L.m_angularVelocity += L.m_invI * (O * k - K * F)), this.m_limitState2 == f.e_atUpperLimit && (E = G.m_linearVelocity.x + -G.m_angularVelocity * b, R = G.m_linearVelocity.y + G.m_angularVelocity * S, V = -(this.m_u2.x * E + this.m_u2.y * R), Y = -this.m_limitMass2 * V, tt = (this || window).m_limitImpulse2, this.m_limitImpulse2 = r.Max(0, this.m_limitImpulse2 + Y), Y = (this || window).m_limitImpulse2 - tt, X = -Y * this.m_u2.x, j = -Y * this.m_u2.y, G.m_linearVelocity.x += G.m_invMass * X, G.m_linearVelocity.y += G.m_invMass * j, G.m_angularVelocity += G.m_invI * (S * j - b * X));
  }, M.prototype.SolvePositionConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I, O = (this || window).m_ground.m_xf.position.x + this.m_groundAnchor1.x, K = (this || window).m_ground.m_xf.position.y + this.m_groundAnchor1.y, $ = (this || window).m_ground.m_xf.position.x + this.m_groundAnchor2.x, S = (this || window).m_ground.m_xf.position.y + this.m_groundAnchor2.y, b = 0, W = 0, x = 0, E = 0, R = 0, F = 0, k = 0, X = 0, j = 0, V = 0, Y = 0, tt = 0, it = 0, lt = 0;
    return this.m_state == f.e_atUpperLimit && (I = L.m_xf.R, b = (this || window).m_localAnchor1.x - L.m_sweep.localCenter.x, W = (this || window).m_localAnchor1.y - L.m_sweep.localCenter.y, it = I.col1.x * b + I.col2.x * W, W = I.col1.y * b + I.col2.y * W, b = it, I = G.m_xf.R, x = (this || window).m_localAnchor2.x - G.m_sweep.localCenter.x, E = (this || window).m_localAnchor2.y - G.m_sweep.localCenter.y, it = I.col1.x * x + I.col2.x * E, E = I.col1.y * x + I.col2.y * E, x = it, R = L.m_sweep.c.x + b, F = L.m_sweep.c.y + W, k = G.m_sweep.c.x + x, X = G.m_sweep.c.y + E, this.m_u1.Set(R - O, F - K), this.m_u2.Set(k - $, X - S), j = (this || window).m_u1.Length(), V = (this || window).m_u2.Length(), j > t.b2_linearSlop ? this.m_u1.Multiply(1 / j) : this.m_u1.SetZero(), V > t.b2_linearSlop ? this.m_u2.Multiply(1 / V) : this.m_u2.SetZero(), Y = (this || window).m_constant - j - this.m_ratio * V, lt = r.Max(lt, -Y), Y = r.Clamp(Y + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), tt = -this.m_pulleyMass * Y, R = -tt * this.m_u1.x, F = -tt * this.m_u1.y, k = -this.m_ratio * tt * this.m_u2.x, X = -this.m_ratio * tt * this.m_u2.y, L.m_sweep.c.x += L.m_invMass * R, L.m_sweep.c.y += L.m_invMass * F, L.m_sweep.a += L.m_invI * (b * F - W * R), G.m_sweep.c.x += G.m_invMass * k, G.m_sweep.c.y += G.m_invMass * X, G.m_sweep.a += G.m_invI * (x * X - E * k), L.SynchronizeTransform(), G.SynchronizeTransform()), this.m_limitState1 == f.e_atUpperLimit && (I = L.m_xf.R, b = (this || window).m_localAnchor1.x - L.m_sweep.localCenter.x, W = (this || window).m_localAnchor1.y - L.m_sweep.localCenter.y, it = I.col1.x * b + I.col2.x * W, W = I.col1.y * b + I.col2.y * W, b = it, R = L.m_sweep.c.x + b, F = L.m_sweep.c.y + W, this.m_u1.Set(R - O, F - K), j = (this || window).m_u1.Length(), j > t.b2_linearSlop ? (this.m_u1.x *= 1 / j, this.m_u1.y *= 1 / j) : this.m_u1.SetZero(), Y = (this || window).m_maxLength1 - j, lt = r.Max(lt, -Y), Y = r.Clamp(Y + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), tt = -this.m_limitMass1 * Y, R = -tt * this.m_u1.x, F = -tt * this.m_u1.y, L.m_sweep.c.x += L.m_invMass * R, L.m_sweep.c.y += L.m_invMass * F, L.m_sweep.a += L.m_invI * (b * F - W * R), L.SynchronizeTransform()), this.m_limitState2 == f.e_atUpperLimit && (I = G.m_xf.R, x = (this || window).m_localAnchor2.x - G.m_sweep.localCenter.x, E = (this || window).m_localAnchor2.y - G.m_sweep.localCenter.y, it = I.col1.x * x + I.col2.x * E, E = I.col1.y * x + I.col2.y * E, x = it, k = G.m_sweep.c.x + x, X = G.m_sweep.c.y + E, this.m_u2.Set(k - $, X - S), V = (this || window).m_u2.Length(), V > t.b2_linearSlop ? (this.m_u2.x *= 1 / V, this.m_u2.y *= 1 / V) : this.m_u2.SetZero(), Y = (this || window).m_maxLength2 - V, lt = r.Max(lt, -Y), Y = r.Clamp(Y + t.b2_linearSlop, -t.b2_maxLinearCorrection, 0), tt = -this.m_limitMass2 * Y, k = -tt * this.m_u2.x, X = -tt * this.m_u2.y, G.m_sweep.c.x += G.m_invMass * k, G.m_sweep.c.y += G.m_invMass * X, G.m_sweep.a += G.m_invI * (x * X - E * k), G.SynchronizeTransform()), lt < t.b2_linearSlop;
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2;
  }), Box2D.inherit(Z, Box2D.Dynamics.Joints.b2JointDef), Z.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, Z.b2PulleyJointDef = function() {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.groundAnchorA = new s(), this.groundAnchorB = new s(), this.localAnchorA = new s(), this.localAnchorB = new s();
  }, Z.prototype.b2PulleyJointDef = function() {
    this.__super.b2JointDef.call(this), this.type = f.e_pulleyJoint, this.groundAnchorA.Set(-1, 1), this.groundAnchorB.Set(1, 1), this.localAnchorA.Set(-1, 0), this.localAnchorB.Set(1, 0), this.lengthA = 0, this.maxLengthA = 0, this.lengthB = 0, this.maxLengthB = 0, this.ratio = 1, this.collideConnected = !0;
  }, Z.prototype.Initialize = function(w, L, G, I, O, K, $) {
    $ === void 0 && ($ = 0), this.bodyA = w, this.bodyB = L, this.groundAnchorA.SetV(G), this.groundAnchorB.SetV(I), this.localAnchorA = (this || window).bodyA.GetLocalPoint(O), this.localAnchorB = (this || window).bodyB.GetLocalPoint(K);
    var S = O.x - G.x, b = O.y - G.y;
    this.lengthA = Math.sqrt(S * S + b * b);
    var W = K.x - I.x, x = K.y - I.y;
    this.lengthB = Math.sqrt(W * W + x * x), this.ratio = $;
    var E = (this || window).lengthA + this.ratio * this.lengthB;
    this.maxLengthA = E - this.ratio * M.b2_minPulleyLength, this.maxLengthB = (E - M.b2_minPulleyLength) / this.ratio;
  }, Box2D.inherit(U, Box2D.Dynamics.Joints.b2Joint), U.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, U.b2RevoluteJoint = function() {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.K = new e(), this.K1 = new e(), this.K2 = new e(), this.K3 = new e(), this.impulse3 = new o(), this.impulse2 = new s(), this.reduced = new s(), this.m_localAnchor1 = new s(), this.m_localAnchor2 = new s(), this.m_impulse = new o(), this.m_mass = new n();
  }, U.prototype.GetAnchorA = function() {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  }, U.prototype.GetAnchorB = function() {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  }, U.prototype.GetReactionForce = function(w) {
    return w === void 0 && (w = 0), new s(w * this.m_impulse.x, w * this.m_impulse.y);
  }, U.prototype.GetReactionTorque = function(w) {
    return w === void 0 && (w = 0), w * this.m_impulse.z;
  }, U.prototype.GetJointAngle = function() {
    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
  }, U.prototype.GetJointSpeed = function() {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
  }, U.prototype.IsLimitEnabled = function() {
    return this.m_enableLimit;
  }, U.prototype.EnableLimit = function(w) {
    this.m_enableLimit = w;
  }, U.prototype.GetLowerLimit = function() {
    return this.m_lowerAngle;
  }, U.prototype.GetUpperLimit = function() {
    return this.m_upperAngle;
  }, U.prototype.SetLimits = function(w, L) {
    w === void 0 && (w = 0), L === void 0 && (L = 0), this.m_lowerAngle = w, this.m_upperAngle = L;
  }, U.prototype.IsMotorEnabled = function() {
    return this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor;
  }, U.prototype.EnableMotor = function(w) {
    this.m_enableMotor = w;
  }, U.prototype.SetMotorSpeed = function(w) {
    w === void 0 && (w = 0), this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = w;
  }, U.prototype.GetMotorSpeed = function() {
    return this.m_motorSpeed;
  }, U.prototype.SetMaxMotorTorque = function(w) {
    w === void 0 && (w = 0), this.m_maxMotorTorque = w;
  }, U.prototype.GetMotorTorque = function() {
    return this.m_maxMotorTorque;
  }, U.prototype.b2RevoluteJoint = function(w) {
    this.__super.b2Joint.call(this, w), this.m_localAnchor1.SetV(w.localAnchorA), this.m_localAnchor2.SetV(w.localAnchorB), this.m_referenceAngle = w.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = w.lowerAngle, this.m_upperAngle = w.upperAngle, this.m_maxMotorTorque = w.maxMotorTorque, this.m_motorSpeed = w.motorSpeed, this.m_enableLimit = w.enableLimit, this.m_enableMotor = w.enableMotor, this.m_limitState = f.e_inactiveLimit;
  }, U.prototype.InitVelocityConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I, O = 0;
    this.m_enableMotor || this.m_enableLimit, I = L.m_xf.R;
    var K = (this || window).m_localAnchor1.x - L.m_sweep.localCenter.x, $ = (this || window).m_localAnchor1.y - L.m_sweep.localCenter.y;
    O = I.col1.x * K + I.col2.x * $, $ = I.col1.y * K + I.col2.y * $, K = O, I = G.m_xf.R;
    var S = (this || window).m_localAnchor2.x - G.m_sweep.localCenter.x, b = (this || window).m_localAnchor2.y - G.m_sweep.localCenter.y;
    O = I.col1.x * S + I.col2.x * b, b = I.col1.y * S + I.col2.y * b, S = O;
    var W = L.m_invMass, x = G.m_invMass, E = L.m_invI, R = G.m_invI;
    if (this.m_mass.col1.x = W + x + $ * $ * E + b * b * R, this.m_mass.col2.x = -$ * K * E - b * S * R, this.m_mass.col3.x = -$ * E - b * R, this.m_mass.col1.y = (this || window).m_mass.col2.x, this.m_mass.col2.y = W + x + K * K * E + S * S * R, this.m_mass.col3.y = K * E + S * R, this.m_mass.col1.z = (this || window).m_mass.col3.x, this.m_mass.col2.z = (this || window).m_mass.col3.y, this.m_mass.col3.z = E + R, this.m_motorMass = 1 / (E + R), this.m_enableMotor == !1 && (this.m_motorImpulse = 0), this.m_enableLimit) {
      var F = G.m_sweep.a - L.m_sweep.a - this.m_referenceAngle;
      r.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * t.b2_angularSlop ? this.m_limitState = f.e_equalLimits : F <= (this || window).m_lowerAngle ? (this.m_limitState != f.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = f.e_atLowerLimit) : F >= (this || window).m_upperAngle ? (this.m_limitState != f.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = f.e_atUpperLimit) : (this.m_limitState = f.e_inactiveLimit, this.m_impulse.z = 0);
    } else
      this.m_limitState = f.e_inactiveLimit;
    if (w.warmStarting) {
      this.m_impulse.x *= w.dtRatio, this.m_impulse.y *= w.dtRatio, this.m_motorImpulse *= w.dtRatio;
      var k = (this || window).m_impulse.x, X = (this || window).m_impulse.y;
      L.m_linearVelocity.x -= W * k, L.m_linearVelocity.y -= W * X, L.m_angularVelocity -= E * (K * X - $ * k + this.m_motorImpulse + this.m_impulse.z), G.m_linearVelocity.x += x * k, G.m_linearVelocity.y += x * X, G.m_angularVelocity += R * (S * X - b * k + this.m_motorImpulse + this.m_impulse.z);
    } else
      this.m_impulse.SetZero(), this.m_motorImpulse = 0;
  }, U.prototype.SolveVelocityConstraints = function(w) {
    var L = (this || window).m_bodyA, G = (this || window).m_bodyB, I, O = 0, K = 0, $ = 0, S = 0, b = 0, W = 0, x = L.m_linearVelocity, E = L.m_angularVelocity, R = G.m_linearVelocity, F = G.m_angularVelocity, k = L.m_invMass, X = G.m_invMass, j = L.m_invI, V = G.m_invI;
    if (this.m_enableMotor && this.m_limitState != f.e_equalLimits) {
      var Y = F - E - this.m_motorSpeed, tt = (this || window).m_motorMass * -Y, it = (this || window).m_motorImpulse, lt = w.dt * this.m_maxMotorTorque;
      this.m_motorImpulse = r.Clamp(this.m_motorImpulse + tt, -lt, lt), tt = (this || window).m_motorImpulse - it, E -= j * tt, F += V * tt;
    }
    if (this.m_enableLimit && this.m_limitState != f.e_inactiveLimit) {
      I = L.m_xf.R, $ = (this || window).m_localAnchor1.x - L.m_sweep.localCenter.x, S = (this || window).m_localAnchor1.y - L.m_sweep.localCenter.y, O = I.col1.x * $ + I.col2.x * S, S = I.col1.y * $ + I.col2.y * S, $ = O, I = G.m_xf.R, b = (this || window).m_localAnchor2.x - G.m_sweep.localCenter.x, W = (this || window).m_localAnchor2.y - G.m_sweep.localCenter.y, O = I.col1.x * b + I.col2.x * W, W = I.col1.y * b + I.col2.y * W, b = O;
      var ut = R.x + -F * W - x.x - -E * S, ft = R.y + F * b - x.y - E * $, vt = F - E;
      this.m_mass.Solve33(this.impulse3, -ut, -ft, -vt), this.m_limitState == f.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == f.e_atLowerLimit ? (K = (this || window).m_impulse.z + this.impulse3.z, K < 0 && (this.m_mass.Solve22(this.reduced, -ut, -ft), this.impulse3.x = (this || window).reduced.x, this.impulse3.y = (this || window).reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += (this || window).reduced.x, this.m_impulse.y += (this || window).reduced.y, this.m_impulse.z = 0)) : this.m_limitState == f.e_atUpperLimit && (K = (this || window).m_impulse.z + this.impulse3.z, K > 0 && (this.m_mass.Solve22(this.reduced, -ut, -ft), this.impulse3.x = (this || window).reduced.x, this.impulse3.y = (this || window).reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += (this || window).reduced.x, this.m_impulse.y += (this || window).reduced.y, this.m_impulse.z = 0)), x.x -= k * this.impulse3.x, x.y -= k * this.impulse3.y, E -= j * ($ * this.impulse3.y - S * this.impulse3.x + this.impulse3.z), R.x += X * this.impulse3.x, R.y += X * this.impulse3.y, F += V * (b * this.impulse3.y - W * this.impulse3.x + this.impulse3.z);
    } else {
      I = L.m_xf.R, $ = (this || window).m_localAnchor1.x - L.m_sweep.localCenter.x, S = (this || window).m_localAnchor1.y - L.m_sweep.localCenter.y, O = I.col1.x * $ + I.col2.x * S, S = I.col1.y * $ + I.col2.y * S, $ = O, I = G.m_xf.R, b = (this || window).m_localAnchor2.x - G.m_sweep.localCenter.x, W = (this || window).m_localAnchor2.y - G.m_sweep.localCenter.y, O = I.col1.x * b + I.col2.x * W, W = I.col1.y * b + I.col2.y * W, b = O;
      var pt = R.x + -F * W - x.x - -E * S, gt = R.y + F * b - x.y - E * $;
      this.m_mass.Solve22(this.impulse2, -pt, -gt), this.m_impulse.x += (this || window).impulse2.x, this.m_impulse.y += (this || window).impulse2.y, x.x -= k * this.impulse2.x, x.y -= k * this.impulse2.y, E -= j * ($ * this.impulse2.y - S * this.impulse2.x), R.x += X * this.impulse2.x, R.y += X * this.impulse2.y, F += V * (b * this.impulse2.y - W * this.impulse2.x);
    }
    L.m_linearVelocity.SetV(x), L.m_angularVelocity = E, G.m_linearVelocity.SetV(R), G.m_angularVelocity = F;
  }, U.prototype.SolvePositionConstraints = function(w) {
    var L = 0, G, I = (this || window).m_bodyA, O = (this || window).m_bodyB, K = 0, $ = 0, S = 0, b = 0, W = 0;
    if (this.m_enableLimit && this.m_limitState != f.e_inactiveLimit) {
      var x = O.m_sweep.a - I.m_sweep.a - this.m_referenceAngle, E = 0;
      this.m_limitState == f.e_equalLimits ? (L = r.Clamp(x - this.m_lowerAngle, -t.b2_maxAngularCorrection, t.b2_maxAngularCorrection), E = -this.m_motorMass * L, K = r.Abs(L)) : this.m_limitState == f.e_atLowerLimit ? (L = x - this.m_lowerAngle, K = -L, L = r.Clamp(L + t.b2_angularSlop, -t.b2_maxAngularCorrection, 0), E = -this.m_motorMass * L) : this.m_limitState == f.e_atUpperLimit && (L = x - this.m_upperAngle, K = L, L = r.Clamp(L - t.b2_angularSlop, 0, t.b2_maxAngularCorrection), E = -this.m_motorMass * L), I.m_sweep.a -= I.m_invI * E, O.m_sweep.a += O.m_invI * E, I.SynchronizeTransform(), O.SynchronizeTransform();
    }
    {
      G = I.m_xf.R;
      var R = (this || window).m_localAnchor1.x - I.m_sweep.localCenter.x, F = (this || window).m_localAnchor1.y - I.m_sweep.localCenter.y;
      S = G.col1.x * R + G.col2.x * F, F = G.col1.y * R + G.col2.y * F, R = S, G = O.m_xf.R;
      var k = (this || window).m_localAnchor2.x - O.m_sweep.localCenter.x, X = (this || window).m_localAnchor2.y - O.m_sweep.localCenter.y;
      S = G.col1.x * k + G.col2.x * X, X = G.col1.y * k + G.col2.y * X, k = S;
      var j = O.m_sweep.c.x + k - I.m_sweep.c.x - R, V = O.m_sweep.c.y + X - I.m_sweep.c.y - F, Y = j * j + V * V, tt = Math.sqrt(Y);
      $ = tt;
      var it = I.m_invMass, lt = O.m_invMass, ut = I.m_invI, ft = O.m_invI, vt = 10 * t.b2_linearSlop;
      if (Y > vt * vt) {
        var pt = it + lt, gt = 1 / pt;
        b = gt * -j, W = gt * -V;
        var St = 0.5;
        I.m_sweep.c.x -= St * it * b, I.m_sweep.c.y -= St * it * W, O.m_sweep.c.x += St * lt * b, O.m_sweep.c.y += St * lt * W, j = O.m_sweep.c.x + k - I.m_sweep.c.x - R, V = O.m_sweep.c.y + X - I.m_sweep.c.y - F;
      }
      this.K1.col1.x = it + lt, this.K1.col2.x = 0, this.K1.col1.y = 0, this.K1.col2.y = it + lt, this.K2.col1.x = ut * F * F, this.K2.col2.x = -ut * R * F, this.K2.col1.y = -ut * R * F, this.K2.col2.y = ut * R * R, this.K3.col1.x = ft * X * X, this.K3.col2.x = -ft * k * X, this.K3.col1.y = -ft * k * X, this.K3.col2.y = ft * k * k, this.K.SetM(this.K1), this.K.AddM(this.K2), this.K.AddM(this.K3), this.K.Solve(U.tImpulse, -j, -V), b = U.tImpulse.x, W = U.tImpulse.y, I.m_sweep.c.x -= I.m_invMass * b, I.m_sweep.c.y -= I.m_invMass * W, I.m_sweep.a -= I.m_invI * (R * W - F * b), O.m_sweep.c.x += O.m_invMass * b, O.m_sweep.c.y += O.m_invMass * W, O.m_sweep.a += O.m_invI * (k * W - X * b), I.SynchronizeTransform(), O.SynchronizeTransform();
    }
    return $ <= t.b2_linearSlop && K <= t.b2_angularSlop;
  }, Box2D.postDefs.push(function() {
    Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new s();
  }), Box2D.inherit(Q, Box2D.Dynamics.Joints.b2JointDef), Q.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, Q.b2RevoluteJointDef = function() {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s(), this.localAnchorB = new s();
  }, Q.prototype.b2RevoluteJointDef = function() {
    this.__super.b2JointDef.call(this), this.type = f.e_revoluteJoint, this.localAnchorA.Set(0, 0), this.localAnchorB.Set(0, 0), this.referenceAngle = 0, this.lowerAngle = 0, this.upperAngle = 0, this.maxMotorTorque = 0, this.motorSpeed = 0, this.enableLimit = !1, this.enableMotor = !1;
  }, Q.prototype.Initialize = function(w, L, G) {
    this.bodyA = w, this.bodyB = L, this.localAnchorA = (this || window).bodyA.GetLocalPoint(G), this.localAnchorB = (this || window).bodyB.GetLocalPoint(G), this.referenceAngle = (this || window).bodyB.GetAngle() - this.bodyA.GetAngle();
  }, Box2D.inherit(et, Box2D.Dynamics.Joints.b2Joint), et.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype, et.b2WeldJoint = function() {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments), this.m_localAnchorA = new s(), this.m_localAnchorB = new s(), this.m_impulse = new o(), this.m_mass = new n();
  }, et.prototype.GetAnchorA = function() {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
  }, et.prototype.GetAnchorB = function() {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
  }, et.prototype.GetReactionForce = function(w) {
    return w === void 0 && (w = 0), new s(w * this.m_impulse.x, w * this.m_impulse.y);
  }, et.prototype.GetReactionTorque = function(w) {
    return w === void 0 && (w = 0), w * this.m_impulse.z;
  }, et.prototype.b2WeldJoint = function(w) {
    this.__super.b2Joint.call(this, w), this.m_localAnchorA.SetV(w.localAnchorA), this.m_localAnchorB.SetV(w.localAnchorB), this.m_referenceAngle = w.referenceAngle, this.m_impulse.SetZero(), this.m_mass = new n();
  }, et.prototype.InitVelocityConstraints = function(w) {
    var L, G = 0, I = (this || window).m_bodyA, O = (this || window).m_bodyB;
    L = I.m_xf.R;
    var K = (this || window).m_localAnchorA.x - I.m_sweep.localCenter.x, $ = (this || window).m_localAnchorA.y - I.m_sweep.localCenter.y;
    G = L.col1.x * K + L.col2.x * $, $ = L.col1.y * K + L.col2.y * $, K = G, L = O.m_xf.R;
    var S = (this || window).m_localAnchorB.x - O.m_sweep.localCenter.x, b = (this || window).m_localAnchorB.y - O.m_sweep.localCenter.y;
    G = L.col1.x * S + L.col2.x * b, b = L.col1.y * S + L.col2.y * b, S = G;
    var W = I.m_invMass, x = O.m_invMass, E = I.m_invI, R = O.m_invI;
    this.m_mass.col1.x = W + x + $ * $ * E + b * b * R, this.m_mass.col2.x = -$ * K * E - b * S * R, this.m_mass.col3.x = -$ * E - b * R, this.m_mass.col1.y = (this || window).m_mass.col2.x, this.m_mass.col2.y = W + x + K * K * E + S * S * R, this.m_mass.col3.y = K * E + S * R, this.m_mass.col1.z = (this || window).m_mass.col3.x, this.m_mass.col2.z = (this || window).m_mass.col3.y, this.m_mass.col3.z = E + R, w.warmStarting ? (this.m_impulse.x *= w.dtRatio, this.m_impulse.y *= w.dtRatio, this.m_impulse.z *= w.dtRatio, I.m_linearVelocity.x -= W * this.m_impulse.x, I.m_linearVelocity.y -= W * this.m_impulse.y, I.m_angularVelocity -= E * (K * this.m_impulse.y - $ * this.m_impulse.x + this.m_impulse.z), O.m_linearVelocity.x += x * this.m_impulse.x, O.m_linearVelocity.y += x * this.m_impulse.y, O.m_angularVelocity += R * (S * this.m_impulse.y - b * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero();
  }, et.prototype.SolveVelocityConstraints = function(w) {
    var L, G = 0, I = (this || window).m_bodyA, O = (this || window).m_bodyB, K = I.m_linearVelocity, $ = I.m_angularVelocity, S = O.m_linearVelocity, b = O.m_angularVelocity, W = I.m_invMass, x = O.m_invMass, E = I.m_invI, R = O.m_invI;
    L = I.m_xf.R;
    var F = (this || window).m_localAnchorA.x - I.m_sweep.localCenter.x, k = (this || window).m_localAnchorA.y - I.m_sweep.localCenter.y;
    G = L.col1.x * F + L.col2.x * k, k = L.col1.y * F + L.col2.y * k, F = G, L = O.m_xf.R;
    var X = (this || window).m_localAnchorB.x - O.m_sweep.localCenter.x, j = (this || window).m_localAnchorB.y - O.m_sweep.localCenter.y;
    G = L.col1.x * X + L.col2.x * j, j = L.col1.y * X + L.col2.y * j, X = G;
    var V = S.x - b * j - K.x + $ * k, Y = S.y + b * X - K.y - $ * F, tt = b - $, it = new o();
    this.m_mass.Solve33(it, -V, -Y, -tt), this.m_impulse.Add(it), K.x -= W * it.x, K.y -= W * it.y, $ -= E * (F * it.y - k * it.x + it.z), S.x += x * it.x, S.y += x * it.y, b += R * (X * it.y - j * it.x + it.z), I.m_angularVelocity = $, O.m_angularVelocity = b;
  }, et.prototype.SolvePositionConstraints = function(w) {
    var L, G = 0, I = (this || window).m_bodyA, O = (this || window).m_bodyB;
    L = I.m_xf.R;
    var K = (this || window).m_localAnchorA.x - I.m_sweep.localCenter.x, $ = (this || window).m_localAnchorA.y - I.m_sweep.localCenter.y;
    G = L.col1.x * K + L.col2.x * $, $ = L.col1.y * K + L.col2.y * $, K = G, L = O.m_xf.R;
    var S = (this || window).m_localAnchorB.x - O.m_sweep.localCenter.x, b = (this || window).m_localAnchorB.y - O.m_sweep.localCenter.y;
    G = L.col1.x * S + L.col2.x * b, b = L.col1.y * S + L.col2.y * b, S = G;
    var W = I.m_invMass, x = O.m_invMass, E = I.m_invI, R = O.m_invI, F = O.m_sweep.c.x + S - I.m_sweep.c.x - K, k = O.m_sweep.c.y + b - I.m_sweep.c.y - $, X = O.m_sweep.a - I.m_sweep.a - this.m_referenceAngle, j = 10 * t.b2_linearSlop, V = Math.sqrt(F * F + k * k), Y = r.Abs(X);
    V > j && (E *= 1, R *= 1), this.m_mass.col1.x = W + x + $ * $ * E + b * b * R, this.m_mass.col2.x = -$ * K * E - b * S * R, this.m_mass.col3.x = -$ * E - b * R, this.m_mass.col1.y = (this || window).m_mass.col2.x, this.m_mass.col2.y = W + x + K * K * E + S * S * R, this.m_mass.col3.y = K * E + S * R, this.m_mass.col1.z = (this || window).m_mass.col3.x, this.m_mass.col2.z = (this || window).m_mass.col3.y, this.m_mass.col3.z = E + R;
    var tt = new o();
    return this.m_mass.Solve33(tt, -F, -k, -X), I.m_sweep.c.x -= W * tt.x, I.m_sweep.c.y -= W * tt.y, I.m_sweep.a -= E * (K * tt.y - $ * tt.x + tt.z), O.m_sweep.c.x += x * tt.x, O.m_sweep.c.y += x * tt.y, O.m_sweep.a += R * (S * tt.y - b * tt.x + tt.z), I.SynchronizeTransform(), O.SynchronizeTransform(), V <= t.b2_linearSlop && Y <= t.b2_angularSlop;
  }, Box2D.inherit(rt, Box2D.Dynamics.Joints.b2JointDef), rt.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype, rt.b2WeldJointDef = function() {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments), this.localAnchorA = new s(), this.localAnchorB = new s();
  }, rt.prototype.b2WeldJointDef = function() {
    this.__super.b2JointDef.call(this), this.type = f.e_weldJoint, this.referenceAngle = 0;
  }, rt.prototype.Initialize = function(w, L, G) {
    this.bodyA = w, this.bodyB = L, this.localAnchorA.SetV(this.bodyA.GetLocalPoint(G)), this.localAnchorB.SetV(this.bodyB.GetLocalPoint(G)), this.referenceAngle = (this || window).bodyB.GetAngle() - this.bodyA.GetAngle();
  };
})();
(function() {
  var t = Box2D.Dynamics.b2DebugDraw;
  t.b2DebugDraw = function() {
    this.m_drawScale = 1, this.m_lineThickness = 1, this.m_alpha = 1, this.m_fillAlpha = 1, this.m_xformScale = 1;
    var e = (this || window);
    this.m_sprite = {
      graphics: {
        clear: function() {
          e.m_ctx.clearRect(0, 0, e.m_ctx.canvas.width, e.m_ctx.canvas.height);
        }
      }
    };
  }, t.prototype._color = function(e, n) {
    return "rgba(" + ((e & 16711680) >> 16) + "," + ((e & 65280) >> 8) + "," + (e & 255) + "," + n + ")";
  }, t.prototype.b2DebugDraw = function() {
    this.m_drawFlags = 0;
  }, t.prototype.SetFlags = function(e) {
    e === void 0 && (e = 0), this.m_drawFlags = e;
  }, t.prototype.GetFlags = function() {
    return this.m_drawFlags;
  }, t.prototype.AppendFlags = function(e) {
    e === void 0 && (e = 0), this.m_drawFlags |= e;
  }, t.prototype.ClearFlags = function(e) {
    e === void 0 && (e = 0), this.m_drawFlags &= ~e;
  }, t.prototype.SetSprite = function(e) {
    this.m_ctx = e;
  }, t.prototype.GetSprite = function() {
    return this.m_ctx;
  }, t.prototype.SetDrawScale = function(e) {
    e === void 0 && (e = 0), this.m_drawScale = e;
  }, t.prototype.GetDrawScale = function() {
    return this.m_drawScale;
  }, t.prototype.SetLineThickness = function(e) {
    e === void 0 && (e = 0), this.m_lineThickness = e, this.m_ctx.strokeWidth = e;
  }, t.prototype.GetLineThickness = function() {
    return this.m_lineThickness;
  }, t.prototype.SetAlpha = function(e) {
    e === void 0 && (e = 0), this.m_alpha = e;
  }, t.prototype.GetAlpha = function() {
    return this.m_alpha;
  }, t.prototype.SetFillAlpha = function(e) {
    e === void 0 && (e = 0), this.m_fillAlpha = e;
  }, t.prototype.GetFillAlpha = function() {
    return this.m_fillAlpha;
  }, t.prototype.SetXFormScale = function(e) {
    e === void 0 && (e = 0), this.m_xformScale = e;
  }, t.prototype.GetXFormScale = function() {
    return this.m_xformScale;
  }, t.prototype.DrawPolygon = function(e, n, r) {
    if (n) {
      var s = (this || window).m_ctx, o = (this || window).m_drawScale;
      s.beginPath(), s.strokeStyle = (this || window)._color(r.color, this.m_alpha), s.moveTo(e[0].x * o, e[0].y * o);
      for (var a = 1; a < n; a++)
        s.lineTo(e[a].x * o, e[a].y * o);
      s.lineTo(e[0].x * o, e[0].y * o), s.closePath(), s.stroke();
    }
  }, t.prototype.DrawSolidPolygon = function(e, n, r) {
    if (n) {
      var s = (this || window).m_ctx, o = (this || window).m_drawScale;
      s.beginPath(), s.strokeStyle = (this || window)._color(r.color, this.m_alpha), s.fillStyle = (this || window)._color(r.color, this.m_fillAlpha), s.moveTo(e[0].x * o, e[0].y * o);
      for (var a = 1; a < n; a++)
        s.lineTo(e[a].x * o, e[a].y * o);
      s.lineTo(e[0].x * o, e[0].y * o), s.closePath(), s.fill(), s.stroke();
    }
  }, t.prototype.DrawCircle = function(e, n, r) {
    if (n) {
      var s = (this || window).m_ctx, o = (this || window).m_drawScale;
      s.beginPath(), s.strokeStyle = (this || window)._color(r.color, this.m_alpha), s.arc(e.x * o, e.y * o, n * o, 0, Math.PI * 2, !0), s.closePath(), s.stroke();
    }
  }, t.prototype.DrawSolidCircle = function(e, n, r, s) {
    if (n) {
      var o = (this || window).m_ctx, a = (this || window).m_drawScale, c = e.x * a, l = e.y * a;
      o.moveTo(0, 0), o.beginPath(), o.strokeStyle = (this || window)._color(s.color, this.m_alpha), o.fillStyle = (this || window)._color(s.color, this.m_fillAlpha), o.arc(c, l, n * a, 0, Math.PI * 2, !0), o.moveTo(c, l), o.lineTo((e.x + r.x * n) * a, (e.y + r.y * n) * a), o.closePath(), o.fill(), o.stroke();
    }
  }, t.prototype.DrawSegment = function(e, n, r) {
    var s = (this || window).m_ctx, o = (this || window).m_drawScale;
    s.strokeStyle = (this || window)._color(r.color, this.m_alpha), s.beginPath(), s.moveTo(e.x * o, e.y * o), s.lineTo(n.x * o, n.y * o), s.closePath(), s.stroke();
  }, t.prototype.DrawTransform = function(e) {
    var n = (this || window).m_ctx, r = (this || window).m_drawScale;
    n.beginPath(), n.strokeStyle = (this || window)._color(16711680, this.m_alpha), n.moveTo(e.position.x * r, e.position.y * r), n.lineTo((e.position.x + this.m_xformScale * e.R.col1.x) * r, (e.position.y + this.m_xformScale * e.R.col1.y) * r), n.strokeStyle = (this || window)._color(65280, this.m_alpha), n.moveTo(e.position.x * r, e.position.y * r), n.lineTo((e.position.x + this.m_xformScale * e.R.col2.x) * r, (e.position.y + this.m_xformScale * e.R.col2.y) * r), n.closePath(), n.stroke();
  };
})();
var i;
for (i = 0; i < Box2D.postDefs.length; ++i)
  Box2D.postDefs[i]();
delete Box2D.postDefs;
typeof require != "undefined" && typeof module != "undefined" && (module.exports = Box2D);
(function() {
  Object.create = Object.create || function(v) {
    function T() {
    }
    return H(T, "F"), T.prototype = v, new T();
  };
  var t;
  typeof exports == "undefined" ? (t = {}, typeof window == "object" && (window.cp = t)) : t = exports;
  var e = /* @__PURE__ */ H(function(v, T) {
    if (!v)
      throw new Error("Assertion failed: " + T);
  }, "assert"), n = /* @__PURE__ */ H(function(v, T) {
    !v && console && console.warn && (console.warn("ASSERTION FAILED: " + T), console.trace && console.trace());
  }, "assertSoft"), r = /* @__PURE__ */ H(function(v, T) {
    return v < T ? v : T;
  }, "mymin"), s = /* @__PURE__ */ H(function(v, T) {
    return v > T ? v : T;
  }, "mymax"), o, a;
  typeof window == "object" && window.navigator.userAgent.indexOf("Firefox") > -1 ? (o = Math.min, a = Math.max) : (o = r, a = s);
  var c = /* @__PURE__ */ H(function(v, T) {
    return v < T ? v + " " + T : T + " " + v;
  }, "hashPair"), l = /* @__PURE__ */ H(function(v, T) {
    for (var P = 0; P < v.length; P++)
      if (v[P] === T) {
        v[P] = v[v.length - 1], v.length--;
        return;
      }
  }, "deleteObjFromList"), h = /* @__PURE__ */ H(function(v, T, P) {
    var B = U(T, P), J = g(D(B, U(v, P)) / K(B));
    return Z(P, et(B, J));
  }, "closestPointOnSegment"), u = /* @__PURE__ */ H(function(v, T, P, B, J, nt) {
    var st = P - J, dt = B - nt, Tt = g(N(st, dt, v - J, T - nt) / $(st, dt));
    return new y(J + st * Tt, nt + dt * Tt);
  }, "closestPointOnSegment2");
  t.momentForCircle = function(v, T, P, B) {
    return v * (0.5 * (T * T + P * P) + K(B));
  }, t.areaForCircle = function(v, T) {
    return Math.PI * Math.abs(v * v - T * T);
  }, t.momentForSegment = function(v, T, P) {
    var B = et(Z(T, P), 0.5);
    return v * (R(P, T) / 12 + K(B));
  }, t.areaForSegment = function(v, T, P) {
    return P * (Math.PI * P + 2 * E(v, T));
  }, t.momentForPoly = function(v, T, P) {
    for (var B = 0, J = 0, nt = T.length, st = 0; st < nt; st += 2) {
      var dt = T[st] + P.x, Tt = T[st + 1] + P.y, xt = T[(st + 2) % nt] + P.x, Rt = T[(st + 3) % nt] + P.y, Mt = w(xt, Rt, dt, Tt), Wt = N(dt, Tt, dt, Tt) + N(dt, Tt, xt, Rt) + N(xt, Rt, xt, Rt);
      B += Mt * Wt, J += Mt;
    }
    return v * B / (6 * J);
  }, t.areaForPoly = function(v) {
    for (var T = 0, P = 0, B = v.length; P < B; P += 2)
      T += rt(new y(v[P], v[P + 1]), new y(v[(P + 2) % B], v[(P + 3) % B]));
    return -T / 2;
  }, t.centroidForPoly = function(v) {
    for (var T = 0, P = new y(0, 0), B = 0, J = v.length; B < J; B += 2) {
      var nt = new y(v[B], v[B + 1]), st = new y(v[(B + 2) % J], v[(B + 3) % J]), dt = rt(nt, st);
      T += dt, P = Z(P, et(Z(nt, st), dt));
    }
    return et(P, 1 / (3 * T));
  }, t.recenterPoly = function(v) {
    for (var T = t.centroidForPoly(v), P = 0; P < v.length; P += 2)
      v[P] -= T.x, v[P + 1] -= T.y;
  }, t.momentForBox = function(v, T, P) {
    return v * (T * T + P * P) / 12;
  }, t.momentForBox2 = function(v, T) {
    var P = T.r - T.l, B = T.t - T.b, J = et([T.l + T.r, T.b + T.t], 0.5);
    return t.momentForBox(v, P, B) + v * K(J);
  };
  var _ = t.loopIndexes = function(v) {
    var T = 0, P = 0, B, J, nt, st;
    B = nt = v[0], J = st = v[1];
    for (var dt = v.length >> 1, Tt = 1; Tt < dt; Tt++) {
      var xt = v[Tt * 2], Rt = v[Tt * 2 + 1];
      xt < B || xt == B && Rt < J ? (B = xt, J = Rt, T = Tt) : (xt > nt || xt == nt && Rt > st) && (nt = xt, st = Rt, P = Tt);
    }
    return [T, P];
  }, d = /* @__PURE__ */ H(function(v, T, P) {
    var B = v[T * 2];
    v[T * 2] = v[P * 2], v[P * 2] = B, B = v[T * 2 + 1], v[T * 2 + 1] = v[P * 2 + 1], v[P * 2 + 1] = B;
  }, "SWAP"), f = /* @__PURE__ */ H(function(v, T, P, B, J, nt) {
    if (P === 0)
      return 0;
    for (var st = 0, dt = T, Tt = U(J, B), xt = nt * z(Tt), Rt = T, Mt = T + P - 1; Rt <= Mt; ) {
      var Wt = new y(v[Rt * 2], v[Rt * 2 + 1]), qt = rt(Tt, U(Wt, B));
      qt > xt ? (qt > st && (st = qt, dt = Rt), Rt++) : (d(v, Rt, Mt), Mt--);
    }
    return dt != T && d(v, T, dt), Rt - T;
  }, "QHullPartition"), C = /* @__PURE__ */ H(function(v, T, P, B, J, nt, st, dt) {
    if (B < 0)
      return 0;
    if (B == 0)
      return T[dt * 2] = nt.x, T[dt * 2 + 1] = nt.y, 1;
    var Tt = f(T, P, B, J, nt, v), xt = new y(T[P * 2], T[P * 2 + 1]), Rt = C(v, T, P + 1, Tt - 1, J, xt, nt, dt), Mt = dt + Rt++;
    T[Mt * 2] = nt.x, T[Mt * 2 + 1] = nt.y;
    var Wt = f(T, P + Tt, B - Tt, nt, st, v), qt = new y(T[(P + Tt) * 2], T[(P + Tt) * 2 + 1]);
    return Rt + C(v, T, P + Tt + 1, Wt - 1, nt, qt, st, dt + Rt);
  }, "QHullReduce");
  t.convexHull = function(v, T, P) {
    if (T)
      for (var B = 0; B < v.length; B++)
        T[B] = v[B];
    else
      T = v;
    var J = _(v), nt = J[0], st = J[1];
    if (nt == st)
      return T.length = 2, T;
    d(T, 0, nt), d(T, 1, st == 0 ? nt : st);
    var dt = new y(T[0], T[1]), Tt = new y(T[2], T[3]), xt = v.length >> 1, Rt = C(P, T, 2, xt - 2, dt, Tt, dt, 1) + 1;
    return T.length = Rt * 2, n(
      pt(T),
      "Internal error: cpConvexHull() and cpPolyValidate() did not agree.Please report this error with as much info as you can."
    ), T;
  };
  var m = /* @__PURE__ */ H(function(v, T, P) {
    return o(a(v, T), P);
  }, "clamp"), g = /* @__PURE__ */ H(function(v) {
    return a(0, o(v, 1));
  }, "clamp01"), y = t.Vect = function(v, T) {
    this.x = v, this.y = T;
  };
  t.v = function(v, T) {
    return new y(v, T);
  };
  var A = t.vzero = new y(0, 0), D = t.v.dot = function(v, T) {
    return v.x * T.x + v.y * T.y;
  }, N = /* @__PURE__ */ H(function(v, T, P, B) {
    return v * P + T * B;
  }, "vdot2"), z = t.v.len = function(v) {
    return Math.sqrt(D(v, v));
  }, M = t.v.len2 = function(v, T) {
    return Math.sqrt(v * v + T * T);
  };
  t.v.eql = function(v, T) {
    return v.x === T.x && v.y === T.y;
  };
  var Z = t.v.add = function(v, T) {
    return new y(v.x + T.x, v.y + T.y);
  };
  y.prototype.add = function(v) {
    return this.x += v.x, this.y += v.y, (this || window)
  };
  var U = t.v.sub = function(v, T) {
    return new y(v.x - T.x, v.y - T.y);
  };
  y.prototype.sub = function(v) {
    return this.x -= v.x, this.y -= v.y, (this || window)
  };
  var Q = t.v.neg = function(v) {
    return new y(-v.x, -v.y);
  };
  y.prototype.neg = function() {
    return this.x = -this.x, this.y = -this.y, (this || window)
  };
  var et = t.v.mult = function(v, T) {
    return new y(v.x * T, v.y * T);
  };
  y.prototype.mult = function(v) {
    return this.x *= v, this.y *= v, (this || window)
  };
  var rt = t.v.cross = function(v, T) {
    return v.x * T.y - v.y * T.x;
  }, w = /* @__PURE__ */ H(function(v, T, P, B) {
    return v * B - T * P;
  }, "vcross2"), L = t.v.perp = function(v) {
    return new y(-v.y, v.x);
  };
  t.v.pvrperp = function(v) {
    return new y(v.y, -v.x);
  };
  var G = t.v.project = function(v, T) {
    return et(T, D(v, T) / K(T));
  };
  y.prototype.project = function(v) {
    return this.mult(D(this, v) / K(v)), (this || window)
  };
  var I = t.v.rotate = function(v, T) {
    return new y(v.x * T.x - v.y * T.y, v.x * T.y + v.y * T.x);
  };
  y.prototype.rotate = function(v) {
    return this.x = (this || window).x * v.x - this.y * v.y, this.y = (this || window).x * v.y + this.y * v.x, (this || window)
  };
  var O = t.v.unrotate = function(v, T) {
    return new y(v.x * T.x + v.y * T.y, v.y * T.x - v.x * T.y);
  }, K = t.v.lengthsq = function(v) {
    return D(v, v);
  }, $ = t.v.lengthsq2 = function(v, T) {
    return v * v + T * T;
  }, S = t.v.lerp = function(v, T, P) {
    return Z(et(v, 1 - P), et(T, P));
  }, b = t.v.normalize = function(v) {
    return et(v, 1 / z(v));
  }, W = t.v.normalize_safe = function(v) {
    return v.x === 0 && v.y === 0 ? A : b(v);
  }, x = t.v.clamp = function(v, T) {
    return D(v, v) > T * T ? et(b(v), T) : v;
  };
  t.v.lerpconst = function(v, T, P) {
    return Z(v, x(U(T, v), P));
  };
  var E = t.v.dist = function(v, T) {
    return z(U(v, T));
  }, R = t.v.distsq = function(v, T) {
    return K(U(v, T));
  };
  t.v.near = function(v, T, P) {
    return R(v, T) < P * P;
  };
  var F = t.v.slerp = function(v, T, P) {
    var B = Math.acos(D(v, T));
    if (B) {
      var J = 1 / Math.sin(B);
      return Z(et(v, Math.sin((1 - P) * B) * J), et(T, Math.sin(P * B) * J));
    } else
      return v;
  };
  t.v.slerpconst = function(v, T, P) {
    var B = Math.acos(D(v, T));
    return F(v, T, o(P, B) / B);
  }, t.v.forangle = function(v) {
    return new y(Math.cos(v), Math.sin(v));
  }, t.v.toangle = function(v) {
    return Math.atan2(v.y, v.x);
  }, t.v.str = function(v) {
    return "(" + v.x.toFixed(3) + ", " + v.y.toFixed(3) + ")";
  };
  var k = t.BB = function(v, T, P, B) {
    this.l = v, this.b = T, this.r = P, this.t = B;
  };
  t.bb = function(v, T, P, B) {
    return new k(v, T, P, B);
  };
  var X = /* @__PURE__ */ H(function(v, T) {
    return new k(
      v.x - T,
      v.y - T,
      v.x + T,
      v.y + T
    );
  }, "bbNewForCircle"), j = /* @__PURE__ */ H(function(v, T, P, B, J) {
    return v.l <= B && T <= v.r && v.b <= J && P <= v.t;
  }, "bbIntersects2"), V = 0;
  t.NO_GROUP = 0;
  var Y = t.ALL_LAYERS = -1;
  t.ALL_CATEGORIES = -1, t.resetShapeIdCounter = function() {
    V = 0;
  };
  var tt = t.Shape = function(v) {
    this.body = v, this.bb_l = (this || window).bb_b = (this || window).bb_r = (this || window).bb_t = 0, this.hashid = V++, this.sensor = !1, this.e = 0, this.u = 0, this.surface_v = A, this.collision_type = 0, this.group = 0, this.layers = Y, this.space = null, this.collisionCode = (this || window).collisionCode;
  };
  tt.prototype.setElasticity = function(v) {
    this.e = v;
  }, tt.prototype.setFriction = function(v) {
    this.body.activate(), this.u = v;
  }, tt.prototype.setLayers = function(v) {
    this.body.activate(), this.layers = v;
  }, tt.prototype.setSensor = function(v) {
    this.body.activate(), this.sensor = v;
  }, tt.prototype.setCollisionType = function(v) {
    this.body.activate(), this.collision_type = v;
  }, tt.prototype.getBody = function() {
    return this.body;
  }, tt.prototype.active = function() {
    return this.body && this.body.shapeList.indexOf(this) !== -1;
  }, tt.prototype.setBody = function(v) {
    e(!this.active(), "You cannot change the body on an active shape. You must remove the shape from the space before changing the body."), this.body = v;
  }, tt.prototype.cacheBB = function() {
    return this.update(this.body.p, this.body.rot);
  }, tt.prototype.update = function(v, T) {
    e(!isNaN(T.x), "Rotation is NaN"), e(!isNaN(v.x), "Position is NaN"), this.cacheData(v, T);
  }, tt.prototype.pointQuery = function(v) {
    var T = (this || window).nearestPointQuery(v);
    if (T.d < 0)
      return T;
  }, tt.prototype.getBB = function() {
    return new k(this.bb_l, this.bb_b, this.bb_r, this.bb_t);
  };
  var it = /* @__PURE__ */ H(function(v, T, P) {
    this.shape = v, this.p = T, this.d = P;
  }, "NearestPointQueryInfo"), lt = /* @__PURE__ */ H(function(v, T, P) {
    this.shape = v, this.t = T, this.n = P;
  }, "SegmentQueryInfo");
  lt.prototype.hitPoint = function(v, T) {
    return S(v, T, this.t);
  }, lt.prototype.hitDist = function(v, T) {
    return E(v, T) * this.t;
  };
  var ut = t.CircleShape = function(v, T, P) {
    this.c = (this || window).tc = P, this.r = T, this.type = "circle", tt.call(this, v);
  };
  ut.prototype = Object.create(tt.prototype), ut.prototype.cacheData = function(v, T) {
    var P = (this || window).tc = I(this.c, T).add(v), B = (this || window).r;
    this.bb_l = P.x - B, this.bb_b = P.y - B, this.bb_r = P.x + B, this.bb_t = P.y + B;
  }, ut.prototype.nearestPointQuery = function(v) {
    var T = v.x - this.tc.x, P = v.y - this.tc.y, B = M(T, P), J = (this || window).r, nt = new y(this.tc.x + T * J / B, this.tc.y + P * J / B);
    return new it(this, nt, B - J);
  };
  var ft = /* @__PURE__ */ H(function(v, T, P, B, J, nt) {
    B = U(B, T), J = U(J, T);
    var st = D(B, B) - 2 * D(B, J) + D(J, J), dt = -2 * D(B, B) + 2 * D(B, J), Tt = D(B, B) - P * P, xt = dt * dt - 4 * st * Tt;
    if (xt >= 0) {
      var Rt = (-dt - Math.sqrt(xt)) / (2 * st);
      if (0 <= Rt && Rt <= 1)
        return new lt(v, Rt, b(S(B, J, Rt)));
    }
  }, "circleSegmentQuery");
  ut.prototype.segmentQuery = function(v, T) {
    return ft(this, this.tc, this.r, v, T);
  };
  var vt = t.SegmentShape = function(v, T, P, B) {
    this.a = T, this.b = P, this.n = L(b(U(P, T))), this.ta = (this || window).tb = (this || window).tn = null, this.r = B, this.a_tangent = A, this.b_tangent = A, this.type = "segment", tt.call(this, v);
  };
  vt.prototype = Object.create(tt.prototype), vt.prototype.cacheData = function(v, T) {
    this.ta = Z(v, I(this.a, T)), this.tb = Z(v, I(this.b, T)), this.tn = I(this.n, T);
    var P, B, J, nt;
    this.ta.x < this.tb.x ? (P = (this || window).ta.x, B = (this || window).tb.x) : (P = (this || window).tb.x, B = (this || window).ta.x), this.ta.y < this.tb.y ? (J = (this || window).ta.y, nt = (this || window).tb.y) : (J = (this || window).tb.y, nt = (this || window).ta.y);
    var st = (this || window).r;
    this.bb_l = P - st, this.bb_b = J - st, this.bb_r = B + st, this.bb_t = nt + st;
  }, vt.prototype.nearestPointQuery = function(v) {
    var T = h(v, this.ta, this.tb), P = v.x - T.x, B = v.y - T.y, J = M(P, B), nt = (this || window).r, st = J ? Z(T, et(new y(P, B), nt / J)) : T;
    return new it(this, st, J - nt);
  }, vt.prototype.segmentQuery = function(v, T) {
    var P = (this || window).tn, B = D(U(this.ta, v), P), J = (this || window).r, nt = B > 0 ? Q(P) : P, st = U(et(nt, J), v), dt = Z(this.ta, st), Tt = Z(this.tb, st), xt = U(T, v);
    if (rt(xt, dt) * rt(xt, Tt) <= 0) {
      var Rt = B + (B > 0 ? -J : J), Mt = -Rt, Wt = D(xt, P) - Rt;
      if (Mt * Wt < 0)
        return new lt(this, Mt / (Mt - Wt), nt);
    } else if (J !== 0) {
      var qt = ft(this, this.ta, this.r, v, T), ne = ft(this, this.tb, this.r, v, T);
      return qt ? ne && ne.t < qt.t ? ne : qt : ne;
    }
  }, vt.prototype.setNeighbors = function(v, T) {
    this.a_tangent = U(v, this.a), this.b_tangent = U(T, this.b);
  }, vt.prototype.setEndpoints = function(v, T) {
    this.a = v, this.b = T, this.n = L(b(U(T, v)));
  };
  var pt = /* @__PURE__ */ H(function(v) {
    for (var T = v.length, P = 0; P < T; P += 2) {
      var B = v[P], J = v[P + 1], nt = v[(P + 2) % T], st = v[(P + 3) % T], dt = v[(P + 4) % T], Tt = v[(P + 5) % T];
      if (w(nt - B, st - J, dt - nt, Tt - st) > 0)
        return !1;
    }
    return !0;
  }, "polyValidate"), gt = t.PolyShape = function(v, T, P) {
    this.setVerts(T, P), this.type = "poly", tt.call(this, v);
  };
  gt.prototype = Object.create(tt.prototype);
  var St = /* @__PURE__ */ H(function(v, T) {
    this.n = v, this.d = T;
  }, "SplittingPlane");
  St.prototype.compare = function(v) {
    return D(this.n, v) - this.d;
  }, gt.prototype.setVerts = function(v, T) {
    e(v.length >= 4, "Polygons require some verts"), e(
      typeof v[0] == "number",
      "Polygon verticies should be specified in a flattened list (eg [x1,y1,x2,y2,x3,y3,...])"
    ), e(pt(v), "Polygon is concave or has a reversed winding. Consider using cpConvexHull()");
    var P = v.length, B = P >> 1;
    this.verts = new Array(P), this.tVerts = new Array(P), this.planes = new Array(B), this.tPlanes = new Array(B);
    for (var J = 0; J < P; J += 2) {
      var nt = v[J] + T.x, st = v[J + 1] + T.y, dt = v[(J + 2) % P] + T.x, Tt = v[(J + 3) % P] + T.y, xt = b(L(new y(dt - nt, Tt - st)));
      this.verts[J] = nt, this.verts[J + 1] = st, this.planes[J >> 1] = new St(xt, N(xt.x, xt.y, nt, st)), this.tPlanes[J >> 1] = new St(new y(0, 0), 0);
    }
  }, t.BoxShape = function(v, T, P) {
    var B = T / 2, J = P / 2;
    return ht(v, new k(-B, -J, B, J));
  };
  var ht = t.BoxShape2 = function(v, T) {
    var P = [
      T.l,
      T.b,
      T.l,
      T.t,
      T.r,
      T.t,
      T.r,
      T.b
    ];
    return new gt(v, P, A);
  };
  gt.prototype.transformVerts = function(v, T) {
    for (var P = (this || window).verts, B = (this || window).tVerts, J = 1 / 0, nt = -1 / 0, st = 1 / 0, dt = -1 / 0, Tt = 0; Tt < P.length; Tt += 2) {
      var xt = P[Tt], Rt = P[Tt + 1], Mt = v.x + xt * T.x - Rt * T.y, Wt = v.y + xt * T.y + Rt * T.x;
      B[Tt] = Mt, B[Tt + 1] = Wt, J = o(J, Mt), nt = a(nt, Mt), st = o(st, Wt), dt = a(dt, Wt);
    }
    this.bb_l = J, this.bb_b = st, this.bb_r = nt, this.bb_t = dt;
  }, gt.prototype.transformAxes = function(v, T) {
    for (var P = (this || window).planes, B = (this || window).tPlanes, J = 0; J < P.length; J++) {
      var nt = I(P[J].n, T);
      B[J].n = nt, B[J].d = D(v, nt) + P[J].d;
    }
  }, gt.prototype.cacheData = function(v, T) {
    this.transformAxes(v, T), this.transformVerts(v, T);
  }, gt.prototype.nearestPointQuery = function(v) {
    for (var T = (this || window).tPlanes, P = (this || window).tVerts, B = P[P.length - 2], J = P[P.length - 1], nt = 1 / 0, st = A, dt = !1, Tt = 0; Tt < T.length; Tt++) {
      T[Tt].compare(v) > 0 && (dt = !0);
      var xt = P[Tt * 2], Rt = P[Tt * 2 + 1], Mt = u(v.x, v.y, B, J, xt, Rt), Wt = E(v, Mt);
      Wt < nt && (nt = Wt, st = Mt), B = xt, J = Rt;
    }
    return new it(this, st, dt ? nt : -nt);
  }, gt.prototype.segmentQuery = function(v, T) {
    for (var P = (this || window).tPlanes, B = (this || window).tVerts, J = P.length, nt = J * 2, st = 0; st < J; st++) {
      var dt = P[st].n, Tt = D(v, dt);
      if (!(P[st].d > Tt)) {
        var xt = D(T, dt), Rt = (P[st].d - Tt) / (xt - Tt);
        if (!(Rt < 0 || 1 < Rt)) {
          var Mt = S(v, T, Rt), Wt = -rt(dt, Mt), qt = -w(dt.x, dt.y, B[st * 2], B[st * 2 + 1]), ne = -w(dt.x, dt.y, B[(st * 2 + 2) % nt], B[(st * 2 + 3) % nt]);
          if (qt <= Wt && Wt <= ne)
            return new lt(this, Rt, dt);
        }
      }
    }
  }, gt.prototype.valueOnAxis = function(v, T) {
    for (var P = (this || window).tVerts, B = N(v.x, v.y, P[0], P[1]), J = 2; J < P.length; J += 2)
      B = o(B, N(v.x, v.y, P[J], P[J + 1]));
    return B - T;
  }, gt.prototype.containsVert = function(v, T) {
    for (var P = (this || window).tPlanes, B = 0; B < P.length; B++) {
      var J = P[B].n, nt = N(J.x, J.y, v, T) - P[B].d;
      if (nt > 0)
        return !1;
    }
    return !0;
  }, gt.prototype.containsVertPartial = function(v, T, P) {
    for (var B = (this || window).tPlanes, J = 0; J < B.length; J++) {
      var nt = B[J].n;
      if (!(D(nt, P) < 0)) {
        var st = N(nt.x, nt.y, v, T) - B[J].d;
        if (st > 0)
          return !1;
      }
    }
    return !0;
  }, gt.prototype.getNumVerts = function() {
    return this.verts.length / 2;
  }, gt.prototype.getCount = gt.prototype.getNumVerts, gt.prototype.getVert = function(v) {
    return new y(this.verts[v * 2], this.verts[v * 2 + 1]);
  };
  var ct = t.Body = function(v, T) {
    this.p = new y(0, 0), this.vx = (this || window).vy = 0, this.f = new y(0, 0), this.w = 0, this.t = 0, this.v_limit = 1 / 0, this.w_limit = 1 / 0, this.v_biasx = (this || window).v_biasy = 0, this.w_bias = 0, this.space = null, this.shapeList = [], this.arbiterList = null, this.constraintList = null, this.nodeRoot = null, this.nodeNext = null, this.nodeIdleTime = 0, this.setMass(v), this.setMoment(T), this.rot = new y(0, 0), this.setAngle(0);
  }, bt = /* @__PURE__ */ H(function() {
    var v = new ct(1 / 0, 1 / 0);
    return v.nodeIdleTime = 1 / 0, v;
  }, "createStaticBody");
  if (t.StaticBody = bt, typeof DEBUG != "undefined" && DEBUG) {
    var Et = /* @__PURE__ */ H(function(v, T) {
      e(v.x == v.x && v.y == v.y, T);
    }, "v_assert_nan"), wt = /* @__PURE__ */ H(function(v, T) {
      e(Math.abs(v.x) !== 1 / 0 && Math.abs(v.y) !== 1 / 0, T);
    }, "v_assert_infinite"), It = /* @__PURE__ */ H(function(v, T) {
      Et(v, T), wt(v, T);
    }, "v_assert_sane");
    ct.prototype.sanityCheck = function() {
      e(this.m === (this || window).m && this.m_inv === (this || window).m_inv, "Body's mass is invalid."), e(this.i === (this || window).i && this.i_inv === (this || window).i_inv, "Body's moment is invalid."), It(this.p, "Body's position is invalid."), It(this.f, "Body's force is invalid."), e(this.vx === (this || window).vx && Math.abs(this.vx) !== 1 / 0, "Body's velocity is invalid."), e(this.vy === (this || window).vy && Math.abs(this.vy) !== 1 / 0, "Body's velocity is invalid."), e(this.a === (this || window).a && Math.abs(this.a) !== 1 / 0, "Body's angle is invalid."), e(this.w === (this || window).w && Math.abs(this.w) !== 1 / 0, "Body's angular velocity is invalid."), e(this.t === (this || window).t && Math.abs(this.t) !== 1 / 0, "Body's torque is invalid."), It(this.rot, "Body's rotation vector is invalid."), e(this.v_limit === (this || window).v_limit, "Body's velocity limit is invalid."), e(this.w_limit === (this || window).w_limit, "Body's angular velocity limit is invalid.");
    };
  } else
    ct.prototype.sanityCheck = function() {
    };
  ct.prototype.getPos = function() {
    return this.p;
  }, ct.prototype.getVel = function() {
    return new y(this.vx, this.vy);
  }, ct.prototype.getAngVel = function() {
    return this.w;
  }, ct.prototype.getPosition = ct.prototype.getPos, ct.prototype.getVelocity = ct.prototype.getVel, ct.prototype.getAngularVelocity = ct.prototype.getAngVel, ct.prototype.getCenterOfGravity = function() {
    return this.p;
  }, ct.prototype.isSleeping = function() {
    return this.nodeRoot !== null;
  }, ct.prototype.isStatic = function() {
    return this.nodeIdleTime === 1 / 0;
  }, ct.prototype.isRogue = function() {
    return this.space === null;
  }, ct.prototype.setMass = function(v) {
    e(v > 0, "Mass must be positive and non-zero."), this.activate(), this.m = v, this.m_inv = 1 / v;
  }, ct.prototype.setMoment = function(v) {
    e(v > 0, "Moment of Inertia must be positive and non-zero."), this.activate(), this.i = v, this.i_inv = 1 / v;
  }, ct.prototype.addShape = function(v) {
    this.shapeList.push(v);
  }, ct.prototype.removeShape = function(v) {
    l(this.shapeList, v);
  };
  var Dt = /* @__PURE__ */ H(function(v, T, P) {
    return v === P ? v.next(T) : (v.a === T ? v.next_a = Dt(v.next_a, T, P) : v.next_b = Dt(v.next_b, T, P), v);
  }, "filterConstraints");
  ct.prototype.removeConstraint = function(v) {
    this.constraintList = Dt(this.constraintList, this, v);
  }, ct.prototype.setPos = function(v) {
    this.activate(), this.sanityCheck(), v === A && (v = t.v(0, 0)), this.p = v;
  }, ct.prototype.setVel = function(v) {
    this.activate(), this.vx = v.x, this.vy = v.y;
  }, ct.prototype.setAngVel = function(v) {
    this.activate(), this.w = v;
  }, ct.prototype.setAngleInternal = function(v) {
    e(!isNaN(v), "Internal Error: Attempting to set body's angle to NaN"), this.a = v, this.rot.x = Math.cos(v), this.rot.y = Math.sin(v);
  }, ct.prototype.setAngle = function(v) {
    this.activate(), this.sanityCheck(), this.setAngleInternal(v);
  }, ct.prototype.velocity_func = function(v, T, P) {
    var B = (this || window).vx * T + (v.x + this.f.x * this.m_inv) * P, J = (this || window).vy * T + (v.y + this.f.y * this.m_inv) * P, nt = (this || window).v_limit, st = B * B + J * J, dt = st > nt * nt ? nt / Math.sqrt(st) : 1;
    this.vx = B * dt, this.vy = J * dt;
    var Tt = (this || window).w_limit;
    this.w = m(this.w * T + this.t * this.i_inv * P, -Tt, Tt), this.sanityCheck();
  }, ct.prototype.position_func = function(v) {
    this.p.x += (this.vx + this.v_biasx) * v, this.p.y += (this.vy + this.v_biasy) * v, this.setAngleInternal(this.a + (this.w + this.w_bias) * v), this.v_biasx = (this || window).v_biasy = 0, this.w_bias = 0, this.sanityCheck();
  }, ct.prototype.resetForces = function() {
    this.activate(), this.f = new y(0, 0), this.t = 0;
  }, ct.prototype.applyForce = function(v, T) {
    this.activate(), this.f = Z(this.f, v), this.t += rt(T, v);
  }, ct.prototype.applyImpulse = function(v, T) {
    this.activate(), Ae(this, v.x, v.y, T);
  }, ct.prototype.getVelAtPoint = function(v) {
    return Z(new y(this.vx, this.vy), et(L(v), this.w));
  }, ct.prototype.getVelAtWorldPoint = function(v) {
    return this.getVelAtPoint(U(v, this.p));
  }, ct.prototype.getVelAtLocalPoint = function(v) {
    return this.getVelAtPoint(I(v, this.rot));
  }, ct.prototype.eachShape = function(v) {
    for (var T = 0, P = (this || window).shapeList.length; T < P; T++)
      v(this.shapeList[T]);
  }, ct.prototype.eachConstraint = function(v) {
    for (var T = (this || window).constraintList; T; ) {
      var P = T.next(this);
      v(T), T = P;
    }
  }, ct.prototype.eachArbiter = function(v) {
    for (var T = (this || window).arbiterList; T; ) {
      var P = T.next(this);
      T.swappedColl = (this || window) === T.body_b, v(T), T = P;
    }
  }, ct.prototype.local2World = function(v) {
    return Z(this.p, I(v, this.rot));
  }, ct.prototype.world2Local = function(v) {
    return O(U(v, this.p), this.rot);
  }, ct.prototype.localToWorld = ct.prototype.local2World, ct.prototype.worldToLocal = ct.prototype.world2Local, ct.prototype.kineticEnergy = function() {
    var v = (this || window).vx * this.vx + this.vy * this.vy, T = (this || window).w * this.w;
    return (v ? v * this.m : 0) + (T ? T * this.i : 0);
  };
  var Ut = t.SpatialIndex = function(v) {
    if (this.staticIndex = v, v) {
      if (v.dynamicIndex)
        throw new Error("This static index is already associated with a dynamic index.");
      v.dynamicIndex = (this || window);
    }
  };
  Ut.prototype.collideStatic = function(v, T) {
    if (v.count > 0) {
      var P = v.query;
      this.each(function(B) {
        P(B, new k(B.bb_l, B.bb_b, B.bb_r, B.bb_t), T);
      });
    }
  };
  var Gt = t.BBTree = function(v) {
    Ut.call(this, v), this.velocityFunc = null, this.leaves = {}, this.count = 0, this.root = null, this.pooledNodes = null, this.pooledPairs = null, this.stamp = 0;
  };
  Gt.prototype = Object.create(Ut.prototype);
  var at = /* @__PURE__ */ H(function(v, T, P) {
    this.obj = null, this.bb_l = o(T.bb_l, P.bb_l), this.bb_b = o(T.bb_b, P.bb_b), this.bb_r = a(T.bb_r, P.bb_r), this.bb_t = a(T.bb_t, P.bb_t), this.parent = null, this.setA(T), this.setB(P);
  }, "Node");
  Gt.prototype.makeNode = function(v, T) {
    var P = (this || window).pooledNodes;
    return P ? (this.pooledNodes = P.parent, P.constructor(this, v, T), P) : new at(this, v, T);
  };
  var ot = /* @__PURE__ */ H(function(v, T) {
    this.obj = T, v.getBB(T, this), this.parent = null, this.stamp = 1, this.pairs = null;
  }, "Leaf");
  Gt.prototype.getBB = function(v, T) {
    var P = (this || window).velocityFunc;
    if (P) {
      var B = 0.1, J = (v.bb_r - v.bb_l) * B, nt = (v.bb_t - v.bb_b) * B, st = et(P(v), 0.1);
      T.bb_l = v.bb_l + o(-J, st.x), T.bb_b = v.bb_b + o(-nt, st.y), T.bb_r = v.bb_r + a(J, st.x), T.bb_t = v.bb_t + a(nt, st.y);
    } else
      T.bb_l = v.bb_l, T.bb_b = v.bb_b, T.bb_r = v.bb_r, T.bb_t = v.bb_t;
  }, Gt.prototype.getStamp = function() {
    var v = (this || window).dynamicIndex;
    return v && v.stamp ? v.stamp : this.stamp;
  }, Gt.prototype.incrementStamp = function() {
    this.dynamicIndex && this.dynamicIndex.stamp ? this.dynamicIndex.stamp++ : this.stamp++;
  };
  var _t = /* @__PURE__ */ H(function(v, T, P, B) {
    this.prevA = null, this.leafA = v, this.nextA = T, this.prevB = null, this.leafB = P, this.nextB = B;
  }, "Pair");
  Gt.prototype.makePair = function(v, T, P, B) {
    var J = (this || window).pooledPairs;
    return J ? (this.pooledPairs = J.prevA, J.prevA = null, J.leafA = v, J.nextA = T, J.prevB = null, J.leafB = P, J.nextB = B, J) : new _t(v, T, P, B);
  }, _t.prototype.recycle = function(v) {
    this.prevA = v.pooledPairs, v.pooledPairs = (this || window);
  };
  var mt = /* @__PURE__ */ H(function(v, T, P) {
    P && (P.leafA === T ? P.prevA = v : P.prevB = v), v ? v.leafA === T ? v.nextA = P : v.nextB = P : T.pairs = P;
  }, "unlinkThread");
  ot.prototype.clearPairs = function(v) {
    var T = (this || window).pairs, P;
    for (this.pairs = null; T; )
      T.leafA === (this || window) ? (P = T.nextA, mt(T.prevB, T.leafB, T.nextB)) : (P = T.nextB, mt(T.prevA, T.leafA, T.nextA)), T.recycle(v), T = P;
  };
  var Ct = /* @__PURE__ */ H(function(v, T, P) {
    var B = v.pairs, J = T.pairs, nt = P.makePair(v, B, T, J);
    v.pairs = T.pairs = nt, B && (B.leafA === v ? B.prevA = nt : B.prevB = nt), J && (J.leafA === T ? J.prevA = nt : J.prevB = nt);
  }, "pairInsert");
  at.prototype.recycle = function(v) {
    this.parent = v.pooledNodes, v.pooledNodes = (this || window);
  }, ot.prototype.recycle = function(v) {
  }, at.prototype.setA = function(v) {
    this.A = v, v.parent = (this || window);
  }, at.prototype.setB = function(v) {
    this.B = v, v.parent = (this || window);
  }, ot.prototype.isLeaf = !0, at.prototype.isLeaf = !1, at.prototype.otherChild = function(v) {
    return this.A == v ? this.B : this.A;
  }, at.prototype.replaceChild = function(v, T, P) {
    n(v == (this || window).A || v == (this || window).B, "Node is not a child of parent."), this.A == v ? (this.A.recycle(P), this.setA(T)) : (this.B.recycle(P), this.setB(T));
    for (var B = (this || window); B; B = B.parent) {
      var J = B.A, nt = B.B;
      B.bb_l = o(J.bb_l, nt.bb_l), B.bb_b = o(J.bb_b, nt.bb_b), B.bb_r = a(J.bb_r, nt.bb_r), B.bb_t = a(J.bb_t, nt.bb_t);
    }
  }, at.prototype.bbArea = ot.prototype.bbArea = function() {
    return (this.bb_r - this.bb_l) * (this.bb_t - this.bb_b);
  };
  var yt = /* @__PURE__ */ H(function(v, T) {
    return (a(v.bb_r, T.bb_r) - o(v.bb_l, T.bb_l)) * (a(v.bb_t, T.bb_t) - o(v.bb_b, T.bb_b));
  }, "bbTreeMergedArea"), At = /* @__PURE__ */ H(function(v, T) {
    return Math.abs(v.bb_l + v.bb_r - T.bb_l - T.bb_r) + Math.abs(v.bb_b + v.bb_t - T.bb_b - T.bb_t);
  }, "bbProximity"), Pt = /* @__PURE__ */ H(function(v, T, P) {
    if (v == null)
      return T;
    if (v.isLeaf)
      return P.makeNode(T, v);
    var B = v.B.bbArea() + yt(v.A, T), J = v.A.bbArea() + yt(v.B, T);
    return B === J && (B = At(v.A, T), J = At(v.B, T)), J < B ? v.setB(Pt(v.B, T, P)) : v.setA(Pt(v.A, T, P)), v.bb_l = o(v.bb_l, T.bb_l), v.bb_b = o(v.bb_b, T.bb_b), v.bb_r = a(v.bb_r, T.bb_r), v.bb_t = a(v.bb_t, T.bb_t), v;
  }, "subtreeInsert");
  at.prototype.intersectsBB = ot.prototype.intersectsBB = function(v) {
    return this.bb_l <= v.r && v.l <= (this || window).bb_r && this.bb_b <= v.t && v.b <= (this || window).bb_t;
  };
  var kt = /* @__PURE__ */ H(function(v, T, P) {
    v.intersectsBB(T) && (v.isLeaf ? P(v.obj) : (kt(v.A, T, P), kt(v.B, T, P)));
  }, "subtreeQuery"), Ot = /* @__PURE__ */ H(function(v, T, P) {
    var B = 1 / (P.x - T.x), J = v.bb_l == T.x ? -1 / 0 : (v.bb_l - T.x) * B, nt = v.bb_r == T.x ? 1 / 0 : (v.bb_r - T.x) * B, st = o(J, nt), dt = a(J, nt), Tt = 1 / (P.y - T.y), xt = v.bb_b == T.y ? -1 / 0 : (v.bb_b - T.y) * Tt, Rt = v.bb_t == T.y ? 1 / 0 : (v.bb_t - T.y) * Tt, Mt = o(xt, Rt), Wt = a(xt, Rt);
    if (Mt <= dt && st <= Wt) {
      var qt = a(st, Mt), ne = o(dt, Wt);
      if (0 <= ne && qt <= 1)
        return a(qt, 0);
    }
    return 1 / 0;
  }, "nodeSegmentQuery"), Xt = /* @__PURE__ */ H(function(v, T, P, B, J) {
    if (v.isLeaf)
      return J(v.obj);
    var nt = Ot(v.A, T, P), st = Ot(v.B, T, P);
    return nt < st ? (nt < B && (B = o(B, Xt(v.A, T, P, B, J))), st < B && (B = o(B, Xt(v.B, T, P, B, J)))) : (st < B && (B = o(B, Xt(v.B, T, P, B, J))), nt < B && (B = o(B, Xt(v.A, T, P, B, J)))), B;
  }, "subtreeSegmentQuery");
  Gt.prototype.subtreeRecycle = function(v) {
    v.isLeaf && (this.subtreeRecycle(v.A), this.subtreeRecycle(v.B), v.recycle(this));
  };
  var Vt = /* @__PURE__ */ H(function(v, T, P) {
    if (T == v)
      return null;
    var B = T.parent;
    if (B == v) {
      var J = v.otherChild(T);
      return J.parent = v.parent, v.recycle(P), J;
    } else
      return B.parent.replaceChild(B, B.otherChild(T), P), v;
  }, "subtreeRemove"), Lt = /* @__PURE__ */ H(function(v, T) {
    return v.bb_l <= T.bb_r && T.bb_l <= v.bb_r && v.bb_b <= T.bb_t && T.bb_b <= v.bb_t;
  }, "bbTreeIntersectsNode");
  ot.prototype.markLeafQuery = function(v, T, P, B) {
    Lt(v, this) && (T ? Ct(v, this, P) : (this.stamp < v.stamp && Ct(this, v, P), B && B(v.obj, this.obj)));
  }, at.prototype.markLeafQuery = function(v, T, P, B) {
    Lt(v, this) && (this.A.markLeafQuery(v, T, P, B), this.B.markLeafQuery(v, T, P, B));
  }, ot.prototype.markSubtree = function(v, T, P) {
    if (this.stamp == v.getStamp()) {
      T && T.markLeafQuery(this, !1, v, P);
      for (var B = (this || window); B.parent; B = B.parent)
        B == B.parent.A ? B.parent.B.markLeafQuery(this, !0, v, P) : B.parent.A.markLeafQuery(this, !1, v, P);
    } else
      for (var J = (this || window).pairs; J; )
        this === J.leafB ? (P && P(J.leafA.obj, this.obj), J = J.nextB) : J = J.nextA;
  }, at.prototype.markSubtree = function(v, T, P) {
    this.A.markSubtree(v, T, P), this.B.markSubtree(v, T, P);
  }, ot.prototype.containsObj = function(v) {
    return this.bb_l <= v.bb_l && this.bb_r >= v.bb_r && this.bb_b <= v.bb_b && this.bb_t >= v.bb_t;
  }, ot.prototype.update = function(v) {
    var T = v.root, P = (this || window).obj;
    return this.containsObj(P) ? !1 : (v.getBB(this.obj, this), T = Vt(T, this, v), v.root = Pt(T, this, v), this.clearPairs(v), this.stamp = v.getStamp(), !0);
  }, ot.prototype.addPairs = function(v) {
    var T = v.dynamicIndex;
    if (T) {
      var P = T.root;
      P && P.markLeafQuery(this, !0, T, null);
    } else {
      var B = v.staticIndex.root;
      this.markSubtree(v, B, null);
    }
  }, Gt.prototype.insert = function(v, T) {
    var P = new ot(this, v);
    this.leaves[T] = P, this.root = Pt(this.root, P, this), this.count++, P.stamp = (this || window).getStamp(), P.addPairs(this), this.incrementStamp();
  }, Gt.prototype.remove = function(v, T) {
    var P = (this || window).leaves[T];
    delete this.leaves[T], this.root = Vt(this.root, P, this), this.count--, P.clearPairs(this), P.recycle(this);
  }, Gt.prototype.contains = function(v, T) {
    return this.leaves[T] != null;
  };
  var Nt = /* @__PURE__ */ H(function(v, T) {
  }, "voidQueryFunc");
  Gt.prototype.reindexQuery = function(v) {
    if (this.root) {
      var T, P = (this || window).leaves;
      for (T in P)
        P[T].update(this);
      var B = (this || window).staticIndex, J = B && B.root;
      this.root.markSubtree(this, J, v), B && !J && this.collideStatic(this, B, v), this.incrementStamp();
    }
  }, Gt.prototype.reindex = function() {
    this.reindexQuery(Nt);
  }, Gt.prototype.reindexObject = function(v, T) {
    var P = (this || window).leaves[T];
    P && (P.update(this) && P.addPairs(this), this.incrementStamp());
  }, Gt.prototype.pointQuery = function(v, T) {
    this.query(new k(v.x, v.y, v.x, v.y), T);
  }, Gt.prototype.segmentQuery = function(v, T, P, B) {
    this.root && Xt(this.root, v, T, P, B);
  }, Gt.prototype.query = function(v, T) {
    this.root && kt(this.root, v, T);
  }, Gt.prototype.count = function() {
    return this.count;
  }, Gt.prototype.each = function(v) {
    var T;
    for (T in this.leaves)
      v(this.leaves[T].obj);
  };
  var Jt = /* @__PURE__ */ H(function(v, T, P, B, J) {
    return (a(v.bb_r, B) - o(v.bb_l, T)) * (a(v.bb_t, J) - o(v.bb_b, P));
  }, "bbTreeMergedArea2"), Ht = /* @__PURE__ */ H(function(v, T, P, B) {
    if (B == 1)
      return T[P];
    if (B == 2)
      return v.makeNode(T[P], T[P + 1]);
    for (var J = T[P], nt = J.bb_l, st = J.bb_b, dt = J.bb_r, Tt = J.bb_t, xt = P + B, Rt = P + 1; Rt < xt; Rt++)
      J = T[Rt], nt = o(nt, J.bb_l), st = o(st, J.bb_b), dt = a(dt, J.bb_r), Tt = a(Tt, J.bb_t);
    var Mt = dt - nt > Tt - st, Wt = new Array(B * 2);
    if (Mt)
      for (var Rt = P; Rt < xt; Rt++)
        Wt[2 * Rt + 0] = T[Rt].bb_l, Wt[2 * Rt + 1] = T[Rt].bb_r;
    else
      for (var Rt = P; Rt < xt; Rt++)
        Wt[2 * Rt + 0] = T[Rt].bb_b, Wt[2 * Rt + 1] = T[Rt].bb_t;
    Wt.sort(function(Ke, Qe) {
      return Ke - Qe;
    });
    var qt = (Wt[B - 1] + Wt[B]) * 0.5, ne = nt, ue = st, Te = dt, Re = Tt, ae = nt, Ie = st, we = dt, je = Tt;
    Mt ? Te = ae = qt : Re = Ie = qt;
    for (var De = xt, We = P; We < De; ) {
      var J = T[We];
      Jt(J, ae, Ie, we, je) < Jt(J, ne, ue, Te, Re) ? (De--, T[We] = T[De], T[De] = J) : We++;
    }
    if (De == B) {
      for (var J = null, Rt = P; Rt < xt; Rt++)
        J = Pt(J, T[Rt], v);
      return J;
    }
    return NodeNew(
      v,
      Ht(v, T, P, De - P),
      Ht(v, T, De, xt - De)
    );
  }, "partitionNodes");
  Gt.prototype.optimize = function() {
    var v = new Array(this.count), T = 0;
    for (var P in this.leaves)
      v[T++] = (this || window).nodes[P];
    tree.subtreeRecycle(root), this.root = Ht(tree, v, v.length);
  };
  var Kt = /* @__PURE__ */ H(function(v, T) {
    !v.isLeaf && T <= 10 && (Kt(v.A, T + 1), Kt(v.B, T + 1));
    for (var P = "", B = 0; B < T; B++)
      P += " ";
    console.log(P + v.bb_b + " " + v.bb_t);
  }, "nodeRender");
  Gt.prototype.log = function() {
    this.root && Kt(this.root, 0);
  };
  var ee = t.CollisionHandler = function() {
    this.a = (this || window).b = 0;
  };
  ee.prototype.begin = function(v, T) {
    return !0;
  }, ee.prototype.preSolve = function(v, T) {
    return !0;
  }, ee.prototype.postSolve = function(v, T) {
  }, ee.prototype.separate = function(v, T) {
  };
  var Zt = /* @__PURE__ */ H(function(v, T) {
    this.e = 0, this.u = 0, this.surface_vr = A, this.a = v, this.body_a = v.body, this.b = T, this.body_b = T.body, this.thread_a_next = (this || window).thread_a_prev = null, this.thread_b_next = (this || window).thread_b_prev = null, this.contacts = null, this.stamp = 0, this.handler = null, this.swappedColl = !1, this.state = "first coll";
  }, "Arbiter");
  Zt.prototype.getShapes = function() {
    return this.swappedColl ? [this.b, this.a] : [this.a, this.b];
  }, Zt.prototype.totalImpulse = function() {
    for (var v = (this || window).contacts, T = new y(0, 0), P = 0, B = v.length; P < B; P++) {
      var J = v[P];
      T.add(et(J.n, J.jnAcc));
    }
    return this.swappedColl ? T : T.neg();
  }, Zt.prototype.totalImpulseWithFriction = function() {
    for (var v = (this || window).contacts, T = new y(0, 0), P = 0, B = v.length; P < B; P++) {
      var J = v[P];
      T.add(new y(J.jnAcc, J.jtAcc).rotate(J.n));
    }
    return this.swappedColl ? T : T.neg();
  }, Zt.prototype.totalKE = function() {
    for (var v = (1 - this.e) / (1 + this.e), T = 0, P = (this || window).contacts, B = 0, J = P.length; B < J; B++) {
      var nt = P[B], st = nt.jnAcc, dt = nt.jtAcc;
      T += v * st * st / nt.nMass + dt * dt / nt.tMass;
    }
    return T;
  }, Zt.prototype.ignore = function() {
    this.state = "ignore";
  }, Zt.prototype.getA = function() {
    return this.swappedColl ? this.b : this.a;
  }, Zt.prototype.getB = function() {
    return this.swappedColl ? this.a : this.b;
  }, Zt.prototype.isFirstContact = function() {
    return this.state === "first coll";
  };
  var $t = /* @__PURE__ */ H(function(v, T, P) {
    this.point = v, this.normal = T, this.dist = P;
  }, "ContactPoint");
  Zt.prototype.getContactPointSet = function() {
    var v = new Array(this.contacts.length), T;
    for (T = 0; T < v.length; T++)
      v[T] = new $t(this.contacts[T].p, this.contacts[T].n, this.contacts[T].dist);
    return v;
  }, Zt.prototype.getNormal = function(v) {
    var T = (this || window).contacts[v].n;
    return this.swappedColl ? Q(T) : T;
  }, Zt.prototype.getPoint = function(v) {
    return this.contacts[v].p;
  }, Zt.prototype.getDepth = function(v) {
    return this.contacts[v].dist;
  };
  var ie = /* @__PURE__ */ H(function(v, T, P, B) {
    P ? P.body_a === T ? P.thread_a_next = B : P.thread_b_next = B : T.arbiterList = B, B && (B.body_a === T ? B.thread_a_prev = P : B.thread_b_prev = P);
  }, "unthreadHelper");
  Zt.prototype.unthread = function() {
    ie(this, this.body_a, this.thread_a_prev, this.thread_a_next), ie(this, this.body_b, this.thread_b_prev, this.thread_b_next), this.thread_a_prev = (this || window).thread_a_next = null, this.thread_b_prev = (this || window).thread_b_next = null;
  }, Zt.prototype.update = function(v, T, P, B) {
    if (this.contacts)
      for (var J = 0; J < this.contacts.length; J++)
        for (var nt = (this || window).contacts[J], st = 0; st < v.length; st++) {
          var dt = v[st];
          dt.hash === nt.hash && (dt.jnAcc = nt.jnAcc, dt.jtAcc = nt.jtAcc);
        }
    this.contacts = v, this.handler = T, this.swappedColl = P.collision_type !== T.a, this.e = P.e * B.e, this.u = P.u * B.u, this.surface_vr = U(P.surface_v, B.surface_v), this.a = P, this.body_a = P.body, this.b = B, this.body_b = B.body, this.state == "cached" && (this.state = "first coll");
  }, Zt.prototype.preStep = function(v, T, P) {
    for (var B = (this || window).body_a, J = (this || window).body_b, nt = 0; nt < this.contacts.length; nt++) {
      var st = (this || window).contacts[nt];
      st.r1 = U(st.p, B.p), st.r2 = U(st.p, J.p), st.nMass = 1 / Be(B, J, st.r1, st.r2, st.n), st.tMass = 1 / Be(B, J, st.r1, st.r2, L(st.n)), st.bias = -P * o(0, st.dist + T) / v, st.jBias = 0, st.bounce = fe(B, J, st.r1, st.r2, st.n) * this.e;
    }
  }, Zt.prototype.applyCachedImpulse = function(v) {
    if (!this.isFirstContact())
      for (var T = (this || window).body_a, P = (this || window).body_b, B = 0; B < this.contacts.length; B++) {
        var J = (this || window).contacts[B], nt = J.n.x, st = J.n.y, dt = nt * J.jnAcc - st * J.jtAcc, Tt = nt * J.jtAcc + st * J.jnAcc;
        ye(T, P, J.r1, J.r2, dt * v, Tt * v);
      }
  }, Zt.prototype.applyImpulse = function() {
    for (var v = (this || window).body_a, T = (this || window).body_b, P = (this || window).surface_vr, B = (this || window).u, J = 0; J < this.contacts.length; J++) {
      var nt = (this || window).contacts[J], st = nt.nMass, dt = nt.n, Tt = nt.r1, xt = nt.r2, Rt = T.vx - xt.y * T.w - (v.vx - Tt.y * v.w), Mt = T.vy + xt.x * T.w - (v.vy + Tt.x * v.w), Wt = dt.x * (T.v_biasx - xt.y * T.w_bias - v.v_biasx + Tt.y * v.w_bias) + dt.y * (xt.x * T.w_bias + T.v_biasy - Tt.x * v.w_bias - v.v_biasy), qt = N(Rt, Mt, dt.x, dt.y), ne = N(Rt + P.x, Mt + P.y, -dt.y, dt.x), ue = (nt.bias - Wt) * st, Te = nt.jBias;
      nt.jBias = a(Te + ue, 0);
      var Re = -(nt.bounce + qt) * st, ae = nt.jnAcc;
      nt.jnAcc = a(ae + Re, 0);
      var Ie = B * nt.jnAcc, we = -ne * nt.tMass, je = nt.jtAcc;
      nt.jtAcc = m(je + we, -Ie, Ie);
      var De = dt.x * (nt.jBias - Te), We = dt.y * (nt.jBias - Te);
      Ue(v, -De, -We, Tt), Ue(T, De, We, xt);
      var Ke = nt.jnAcc - ae, Qe = nt.jtAcc - je;
      ye(v, T, Tt, xt, dt.x * Ke - dt.y * Qe, dt.x * Qe + dt.y * Ke);
    }
  }, Zt.prototype.callSeparate = function(v) {
    var T = v.lookupHandler(this.a.collision_type, this.b.collision_type);
    T.separate(this, v);
  }, Zt.prototype.next = function(v) {
    return this.body_a == v ? this.thread_a_next : this.thread_b_next;
  };
  var Ft = /* @__PURE__ */ H(function(v, T, P, B) {
    this.p = v, this.n = T, this.dist = P, this.r1 = (this || window).r2 = A, this.nMass = (this || window).tMass = (this || window).bounce = (this || window).bias = 0, this.jnAcc = (this || window).jtAcc = (this || window).jBias = 0, this.hash = B;
  }, "Contact"), zt = [], Qt = /* @__PURE__ */ H(function(v, T, P, B) {
    var J = P + B, nt = U(T, v), st = K(nt);
    if (!(st >= J * J)) {
      var dt = Math.sqrt(st);
      return new Ft(
        Z(v, et(nt, 0.5 + (P - 0.5 * J) / (dt || 1 / 0))),
        dt ? et(nt, 1 / dt) : new y(1, 0),
        dt - J,
        0
      );
    }
  }, "circle2circleQuery"), le = /* @__PURE__ */ H(function(v, T) {
    var P = Qt(v.tc, T.tc, v.r, T.r);
    return P ? [P] : zt;
  }, "circle2circle"), _e = /* @__PURE__ */ H(function(v, T) {
    var P = T.ta, B = T.tb, J = v.tc, nt = U(B, P), st = g(D(nt, U(J, P)) / K(nt)), dt = Z(P, et(nt, st)), Tt = Qt(J, dt, v.r, T.r);
    if (Tt) {
      var xt = Tt.n;
      return st === 0 && D(xt, T.a_tangent) < 0 || st === 1 && D(xt, T.b_tangent) < 0 ? zt : [Tt];
    } else
      return zt;
  }, "circle2segment"), he = 0, Se = /* @__PURE__ */ H(function(v, T) {
    var P = 0, B = v.valueOnAxis(T[0].n, T[0].d);
    if (B > 0)
      return -1;
    for (var J = 1; J < T.length; J++) {
      var nt = v.valueOnAxis(T[J].n, T[J].d);
      if (nt > 0)
        return -1;
      nt > B && (B = nt, P = J);
    }
    return he = B, P;
  }, "findMSA"), xe = /* @__PURE__ */ H(function(v, T, P, B) {
    for (var J = [], nt = v.tVerts, st = 0; st < nt.length; st += 2) {
      var dt = nt[st], Tt = nt[st + 1];
      T.containsVertPartial(dt, Tt, Q(P)) && J.push(new Ft(new y(dt, Tt), P, B, c(v.hashid, st)));
    }
    for (var xt = T.tVerts, st = 0; st < xt.length; st += 2) {
      var dt = xt[st], Tt = xt[st + 1];
      v.containsVertPartial(dt, Tt, P) && J.push(new Ft(new y(dt, Tt), P, B, c(T.hashid, st)));
    }
    return J;
  }, "findVertsFallback"), Bt = /* @__PURE__ */ H(function(v, T, P, B) {
    for (var J = [], nt = v.tVerts, st = 0; st < nt.length; st += 2) {
      var dt = nt[st], Tt = nt[st + 1];
      T.containsVert(dt, Tt) && J.push(new Ft(new y(dt, Tt), P, B, c(v.hashid, st >> 1)));
    }
    for (var xt = T.tVerts, st = 0; st < xt.length; st += 2) {
      var dt = xt[st], Tt = xt[st + 1];
      v.containsVert(dt, Tt) && J.push(new Ft(new y(dt, Tt), P, B, c(T.hashid, st >> 1)));
    }
    return J.length ? J : xe(v, T, P, B);
  }, "findVerts"), ce = /* @__PURE__ */ H(function(v, T) {
    var P = Se(T, v.tPlanes);
    if (P == -1)
      return zt;
    var B = he, J = Se(v, T.tPlanes);
    if (J == -1)
      return zt;
    var nt = he;
    return B > nt ? Bt(v, T, v.tPlanes[P].n, B) : Bt(v, T, Q(T.tPlanes[J].n), nt);
  }, "poly2poly"), pe = /* @__PURE__ */ H(function(v, T, P) {
    var B = D(T, v.ta) - v.r, J = D(T, v.tb) - v.r;
    return o(B, J) - P;
  }, "segValueOnAxis"), de = /* @__PURE__ */ H(function(v, T, P, B, J) {
    for (var nt = rt(T.tn, T.ta), st = rt(T.tn, T.tb), dt = et(T.tn, J), Tt = P.tVerts, xt = 0; xt < Tt.length; xt += 2) {
      var Rt = Tt[xt], Mt = Tt[xt + 1];
      if (N(Rt, Mt, dt.x, dt.y) < D(T.tn, T.ta) * J + T.r) {
        var Wt = w(T.tn.x, T.tn.y, Rt, Mt);
        nt >= Wt && Wt >= st && v.push(new Ft(new y(Rt, Mt), dt, B, c(P.hashid, xt)));
      }
    }
  }, "findPointsBehindSeg"), jt = /* @__PURE__ */ H(function(v, T) {
    var P = [], B = T.tPlanes, J = B.length, nt = D(v.tn, v.ta), st = T.valueOnAxis(v.tn, nt) - v.r, dt = T.valueOnAxis(Q(v.tn), -nt) - v.r;
    if (dt > 0 || st > 0)
      return zt;
    var Tt = 0, xt = pe(v, B[0].n, B[0].d);
    if (xt > 0)
      return zt;
    for (var Rt = 0; Rt < J; Rt++) {
      var Mt = pe(v, B[Rt].n, B[Rt].d);
      if (Mt > 0)
        return zt;
      Mt > xt && (xt = Mt, Tt = Rt);
    }
    var Wt = Q(B[Tt].n), qt = Z(v.ta, et(Wt, v.r)), ne = Z(v.tb, et(Wt, v.r));
    if (T.containsVert(qt.x, qt.y) && P.push(new Ft(qt, Wt, xt, c(v.hashid, 0))), T.containsVert(ne.x, ne.y) && P.push(new Ft(ne, Wt, xt, c(v.hashid, 1))), (st >= xt || dt >= xt) && (st > dt ? de(P, v, T, st, 1) : de(P, v, T, dt, -1)), P.length === 0) {
      var ue = Tt * 2, Te = T.tVerts, Re = new y(Te[ue], Te[ue + 1]), ae;
      if (ae = Qt(v.ta, Re, v.r, 0))
        return [ae];
      if (ae = Qt(v.tb, Re, v.r, 0))
        return [ae];
      var Ie = J * 2, we = new y(Te[(ue + 2) % Ie], Te[(ue + 3) % Ie]);
      if (ae = Qt(v.ta, we, v.r, 0))
        return [ae];
      if (ae = Qt(v.tb, we, v.r, 0))
        return [ae];
    }
    return P;
  }, "seg2poly"), ve = /* @__PURE__ */ H(function(v, T) {
    for (var P = T.tPlanes, B = 0, J = D(P[0].n, v.tc) - P[0].d - v.r, nt = 0; nt < P.length; nt++) {
      var st = D(P[nt].n, v.tc) - P[nt].d - v.r;
      if (st > 0)
        return zt;
      st > J && (J = st, B = nt);
    }
    var dt = P[B].n, Tt = T.tVerts, xt = Tt.length, Rt = B << 1, Mt = Tt[Rt], Wt = Tt[Rt + 1], qt = Tt[(Rt + 2) % xt], ne = Tt[(Rt + 3) % xt], ue = w(dt.x, dt.y, Mt, Wt), Te = w(dt.x, dt.y, qt, ne), Re = rt(dt, v.tc);
    if (Re < Te) {
      var ae = Qt(v.tc, new y(qt, ne), v.r, 0);
      return ae ? [ae] : zt;
    } else {
      if (Re < ue)
        return [new Ft(
          U(v.tc, et(dt, v.r + J / 2)),
          Q(dt),
          J,
          0
        )];
      var ae = Qt(v.tc, new y(Mt, Wt), v.r, 0);
      return ae ? [ae] : zt;
    }
  }, "circle2poly");
  ut.prototype.collisionCode = 0, vt.prototype.collisionCode = 1, gt.prototype.collisionCode = 2, ut.prototype.collisionTable = [
    le,
    _e,
    ve
  ], vt.prototype.collisionTable = [
    null,
    function(v, T) {
      return zt;
    },
    jt
  ], gt.prototype.collisionTable = [
    null,
    null,
    ce
  ];
  var re = t.collideShapes = function(v, T) {
    return e(v.collisionCode <= T.collisionCode, "Collided shapes must be sorted by type"), v.collisionTable[T.collisionCode](v, T);
  }, Oe = new ee(), Yt = t.Space = function() {
    this.stamp = 0, this.curr_dt = 0, this.bodies = [], this.rousedBodies = [], this.sleepingComponents = [], this.staticShapes = new Gt(null), this.activeShapes = new Gt(this.staticShapes), this.arbiters = [], this.contactBuffersHead = null, this.cachedArbiters = {}, this.constraints = [], this.locked = 0, this.collisionHandlers = {}, this.defaultHandler = Oe, this.postStepCallbacks = [], this.iterations = 10, this.gravity = A, this.damping = 1, this.idleSpeedThreshold = 0, this.sleepTimeThreshold = 1 / 0, this.collisionSlop = 0.1, this.collisionBias = Math.pow(1 - 0.1, 60), this.collisionPersistence = 3, this.enableContactGraph = !1, this.staticBody = new ct(1 / 0, 1 / 0), this.staticBody.nodeIdleTime = 1 / 0, this.collideShapes = (this || window).makeCollideShapes();
  };
  Yt.prototype.getCurrentTimeStep = function() {
    return this.curr_dt;
  }, Yt.prototype.setIterations = function(v) {
    this.iterations = v;
  }, Yt.prototype.isLocked = function() {
    return this.locked;
  };
  var Ce = /* @__PURE__ */ H(function(v) {
    e(!v.locked, "This addition/removal cannot be done safely during a call to cpSpaceStep()  or during a query. Put these calls into a post-step callback.");
  }, "assertSpaceUnlocked");
  Yt.prototype.addCollisionHandler = function(v, T, P, B, J, nt) {
    Ce(this), this.removeCollisionHandler(v, T);
    var st = new ee();
    st.a = v, st.b = T, P && (st.begin = P), B && (st.preSolve = B), J && (st.postSolve = J), nt && (st.separate = nt), this.collisionHandlers[c(v, T)] = st;
  }, Yt.prototype.removeCollisionHandler = function(v, T) {
    Ce(this), delete this.collisionHandlers[c(v, T)];
  }, Yt.prototype.setDefaultCollisionHandler = function(v, T, P, B) {
    Ce(this);
    var J = new ee();
    v && (J.begin = v), T && (J.preSolve = T), P && (J.postSolve = P), B && (J.separate = B), this.defaultHandler = J;
  }, Yt.prototype.lookupHandler = function(v, T) {
    return this.collisionHandlers[c(v, T)] || this.defaultHandler;
  }, Yt.prototype.addShape = function(v) {
    var T = v.body;
    return T.isStatic() ? this.addStaticShape(v) : (e(!v.space, "This shape is already added to a space and cannot be added to another."), Ce(this), T.activate(), T.addShape(v), v.update(T.p, T.rot), this.activeShapes.insert(v, v.hashid), v.space = (this || window), v);
  }, Yt.prototype.addStaticShape = function(v) {
    e(!v.space, "This shape is already added to a space and cannot be added to another."), Ce(this);
    var T = v.body;
    return T.addShape(v), v.update(T.p, T.rot), this.staticShapes.insert(v, v.hashid), v.space = (this || window), v;
  }, Yt.prototype.addBody = function(v) {
    return e(!v.isStatic(), "Static bodies cannot be added to a space as they are not meant to be simulated."), e(!v.space, "This body is already added to a space and cannot be added to another."), Ce(this), this.bodies.push(v), v.space = (this || window), v;
  }, Yt.prototype.addConstraint = function(v) {
    e(!v.space, "This shape is already added to a space and cannot be added to another."), Ce(this);
    var T = v.a, P = v.b;
    return T.activate(), P.activate(), this.constraints.push(v), v.next_a = T.constraintList, T.constraintList = v, v.next_b = P.constraintList, P.constraintList = v, v.space = (this || window), v;
  }, Yt.prototype.filterArbiters = function(v, T) {
    for (var P in this.cachedArbiters) {
      var B = (this || window).cachedArbiters[P];
      (v === B.body_a && (T === B.a || T === null) || v === B.body_b && (T === B.b || T === null)) && (T && B.state !== "cached" && B.callSeparate(this), B.unthread(), l(this.arbiters, B), delete this.cachedArbiters[P]);
    }
  }, Yt.prototype.removeShape = function(v) {
    var T = v.body;
    T.isStatic() ? this.removeStaticShape(v) : (e(
      this.containsShape(v),
      "Cannot remove a shape that was not added to the space. (Removed twice maybe?)"
    ), Ce(this), T.activate(), T.removeShape(v), this.filterArbiters(T, v), this.activeShapes.remove(v, v.hashid), v.space = null);
  }, Yt.prototype.removeStaticShape = function(v) {
    e(
      this.containsShape(v),
      "Cannot remove a static or sleeping shape that was not added to the space. (Removed twice maybe?)"
    ), Ce(this);
    var T = v.body;
    T.isStatic() && T.activateStatic(v), T.removeShape(v), this.filterArbiters(T, v), this.staticShapes.remove(v, v.hashid), v.space = null;
  }, Yt.prototype.removeBody = function(v) {
    e(
      this.containsBody(v),
      "Cannot remove a body that was not added to the space. (Removed twice maybe?)"
    ), Ce(this), v.activate(), l(this.bodies, v), v.space = null;
  }, Yt.prototype.removeConstraint = function(v) {
    e(
      this.containsConstraint(v),
      "Cannot remove a constraint that was not added to the space. (Removed twice maybe?)"
    ), Ce(this), v.a.activate(), v.b.activate(), l(this.constraints, v), v.a.removeConstraint(v), v.b.removeConstraint(v), v.space = null;
  }, Yt.prototype.containsShape = function(v) {
    return v.space === (this || window);
  }, Yt.prototype.containsBody = function(v) {
    return v.space == (this || window);
  }, Yt.prototype.containsConstraint = function(v) {
    return v.space == (this || window);
  }, Yt.prototype.uncacheArbiter = function(v) {
    delete this.cachedArbiters[c(v.a.hashid, v.b.hashid)], l(this.arbiters, v);
  }, Yt.prototype.eachBody = function(v) {
    this.lock();
    {
      for (var T = (this || window).bodies, P = 0; P < T.length; P++)
        v(T[P]);
      for (var B = (this || window).sleepingComponents, P = 0; P < B.length; P++)
        for (var J = B[P], nt = J; nt; ) {
          var st = nt.nodeNext;
          v(nt), nt = st;
        }
    }
    this.unlock(!0);
  }, Yt.prototype.eachShape = function(v) {
    this.lock(), this.activeShapes.each(v), this.staticShapes.each(v), this.unlock(!0);
  }, Yt.prototype.eachConstraint = function(v) {
    this.lock();
    for (var T = (this || window).constraints, P = 0; P < T.length; P++)
      v(T[P]);
    this.unlock(!0);
  }, Yt.prototype.reindexStatic = function() {
    e(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete."), this.staticShapes.each(function(v) {
      var T = v.body;
      v.update(T.p, T.rot);
    }), this.staticShapes.reindex();
  }, Yt.prototype.reindexShape = function(v) {
    e(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
    var T = v.body;
    v.update(T.p, T.rot), this.activeShapes.reindexObject(v, v.hashid), this.staticShapes.reindexObject(v, v.hashid);
  }, Yt.prototype.reindexShapesForBody = function(v) {
    for (var T = v.shapeList; T; T = T.next)
      this.reindexShape(T);
  }, Yt.prototype.useSpatialHash = function(v, T) {
    throw new Error("Spatial Hash not implemented.");
  }, Yt.prototype.activateBody = function(v) {
    if (e(!v.isRogue(), "Internal error: Attempting to activate a rogue body."), this.locked)
      this.rousedBodies.indexOf(v) === -1 && this.rousedBodies.push(v);
    else {
      this.bodies.push(v);
      for (var T = 0; T < v.shapeList.length; T++) {
        var P = v.shapeList[T];
        this.staticShapes.remove(P, P.hashid), this.activeShapes.insert(P, P.hashid);
      }
      for (var B = v.arbiterList; B; B = B.next(v)) {
        var J = B.body_a;
        if (v === J || J.isStatic()) {
          var nt = B.a, st = B.b;
          this.cachedArbiters[c(nt.hashid, st.hashid)] = B, B.stamp = (this || window).stamp, B.handler = (this || window).lookupHandler(nt.collision_type, st.collision_type), this.arbiters.push(B);
        }
      }
      for (var dt = v.constraintList; dt; dt = dt.nodeNext) {
        var J = dt.a;
        (v === J || J.isStatic()) && this.constraints.push(dt);
      }
    }
  }, Yt.prototype.deactivateBody = function(v) {
    e(!v.isRogue(), "Internal error: Attempting to deactivate a rogue body."), l(this.bodies, v);
    for (var T = 0; T < v.shapeList.length; T++) {
      var P = v.shapeList[T];
      this.activeShapes.remove(P, P.hashid), this.staticShapes.insert(P, P.hashid);
    }
    for (var B = v.arbiterList; B; B = B.next(v)) {
      var J = B.body_a;
      (v === J || J.isStatic()) && this.uncacheArbiter(B);
    }
    for (var nt = v.constraintList; nt; nt = nt.nodeNext) {
      var J = nt.a;
      (v === J || J.isStatic()) && l(this.constraints, nt);
    }
  };
  var me = /* @__PURE__ */ H(function(v) {
    return v ? v.nodeRoot : null;
  }, "componentRoot"), se = /* @__PURE__ */ H(function(v) {
    if (!(!v || !v.isSleeping(v))) {
      e(!v.isRogue(), "Internal Error: componentActivate() called on a rogue body.");
      for (var T = v.space, P = v; P; ) {
        var B = P.nodeNext;
        P.nodeIdleTime = 0, P.nodeRoot = null, P.nodeNext = null, T.activateBody(P), P = B;
      }
      l(T.sleepingComponents, v);
    }
  }, "componentActivate");
  ct.prototype.activate = function() {
    this.isRogue() || (this.nodeIdleTime = 0, se(me(this)));
  }, ct.prototype.activateStatic = function(v) {
    e(this.isStatic(), "Body.activateStatic() called on a non-static body.");
    for (var T = (this || window).arbiterList; T; T = T.next(this))
      (!v || v == T.a || v == T.b) && (T.body_a == (this || window) ? T.body_b : T.body_a).activate();
  }, ct.prototype.pushArbiter = function(v) {
    n(
      (v.body_a === (this || window) ? v.thread_a_next : v.thread_b_next) === null,
      "Internal Error: Dangling contact graph pointers detected. (A)"
    ), n(
      (v.body_a === (this || window) ? v.thread_a_prev : v.thread_b_prev) === null,
      "Internal Error: Dangling contact graph pointers detected. (B)"
    );
    var T = (this || window).arbiterList;
    n(
      T === null || (T.body_a === (this || window) ? T.thread_a_prev : T.thread_b_prev) === null,
      "Internal Error: Dangling contact graph pointers detected. (C)"
    ), v.body_a === (this || window) ? v.thread_a_next = T : v.thread_b_next = T, T && (T.body_a === (this || window) ? T.thread_a_prev = v : T.thread_b_prev = v), this.arbiterList = v;
  };
  var Pe = /* @__PURE__ */ H(function(v, T) {
    T.nodeRoot = v, T !== v && (T.nodeNext = v.nodeNext, v.nodeNext = T);
  }, "componentAdd"), oe = /* @__PURE__ */ H(function(v, T) {
    if (!T.isRogue()) {
      var P = me(T);
      if (P == null) {
        Pe(v, T);
        for (var B = T.arbiterList; B; B = B.next(T))
          oe(v, T == B.body_a ? B.body_b : B.body_a);
        for (var J = T.constraintList; J; J = J.next(T))
          oe(v, T == J.a ? J.b : J.a);
      } else
        n(P === v, "Internal Error: Inconsistency detected in the contact graph.");
    }
  }, "floodFillComponent"), Ge = /* @__PURE__ */ H(function(v, T) {
    for (var P = v; P; P = P.nodeNext)
      if (P.nodeIdleTime < T)
        return !0;
    return !1;
  }, "componentActive");
  Yt.prototype.processComponents = function(v) {
    for (var T = (this || window).sleepTimeThreshold !== 1 / 0, P = (this || window).bodies, B = 0; B < P.length; B++) {
      var J = P[B];
      n(J.nodeNext === null, "Internal Error: Dangling next pointer detected in contact graph."), n(J.nodeRoot === null, "Internal Error: Dangling root pointer detected in contact graph.");
    }
    if (T)
      for (var nt = (this || window).idleSpeedThreshold, st = nt ? nt * nt : K(this.gravity) * v * v, B = 0; B < P.length; B++) {
        var J = P[B], dt = st ? J.m * st : 0;
        J.nodeIdleTime = J.kineticEnergy() > dt ? 0 : J.nodeIdleTime + v;
      }
    for (var Tt = (this || window).arbiters, B = 0, xt = Tt.length; B < xt; B++) {
      var Rt = Tt[B], Mt = Rt.body_a, Wt = Rt.body_b;
      T && ((Wt.isRogue() && !Wt.isStatic() || Mt.isSleeping()) && Mt.activate(), (Mt.isRogue() && !Mt.isStatic() || Wt.isSleeping()) && Wt.activate()), Mt.pushArbiter(Rt), Wt.pushArbiter(Rt);
    }
    if (T) {
      for (var qt = (this || window).constraints, B = 0; B < qt.length; B++) {
        var ne = qt[B], Mt = ne.a, Wt = ne.b;
        Wt.isRogue() && !Wt.isStatic() && Mt.activate(), Mt.isRogue() && !Mt.isStatic() && Wt.activate();
      }
      for (var B = 0; B < P.length; ) {
        var J = P[B];
        if (me(J) === null && (oe(J, J), !Ge(J, this.sleepTimeThreshold))) {
          this.sleepingComponents.push(J);
          for (var ue = J; ue; ue = ue.nodeNext)
            this.deactivateBody(ue);
          continue;
        }
        B++, J.nodeRoot = null, J.nodeNext = null;
      }
    }
  }, ct.prototype.sleep = function() {
    this.sleepWithGroup(null);
  }, ct.prototype.sleepWithGroup = function(v) {
    e(!this.isStatic() && !this.isRogue(), "Rogue and static bodies cannot be put to sleep.");
    var T = (this || window).space;
    if (e(T, "Cannot put a rogue body to sleep."), e(!T.locked, "Bodies cannot be put to sleep during a query or a call to cpSpaceStep(). Put these calls into a post-step callback."), e(v === null || v.isSleeping(), "Cannot use a non-sleeping body as a group identifier."), this.isSleeping()) {
      e(me(this) === me(v), "The body is already sleeping and it's group cannot be reassigned.");
      return;
    }
    for (var P = 0; P < this.shapeList.length; P++)
      this.shapeList[P].update(this.p, this.rot);
    if (T.deactivateBody(this), v) {
      var B = me(v);
      this.nodeRoot = B, this.nodeNext = B.nodeNext, this.nodeIdleTime = 0, B.nodeNext = (this || window);
    } else
      this.nodeRoot = (this || window), this.nodeNext = null, this.nodeIdleTime = 0, T.sleepingComponents.push(this);
    l(T.bodies, this);
  }, Yt.prototype.activateShapesTouchingShape = function(v) {
    this.sleepTimeThreshold !== 1 / 0 && this.shapeQuery(v, function(T, P) {
      T.body.activate();
    });
  }, Yt.prototype.pointQuery = function(v, T, P, B) {
    var J = /* @__PURE__ */ H(function(st) {
      !(st.group && P === st.group) && T & st.layers && st.pointQuery(v) && B(st);
    }, "helper"), nt = new k(v.x, v.y, v.x, v.y);
    this.lock(), this.activeShapes.query(nt, J), this.staticShapes.query(nt, J), this.unlock(!0);
  }, Yt.prototype.pointQueryFirst = function(v, T, P) {
    var B = null;
    return this.pointQuery(v, T, P, function(J) {
      J.sensor || (B = J);
    }), B;
  }, Yt.prototype.nearestPointQuery = function(v, T, P, B, J) {
    var nt = /* @__PURE__ */ H(function(dt) {
      if (!(dt.group && B === dt.group) && P & dt.layers) {
        var Tt = dt.nearestPointQuery(v);
        Tt.d < T && J(dt, Tt.d, Tt.p);
      }
    }, "helper"), st = X(v, T);
    this.lock(), this.activeShapes.query(st, nt), this.staticShapes.query(st, nt), this.unlock(!0);
  }, Yt.prototype.nearestPointQueryNearest = function(v, T, P, B) {
    var J, nt = /* @__PURE__ */ H(function(dt) {
      if (!(dt.group && B === dt.group) && P & dt.layers && !dt.sensor) {
        var Tt = dt.nearestPointQuery(v);
        Tt.d < T && (!J || Tt.d < J.d) && (J = Tt);
      }
    }, "helper"), st = X(v, T);
    return this.activeShapes.query(st, nt), this.staticShapes.query(st, nt), J;
  }, t.SHAPE_FILTER_ALL = {
    group: t.NO_GROUP,
    categories: t.ALL_CATEGORIES,
    mask: t.ALL_CATEGORIES
  }, Yt.prototype.pointQueryNearest = function(v, T, P) {
    var B = (this || window).nearestPointQueryNearest(v, T, P.mask, P.group);
    return typeof B != "undefined" && (B.distance = B.d, B.point = B.p), B;
  }, Yt.prototype.segmentQuery = function(v, T, P, B, J) {
    var nt = /* @__PURE__ */ H(function(st) {
      var dt;
      return !(st.group && B === st.group) && P & st.layers && (dt = st.segmentQuery(v, T)) && J(st, dt.t, dt.n), 1;
    }, "helper");
    this.lock(), this.staticShapes.segmentQuery(v, T, 1, nt), this.activeShapes.segmentQuery(v, T, 1, nt), this.unlock(!0);
  }, Yt.prototype.segmentQueryFirst = function(v, T, P, B) {
    var J = null, nt = /* @__PURE__ */ H(function(st) {
      var dt;
      return !(st.group && B === st.group) && P & st.layers && !st.sensor && (dt = st.segmentQuery(v, T)) && (J === null || dt.t < J.t) && (J = dt), J ? J.t : 1;
    }, "helper");
    return this.staticShapes.segmentQuery(v, T, 1, nt), this.activeShapes.segmentQuery(v, T, J ? J.t : 1, nt), J && J !== "null" && J !== "undefined" && (J.normal = J.n, J.alpha = J.t, J.p = J.point = t.v.lerp(v, T, J.t)), J;
  }, Yt.prototype.bbQuery = function(v, T, P, B) {
    var J = /* @__PURE__ */ H(function(nt) {
      !(nt.group && P === nt.group) && T & nt.layers && j(v, nt.bb_l, nt.bb_b, nt.bb_r, nt.bb_t) && B(nt);
    }, "helper");
    this.lock(), this.activeShapes.query(v, J), this.staticShapes.query(v, J), this.unlock(!0);
  }, Yt.prototype.shapeQuery = function(v, T) {
    var P = v.body;
    P && v.update(P.p, P.rot);
    var B = new k(v.bb_l, v.bb_b, v.bb_r, v.bb_t), J = !1, nt = /* @__PURE__ */ H(function(st) {
      var dt = v;
      if (!(dt.group && dt.group === st.group || !(dt.layers & st.layers) || dt === st)) {
        var Tt;
        if (dt.collisionCode <= st.collisionCode)
          Tt = re(dt, st);
        else {
          Tt = re(st, dt);
          for (var xt = 0; xt < Tt.length; xt++)
            Tt[xt].n = Q(Tt[xt].n);
        }
        if (Tt.length && (J = !(dt.sensor || st.sensor), T)) {
          for (var Rt = new Array(Tt.length), xt = 0; xt < Tt.length; xt++)
            Rt[xt] = new $t(Tt[xt].p, Tt[xt].n, Tt[xt].dist);
          T(st, Rt);
        }
      }
    }, "helper");
    return this.lock(), this.activeShapes.query(B, nt), this.staticShapes.query(B, nt), this.unlock(!0), J;
  }, Yt.prototype.addPostStepCallback = function(v) {
    n(
      this.locked,
      "Adding a post-step callback when the space is not locked is unnecessary. Post-step callbacks will not called until the end of the next call to cpSpaceStep() or the next query."
    ), this.postStepCallbacks.push(v);
  }, Yt.prototype.runPostStepCallbacks = function() {
    for (var v = 0; v < this.postStepCallbacks.length; v++)
      this.postStepCallbacks[v]();
    this.postStepCallbacks = [];
  }, Yt.prototype.lock = function() {
    this.locked++;
  }, Yt.prototype.unlock = function(v) {
    if (this.locked--, e(this.locked >= 0, "Internal Error: Space lock underflow."), this.locked === 0 && v) {
      for (var T = (this || window).rousedBodies, P = 0; P < T.length; P++)
        this.activateBody(T[P]);
      T.length = 0, this.runPostStepCallbacks();
    }
  }, Yt.prototype.makeCollideShapes = function() {
    var v = (this || window);
    return function(T, P) {
      var B = v;
      if (!(!(T.bb_l <= P.bb_r && P.bb_l <= T.bb_r && T.bb_b <= P.bb_t && P.bb_b <= T.bb_t) || T.body === P.body || T.group && T.group === P.group || !(T.layers & P.layers))) {
        var J = B.lookupHandler(T.collision_type, P.collision_type), nt = T.sensor || P.sensor;
        if (!(nt && J === Oe)) {
          if (T.collisionCode > P.collisionCode) {
            var st = T;
            T = P, P = st;
          }
          var dt = re(T, P);
          if (dt.length !== 0) {
            var Tt = c(T.hashid, P.hashid), xt = B.cachedArbiters[Tt];
            xt || (xt = B.cachedArbiters[Tt] = new Zt(T, P)), xt.update(dt, J, T, P), xt.state == "first coll" && !J.begin(xt, B) && xt.ignore(), xt.state !== "ignore" && J.preSolve(xt, B) && !nt ? B.arbiters.push(xt) : (xt.contacts = null, xt.state !== "ignore" && (xt.state = "normal")), xt.stamp = B.stamp;
          }
        }
      }
    };
  }, Yt.prototype.arbiterSetFilter = function(v) {
    var T = (this || window).stamp - v.stamp, P = v.body_a, B = v.body_b;
    return (P.isStatic() || P.isSleeping()) && (B.isStatic() || B.isSleeping()) ? !0 : (T >= 1 && v.state != "cached" && (v.callSeparate(this), v.state = "cached"), T >= (this || window).collisionPersistence ? (v.contacts = null, !1) : !0);
  };
  var Ee = /* @__PURE__ */ H(function(v) {
    var T = v.body;
    v.update(T.p, T.rot);
  }, "updateFunc");
  Yt.prototype.step = function(v) {
    if (v !== 0) {
      e(A.x === 0 && A.y === 0, "vzero is invalid"), this.stamp++;
      var T = (this || window).curr_dt;
      this.curr_dt = v;
      var P, B, J, nt = (this || window).bodies, st = (this || window).constraints, dt = (this || window).arbiters;
      for (P = 0; P < dt.length; P++) {
        var Tt = dt[P];
        Tt.state = "normal", !Tt.body_a.isSleeping() && !Tt.body_b.isSleeping() && Tt.unthread();
      }
      dt.length = 0, this.lock();
      {
        for (P = 0; P < nt.length; P++)
          nt[P].position_func(v);
        this.activeShapes.each(Ee), this.activeShapes.reindexQuery(this.collideShapes);
      }
      this.unlock(!1), this.processComponents(v), this.lock();
      {
        for (J in this.cachedArbiters)
          this.arbiterSetFilter(this.cachedArbiters[J]) || delete this.cachedArbiters[J];
        var xt = (this || window).collisionSlop, Rt = 1 - Math.pow(this.collisionBias, v);
        for (P = 0; P < dt.length; P++)
          dt[P].preStep(v, xt, Rt);
        for (P = 0; P < st.length; P++) {
          var Mt = st[P];
          Mt.preSolve(this), Mt.preStep(v);
        }
        var Wt = Math.pow(this.damping, v), qt = (this || window).gravity;
        for (P = 0; P < nt.length; P++)
          nt[P].velocity_func(qt, Wt, v);
        var ne = T === 0 ? 0 : v / T;
        for (P = 0; P < dt.length; P++)
          dt[P].applyCachedImpulse(ne);
        for (P = 0; P < st.length; P++)
          st[P].applyCachedImpulse(ne);
        for (P = 0; P < this.iterations; P++) {
          for (B = 0; B < dt.length; B++)
            dt[B].applyImpulse();
          for (B = 0; B < st.length; B++)
            st[B].applyImpulse();
        }
        for (P = 0; P < st.length; P++)
          st[P].postSolve(this);
        for (P = 0; P < dt.length; P++)
          dt[P].handler.postSolve(dt[P], this);
      }
      this.unlock(!0);
    }
  };
  var ge = /* @__PURE__ */ H(function(v, T, P, B) {
    var J = v.vx + -P.y * v.w, nt = v.vy + P.x * v.w, st = T.vx + -B.y * T.w, dt = T.vy + B.x * T.w;
    return new y(st - J, dt - nt);
  }, "relative_velocity"), fe = /* @__PURE__ */ H(function(v, T, P, B, J) {
    var nt = v.vx + -P.y * v.w, st = v.vy + P.x * v.w, dt = T.vx + -B.y * T.w, Tt = T.vy + B.x * T.w;
    return N(dt - nt, Tt - st, J.x, J.y);
  }, "normal_relative_velocity"), Ae = /* @__PURE__ */ H(function(v, T, P, B) {
    v.vx += T * v.m_inv, v.vy += P * v.m_inv, v.w += v.i_inv * (B.x * P - B.y * T);
  }, "apply_impulse"), ye = /* @__PURE__ */ H(function(v, T, P, B, J, nt) {
    Ae(v, -J, -nt, P), Ae(T, J, nt, B);
  }, "apply_impulses"), Ue = /* @__PURE__ */ H(function(v, T, P, B) {
    v.v_biasx += T * v.m_inv, v.v_biasy += P * v.m_inv, v.w_bias += v.i_inv * w(B.x, B.y, T, P);
  }, "apply_bias_impulse"), be = /* @__PURE__ */ H(function(v, T, P) {
    var B = rt(T, P);
    return v.m_inv + v.i_inv * B * B;
  }, "k_scalar_body"), Be = /* @__PURE__ */ H(function(v, T, P, B, J) {
    var nt = be(v, P, J) + be(T, B, J);
    return n(nt !== 0, "Unsolvable collision or constraint."), nt;
  }, "k_scalar"), Fe = /* @__PURE__ */ H(function(v, T, P, B, J, nt) {
    var st, dt, Tt, xt, Rt = v.m_inv + T.m_inv;
    st = Rt, dt = 0, Tt = 0, xt = Rt;
    var Mt = v.i_inv, Wt = P.x * P.x * Mt, qt = P.y * P.y * Mt, ne = -P.x * P.y * Mt;
    st += qt, dt += ne, Tt += ne, xt += Wt;
    var ue = T.i_inv, Te = B.x * B.x * ue, Re = B.y * B.y * ue, ae = -B.x * B.y * ue;
    st += Re, dt += ae, Tt += ae, xt += Te;
    var Ie = st * xt - dt * Tt;
    n(Ie !== 0, "Unsolvable constraint.");
    var we = 1 / Ie;
    J.x = xt * we, J.y = -dt * we, nt.x = -Tt * we, nt.y = st * we;
  }, "k_tensor"), ke = /* @__PURE__ */ H(function(v, T, P) {
    return new y(D(v, T), D(v, P));
  }, "mult_k"), Le = /* @__PURE__ */ H(function(v, T) {
    return 1 - Math.pow(v, T);
  }, "bias_coef"), te = t.Constraint = function(v, T) {
    this.a = v, this.b = T, this.space = null, this.next_a = null, this.next_b = null, this.maxForce = 1 / 0, this.errorBias = Math.pow(1 - 0.1, 60), this.maxBias = 1 / 0;
  };
  te.prototype.activateBodies = function() {
    this.a && this.a.activate(), this.b && this.b.activate();
  }, te.prototype.preStep = function(v) {
  }, te.prototype.applyCachedImpulse = function(v) {
  }, te.prototype.applyImpulse = function() {
  }, te.prototype.getImpulse = function() {
    return 0;
  }, te.prototype.preSolve = function(v) {
  }, te.prototype.postSolve = function(v) {
  }, te.prototype.next = function(v) {
    return this.a === v ? this.next_a : this.next_b;
  };
  var Ne = t.PinJoint = function(v, T, P, B) {
    te.call(this, v, T), this.anchr1 = P, this.anchr2 = B;
    var J = v ? Z(v.p, I(P, v.rot)) : P, nt = T ? Z(T.p, I(B, T.rot)) : B;
    this.dist = z(U(nt, J)), n(this.dist > 0, "You created a 0 length pin joint. A pivot joint will be much more stable."), this.r1 = (this || window).r2 = null, this.n = null, this.nMass = 0, this.jnAcc = (this || window).jnMax = 0, this.bias = 0;
  };
  Ne.prototype = Object.create(te.prototype), Ne.prototype.preStep = function(v) {
    var T = (this || window).a, P = (this || window).b;
    this.r1 = I(this.anchr1, T.rot), this.r2 = I(this.anchr2, P.rot);
    var B = U(Z(P.p, this.r2), Z(T.p, this.r1)), J = z(B);
    this.n = et(B, 1 / (J || 1 / 0)), this.nMass = 1 / Be(T, P, this.r1, this.r2, this.n);
    var nt = (this || window).maxBias;
    this.bias = m(-Le(this.errorBias, v) * (J - this.dist) / v, -nt, nt), this.jnMax = (this || window).maxForce * v;
  }, Ne.prototype.applyCachedImpulse = function(v) {
    var T = et(this.n, this.jnAcc * v);
    ye(this.a, this.b, this.r1, this.r2, T.x, T.y);
  }, Ne.prototype.applyImpulse = function() {
    var v = (this || window).a, T = (this || window).b, P = (this || window).n, B = fe(v, T, this.r1, this.r2, P), J = (this.bias - B) * this.nMass, nt = (this || window).jnAcc;
    this.jnAcc = m(nt + J, -this.jnMax, this.jnMax), J = (this || window).jnAcc - nt, ye(v, T, this.r1, this.r2, P.x * J, P.y * J);
  }, Ne.prototype.getImpulse = function() {
    return Math.abs(this.jnAcc);
  };
  var Me = t.SlideJoint = function(v, T, P, B, J, nt) {
    te.call(this, v, T), this.anchr1 = P, this.anchr2 = B, this.min = J, this.max = nt, this.r1 = (this || window).r2 = (this || window).n = null, this.nMass = 0, this.jnAcc = (this || window).jnMax = 0, this.bias = 0;
  };
  Me.prototype = Object.create(te.prototype), Me.prototype.preStep = function(v) {
    var T = (this || window).a, P = (this || window).b;
    this.r1 = I(this.anchr1, T.rot), this.r2 = I(this.anchr2, P.rot);
    var B = U(Z(P.p, this.r2), Z(T.p, this.r1)), J = z(B), nt = 0;
    J > this.max ? (nt = J - this.max, this.n = W(B)) : J < this.min ? (nt = (this || window).min - J, this.n = Q(W(B))) : (this.n = A, this.jnAcc = 0), this.nMass = 1 / Be(T, P, this.r1, this.r2, this.n);
    var st = (this || window).maxBias;
    this.bias = m(-Le(this.errorBias, v) * nt / v, -st, st), this.jnMax = (this || window).maxForce * v;
  }, Me.prototype.applyCachedImpulse = function(v) {
    var T = (this || window).jnAcc * v;
    ye(this.a, this.b, this.r1, this.r2, this.n.x * T, this.n.y * T);
  }, Me.prototype.applyImpulse = function() {
    if (!(this.n.x === 0 && this.n.y === 0)) {
      var v = (this || window).a, T = (this || window).b, P = (this || window).n, B = (this || window).r1, J = (this || window).r2, nt = ge(v, T, B, J), st = D(nt, P), dt = (this.bias - st) * this.nMass, Tt = (this || window).jnAcc;
      this.jnAcc = m(Tt + dt, -this.jnMax, 0), dt = (this || window).jnAcc - Tt, ye(v, T, this.r1, this.r2, P.x * dt, P.y * dt);
    }
  }, Me.prototype.getImpulse = function() {
    return Math.abs(this.jnAcc);
  };
  var Ye = t.PivotJoint = function(v, T, P, B) {
    if (te.call(this, v, T), typeof B == "undefined") {
      var J = P;
      P = v ? v.world2Local(J) : J, B = T ? T.world2Local(J) : J;
    }
    this.anchr1 = P, this.anchr2 = B, this.r1 = (this || window).r2 = A, this.k1 = new y(0, 0), this.k2 = new y(0, 0), this.jAcc = A, this.jMaxLen = 0, this.bias = A;
  };
  Ye.prototype = Object.create(te.prototype), Ye.prototype.preStep = function(v) {
    var T = (this || window).a, P = (this || window).b;
    this.r1 = I(this.anchr1, T.rot), this.r2 = I(this.anchr2, P.rot), Fe(T, P, this.r1, this.r2, this.k1, this.k2), this.jMaxLen = (this || window).maxForce * v;
    var B = U(Z(P.p, this.r2), Z(T.p, this.r1));
    this.bias = x(et(B, -Le(this.errorBias, v) / v), this.maxBias);
  }, Ye.prototype.applyCachedImpulse = function(v) {
    ye(this.a, this.b, this.r1, this.r2, this.jAcc.x * v, this.jAcc.y * v);
  }, Ye.prototype.applyImpulse = function() {
    var v = (this || window).a, T = (this || window).b, P = (this || window).r1, B = (this || window).r2, J = ge(v, T, P, B), nt = ke(U(this.bias, J), this.k1, this.k2), st = (this || window).jAcc;
    this.jAcc = x(Z(this.jAcc, nt), this.jMaxLen), ye(v, T, this.r1, this.r2, this.jAcc.x - st.x, this.jAcc.y - st.y);
  }, Ye.prototype.getImpulse = function() {
    return z(this.jAcc);
  };
  var Ve = t.GrooveJoint = function(v, T, P, B, J) {
    te.call(this, v, T), this.grv_a = P, this.grv_b = B, this.grv_n = L(b(U(B, P))), this.anchr2 = J, this.grv_tn = null, this.clamp = 0, this.r1 = (this || window).r2 = null, this.k1 = new y(0, 0), this.k2 = new y(0, 0), this.jAcc = A, this.jMaxLen = 0, this.bias = null;
  };
  Ve.prototype = Object.create(te.prototype), Ve.prototype.preStep = function(v) {
    var T = (this || window).a, P = (this || window).b, B = T.local2World(this.grv_a), J = T.local2World(this.grv_b), nt = I(this.grv_n, T.rot), st = D(B, nt);
    this.grv_tn = nt, this.r2 = I(this.anchr2, P.rot);
    var dt = rt(Z(P.p, this.r2), nt);
    dt <= rt(B, nt) ? (this.clamp = 1, this.r1 = U(B, T.p)) : dt >= rt(J, nt) ? (this.clamp = -1, this.r1 = U(J, T.p)) : (this.clamp = 0, this.r1 = U(Z(et(L(nt), -dt), et(nt, st)), T.p)), Fe(T, P, this.r1, this.r2, this.k1, this.k2), this.jMaxLen = (this || window).maxForce * v;
    var Tt = U(Z(P.p, this.r2), Z(T.p, this.r1));
    this.bias = x(et(Tt, -Le(this.errorBias, v) / v), this.maxBias);
  }, Ve.prototype.applyCachedImpulse = function(v) {
    ye(this.a, this.b, this.r1, this.r2, this.jAcc.x * v, this.jAcc.y * v);
  }, Ve.prototype.grooveConstrain = function(v) {
    var T = (this || window).grv_tn, P = (this || window).clamp * rt(v, T) > 0 ? v : G(v, T);
    return x(P, this.jMaxLen);
  }, Ve.prototype.applyImpulse = function() {
    var v = (this || window).a, T = (this || window).b, P = (this || window).r1, B = (this || window).r2, J = ge(v, T, P, B), nt = ke(U(this.bias, J), this.k1, this.k2), st = (this || window).jAcc;
    this.jAcc = (this || window).grooveConstrain(Z(st, nt)), ye(v, T, this.r1, this.r2, this.jAcc.x - st.x, this.jAcc.y - st.y);
  }, Ve.prototype.getImpulse = function() {
    return z(this.jAcc);
  }, Ve.prototype.setGrooveA = function(v) {
    this.grv_a = v, this.grv_n = L(b(U(this.grv_b, v))), this.activateBodies();
  }, Ve.prototype.setGrooveB = function(v) {
    this.grv_b = v, this.grv_n = L(b(U(v, this.grv_a))), this.activateBodies();
  };
  var $e = /* @__PURE__ */ H(function(v, T) {
    return (v.restLength - T) * v.stiffness;
  }, "defaultSpringForce"), Xe = t.DampedSpring = function(v, T, P, B, J, nt, st) {
    te.call(this, v, T), this.anchr1 = P, this.anchr2 = B, this.restLength = J, this.stiffness = nt, this.damping = st, this.springForceFunc = $e, this.target_vrn = (this || window).v_coef = 0, this.r1 = (this || window).r2 = null, this.nMass = 0, this.n = null;
  };
  Xe.prototype = Object.create(te.prototype), Xe.prototype.preStep = function(v) {
    var T = (this || window).a, P = (this || window).b;
    this.r1 = I(this.anchr1, T.rot), this.r2 = I(this.anchr2, P.rot);
    var B = U(Z(P.p, this.r2), Z(T.p, this.r1)), J = z(B);
    this.n = et(B, 1 / (J || 1 / 0));
    var nt = Be(T, P, this.r1, this.r2, this.n);
    n(nt !== 0, "Unsolvable this."), this.nMass = 1 / nt, this.target_vrn = 0, this.v_coef = 1 - Math.exp(-this.damping * v * nt);
    var st = (this || window).springForceFunc(this, J);
    ye(T, P, this.r1, this.r2, this.n.x * st * v, this.n.y * st * v);
  }, Xe.prototype.applyCachedImpulse = function(v) {
  }, Xe.prototype.applyImpulse = function() {
    var v = (this || window).a, T = (this || window).b, P = (this || window).n, B = (this || window).r1, J = (this || window).r2, nt = fe(v, T, B, J, P), st = (this.target_vrn - nt) * this.v_coef;
    this.target_vrn = nt + st, st *= (this || window).nMass, ye(v, T, this.r1, this.r2, this.n.x * st, this.n.y * st);
  }, Xe.prototype.getImpulse = function() {
    return 0;
  };
  var ti = /* @__PURE__ */ H(function(v, T) {
    return (T - v.restAngle) * v.stiffness;
  }, "defaultSpringTorque"), qe = t.DampedRotarySpring = function(v, T, P, B, J) {
    te.call(this, v, T), this.restAngle = P, this.stiffness = B, this.damping = J, this.springTorqueFunc = ti, this.target_wrn = 0, this.w_coef = 0, this.iSum = 0;
  };
  qe.prototype = Object.create(te.prototype), qe.prototype.preStep = function(v) {
    var T = (this || window).a, P = (this || window).b, B = T.i_inv + P.i_inv;
    n(B !== 0, "Unsolvable spring."), this.iSum = 1 / B, this.w_coef = 1 - Math.exp(-this.damping * v * B), this.target_wrn = 0;
    var J = (this || window).springTorqueFunc(this, T.a - P.a) * v;
    T.w -= J * T.i_inv, P.w += J * P.i_inv;
  }, qe.prototype.applyImpulse = function() {
    var v = (this || window).a, T = (this || window).b, P = v.w - T.w, B = (this.target_wrn - P) * this.w_coef;
    this.target_wrn = P + B;
    var J = B * this.iSum;
    v.w += J * v.i_inv, T.w -= J * T.i_inv;
  };
  var He = t.RotaryLimitJoint = function(v, T, P, B) {
    te.call(this, v, T), this.min = P, this.max = B, this.jAcc = 0, this.iSum = (this || window).bias = (this || window).jMax = 0;
  };
  He.prototype = Object.create(te.prototype), He.prototype.preStep = function(v) {
    var T = (this || window).a, P = (this || window).b, B = P.a - T.a, J = 0;
    B > this.max ? J = (this || window).max - B : B < this.min && (J = (this || window).min - B), this.iSum = 1 / (1 / T.i + 1 / P.i);
    var nt = (this || window).maxBias;
    this.bias = m(-Le(this.errorBias, v) * J / v, -nt, nt), this.jMax = (this || window).maxForce * v, this.bias || (this.jAcc = 0);
  }, He.prototype.applyCachedImpulse = function(v) {
    var T = (this || window).a, P = (this || window).b, B = (this || window).jAcc * v;
    T.w -= B * T.i_inv, P.w += B * P.i_inv;
  }, He.prototype.applyImpulse = function() {
    if (this.bias) {
      var v = (this || window).a, T = (this || window).b, P = T.w - v.w, B = -(this.bias + P) * this.iSum, J = (this || window).jAcc;
      this.bias < 0 ? this.jAcc = m(J + B, 0, this.jMax) : this.jAcc = m(J + B, -this.jMax, 0), B = (this || window).jAcc - J, v.w -= B * v.i_inv, T.w += B * T.i_inv;
    }
  }, He.prototype.getImpulse = function() {
    return Math.abs(joint.jAcc);
  };
  var Je = t.RatchetJoint = function(v, T, P, B) {
    te.call(this, v, T), this.angle = 0, this.phase = P, this.ratchet = B, this.angle = (T ? T.a : 0) - (v ? v.a : 0), this.iSum = (this || window).bias = (this || window).jAcc = (this || window).jMax = 0;
  };
  Je.prototype = Object.create(te.prototype), Je.prototype.preStep = function(v) {
    var T = (this || window).a, P = (this || window).b, B = (this || window).angle, J = (this || window).phase, nt = (this || window).ratchet, st = P.a - T.a, dt = B - st, Tt = 0;
    dt * nt > 0 ? Tt = dt : this.angle = Math.floor((st - J) / nt) * nt + J, this.iSum = 1 / (T.i_inv + P.i_inv);
    var xt = (this || window).maxBias;
    this.bias = m(-Le(this.errorBias, v) * Tt / v, -xt, xt), this.jMax = (this || window).maxForce * v, this.bias || (this.jAcc = 0);
  }, Je.prototype.applyCachedImpulse = function(v) {
    var T = (this || window).a, P = (this || window).b, B = (this || window).jAcc * v;
    T.w -= B * T.i_inv, P.w += B * P.i_inv;
  }, Je.prototype.applyImpulse = function() {
    if (this.bias) {
      var v = (this || window).a, T = (this || window).b, P = T.w - v.w, B = (this || window).ratchet, J = -(this.bias + P) * this.iSum, nt = (this || window).jAcc;
      this.jAcc = m((nt + J) * B, 0, this.jMax * Math.abs(B)) / B, J = (this || window).jAcc - nt, v.w -= J * v.i_inv, T.w += J * T.i_inv;
    }
  }, Je.prototype.getImpulse = function(v) {
    return Math.abs(v.jAcc);
  };
  var ze = t.GearJoint = function(v, T, P, B) {
    te.call(this, v, T), this.phase = P, this.ratio = B, this.ratio_inv = 1 / B, this.jAcc = 0, this.iSum = (this || window).bias = (this || window).jMax = 0;
  };
  ze.prototype = Object.create(te.prototype), ze.prototype.preStep = function(v) {
    var T = (this || window).a, P = (this || window).b;
    this.iSum = 1 / (T.i_inv * this.ratio_inv + this.ratio * P.i_inv);
    var B = (this || window).maxBias;
    this.bias = m(-Le(this.errorBias, v) * (P.a * this.ratio - T.a - this.phase) / v, -B, B), this.jMax = (this || window).maxForce * v;
  }, ze.prototype.applyCachedImpulse = function(v) {
    var T = (this || window).a, P = (this || window).b, B = (this || window).jAcc * v;
    T.w -= B * T.i_inv * this.ratio_inv, P.w += B * P.i_inv;
  }, ze.prototype.applyImpulse = function() {
    var v = (this || window).a, T = (this || window).b, P = T.w * this.ratio - v.w, B = (this.bias - P) * this.iSum, J = (this || window).jAcc;
    this.jAcc = m(J + B, -this.jMax, this.jMax), B = (this || window).jAcc - J, v.w -= B * v.i_inv * this.ratio_inv, T.w += B * T.i_inv;
  }, ze.prototype.getImpulse = function() {
    return Math.abs(this.jAcc);
  }, ze.prototype.setRatio = function(v) {
    this.ratio = v, this.ratio_inv = 1 / v, this.activateBodies();
  };
  var Ze = t.SimpleMotor = function(v, T, P) {
    te.call(this, v, T), this.rate = P, this.jAcc = 0, this.iSum = (this || window).jMax = 0;
  };
  Ze.prototype = Object.create(te.prototype), Ze.prototype.preStep = function(v) {
    this.iSum = 1 / (this.a.i_inv + this.b.i_inv), this.jMax = (this || window).maxForce * v;
  }, Ze.prototype.applyCachedImpulse = function(v) {
    var T = (this || window).a, P = (this || window).b, B = (this || window).jAcc * v;
    T.w -= B * T.i_inv, P.w += B * P.i_inv;
  }, Ze.prototype.applyImpulse = function() {
    var v = (this || window).a, T = (this || window).b, P = T.w - v.w + this.rate, B = -P * this.iSum, J = (this || window).jAcc;
    this.jAcc = m(J + B, -this.jMax, this.jMax), B = (this || window).jAcc - J, v.w -= B * v.i_inv, T.w += B * T.i_inv;
  }, Ze.prototype.getImpulse = function() {
    return Math.abs(this.jAcc);
  };
})();
var sp = sp || {};
sp.VERTEX_INDEX = {
  X1: 0,
  Y1: 1,
  X2: 2,
  Y2: 3,
  X3: 4,
  Y3: 5,
  X4: 6,
  Y4: 7
};
sp.ATTACHMENT_TYPE = {
  REGION: 0,
  BOUNDING_BOX: 1,
  MESH: 2,
  SKINNED_MESH: 3
};
sp.Skeleton = cc.Node.extend({
  _skeleton: null,
  _rootBone: null,
  _timeScale: 1,
  _debugSlots: !1,
  _debugBones: !1,
  _premultipliedAlpha: !1,
  _ownsSkeletonData: null,
  _atlas: null,
  _blendFunc: null,
  ctor: function(t, e, n) {
    cc.Node.prototype.ctor.call(this), arguments.length === 0 ? this.init() : this.initWithArgs(t, e, n);
  },
  _createRenderCmd: function() {
    return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new sp.Skeleton.CanvasRenderCmd(this) : new sp.Skeleton.WebGLRenderCmd(this);
  },
  init: function() {
    cc.Node.prototype.init.call(this), this._premultipliedAlpha = cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA, this._blendFunc = { src: cc.BLEND_SRC, dst: cc.BLEND_DST }, this.scheduleUpdate();
  },
  setDebugSolots: function(t) {
    this._debugSlots = t;
  },
  setDebugBones: function(t) {
    this._debugBones = t;
  },
  setDebugSlotsEnabled: function(t) {
    this._debugSlots = t;
  },
  getDebugSlotsEnabled: function() {
    return this._debugSlots;
  },
  setDebugBonesEnabled: function(t) {
    this._debugBones = t;
  },
  getDebugBonesEnabled: function() {
    return this._debugBones;
  },
  setTimeScale: function(t) {
    this._timeScale = t;
  },
  getTimeScale: function() {
    return this._timeScale;
  },
  initWithArgs: function(t, e, n) {
    var r = t, s = e, o, a, c;
    if (cc.isString(r)) {
      if (cc.isString(s)) {
        var l = cc.loader.getRes(s);
        sp._atlasLoader.setAtlasFile(s), a = new spine.Atlas(l, sp._atlasLoader);
      } else
        a = e;
      n = n || 1 / cc.director.getContentScaleFactor();
      var h = new spine.AtlasAttachmentLoader(a), u = new spine.SkeletonJson(h);
      u.scale = n;
      var _ = cc.loader.getRes(r);
      o = u.readSkeletonData(_), a.dispose(u), c = !0;
    } else
      o = t, c = e;
    this.setSkeletonData(o, c), this.init();
  },
  getBoundingBox: function() {
    for (var t = cc.FLT_MAX, e = cc.FLT_MAX, n = cc.FLT_MIN, r = cc.FLT_MIN, s = (this || window).getScaleX(), o = (this || window).getScaleY(), a = [], c = (this || window)._skeleton.slots, l = sp.VERTEX_INDEX, h = 0, u = c.length; h < u; ++h) {
      var _ = c[h];
      if (!(!_.attachment || _.attachment.type != sp.ATTACHMENT_TYPE.REGION)) {
        var d = _.attachment;
        this._computeRegionAttachmentWorldVertices(d, _.bone.skeleton.x, _.bone.skeleton.y, _.bone, a), t = Math.min(t, a[l.X1] * s, a[l.X4] * s, a[l.X2] * s, a[l.X3] * s), e = Math.min(e, a[l.Y1] * o, a[l.Y4] * o, a[l.Y2] * o, a[l.Y3] * o), n = Math.max(n, a[l.X1] * s, a[l.X4] * s, a[l.X2] * s, a[l.X3] * s), r = Math.max(r, a[l.Y1] * o, a[l.Y4] * o, a[l.Y2] * o, a[l.Y3] * o);
      }
    }
    var f = (this || window).getPosition();
    return cc.rect(f.x + t, f.y + e, n - t, r - e);
  },
  _computeRegionAttachmentWorldVertices: function(t, e, n, r, s) {
    var o = t.offset, a = sp.VERTEX_INDEX;
    e += r.worldX, n += r.worldY, s[a.X1] = o[a.X1] * r.m00 + o[a.Y1] * r.m01 + e, s[a.Y1] = o[a.X1] * r.m10 + o[a.Y1] * r.m11 + n, s[a.X2] = o[a.X2] * r.m00 + o[a.Y2] * r.m01 + e, s[a.Y2] = o[a.X2] * r.m10 + o[a.Y2] * r.m11 + n, s[a.X3] = o[a.X3] * r.m00 + o[a.Y3] * r.m01 + e, s[a.Y3] = o[a.X3] * r.m10 + o[a.Y3] * r.m11 + n, s[a.X4] = o[a.X4] * r.m00 + o[a.Y4] * r.m01 + e, s[a.Y4] = o[a.X4] * r.m10 + o[a.Y4] * r.m11 + n;
  },
  updateWorldTransform: function() {
    this._skeleton.updateWorldTransform();
  },
  setToSetupPose: function() {
    this._skeleton.setToSetupPose();
  },
  setBonesToSetupPose: function() {
    this._skeleton.setBonesToSetupPose();
  },
  setSlotsToSetupPose: function() {
    this._skeleton.setSlotsToSetupPose();
  },
  findBone: function(t) {
    return this._skeleton.findBone(t);
  },
  findSlot: function(t) {
    return this._skeleton.findSlot(t);
  },
  setSkin: function(t) {
    return this._skeleton.setSkinByName(t);
  },
  getAttachment: function(t, e) {
    return this._skeleton.getAttachmentBySlotName(t, e);
  },
  setAttachment: function(t, e) {
    this._skeleton.setAttachment(t, e);
  },
  setPremultipliedAlpha: function(t) {
    this._premultipliedAlpha = t;
  },
  isPremultipliedAlpha: function() {
    return this._premultipliedAlpha;
  },
  setSkeletonData: function(t, e) {
    t.width != null && t.height != null && this.setContentSize(t.width / cc.director.getContentScaleFactor(), t.height / cc.director.getContentScaleFactor()), this._skeleton = new spine.Skeleton(t), this._skeleton.updateWorldTransform(), this._rootBone = (this || window)._skeleton.getRootBone(), this._ownsSkeletonData = e, this._renderCmd._createChildFormSkeletonData();
  },
  getTextureAtlas: function(t) {
    return t.rendererObject.page.rendererObject;
  },
  getBlendFunc: function() {
    return this._blendFunc;
  },
  setBlendFunc: function(t, e) {
    var n = (this || window)._blendFunc;
    e === void 0 ? (n.src = t.src, n.dst = t.dst) : (n.src = t, n.dst = e);
  },
  update: function(t) {
    this._skeleton.update(t);
  }
});
sp.Skeleton.create = function(t, e, n) {
  return new sp.Skeleton(t, e, n);
};
var spine = {
  radDeg: 180 / Math.PI,
  degRad: Math.PI / 180,
  temp: [],
  Float32Array: typeof Float32Array == "undefined" ? Array : Float32Array,
  Uint16Array: typeof Uint16Array == "undefined" ? Array : Uint16Array
};
spine.BoneData = function(t, e) {
  this.length = (this || window).x = (this || window).y = (this || window).rotation = 0, this.scaleX = (this || window).scaleY = 1, this.name = t, this.parent = e;
};
spine.BoneData.prototype = {
  length: 0,
  x: 0,
  y: 0,
  rotation: 0,
  scaleX: 1,
  scaleY: 1,
  inheritScale: !0,
  inheritRotation: !0,
  flipX: !1,
  flipY: !1
};
spine.BlendMode = {
  normal: 0,
  additive: 1,
  multiply: 2,
  screen: 3
};
spine.SlotData = function(t, e) {
  this.r = (this || window).g = (this || window).b = (this || window).a = 1, this.blendMode = spine.BlendMode.normal, this.name = t, this.boneData = e;
};
spine.SlotData.prototype = {
  r: 1,
  g: 1,
  b: 1,
  a: 1,
  attachmentName: null,
  blendMode: spine.BlendMode.normal
};
spine.IkConstraintData = function(t) {
  this.bendDirection = (this || window).mix = 1, this.name = t, this.bones = [];
};
spine.IkConstraintData.prototype = {
  target: null,
  bendDirection: 1,
  mix: 1
};
spine.Bone = function(t, e, n) {
  this.x = (this || window).y = (this || window).rotation = (this || window).rotationIK = 0, this.scaleX = (this || window).scaleY = 1, this.flipX = (this || window).flipY = !1, this.m00 = (this || window).m01 = (this || window).worldX = 0, this.m10 = (this || window).m11 = (this || window).worldY = 0, this.worldRotation = 0, this.worldScaleX = (this || window).worldScaleY = 1, this.worldFlipX = (this || window).worldFlipY = !1, this.data = t, this.skeleton = e, this.parent = n, this.setToSetupPose();
};
spine.Bone.yDown = !1;
spine.Bone.prototype = {
  x: 0,
  y: 0,
  rotation: 0,
  rotationIK: 0,
  scaleX: 1,
  scaleY: 1,
  flipX: !1,
  flipY: !1,
  m00: 0,
  m01: 0,
  worldX: 0,
  m10: 0,
  m11: 0,
  worldY: 0,
  worldRotation: 0,
  worldScaleX: 1,
  worldScaleY: 1,
  worldFlipX: !1,
  worldFlipY: !1,
  updateWorldTransform: function() {
    var t = (this || window).parent;
    if (t)
      this.worldX = (this || window).x * t.m00 + this.y * t.m01 + t.worldX, this.worldY = (this || window).x * t.m10 + this.y * t.m11 + t.worldY, this.data.inheritScale ? (this.worldScaleX = t.worldScaleX * this.scaleX, this.worldScaleY = t.worldScaleY * this.scaleY) : (this.worldScaleX = (this || window).scaleX, this.worldScaleY = (this || window).scaleY), this.worldRotation = (this || window).data.inheritRotation ? t.worldRotation + this.rotationIK : this.rotationIK, this.worldFlipX = t.worldFlipX != (this || window).flipX, this.worldFlipY = t.worldFlipY != (this || window).flipY;
    else {
      var e = (this || window).skeleton.flipX, n = (this || window).skeleton.flipY;
      this.worldX = e ? -this.x : this.x, this.worldY = n != spine.Bone.yDown ? -this.y : this.y, this.worldScaleX = (this || window).scaleX, this.worldScaleY = (this || window).scaleY, this.worldRotation = (this || window).rotationIK, this.worldFlipX = e != (this || window).flipX, this.worldFlipY = n != (this || window).flipY;
    }
    var r = (this || window).worldRotation * spine.degRad, s = Math.cos(r), o = Math.sin(r);
    this.worldFlipX ? (this.m00 = -s * this.worldScaleX, this.m01 = o * this.worldScaleY) : (this.m00 = s * this.worldScaleX, this.m01 = -o * this.worldScaleY), this.worldFlipY != spine.Bone.yDown ? (this.m10 = -o * this.worldScaleX, this.m11 = -s * this.worldScaleY) : (this.m10 = o * this.worldScaleX, this.m11 = s * this.worldScaleY);
  },
  setToSetupPose: function() {
    var t = (this || window).data;
    this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.rotationIK = (this || window).rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.flipX = t.flipX, this.flipY = t.flipY;
  },
  worldToLocal: function(t) {
    var e = t[0] - this.worldX, n = t[1] - this.worldY, r = (this || window).m00, s = (this || window).m10, o = (this || window).m01, a = (this || window).m11;
    this.worldFlipX != (this.worldFlipY != spine.Bone.yDown) && (r = -r, a = -a);
    var c = 1 / (r * a - o * s);
    t[0] = e * r * c - n * o * c, t[1] = n * a * c - e * s * c;
  },
  localToWorld: function(t) {
    var e = t[0], n = t[1];
    t[0] = e * this.m00 + n * this.m01 + this.worldX, t[1] = e * this.m10 + n * this.m11 + this.worldY;
  }
};
spine.Slot = function(t, e) {
  this.r = (this || window).g = (this || window).b = (this || window).a = 1, this._attachmentTime = 0, this.data = t, this.bone = e, this.setToSetupPose();
};
spine.Slot.prototype = {
  r: 1,
  g: 1,
  b: 1,
  a: 1,
  _attachmentTime: 0,
  attachment: null,
  attachmentVertices: [],
  setAttachment: function(t) {
    this.attachment = t, this._attachmentTime = (this || window).bone.skeleton.time, this.attachmentVertices.length = 0;
  },
  setAttachmentTime: function(t) {
    this._attachmentTime = (this || window).bone.skeleton.time - t;
  },
  getAttachmentTime: function() {
    return this.bone.skeleton.time - this._attachmentTime;
  },
  setToSetupPose: function() {
    var t = (this || window).data;
    this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a;
    for (var e = (this || window).bone.skeleton.data.slots, n = 0, r = e.length; n < r; n++)
      if (e[n] == t) {
        this.setAttachment(t.attachmentName ? this.bone.skeleton.getAttachmentBySlotIndex(n, t.attachmentName) : null);
        break;
      }
  }
};
spine.IkConstraint = function(t, e) {
  this.data = t, this.mix = t.mix, this.bendDirection = t.bendDirection, this.bones = [];
  for (var n = 0, r = t.bones.length; n < r; n++)
    this.bones.push(e.findBone(t.bones[n].name));
  this.target = e.findBone(t.target.name);
};
spine.IkConstraint.prototype = {
  apply: function() {
    var t = (this || window).target, e = (this || window).bones;
    switch (e.length) {
      case 1:
        spine.IkConstraint.apply1(e[0], t.worldX, t.worldY, this.mix);
        break;
      case 2:
        spine.IkConstraint.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.mix);
        break;
    }
  }
};
spine.IkConstraint.apply1 = function(t, e, n, r) {
  var s = !t.data.inheritRotation || !t.parent ? 0 : t.parent.worldRotation, o = t.rotation, a = Math.atan2(n - t.worldY, e - t.worldX) * spine.radDeg;
  t.worldFlipX != (t.worldFlipY != spine.Bone.yDown) && (a = -a), a -= s, t.rotationIK = o + (a - o) * r;
};
spine.IkConstraint.apply2 = function(t, e, n, r, s, o) {
  var a = e.rotation, c = t.rotation;
  if (!o) {
    e.rotationIK = a, t.rotationIK = c;
    return;
  }
  var l, h, u = spine.temp, _ = t.parent;
  _ ? (u[0] = n, u[1] = r, _.worldToLocal(u), n = (u[0] - t.x) * _.worldScaleX, r = (u[1] - t.y) * _.worldScaleY) : (n -= t.x, r -= t.y), e.parent == t ? (l = e.x, h = e.y) : (u[0] = e.x, u[1] = e.y, e.parent.localToWorld(u), t.worldToLocal(u), l = u[0], h = u[1]);
  var d = l * t.worldScaleX, f = h * t.worldScaleY, C = Math.atan2(f, d), m = Math.sqrt(d * d + f * f), g = e.data.length * e.worldScaleX, y = 2 * m * g;
  if (y < 1e-4) {
    e.rotationIK = a + (Math.atan2(r, n) * spine.radDeg - c - a) * o;
    return;
  }
  var A = (n * n + r * r - m * m - g * g) / y;
  A < -1 ? A = -1 : A > 1 && (A = 1);
  var D = Math.acos(A) * s, N = m + g * A, z = g * Math.sin(D), M = Math.atan2(r * N - n * z, n * N + r * z), Z = (M - C) * spine.radDeg - c;
  Z > 180 ? Z -= 360 : Z < -180 && (Z += 360), t.rotationIK = c + Z * o, Z = (D + C) * spine.radDeg - a, Z > 180 ? Z -= 360 : Z < -180 && (Z += 360), e.rotationIK = a + (Z + t.worldRotation - e.parent.worldRotation) * o;
};
spine.Skin = function(t) {
  this.name = t, this.attachments = {};
};
spine.Skin.prototype = {
  addAttachment: function(t, e, n) {
    this.attachments[t + ":" + e] = n;
  },
  getAttachment: function(t, e) {
    return this.attachments[t + ":" + e];
  },
  _attachAll: function(t, e) {
    for (var n in e.attachments) {
      var r = n.indexOf(":"), s = parseInt(n.substring(0, r)), o = n.substring(r + 1), a = t.slots[s];
      if (a.attachment && a.attachment.name == o) {
        var c = (this || window).getAttachment(s, o);
        c && a.setAttachment(c);
      }
    }
  }
};
spine.Animation = function(t, e, n) {
  this.name = t, this.timelines = e, this.duration = n;
};
spine.Animation.prototype = {
  apply: function(t, e, n, r, s) {
    r && this.duration != 0 && (n %= (this || window).duration, e %= (this || window).duration);
    for (var o = (this || window).timelines, a = 0, c = o.length; a < c; a++)
      o[a].apply(t, e, n, s, 1);
  },
  mix: function(t, e, n, r, s, o) {
    r && this.duration != 0 && (n %= (this || window).duration, e %= (this || window).duration);
    for (var a = (this || window).timelines, c = 0, l = a.length; c < l; c++)
      a[c].apply(t, e, n, s, o);
  }
};
spine.Animation.binarySearch = function(t, e, n) {
  var r = 0, s = Math.floor(t.length / n) - 2;
  if (!s)
    return n;
  for (var o = s >>> 1; ; ) {
    if (t[(o + 1) * n] <= e ? r = o + 1 : s = o, r == s)
      return (r + 1) * n;
    o = r + s >>> 1;
  }
};
spine.Animation.binarySearch1 = function(t, e) {
  var n = 0, r = t.length - 2;
  if (!r)
    return 1;
  for (var s = r >>> 1; ; ) {
    if (t[s + 1] <= e ? n = s + 1 : r = s, n == r)
      return n + 1;
    s = n + r >>> 1;
  }
};
spine.Animation.linearSearch = function(t, e, n) {
  for (var r = 0, s = t.length - n; r <= s; r += n)
    if (t[r] > e)
      return r;
  return -1;
};
spine.Curves = function(t) {
  this.curves = [];
};
spine.Curves.prototype = {
  setLinear: function(t) {
    this.curves[t * 19] = 0;
  },
  setStepped: function(t) {
    this.curves[t * 19] = 1;
  },
  setCurve: function(t, e, n, r, s) {
    var o = 0.1, a = o * o, c = a * o, l = 3 * o, h = 3 * a, u = 6 * a, _ = 6 * c, d = -e * 2 + r, f = -n * 2 + s, C = (e - r) * 3 + 1, m = (n - s) * 3 + 1, g = e * l + d * h + C * c, y = n * l + f * h + m * c, A = d * u + C * _, D = f * u + m * _, N = C * _, z = m * _, M = t * 19, Z = (this || window).curves;
    Z[M++] = 2;
    for (var U = g, Q = y, et = M + 19 - 1; M < et; M += 2)
      Z[M] = U, Z[M + 1] = Q, g += A, y += D, A += N, D += z, U += g, Q += y;
  },
  getCurvePercent: function(t, e) {
    e = e < 0 ? 0 : e > 1 ? 1 : e;
    var n = (this || window).curves, r = t * 19, s = n[r];
    if (s === 0)
      return e;
    if (s == 1)
      return 0;
    r++;
    for (var o = 0, a = r, c = r + 19 - 1; r < c; r += 2)
      if (o = n[r], o >= e) {
        var l, h;
        return r == a ? (l = 0, h = 0) : (l = n[r - 2], h = n[r - 1]), h + (n[r + 1] - h) * (e - l) / (o - l);
      }
    var u = n[r - 1];
    return u + (1 - u) * (e - o) / (1 - o);
  }
};
spine.RotateTimeline = function(t) {
  this.boneIndex = 0, this.curves = new spine.Curves(t), this.frames = [], this.frames.length = t * 2;
};
spine.RotateTimeline.prototype = {
  boneIndex: 0,
  getFrameCount: function() {
    return this.frames.length / 2;
  },
  setFrame: function(t, e, n) {
    t *= 2, this.frames[t] = e, this.frames[t + 1] = n;
  },
  apply: function(t, e, n, r, s) {
    var o = (this || window).frames;
    if (!(n < o[0])) {
      var a = t.bones[this.boneIndex];
      if (n >= o[o.length - 2]) {
        for (var _ = a.data.rotation + o[o.length - 1] - a.rotation; _ > 180; )
          _ -= 360;
        for (; _ < -180; )
          _ += 360;
        a.rotation += _ * s;
        return;
      }
      var c = spine.Animation.binarySearch(o, n, 2), l = o[c - 1], h = o[c], u = 1 - (n - h) / (o[c - 2] - h);
      u = (this || window).curves.getCurvePercent(c / 2 - 1, u);
      for (var _ = o[c + 1] - l; _ > 180; )
        _ -= 360;
      for (; _ < -180; )
        _ += 360;
      for (_ = a.data.rotation + (l + _ * u) - a.rotation; _ > 180; )
        _ -= 360;
      for (; _ < -180; )
        _ += 360;
      a.rotation += _ * s;
    }
  }
};
spine.TranslateTimeline = function(t) {
  this.boneIndex = 0, this.curves = new spine.Curves(t), this.frames = [], this.frames.length = t * 3;
};
spine.TranslateTimeline.prototype = {
  boneIndex: 0,
  getFrameCount: function() {
    return this.frames.length / 3;
  },
  setFrame: function(t, e, n, r) {
    t *= 3, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r;
  },
  apply: function(t, e, n, r, s) {
    var o = (this || window).frames;
    if (!(n < o[0])) {
      var a = t.bones[this.boneIndex];
      if (n >= o[o.length - 3]) {
        a.x += (a.data.x + o[o.length - 2] - a.x) * s, a.y += (a.data.y + o[o.length - 1] - a.y) * s;
        return;
      }
      var c = spine.Animation.binarySearch(o, n, 3), l = o[c - 2], h = o[c - 1], u = o[c], _ = 1 - (n - u) / (o[c + -3] - u);
      _ = (this || window).curves.getCurvePercent(c / 3 - 1, _), a.x += (a.data.x + l + (o[c + 1] - l) * _ - a.x) * s, a.y += (a.data.y + h + (o[c + 2] - h) * _ - a.y) * s;
    }
  }
};
spine.ScaleTimeline = function(t) {
  this.boneIndex = 0, this.curves = new spine.Curves(t), this.frames = [], this.frames.length = t * 3;
};
spine.ScaleTimeline.prototype = {
  boneIndex: 0,
  getFrameCount: function() {
    return this.frames.length / 3;
  },
  setFrame: function(t, e, n, r) {
    t *= 3, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r;
  },
  apply: function(t, e, n, r, s) {
    var o = (this || window).frames;
    if (!(n < o[0])) {
      var a = t.bones[this.boneIndex];
      if (n >= o[o.length - 3]) {
        a.scaleX += (a.data.scaleX * o[o.length - 2] - a.scaleX) * s, a.scaleY += (a.data.scaleY * o[o.length - 1] - a.scaleY) * s;
        return;
      }
      var c = spine.Animation.binarySearch(o, n, 3), l = o[c - 2], h = o[c - 1], u = o[c], _ = 1 - (n - u) / (o[c + -3] - u);
      _ = (this || window).curves.getCurvePercent(c / 3 - 1, _), a.scaleX += (a.data.scaleX * (l + (o[c + 1] - l) * _) - a.scaleX) * s, a.scaleY += (a.data.scaleY * (h + (o[c + 2] - h) * _) - a.scaleY) * s;
    }
  }
};
spine.ColorTimeline = function(t) {
  this.boneIndex = 0, this.curves = new spine.Curves(t), this.frames = [], this.frames.length = t * 5;
};
spine.ColorTimeline.prototype = {
  slotIndex: 0,
  getFrameCount: function() {
    return this.frames.length / 5;
  },
  setFrame: function(t, e, n, r, s, o) {
    t *= 5, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r, this.frames[t + 3] = s, this.frames[t + 4] = o;
  },
  apply: function(t, e, n, r, s) {
    var o = (this || window).frames;
    if (!(n < o[0])) {
      var a, c, l, h;
      if (n >= o[o.length - 5]) {
        var u = o.length - 1;
        a = o[u - 3], c = o[u - 2], l = o[u - 1], h = o[u];
      } else {
        var _ = spine.Animation.binarySearch(o, n, 5), d = o[_ - 4], f = o[_ - 3], C = o[_ - 2], m = o[_ - 1], g = o[_], y = 1 - (n - g) / (o[_ - 5] - g);
        y = (this || window).curves.getCurvePercent(_ / 5 - 1, y), a = d + (o[_ + 1] - d) * y, c = f + (o[_ + 2] - f) * y, l = C + (o[_ + 3] - C) * y, h = m + (o[_ + 4] - m) * y;
      }
      var A = t.slots[this.slotIndex];
      s < 1 ? (A.r += (a - A.r) * s, A.g += (c - A.g) * s, A.b += (l - A.b) * s, A.a += (h - A.a) * s) : (A.r = a, A.g = c, A.b = l, A.a = h);
    }
  }
};
spine.AttachmentTimeline = function(t) {
  this.slotIndex = 0, this.curves = new spine.Curves(t), this.frames = [], this.frames.length = t, this.attachmentNames = [], this.attachmentNames.length = t;
};
spine.AttachmentTimeline.prototype = {
  slotIndex: 0,
  getFrameCount: function() {
    return this.frames.length;
  },
  setFrame: function(t, e, n) {
    this.frames[t] = e, this.attachmentNames[t] = n;
  },
  apply: function(t, e, n, r, s) {
    var o = (this || window).frames;
    if (n < o[0]) {
      e > n && this.apply(t, e, Number.MAX_VALUE, null, 0);
      return;
    } else
      e > n && (e = -1);
    var a = n >= o[o.length - 1] ? o.length - 1 : spine.Animation.binarySearch1(o, n) - 1;
    if (!(o[a] < e)) {
      var c = (this || window).attachmentNames[a];
      t.slots[this.slotIndex].setAttachment(
        c ? t.getAttachmentBySlotIndex(this.slotIndex, c) : null
      );
    }
  }
};
spine.EventTimeline = function(t) {
  this.frames = [], this.frames.length = t, this.events = [], this.events.length = t;
};
spine.EventTimeline.prototype = {
  getFrameCount: function() {
    return this.frames.length;
  },
  setFrame: function(t, e, n) {
    this.frames[t] = e, this.events[t] = n;
  },
  apply: function(t, e, n, r, s) {
    if (r) {
      var o = (this || window).frames, a = o.length;
      if (e > n)
        this.apply(t, e, Number.MAX_VALUE, r, s), e = -1;
      else if (e >= o[a - 1])
        return;
      if (!(n < o[0])) {
        var c;
        if (e < o[0])
          c = 0;
        else {
          c = spine.Animation.binarySearch1(o, e);
          for (var l = o[c]; c > 0 && o[c - 1] == l; )
            c--;
        }
        for (var h = (this || window).events; c < a && n >= o[c]; c++)
          r.push(h[c]);
      }
    }
  }
};
spine.DrawOrderTimeline = function(t) {
  this.frames = [], this.frames.length = t, this.drawOrders = [], this.drawOrders.length = t;
};
spine.DrawOrderTimeline.prototype = {
  getFrameCount: function() {
    return this.frames.length;
  },
  setFrame: function(t, e, n) {
    this.frames[t] = e, this.drawOrders[t] = n;
  },
  apply: function(t, e, n, r, s) {
    var o = (this || window).frames;
    if (!(n < o[0])) {
      var a;
      n >= o[o.length - 1] ? a = o.length - 1 : a = spine.Animation.binarySearch1(o, n) - 1;
      var c = t.drawOrder, l = t.slots, h = (this || window).drawOrders[a];
      if (h)
        for (var u = 0, _ = h.length; u < _; u++)
          c[u] = t.slots[h[u]];
      else
        for (var u = 0, _ = l.length; u < _; u++)
          c[u] = l[u];
    }
  }
};
spine.FfdTimeline = function(t) {
  this.slotIndex = (this || window).attachment = 0, this.curves = new spine.Curves(t), this.frames = [], this.frames.length = t, this.frameVertices = [], this.frameVertices.length = t;
};
spine.FfdTimeline.prototype = {
  slotIndex: 0,
  attachment: 0,
  getFrameCount: function() {
    return this.frames.length;
  },
  setFrame: function(t, e, n) {
    this.frames[t] = e, this.frameVertices[t] = n;
  },
  apply: function(t, e, n, r, s) {
    var o = t.slots[this.slotIndex];
    if (o.attachment == (this || window).attachment) {
      var a = (this || window).frames;
      if (!(n < a[0])) {
        var c = (this || window).frameVertices, l = c[0].length, h = o.attachmentVertices;
        if (h.length != l && (s = 1), h.length = l, n >= a[a.length - 1]) {
          var u = c[a.length - 1];
          if (s < 1)
            for (var _ = 0; _ < l; _++)
              h[_] += (u[_] - h[_]) * s;
          else
            for (var _ = 0; _ < l; _++)
              h[_] = u[_];
          return;
        }
        var d = spine.Animation.binarySearch1(a, n), f = a[d], C = 1 - (n - f) / (a[d - 1] - f);
        C = (this || window).curves.getCurvePercent(d - 1, C < 0 ? 0 : C > 1 ? 1 : C);
        var m = c[d - 1], g = c[d];
        if (s < 1)
          for (var _ = 0; _ < l; _++) {
            var y = m[_];
            h[_] += (y + (g[_] - y) * C - h[_]) * s;
          }
        else
          for (var _ = 0; _ < l; _++) {
            var y = m[_];
            h[_] = y + (g[_] - y) * C;
          }
      }
    }
  }
};
spine.IkConstraintTimeline = function(t) {
  this.ikConstraintIndex = 0, this.curves = new spine.Curves(t), this.frames = [], this.frames.length = t * 3;
};
spine.IkConstraintTimeline.prototype = {
  ikConstraintIndex: 0,
  getFrameCount: function() {
    return this.frames.length / 3;
  },
  setFrame: function(t, e, n, r) {
    t *= 3, this.frames[t] = e, this.frames[t + 1] = n, this.frames[t + 2] = r;
  },
  apply: function(t, e, n, r, s) {
    var o = (this || window).frames;
    if (!(n < o[0])) {
      var a = t.ikConstraints[this.ikConstraintIndex];
      if (n >= o[o.length - 3]) {
        a.mix += (o[o.length - 2] - a.mix) * s, a.bendDirection = o[o.length - 1];
        return;
      }
      var c = spine.Animation.binarySearch(o, n, 3), l = o[c + -2], h = o[c], u = 1 - (n - h) / (o[c + -3] - h);
      u = (this || window).curves.getCurvePercent(c / 3 - 1, u);
      var _ = l + (o[c + 1] - l) * u;
      a.mix += (_ - a.mix) * s, a.bendDirection = o[c + -1];
    }
  }
};
spine.FlipXTimeline = function(t) {
  this.boneIndex = 0, this.curves = new spine.Curves(t), this.frames = [], this.frames.length = t * 2;
};
spine.FlipXTimeline.prototype = {
  boneIndex: 0,
  getFrameCount: function() {
    return this.frames.length / 2;
  },
  setFrame: function(t, e, n) {
    t *= 2, this.frames[t] = e, this.frames[t + 1] = n ? 1 : 0;
  },
  apply: function(t, e, n, r, s) {
    var o = (this || window).frames;
    if (n < o[0]) {
      e > n && this.apply(t, e, Number.MAX_VALUE, null, 0);
      return;
    } else
      e > n && (e = -1);
    var a = (n >= o[o.length - 2] ? o.length : spine.Animation.binarySearch(o, n, 2)) - 2;
    o[a] < e || (t.bones[this.boneIndex].flipX = o[a + 1] != 0);
  }
};
spine.FlipYTimeline = function(t) {
  this.boneIndex = 0, this.curves = new spine.Curves(t), this.frames = [], this.frames.length = t * 2;
};
spine.FlipYTimeline.prototype = {
  boneIndex: 0,
  getFrameCount: function() {
    return this.frames.length / 2;
  },
  setFrame: function(t, e, n) {
    t *= 2, this.frames[t] = e, this.frames[t + 1] = n ? 1 : 0;
  },
  apply: function(t, e, n, r, s) {
    var o = (this || window).frames;
    if (n < o[0]) {
      e > n && this.apply(t, e, Number.MAX_VALUE, null, 0);
      return;
    } else
      e > n && (e = -1);
    var a = (n >= o[o.length - 2] ? o.length : spine.Animation.binarySearch(o, n, 2)) - 2;
    o[a] < e || (t.bones[this.boneIndex].flipY = o[a + 1] != 0);
  }
};
spine.SkeletonData = function() {
  this.width = (this || window).height = 0, this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], this.ikConstraints = [];
};
spine.SkeletonData.prototype = {
  name: null,
  defaultSkin: null,
  width: 0,
  height: 0,
  version: null,
  hash: null,
  findBone: function(t) {
    for (var e = (this || window).bones, n = 0, r = e.length; n < r; n++)
      if (e[n].name == t)
        return e[n];
    return null;
  },
  findBoneIndex: function(t) {
    for (var e = (this || window).bones, n = 0, r = e.length; n < r; n++)
      if (e[n].name == t)
        return n;
    return -1;
  },
  findSlot: function(t) {
    for (var e = (this || window).slots, n = 0, r = e.length; n < r; n++)
      if (e[n].name == t)
        return slot[n];
    return null;
  },
  findSlotIndex: function(t) {
    for (var e = (this || window).slots, n = 0, r = e.length; n < r; n++)
      if (e[n].name == t)
        return n;
    return -1;
  },
  findSkin: function(t) {
    for (var e = (this || window).skins, n = 0, r = e.length; n < r; n++)
      if (e[n].name == t)
        return e[n];
    return null;
  },
  findEvent: function(t) {
    for (var e = (this || window).events, n = 0, r = e.length; n < r; n++)
      if (e[n].name == t)
        return e[n];
    return null;
  },
  findAnimation: function(t) {
    for (var e = (this || window).animations, n = 0, r = e.length; n < r; n++)
      if (e[n].name == t)
        return e[n];
    return null;
  },
  findIkConstraint: function(t) {
    for (var e = (this || window).ikConstraints, n = 0, r = e.length; n < r; n++)
      if (e[n].name == t)
        return e[n];
    return null;
  }
};
spine.Skeleton = function(t) {
  this.x = (this || window).y = 0, this.r = (this || window).g = (this || window).b = (this || window).a = 1, this.time = 0, this.flipX = (this || window).flipY = !1, this.data = t, this.bones = [];
  for (var e = 0, n = t.bones.length; e < n; e++) {
    var r = t.bones[e], s = r.parent ? this.bones[t.bones.indexOf(r.parent)] : null;
    this.bones.push(new spine.Bone(r, this, s));
  }
  this.slots = [], this.drawOrder = [];
  for (var e = 0, n = t.slots.length; e < n; e++) {
    var o = t.slots[e], a = (this || window).bones[t.bones.indexOf(o.boneData)], c = new spine.Slot(o, a);
    this.slots.push(c), this.drawOrder.push(c);
  }
  this.ikConstraints = [];
  for (var e = 0, n = t.ikConstraints.length; e < n; e++)
    this.ikConstraints.push(new spine.IkConstraint(t.ikConstraints[e], this));
  this.boneCache = [], this.updateCache();
};
spine.Skeleton.prototype = {
  x: 0,
  y: 0,
  skin: null,
  r: 1,
  g: 1,
  b: 1,
  a: 1,
  time: 0,
  flipX: !1,
  flipY: !1,
  updateCache: function() {
    var t = (this || window).ikConstraints, e = t.length, n = e + 1, r = (this || window).boneCache;
    r.length > n && (r.length = n);
    for (var s = 0, o = r.length; s < o; s++)
      r[s].length = 0;
    for (; r.length < n; )
      r[r.length] = [];
    var a = r[0], c = (this || window).bones;
    t:
      for (var s = 0, o = c.length; s < o; s++) {
        var l = c[s], h = l;
        do {
          for (var u = 0; u < e; u++)
            for (var _ = t[u], d = _.bones[0], f = _.bones[_.bones.length - 1]; ; ) {
              if (h == f) {
                r[u].push(l), r[u + 1].push(l);
                continue t;
              }
              if (f == d)
                break;
              f = f.parent;
            }
          h = h.parent;
        } while (h);
        a[a.length] = l;
      }
  },
  updateWorldTransform: function() {
    for (var t = (this || window).bones, r = 0, e = t.length; r < e; r++) {
      var n = t[r];
      n.rotationIK = n.rotation;
    }
    for (var r = 0, s = (this || window).boneCache.length - 1; ; ) {
      for (var o = (this || window).boneCache[r], a = 0, c = o.length; a < c; a++)
        o[a].updateWorldTransform();
      if (r == s)
        break;
      this.ikConstraints[r].apply(), r++;
    }
  },
  setToSetupPose: function() {
    this.setBonesToSetupPose(), this.setSlotsToSetupPose();
  },
  setBonesToSetupPose: function() {
    for (var t = (this || window).bones, e = 0, n = t.length; e < n; e++)
      t[e].setToSetupPose();
    for (var r = (this || window).ikConstraints, e = 0, n = r.length; e < n; e++) {
      var s = r[e];
      s.bendDirection = s.data.bendDirection, s.mix = s.data.mix;
    }
  },
  setSlotsToSetupPose: function() {
    for (var t = (this || window).slots, e = (this || window).drawOrder, n = 0, r = t.length; n < r; n++)
      e[n] = t[n], t[n].setToSetupPose(n);
  },
  getRootBone: function() {
    return this.bones.length ? this.bones[0] : null;
  },
  findBone: function(t) {
    for (var e = (this || window).bones, n = 0, r = e.length; n < r; n++)
      if (e[n].data.name == t)
        return e[n];
    return null;
  },
  findBoneIndex: function(t) {
    for (var e = (this || window).bones, n = 0, r = e.length; n < r; n++)
      if (e[n].data.name == t)
        return n;
    return -1;
  },
  findSlot: function(t) {
    for (var e = (this || window).slots, n = 0, r = e.length; n < r; n++)
      if (e[n].data.name == t)
        return e[n];
    return null;
  },
  findSlotIndex: function(t) {
    for (var e = (this || window).slots, n = 0, r = e.length; n < r; n++)
      if (e[n].data.name == t)
        return n;
    return -1;
  },
  setSkinByName: function(t) {
    var e = (this || window).data.findSkin(t);
    if (!e)
      throw new Error("Skin not found: " + t);
    this.setSkin(e);
  },
  setSkin: function(t) {
    if (t)
      if (this.skin)
        t._attachAll(this, this.skin);
      else
        for (var e = (this || window).slots, n = 0, r = e.length; n < r; n++) {
          var s = e[n], o = s.data.attachmentName;
          if (o) {
            var a = t.getAttachment(n, o);
            a && s.setAttachment(a);
          }
        }
    this.skin = t;
  },
  getAttachmentBySlotName: function(t, e) {
    return this.getAttachmentBySlotIndex(this.data.findSlotIndex(t), e);
  },
  getAttachmentBySlotIndex: function(t, e) {
    if (this.skin) {
      var n = (this || window).skin.getAttachment(t, e);
      if (n)
        return n;
    }
    return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null;
  },
  setAttachment: function(t, e) {
    for (var n = (this || window).slots, r = 0, s = n.length; r < s; r++) {
      var o = n[r];
      if (o.data.name == t) {
        var a = null;
        if (e && (a = (this || window).getAttachmentBySlotIndex(r, e), !a))
          throw new Error("Attachment not found: " + e + ", for slot: " + t);
        o.setAttachment(a);
        return;
      }
    }
    throw new Error("Slot not found: " + t);
  },
  findIkConstraint: function(t) {
    for (var e = (this || window).ikConstraints, n = 0, r = e.length; n < r; n++)
      if (e[n].data.name == t)
        return e[n];
    return null;
  },
  update: function(t) {
    this.time += t;
  }
};
spine.EventData = function(t) {
  this.intValue = (this || window).floatValue = 0, this.name = t;
};
spine.EventData.prototype = {
  intValue: 0,
  floatValue: 0,
  stringValue: null
};
spine.Event = function(t) {
  this.intValue = (this || window).floatValue = 0, this.data = t;
};
spine.Event.prototype = {
  intValue: 0,
  floatValue: 0,
  stringValue: null
};
spine.AttachmentType = {
  region: 0,
  boundingbox: 1,
  mesh: 2,
  skinnedmesh: 3
};
spine.RegionAttachment = function(t) {
  this.type = spine.AttachmentType.region, this.x = (this || window).y = (this || window).rotation = 0, this.scaleX = (this || window).scaleY = 1, this.width = (this || window).height = 0, this.r = (this || window).g = (this || window).b = (this || window).a = 1, this.regionOffsetX = (this || window).regionOffsetY = (this || window).regionWidth = (this || window).regionHeight = (this || window).regionOriginalWidth = (this || window).regionOriginalHeight = 0, this.name = t, this.offset = [], this.offset.length = 8, this.uvs = [], this.uvs.length = 8;
};
spine.RegionAttachment.prototype = {
  x: 0,
  y: 0,
  rotation: 0,
  scaleX: 1,
  scaleY: 1,
  width: 0,
  height: 0,
  r: 1,
  g: 1,
  b: 1,
  a: 1,
  path: null,
  rendererObject: null,
  regionOffsetX: 0,
  regionOffsetY: 0,
  regionWidth: 0,
  regionHeight: 0,
  regionOriginalWidth: 0,
  regionOriginalHeight: 0,
  setUVs: function(t, e, n, r, s) {
    var o = (this || window).uvs;
    s ? (o[2] = t, o[3] = r, o[4] = t, o[5] = e, o[6] = n, o[7] = e, o[0] = n, o[1] = r) : (o[0] = t, o[1] = r, o[2] = t, o[3] = e, o[4] = n, o[5] = e, o[6] = n, o[7] = r);
  },
  updateOffset: function() {
    var t = (this || window).width / this.regionOriginalWidth * this.scaleX, e = (this || window).height / this.regionOriginalHeight * this.scaleY, n = -this.width / 2 * this.scaleX + this.regionOffsetX * t, r = -this.height / 2 * this.scaleY + this.regionOffsetY * e, s = n + this.regionWidth * t, o = r + this.regionHeight * e, a = (this || window).rotation * spine.degRad, c = Math.cos(a), l = Math.sin(a), h = n * c + this.x, u = n * l, _ = r * c + this.y, d = r * l, f = s * c + this.x, C = s * l, m = o * c + this.y, g = o * l, y = (this || window).offset;
    y[0] = h - d, y[1] = _ + u, y[2] = h - g, y[3] = m + u, y[4] = f - g, y[5] = m + C, y[6] = f - d, y[7] = _ + C;
  },
  computeVertices: function(t, e, n, r) {
    t += n.worldX, e += n.worldY;
    var s = n.m00, o = n.m01, a = n.m10, c = n.m11, l = (this || window).offset;
    r[0] = l[0] * s + l[1] * o + t, r[1] = l[0] * a + l[1] * c + e, r[2] = l[2] * s + l[3] * o + t, r[3] = l[2] * a + l[3] * c + e, r[4] = l[4] * s + l[5] * o + t, r[5] = l[4] * a + l[5] * c + e, r[6] = l[6] * s + l[7] * o + t, r[7] = l[6] * a + l[7] * c + e;
  }
};
spine.MeshAttachment = function(t) {
  this.type = spine.AttachmentType.mesh, this.hullLength = 0, this.r = (this || window).g = (this || window).b = (this || window).a = 1, this.regionU = (this || window).regionV = (this || window).regionV2 = 0, this.regionRotate = !1, this.regionOffsetX = (this || window).regionOffsetY = (this || window).regionWidth = (this || window).regionHeight = (this || window).regionOriginalWidth = (this || window).regionOriginalHeight = 0, this.width = (this || window).height = 0, this.name = t;
};
spine.MeshAttachment.prototype = {
  vertices: null,
  uvs: null,
  regionUVs: null,
  triangles: null,
  hullLength: 0,
  r: 1,
  g: 1,
  b: 1,
  a: 1,
  path: null,
  rendererObject: null,
  regionU: 0,
  regionV: 0,
  regionU2: 0,
  regionV2: 0,
  regionRotate: !1,
  regionOffsetX: 0,
  regionOffsetY: 0,
  regionWidth: 0,
  regionHeight: 0,
  regionOriginalWidth: 0,
  regionOriginalHeight: 0,
  edges: null,
  width: 0,
  height: 0,
  updateUVs: function() {
    var t = (this || window).regionU2 - this.regionU, e = (this || window).regionV2 - this.regionV, n = (this || window).regionUVs.length;
    if ((!this.uvs || this.uvs.length != n) && (this.uvs = new spine.Float32Array(n)), this.regionRotate)
      for (var r = 0; r < n; r += 2)
        this.uvs[r] = (this || window).regionU + this.regionUVs[r + 1] * t, this.uvs[r + 1] = (this || window).regionV + e - this.regionUVs[r] * e;
    else
      for (var r = 0; r < n; r += 2)
        this.uvs[r] = (this || window).regionU + this.regionUVs[r] * t, this.uvs[r + 1] = (this || window).regionV + this.regionUVs[r + 1] * e;
  },
  computeWorldVertices: function(t, e, n, r) {
    var s = n.bone;
    t += s.worldX, e += s.worldY;
    var o = s.m00, a = s.m01, c = s.m10, l = s.m11, h = (this || window).vertices, u = h.length;
    n.attachmentVertices.length == u && (h = n.attachmentVertices);
    for (var _ = 0; _ < u; _ += 2) {
      var d = h[_], f = h[_ + 1];
      r[_] = d * o + f * a + t, r[_ + 1] = d * c + f * l + e;
    }
  }
};
spine.SkinnedMeshAttachment = function(t) {
  this.type = spine.AttachmentType.skinnedmesh, this.hullLength = 0, this.r = (this || window).g = (this || window).b = (this || window).a = 1, this.regionU = (this || window).regionV = (this || window).regionU2 = (this || window).regionV2 = 0, this.regionRotate = !1, this.regionOffsetX = (this || window).regionOffsetY = (this || window).regionWidth = (this || window).regionHeight = (this || window).regionOriginalWidth = (this || window).regionOriginalHeight = 0, this.width = (this || window).height = 0, this.name = t;
};
spine.SkinnedMeshAttachment.prototype = {
  bones: null,
  weights: null,
  uvs: null,
  regionUVs: null,
  triangles: null,
  hullLength: 0,
  r: 1,
  g: 1,
  b: 1,
  a: 1,
  path: null,
  rendererObject: null,
  regionU: 0,
  regionV: 0,
  regionU2: 0,
  regionV2: 0,
  regionRotate: !1,
  regionOffsetX: 0,
  regionOffsetY: 0,
  regionWidth: 0,
  regionHeight: 0,
  regionOriginalWidth: 0,
  regionOriginalHeight: 0,
  edges: null,
  width: 0,
  height: 0,
  updateUVs: function(t, e, n, r, s) {
    var o = (this || window).regionU2 - this.regionU, a = (this || window).regionV2 - this.regionV, c = (this || window).regionUVs.length;
    if ((!this.uvs || this.uvs.length != c) && (this.uvs = new spine.Float32Array(c)), this.regionRotate)
      for (var l = 0; l < c; l += 2)
        this.uvs[l] = (this || window).regionU + this.regionUVs[l + 1] * o, this.uvs[l + 1] = (this || window).regionV + a - this.regionUVs[l] * a;
    else
      for (var l = 0; l < c; l += 2)
        this.uvs[l] = (this || window).regionU + this.regionUVs[l] * o, this.uvs[l + 1] = (this || window).regionV + this.regionUVs[l + 1] * a;
  },
  computeWorldVertices: function(t, e, n, r) {
    var s = n.bone.skeleton.bones, o = (this || window).weights, a = (this || window).bones, c = 0, l = 0, h = 0, u = 0, _ = a.length, d, f, C, m, g, y, A;
    if (n.attachmentVertices.length)
      for (var D = n.attachmentVertices; l < _; c += 2) {
        for (f = 0, C = 0, d = a[l++] + l; l < d; l++, h += 3, u += 2)
          m = s[a[l]], g = o[h] + D[u], y = o[h + 1] + D[u + 1], A = o[h + 2], f += (g * m.m00 + y * m.m01 + m.worldX) * A, C += (g * m.m10 + y * m.m11 + m.worldY) * A;
        r[c] = f + t, r[c + 1] = C + e;
      }
    else
      for (; l < _; c += 2) {
        for (f = 0, C = 0, d = a[l++] + l; l < d; l++, h += 3)
          m = s[a[l]], g = o[h], y = o[h + 1], A = o[h + 2], f += (g * m.m00 + y * m.m01 + m.worldX) * A, C += (g * m.m10 + y * m.m11 + m.worldY) * A;
        r[c] = f + t, r[c + 1] = C + e;
      }
  }
};
spine.BoundingBoxAttachment = function(t) {
  this.type = spine.AttachmentType.boundingbox, this.name = t, this.vertices = [];
};
spine.BoundingBoxAttachment.prototype = {
  computeWorldVertices: function(t, e, n, r) {
    t += n.worldX, e += n.worldY;
    for (var s = n.m00, o = n.m01, a = n.m10, c = n.m11, l = (this || window).vertices, h = 0, u = l.length; h < u; h += 2) {
      var _ = l[h], d = l[h + 1];
      r[h] = _ * s + d * o + t, r[h + 1] = _ * a + d * c + e;
    }
  }
};
spine.AnimationStateData = function(t) {
  this.skeletonData = t, this.animationToMixTime = {}, this.defaultMix = 0;
};
spine.AnimationStateData.prototype = {
  defaultMix: 0,
  setMixByName: function(t, e, n) {
    var r = (this || window).skeletonData.findAnimation(t);
    if (!r)
      throw new Error("Animation not found: " + t);
    var s = (this || window).skeletonData.findAnimation(e);
    if (!s)
      throw new Error("Animation not found: " + e);
    this.setMix(r, s, n);
  },
  setMix: function(t, e, n) {
    this.animationToMixTime[t.name + ":" + e.name] = n;
  },
  getMix: function(t, e) {
    var n = t.name + ":" + e.name;
    return this.animationToMixTime.hasOwnProperty(n) ? this.animationToMixTime[n] : this.defaultMix;
  }
};
spine.TrackEntry = function() {
  this.delay = (this || window).time = (this || window).endTime = 0, this.lastTime = -1, this.timeScale = 1, this.mixTime = (this || window).mixDuration = 1, this.mix = 1;
};
spine.TrackEntry.prototype = {
  next: null,
  previous: null,
  animation: null,
  loop: !1,
  delay: 0,
  time: 0,
  lastTime: -1,
  endTime: 0,
  timeScale: 1,
  mixTime: 0,
  mixDuration: 0,
  mix: 1,
  onStart: null,
  onEnd: null,
  onComplete: null,
  onEvent: null
};
spine.AnimationState = function(t) {
  this.timeScale = 1, this.data = t, this.tracks = [], this.events = [];
};
spine.AnimationState.prototype = {
  onStart: null,
  onEnd: null,
  onComplete: null,
  onEvent: null,
  timeScale: 1,
  update: function(t) {
    t *= (this || window).timeScale;
    for (var e = 0; e < this.tracks.length; e++) {
      var n = (this || window).tracks[e];
      if (n) {
        if (n.time += t * n.timeScale, n.previous) {
          var r = t * n.previous.timeScale;
          n.previous.time += r, n.mixTime += r;
        }
        var s = n.next;
        s ? (s.time = n.lastTime - s.delay, s.time >= 0 && this.setCurrent(e, s)) : !n.loop && n.lastTime >= n.endTime && this.clearTrack(e);
      }
    }
  },
  apply: function(t) {
    for (var e = 0; e < this.tracks.length; e++) {
      var n = (this || window).tracks[e];
      if (n) {
        this.events.length = 0;
        var r = n.time, s = n.lastTime, o = n.endTime, a = n.loop;
        !a && r > o && (r = o);
        var c = n.previous;
        if (!c)
          n.mix == 1 ? n.animation.apply(t, n.lastTime, r, a, this.events) : n.animation.mix(t, n.lastTime, r, a, this.events, n.mix);
        else {
          var l = c.time;
          !c.loop && l > c.endTime && (l = c.endTime), c.animation.apply(t, l, l, c.loop, null);
          var h = n.mixTime / n.mixDuration * n.mix;
          h >= 1 && (h = 1, n.previous = null), n.animation.mix(t, n.lastTime, r, a, this.events, h);
        }
        for (var u = 0, _ = (this || window).events.length; u < _; u++) {
          var d = (this || window).events[u];
          n.onEvent && n.onEvent(e, d), this.onEvent && this.onEvent(e, d);
        }
        if (a ? s % o > r % o : s < o && r >= o) {
          var f = Math.floor(r / o);
          n.onComplete && n.onComplete(e, f), this.onComplete && this.onComplete(e, f);
        }
        n.lastTime = n.time;
      }
    }
  },
  clearTracks: function() {
    for (var t = 0, e = (this || window).tracks.length; t < e; t++)
      this.clearTrack(t);
    this.tracks.length = 0;
  },
  clearTrack: function(t) {
    if (!(t >= (this || window).tracks.length)) {
      var e = (this || window).tracks[t];
      e && (e.onEnd && e.onEnd(t), this.onEnd && this.onEnd(t), this.tracks[t] = null);
    }
  },
  _expandToIndex: function(t) {
    if (t < this.tracks.length)
      return this.tracks[t];
    for (; t >= (this || window).tracks.length; )
      this.tracks.push(null);
    return null;
  },
  setCurrent: function(t, e) {
    var n = (this || window)._expandToIndex(t);
    if (n) {
      var r = n.previous;
      n.previous = null, n.onEnd && n.onEnd(t), this.onEnd && this.onEnd(t), e.mixDuration = (this || window).data.getMix(n.animation, e.animation), e.mixDuration > 0 && (e.mixTime = 0, r && n.mixTime / n.mixDuration < 0.5 ? e.previous = r : e.previous = n);
    }
    this.tracks[t] = e, e.onStart && e.onStart(t), this.onStart && this.onStart(t);
  },
  setAnimationByName: function(t, e, n) {
    var r = (this || window).data.skeletonData.findAnimation(e);
    if (!r)
      throw new Error("Animation not found: " + e);
    return this.setAnimation(t, r, n);
  },
  setAnimation: function(t, e, n) {
    var r = new spine.TrackEntry();
    return r.animation = e, r.loop = n, r.endTime = e.duration, this.setCurrent(t, r), r;
  },
  addAnimationByName: function(t, e, n, r) {
    var s = (this || window).data.skeletonData.findAnimation(e);
    if (!s)
      throw new Error("Animation not found: " + e);
    return this.addAnimation(t, s, n, r);
  },
  addAnimation: function(t, e, n, r) {
    var s = new spine.TrackEntry();
    s.animation = e, s.loop = n, s.endTime = e.duration;
    var o = (this || window)._expandToIndex(t);
    if (o) {
      for (; o.next; )
        o = o.next;
      o.next = s;
    } else
      this.tracks[t] = s;
    return r <= 0 && (o ? r += o.endTime - this.data.getMix(o.animation, e) : r = 0), s.delay = r, s;
  },
  getCurrent: function(t) {
    return t >= (this || window).tracks.length ? null : this.tracks[t];
  }
};
spine.SkeletonJson = function(t) {
  this.scale = 1, this.attachmentLoader = t;
};
spine.SkeletonJson.prototype = {
  scale: 1,
  readSkeletonData: function(t, e) {
    var n = new spine.SkeletonData();
    n.name = e;
    var r = t.skeleton;
    r && (n.hash = r.hash, n.version = r.spine, n.width = r.width || 0, n.height = r.height || 0);
    for (var s = t.bones, o = 0, a = s.length; o < a; o++) {
      var c = s[o], l = null;
      if (c.parent && (l = n.findBone(c.parent), !l))
        throw new Error("Parent bone not found: " + c.parent);
      var h = new spine.BoneData(c.name, l);
      h.length = (c.length || 0) * this.scale, h.x = (c.x || 0) * this.scale, h.y = (c.y || 0) * this.scale, h.rotation = c.rotation || 0, h.scaleX = c.hasOwnProperty("scaleX") ? c.scaleX : 1, h.scaleY = c.hasOwnProperty("scaleY") ? c.scaleY : 1, h.inheritScale = c.hasOwnProperty("inheritScale") ? c.inheritScale : !0, h.inheritRotation = c.hasOwnProperty("inheritRotation") ? c.inheritRotation : !0, n.bones.push(h);
    }
    var u = t.ik;
    if (u)
      for (var o = 0, a = u.length; o < a; o++) {
        for (var _ = u[o], d = new spine.IkConstraintData(_.name), s = _.bones, f = 0, C = s.length; f < C; f++) {
          var m = n.findBone(s[f]);
          if (!m)
            throw new Error("IK bone not found: " + s[f]);
          d.bones.push(m);
        }
        if (d.target = n.findBone(_.target), !d.target)
          throw new Error("Target bone not found: " + _.target);
        d.bendDirection = !_.hasOwnProperty("bendPositive") || _.bendPositive ? 1 : -1, d.mix = _.hasOwnProperty("mix") ? _.mix : 1, n.ikConstraints.push(d);
      }
    for (var g = t.slots, o = 0, a = g.length; o < a; o++) {
      var y = g[o], h = n.findBone(y.bone);
      if (!h)
        throw new Error("Slot bone not found: " + y.bone);
      var A = new spine.SlotData(y.name, h), D = y.color;
      D && (A.r = (this || window).toColor(D, 0), A.g = (this || window).toColor(D, 1), A.b = (this || window).toColor(D, 2), A.a = (this || window).toColor(D, 3)), A.attachmentName = y.attachment, A.blendMode = spine.AttachmentType[y.blend || "normal"], n.slots.push(A);
    }
    var N = t.skins;
    for (var z in N)
      if (N.hasOwnProperty(z)) {
        var M = N[z], Z = new spine.Skin(z);
        for (var U in M)
          if (M.hasOwnProperty(U)) {
            var Q = n.findSlotIndex(U), et = M[U];
            for (var rt in et)
              if (et.hasOwnProperty(rt)) {
                var w = (this || window).readAttachment(Z, rt, et[rt]);
                w && Z.addAttachment(Q, rt, w);
              }
          }
        n.skins.push(Z), Z.name == "default" && (n.defaultSkin = Z);
      }
    var L = t.events;
    for (var G in L)
      if (L.hasOwnProperty(G)) {
        var I = L[G], O = new spine.EventData(G);
        O.intValue = I.int || 0, O.floatValue = I.float || 0, O.stringValue = I.string || null, n.events.push(O);
      }
    var K = t.animations;
    for (var $ in K)
      K.hasOwnProperty($) && this.readAnimation($, K[$], n);
    return n;
  },
  readAttachment: function(t, e, n) {
    e = n.name || e;
    var r = spine.AttachmentType[n.type || "region"], s = n.path || e, o = (this || window).scale;
    if (r == spine.AttachmentType.region) {
      var a = (this || window).attachmentLoader.newRegionAttachment(t, e, s);
      if (!a)
        return null;
      a.path = s, a.x = (n.x || 0) * o, a.y = (n.y || 0) * o, a.scaleX = n.hasOwnProperty("scaleX") ? n.scaleX : 1, a.scaleY = n.hasOwnProperty("scaleY") ? n.scaleY : 1, a.rotation = n.rotation || 0, a.width = (n.width || 0) * o, a.height = (n.height || 0) * o;
      var c = n.color;
      return c && (a.r = (this || window).toColor(c, 0), a.g = (this || window).toColor(c, 1), a.b = (this || window).toColor(c, 2), a.a = (this || window).toColor(c, 3)), a.updateOffset(), a;
    } else if (r == spine.AttachmentType.mesh) {
      var l = (this || window).attachmentLoader.newMeshAttachment(t, e, s);
      return l ? (l.path = s, l.vertices = (this || window).getFloatArray(n, "vertices", o), l.triangles = (this || window).getIntArray(n, "triangles"), l.regionUVs = (this || window).getFloatArray(n, "uvs", 1), l.updateUVs(), c = n.color, c && (l.r = (this || window).toColor(c, 0), l.g = (this || window).toColor(c, 1), l.b = (this || window).toColor(c, 2), l.a = (this || window).toColor(c, 3)), l.hullLength = (n.hull || 0) * 2, n.edges && (l.edges = (this || window).getIntArray(n, "edges")), l.width = (n.width || 0) * o, l.height = (n.height || 0) * o, l) : null;
    } else if (r == spine.AttachmentType.skinnedmesh) {
      var l = (this || window).attachmentLoader.newSkinnedMeshAttachment(t, e, s);
      if (!l)
        return null;
      l.path = s;
      for (var h = (this || window).getFloatArray(n, "uvs", 1), u = (this || window).getFloatArray(n, "vertices", 1), _ = [], d = [], f = 0, C = u.length; f < C; ) {
        var m = u[f++] | 0;
        d[d.length] = m;
        for (var g = f + m * 4; f < g; )
          d[d.length] = u[f], _[_.length] = u[f + 1] * o, _[_.length] = u[f + 2] * o, _[_.length] = u[f + 3], f += 4;
      }
      return l.bones = d, l.weights = _, l.triangles = (this || window).getIntArray(n, "triangles"), l.regionUVs = h, l.updateUVs(), c = n.color, c && (l.r = (this || window).toColor(c, 0), l.g = (this || window).toColor(c, 1), l.b = (this || window).toColor(c, 2), l.a = (this || window).toColor(c, 3)), l.hullLength = (n.hull || 0) * 2, n.edges && (l.edges = (this || window).getIntArray(n, "edges")), l.width = (n.width || 0) * o, l.height = (n.height || 0) * o, l;
    } else if (r == spine.AttachmentType.boundingbox) {
      for (var y = (this || window).attachmentLoader.newBoundingBoxAttachment(t, e), u = n.vertices, f = 0, C = u.length; f < C; f++)
        y.vertices.push(u[f] * o);
      return y;
    }
    throw new Error("Unknown attachment type: " + r);
  },
  readAnimation: function(t, e, n) {
    var r = [], s = 0, o = e.slots;
    for (var a in o)
      if (o.hasOwnProperty(a)) {
        var c = o[a], l = n.findSlotIndex(a);
        for (var h in c)
          if (c.hasOwnProperty(h)) {
            var u = c[h];
            if (h == "color") {
              var _ = new spine.ColorTimeline(u.length);
              _.slotIndex = l;
              for (var d = 0, f = 0, C = u.length; f < C; f++) {
                var m = u[f], g = m.color, y = (this || window).toColor(g, 0), A = (this || window).toColor(g, 1), D = (this || window).toColor(g, 2), N = (this || window).toColor(g, 3);
                _.setFrame(d, m.time, y, A, D, N), this.readCurve(_, d, m), d++;
              }
              r.push(_), s = Math.max(s, _.frames[_.getFrameCount() * 5 - 5]);
            } else if (h == "attachment") {
              var _ = new spine.AttachmentTimeline(u.length);
              _.slotIndex = l;
              for (var d = 0, f = 0, C = u.length; f < C; f++) {
                var m = u[f];
                _.setFrame(d++, m.time, m.name);
              }
              r.push(_), s = Math.max(s, _.frames[_.getFrameCount() - 1]);
            } else
              throw new Error("Invalid timeline type for a slot: " + h + " (" + a + ")");
          }
      }
    var z = e.bones;
    for (var M in z)
      if (z.hasOwnProperty(M)) {
        var Z = n.findBoneIndex(M);
        if (Z == -1)
          throw new Error("Bone not found: " + M);
        var U = z[M];
        for (var h in U)
          if (U.hasOwnProperty(h)) {
            var u = U[h];
            if (h == "rotate") {
              var _ = new spine.RotateTimeline(u.length);
              _.boneIndex = Z;
              for (var d = 0, f = 0, C = u.length; f < C; f++) {
                var m = u[f];
                _.setFrame(d, m.time, m.angle), this.readCurve(_, d, m), d++;
              }
              r.push(_), s = Math.max(s, _.frames[_.getFrameCount() * 2 - 2]);
            } else if (h == "translate" || h == "scale") {
              var _, Q = 1;
              h == "scale" ? _ = new spine.ScaleTimeline(u.length) : (_ = new spine.TranslateTimeline(u.length), Q = (this || window).scale), _.boneIndex = Z;
              for (var d = 0, f = 0, C = u.length; f < C; f++) {
                var m = u[f], et = (m.x || 0) * Q, rt = (m.y || 0) * Q;
                _.setFrame(d, m.time, et, rt), this.readCurve(_, d, m), d++;
              }
              r.push(_), s = Math.max(s, _.frames[_.getFrameCount() * 3 - 3]);
            } else if (h == "flipX" || h == "flipY") {
              var et = h == "flipX", _ = et ? new spine.FlipXTimeline(u.length) : new spine.FlipYTimeline(u.length);
              _.boneIndex = Z;
              for (var w = et ? "x" : "y", d = 0, f = 0, C = u.length; f < C; f++) {
                var m = u[f];
                _.setFrame(d, m.time, m[w] || !1), d++;
              }
              r.push(_), s = Math.max(s, _.frames[_.getFrameCount() * 2 - 2]);
            } else
              throw new Error("Invalid timeline type for a bone: " + h + " (" + M + ")");
          }
      }
    var L = e.ik;
    for (var G in L)
      if (L.hasOwnProperty(G)) {
        var I = n.findIkConstraint(G), u = L[G], _ = new spine.IkConstraintTimeline(u.length);
        _.ikConstraintIndex = n.ikConstraints.indexOf(I);
        for (var d = 0, f = 0, C = u.length; f < C; f++) {
          var m = u[f], O = m.hasOwnProperty("mix") ? m.mix : 1, K = !m.hasOwnProperty("bendPositive") || m.bendPositive ? 1 : -1;
          _.setFrame(d, m.time, O, K), this.readCurve(_, d, m), d++;
        }
        r.push(_), s = Math.max(s, _.frames[_.frameCount * 3 - 3]);
      }
    var $ = e.ffd;
    for (var S in $) {
      var b = n.findSkin(S), c = $[S];
      for (a in c) {
        var l = n.findSlotIndex(a), W = c[a];
        for (var x in W) {
          var u = W[x], _ = new spine.FfdTimeline(u.length), E = b.getAttachment(l, x);
          if (!E)
            throw new Error("FFD attachment not found: " + x);
          _.slotIndex = l, _.attachment = E;
          var R = E.type == spine.AttachmentType.mesh, F;
          R ? F = E.vertices.length : F = E.weights.length / 3 * 2;
          for (var d = 0, f = 0, C = u.length; f < C; f++) {
            var m = u[f], k;
            if (!m.vertices)
              R ? k = E.vertices : (k = [], k.length = F);
            else {
              var X = m.vertices, k = [];
              k.length = F;
              var j = m.offset || 0, V = X.length;
              if (this.scale == 1)
                for (var Y = 0; Y < V; Y++)
                  k[Y + j] = X[Y];
              else
                for (var Y = 0; Y < V; Y++)
                  k[Y + j] = X[Y] * this.scale;
              if (R)
                for (var tt = E.vertices, Y = 0, V = k.length; Y < V; Y++)
                  k[Y] += tt[Y];
            }
            _.setFrame(d, m.time, k), this.readCurve(_, d, m), d++;
          }
          r[r.length] = _, s = Math.max(s, _.frames[_.frameCount - 1]);
        }
      }
    }
    var it = e.drawOrder;
    if (it || (it = e.draworder), it) {
      for (var _ = new spine.DrawOrderTimeline(it.length), lt = n.slots.length, d = 0, f = 0, C = it.length; f < C; f++) {
        var ut = it[f], ft = null;
        if (ut.offsets) {
          ft = [], ft.length = lt;
          for (var Y = lt - 1; Y >= 0; Y--)
            ft[Y] = -1;
          var vt = ut.offsets, pt = [];
          pt.length = lt - vt.length;
          for (var gt = 0, St = 0, Y = 0, V = vt.length; Y < V; Y++) {
            var ht = vt[Y], l = n.findSlotIndex(ht.slot);
            if (l == -1)
              throw new Error("Slot not found: " + ht.slot);
            for (; gt != l; )
              pt[St++] = gt++;
            ft[gt + ht.offset] = gt++;
          }
          for (; gt < lt; )
            pt[St++] = gt++;
          for (var Y = lt - 1; Y >= 0; Y--)
            ft[Y] == -1 && (ft[Y] = pt[--St]);
        }
        _.setFrame(d++, ut.time, ft);
      }
      r.push(_), s = Math.max(s, _.frames[_.getFrameCount() - 1]);
    }
    var ct = e.events;
    if (ct) {
      for (var _ = new spine.EventTimeline(ct.length), d = 0, f = 0, C = ct.length; f < C; f++) {
        var bt = ct[f], Et = n.findEvent(bt.name);
        if (!Et)
          throw new Error("Event not found: " + bt.name);
        var wt = new spine.Event(Et);
        wt.intValue = bt.hasOwnProperty("int") ? bt.int : Et.intValue, wt.floatValue = bt.hasOwnProperty("float") ? bt.float : Et.floatValue, wt.stringValue = bt.hasOwnProperty("string") ? bt.string : Et.stringValue, _.setFrame(d++, bt.time, wt);
      }
      r.push(_), s = Math.max(s, _.frames[_.getFrameCount() - 1]);
    }
    n.animations.push(new spine.Animation(t, r, s));
  },
  readCurve: function(t, e, n) {
    var r = n.curve;
    r ? r == "stepped" ? t.curves.setStepped(e) : r instanceof Array && t.curves.setCurve(e, r[0], r[1], r[2], r[3]) : t.curves.setLinear(e);
  },
  toColor: function(t, e) {
    if (t.length != 8)
      throw new Error("Color hexadecimal length must be 8, received: " + t);
    return parseInt(t.substring(e * 2, e * 2 + 2), 16) / 255;
  },
  getFloatArray: function(t, e, n) {
    var r = t[e], s = new spine.Float32Array(r.length), o = 0, a = r.length;
    if (n == 1)
      for (; o < a; o++)
        s[o] = r[o];
    else
      for (; o < a; o++)
        s[o] = r[o] * n;
    return s;
  },
  getIntArray: function(t, e) {
    for (var n = t[e], r = new spine.Uint16Array(n.length), s = 0, o = n.length; s < o; s++)
      r[s] = n[s] | 0;
    return r;
  }
};
spine.Atlas = function(t, e) {
  this.textureLoader = e, this.pages = [], this.regions = [];
  var n = new spine.AtlasReader(t), r = [];
  r.length = 4;
  for (var s = null; ; ) {
    var o = n.readLine();
    if (o === null)
      break;
    if (o = n.trim(o), !o.length)
      s = null;
    else if (s) {
      var c = new spine.AtlasRegion();
      c.name = o, c.page = s, c.rotate = n.readValue() == "true", n.readTuple(r);
      var l = parseInt(r[0]), h = parseInt(r[1]);
      n.readTuple(r);
      var u = parseInt(r[0]), _ = parseInt(r[1]);
      c.u = l / s.width, c.v = h / s.height, c.rotate ? (c.u2 = (l + _) / s.width, c.v2 = (h + u) / s.height) : (c.u2 = (l + u) / s.width, c.v2 = (h + _) / s.height), c.x = l, c.y = h, c.width = Math.abs(u), c.height = Math.abs(_), n.readTuple(r) == 4 && (c.splits = [parseInt(r[0]), parseInt(r[1]), parseInt(r[2]), parseInt(r[3])], n.readTuple(r) == 4 && (c.pads = [parseInt(r[0]), parseInt(r[1]), parseInt(r[2]), parseInt(r[3])], n.readTuple(r))), c.originalWidth = parseInt(r[0]), c.originalHeight = parseInt(r[1]), n.readTuple(r), c.offsetX = parseInt(r[0]), c.offsetY = parseInt(r[1]), c.index = parseInt(n.readValue()), this.regions.push(c);
    } else {
      s = new spine.AtlasPage(), s.name = o, n.readTuple(r) == 2 && (s.width = parseInt(r[0]), s.height = parseInt(r[1]), n.readTuple(r)), s.format = spine.Atlas.Format[r[0]], n.readTuple(r), s.minFilter = spine.Atlas.TextureFilter[r[0]], s.magFilter = spine.Atlas.TextureFilter[r[1]];
      var a = n.readValue();
      s.uWrap = spine.Atlas.TextureWrap.clampToEdge, s.vWrap = spine.Atlas.TextureWrap.clampToEdge, a == "x" ? s.uWrap = spine.Atlas.TextureWrap.repeat : a == "y" ? s.vWrap = spine.Atlas.TextureWrap.repeat : a == "xy" && (s.uWrap = s.vWrap = spine.Atlas.TextureWrap.repeat), e.load(s, o, this), this.pages.push(s);
    }
  }
};
spine.Atlas.prototype = {
  findRegion: function(t) {
    for (var e = (this || window).regions, n = 0, r = e.length; n < r; n++)
      if (e[n].name == t)
        return e[n];
    return null;
  },
  dispose: function() {
    for (var t = (this || window).pages, e = 0, n = t.length; e < n; e++)
      this.textureLoader.unload(t[e].rendererObject);
  },
  updateUVs: function(t) {
    for (var e = (this || window).regions, n = 0, r = e.length; n < r; n++) {
      var s = e[n];
      s.page == t && (s.u = s.x / t.width, s.v = s.y / t.height, s.rotate ? (s.u2 = (s.x + s.height) / t.width, s.v2 = (s.y + s.width) / t.height) : (s.u2 = (s.x + s.width) / t.width, s.v2 = (s.y + s.height) / t.height));
    }
  }
};
spine.Atlas.Format = {
  alpha: 0,
  intensity: 1,
  luminanceAlpha: 2,
  rgb565: 3,
  rgba4444: 4,
  rgb888: 5,
  rgba8888: 6
};
spine.Atlas.TextureFilter = {
  nearest: 0,
  linear: 1,
  mipMap: 2,
  mipMapNearestNearest: 3,
  mipMapLinearNearest: 4,
  mipMapNearestLinear: 5,
  mipMapLinearLinear: 6
};
spine.Atlas.TextureWrap = {
  mirroredRepeat: 0,
  clampToEdge: 1,
  repeat: 2
};
spine.AtlasPage = function() {
  this.width = (this || window).height = 0;
};
spine.AtlasPage.prototype = {
  name: null,
  format: null,
  minFilter: null,
  magFilter: null,
  uWrap: null,
  vWrap: null,
  rendererObject: null,
  width: 0,
  height: 0
};
spine.AtlasRegion = function() {
  this.x = (this || window).y = (this || window).width = (this || window).height = (this || window).u = (this || window).v = (this || window).u2 = (this || window).v2 = (this || window).offsetX = (this || window).offsetY = (this || window).originalWidth = (this || window).originalHeight = 0, this.index = 0;
};
spine.AtlasRegion.prototype = {
  page: null,
  name: null,
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  u: 0,
  v: 0,
  u2: 0,
  v2: 0,
  offsetX: 0,
  offsetY: 0,
  originalWidth: 0,
  originalHeight: 0,
  index: 0,
  rotate: !1,
  splits: null,
  pads: null
};
spine.AtlasReader = function(t) {
  this.index = 0, this.lines = t.split(/\r\n|\r|\n/);
};
spine.AtlasReader.prototype = {
  index: 0,
  trim: function(t) {
    return t.replace(/^\s+|\s+$/g, "");
  },
  readLine: function() {
    return this.index >= (this || window).lines.length ? null : this.lines[this.index++];
  },
  readValue: function() {
    var t = (this || window).readLine(), e = t.indexOf(":");
    if (e == -1)
      throw new Error("Invalid line: " + t);
    return this.trim(t.substring(e + 1));
  },
  readTuple: function(t) {
    var e = (this || window).readLine(), n = e.indexOf(":");
    if (n == -1)
      throw new Error("Invalid line: " + e);
    for (var r = 0, s = n + 1; r < 3; r++) {
      var o = e.indexOf(",", s);
      if (o == -1)
        break;
      t[r] = (this || window).trim(e.substr(s, o - s)), s = o + 1;
    }
    return t[r] = (this || window).trim(e.substring(s)), r + 1;
  }
};
spine.AtlasAttachmentLoader = function(t) {
  this.atlas = t;
};
spine.AtlasAttachmentLoader.prototype = {
  newRegionAttachment: function(t, e, n) {
    var r = (this || window).atlas.findRegion(n);
    if (!r)
      throw new Error("Region not found in atlas: " + n + " (region attachment: " + e + ")");
    var s = new spine.RegionAttachment(e);
    return s.rendererObject = r, s.setUVs(r.u, r.v, r.u2, r.v2, r.rotate), s.regionOffsetX = r.offsetX, s.regionOffsetY = r.offsetY, s.regionWidth = r.width, s.regionHeight = r.height, s.regionOriginalWidth = r.originalWidth, s.regionOriginalHeight = r.originalHeight, s;
  },
  newMeshAttachment: function(t, e, n) {
    var r = (this || window).atlas.findRegion(n);
    if (!r)
      throw new Error("Region not found in atlas: " + n + " (mesh attachment: " + e + ")");
    var s = new spine.MeshAttachment(e);
    return s.rendererObject = r, s.regionU = r.u, s.regionV = r.v, s.regionU2 = r.u2, s.regionV2 = r.v2, s.regionRotate = r.rotate, s.regionOffsetX = r.offsetX, s.regionOffsetY = r.offsetY, s.regionWidth = r.width, s.regionHeight = r.height, s.regionOriginalWidth = r.originalWidth, s.regionOriginalHeight = r.originalHeight, s;
  },
  newSkinnedMeshAttachment: function(t, e, n) {
    var r = (this || window).atlas.findRegion(n);
    if (!r)
      throw new Error("Region not found in atlas: " + n + " (skinned mesh attachment: " + e + ")");
    var s = new spine.SkinnedMeshAttachment(e);
    return s.rendererObject = r, s.regionU = r.u, s.regionV = r.v, s.regionU2 = r.u2, s.regionV2 = r.v2, s.regionRotate = r.rotate, s.regionOffsetX = r.offsetX, s.regionOffsetY = r.offsetY, s.regionWidth = r.width, s.regionHeight = r.height, s.regionOriginalWidth = r.originalWidth, s.regionOriginalHeight = r.originalHeight, s;
  },
  newBoundingBoxAttachment: function(t, e) {
    return new spine.BoundingBoxAttachment(e);
  }
};
spine.SkeletonBounds = function() {
  this.minX = (this || window).minY = (this || window).maxX = (this || window).maxY = 0, this.polygonPool = [], this.polygons = [], this.boundingBoxes = [];
};
spine.SkeletonBounds.prototype = {
  minX: 0,
  minY: 0,
  maxX: 0,
  maxY: 0,
  update: function(t, e) {
    var n = t.slots, r = n.length, s = t.x, o = t.y, a = (this || window).boundingBoxes, c = (this || window).polygonPool, l = (this || window).polygons;
    a.length = 0;
    for (var h = 0, u = l.length; h < u; h++)
      c.push(l[h]);
    l.length = 0;
    for (var h = 0; h < r; h++) {
      var _ = n[h], d = _.attachment;
      if (d.type == spine.AttachmentType.boundingbox) {
        a.push(d);
        var f = c.length, C;
        f > 0 ? (C = c[f - 1], c.splice(f - 1, 1)) : C = [], l.push(C), C.length = d.vertices.length, d.computeWorldVertices(s, o, _.bone, C);
      }
    }
    e && this.aabbCompute();
  },
  aabbCompute: function() {
    for (var t = (this || window).polygons, e = Number.MAX_VALUE, n = Number.MAX_VALUE, r = Number.MIN_VALUE, s = Number.MIN_VALUE, o = 0, a = t.length; o < a; o++)
      for (var c = t[o], l = 0, h = c.length; l < h; l += 2) {
        var u = c[l], _ = c[l + 1];
        e = Math.min(e, u), n = Math.min(n, _), r = Math.max(r, u), s = Math.max(s, _);
      }
    this.minX = e, this.minY = n, this.maxX = r, this.maxY = s;
  },
  aabbContainsPoint: function(t, e) {
    return t >= (this || window).minX && t <= (this || window).maxX && e >= (this || window).minY && e <= (this || window).maxY;
  },
  aabbIntersectsSegment: function(t, e, n, r) {
    var s = (this || window).minX, o = (this || window).minY, a = (this || window).maxX, c = (this || window).maxY;
    if (t <= s && n <= s || e <= o && r <= o || t >= a && n >= a || e >= c && r >= c)
      return !1;
    var l = (r - e) / (n - t), h = l * (s - t) + e;
    if (h > o && h < c || (h = l * (a - t) + e, h > o && h < c))
      return !0;
    var u = (o - e) / l + t;
    return u > s && u < a || (u = (c - e) / l + t, u > s && u < a);
  },
  aabbIntersectsSkeleton: function(t) {
    return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY;
  },
  containsPoint: function(t, e) {
    for (var n = (this || window).polygons, r = 0, s = n.length; r < s; r++)
      if (this.polygonContainsPoint(n[r], t, e))
        return this.boundingBoxes[r];
    return null;
  },
  intersectsSegment: function(t, e, n, r) {
    for (var s = (this || window).polygons, o = 0, a = s.length; o < a; o++)
      if (s[o].intersectsSegment(t, e, n, r))
        return this.boundingBoxes[o];
    return null;
  },
  polygonContainsPoint: function(t, e, n) {
    for (var r = t.length, s = r - 2, o = !1, a = 0; a < r; a += 2) {
      var c = t[a + 1], l = t[s + 1];
      if (c < n && l >= n || l < n && c >= n) {
        var h = t[a];
        h + (n - c) / (l - c) * (t[s] - h) < e && (o = !o);
      }
      s = a;
    }
    return o;
  },
  polygonIntersectsSegment: function(t, e, n, r, s) {
    for (var o = t.length, a = e - r, c = n - s, l = e * s - n * r, h = t[o - 2], u = t[o - 1], _ = 0; _ < o; _ += 2) {
      var d = t[_], f = t[_ + 1], C = h * f - u * d, m = h - d, g = u - f, y = a * g - c * m, A = (l * m - a * C) / y;
      if ((A >= h && A <= d || A >= d && A <= h) && (A >= e && A <= r || A >= r && A <= e)) {
        var D = (l * g - c * C) / y;
        if ((D >= u && D <= f || D >= f && D <= u) && (D >= n && D <= s || D >= s && D <= n))
          return !0;
      }
      h = d, u = f;
    }
    return !1;
  },
  getPolygon: function(t) {
    var e = (this || window).boundingBoxes.indexOf(t);
    return e == -1 ? null : this.polygons[e];
  },
  getWidth: function() {
    return this.maxX - this.minX;
  },
  getHeight: function() {
    return this.maxY - this.minY;
  }
};
sp._atlasPage_createTexture_webGL = function(t, e) {
  var n = cc.textureCache.addImage(e);
  t.rendererObject = new cc.TextureAtlas(n, 128), t.width = n.getPixelsWide(), t.height = n.getPixelsHigh();
};
sp._atlasPage_createTexture_canvas = function(t, e) {
  t._texture = cc.textureCache.addImage(e);
};
sp._atlasPage_disposeTexture = function(t) {
  t.rendererObject.release();
};
sp._atlasLoader = {
  spAtlasFile: null,
  setAtlasFile: function(t) {
    this.spAtlasFile = t;
  },
  load: function(t, e, n) {
    var r = cc.path.join(cc.path.dirname(this.spAtlasFile), e);
    cc._renderType === cc.game.RENDER_TYPE_WEBGL ? sp._atlasPage_createTexture_webGL(t, r) : sp._atlasPage_createTexture_canvas(t, r);
  },
  unload: function(t) {
  }
};
sp.ANIMATION_EVENT_TYPE = {
  START: 0,
  END: 1,
  COMPLETE: 2,
  EVENT: 3
};
sp.TrackEntryListeners = function(t, e, n, r) {
  this.startListener = t || null, this.endListener = e || null, this.completeListener = n || null, this.eventListener = r || null;
};
sp.TrackEntryListeners.getListeners = function(t) {
  return t.rendererObject || (t.rendererObject = new sp.TrackEntryListeners(), t.listener = sp.trackEntryCallback), t.rendererObject;
};
sp.trackEntryCallback = function(t, e, n, r, s) {
  t.rendererObject.onTrackEntryEvent(e, n, r, s);
};
sp.SkeletonAnimation = sp.Skeleton.extend({
  _state: null,
  _target: null,
  _callback: null,
  _ownsAnimationStateData: !1,
  _startListener: null,
  _endListener: null,
  _completeListener: null,
  _eventListener: null,
  init: function() {
    sp.Skeleton.prototype.init.call(this), this._ownsAnimationStateData = !0, this.setAnimationStateData(new spine.AnimationStateData(this._skeleton.data));
  },
  setAnimationStateData: function(t) {
    var e = new spine.AnimationState(t);
    e.rendererObject = (this || window), e.onStart = (this || window)._onAnimationStateStart.bind(this), e.onComplete = (this || window)._onAnimationStateComplete.bind(this), e.onEnd = (this || window)._onAnimationStateEnd.bind(this), e.onEvent = (this || window)._onAnimationStateEvent.bind(this), this._state = e;
  },
  setMix: function(t, e, n) {
    this._state.data.setMixByName(t, e, n);
  },
  setAnimationListener: function(t, e) {
    this._target = t, this._callback = e;
  },
  setAnimation: function(t, e, n) {
    var r = (this || window)._skeleton.data.findAnimation(e);
    return r ? this._state.setAnimation(t, r, n) : (cc.log("Spine: Animation not found: " + e), null);
  },
  addAnimation: function(t, e, n, r) {
    r = r == null ? 0 : r;
    var s = (this || window)._skeleton.data.findAnimation(e);
    return s ? this._state.addAnimation(t, s, n, r) : (cc.log("Spine: Animation not found:" + e), null);
  },
  getCurrent: function(t) {
    return this._state.getCurrent(t);
  },
  clearTracks: function() {
    this._state.clearTracks();
  },
  clearTrack: function(t) {
    this._state.clearTrack(t);
  },
  update: function(t) {
    this._super(t), t *= (this || window)._timeScale, this._state.update(t), this._state.apply(this._skeleton), this._skeleton.updateWorldTransform(), this._renderCmd._updateChild();
  },
  setStartListener: function(t) {
    this._startListener = t;
  },
  setEndListener: function(t) {
    this._endListener = t;
  },
  setCompleteListener: function(t) {
    this._completeListener = t;
  },
  setEventListener: function(t) {
    this._eventListener = t;
  },
  setTrackStartListener: function(t, e) {
    sp.TrackEntryListeners.getListeners(t).startListener = e;
  },
  setTrackEndListener: function(t, e) {
    sp.TrackEntryListeners.getListeners(t).endListener = e;
  },
  setTrackCompleteListener: function(t, e) {
    sp.TrackEntryListeners.getListeners(t).completeListener = e;
  },
  setTrackEventListener: function(t, e) {
    sp.TrackEntryListeners.getListeners(t).eventListener = e;
  },
  onTrackEntryEvent: function(t, e, n, r) {
    var s = (this || window)._state.getCurrent(t);
    if (s.rendererObject) {
      var o = s.rendererObject;
      switch (e) {
        case sp.ANIMATION_EVENT_TYPE.START:
          o.startListener && o.startListener(t);
          break;
        case sp.ANIMATION_EVENT_TYPE.END:
          o.endListener && o.endListener(t);
          break;
        case sp.ANIMATION_EVENT_TYPE.COMPLETE:
          o.completeListener && o.completeListener(t, r);
          break;
        case sp.ANIMATION_EVENT_TYPE.EVENT:
          o.eventListener && o.eventListener(t, n);
          break;
      }
    }
  },
  onAnimationStateEvent: function(t, e, n, r) {
    switch (e) {
      case sp.ANIMATION_EVENT_TYPE.START:
        this._startListener && this._startListener(t);
        break;
      case sp.ANIMATION_EVENT_TYPE.END:
        this._endListener && this._endListener(t);
        break;
      case sp.ANIMATION_EVENT_TYPE.COMPLETE:
        this._completeListener && this._completeListener(t, r);
        break;
      case sp.ANIMATION_EVENT_TYPE.EVENT:
        this._eventListener && this._eventListener(t, n);
        break;
    }
  },
  getState: function() {
    return this._state;
  },
  _onAnimationStateStart: function(t) {
    this._animationStateCallback(t, sp.ANIMATION_EVENT_TYPE.START, null, 0);
  },
  _onAnimationStateEnd: function(t) {
    this._animationStateCallback(t, sp.ANIMATION_EVENT_TYPE.END, null, 0);
  },
  _onAnimationStateComplete: function(t, e) {
    this._animationStateCallback(t, sp.ANIMATION_EVENT_TYPE.COMPLETE, null, e);
  },
  _onAnimationStateEvent: function(t, e) {
    this._animationStateCallback(t, sp.ANIMATION_EVENT_TYPE.EVENT, e, 0);
  },
  _animationStateCallback: function(t, e, n, r) {
    this.onAnimationStateEvent(t, e, n, r), this._target && this._callback && this._callback.call(this._target, this, t, e, n, r);
  }
});
sp.SkeletonAnimation.create = function(t, e, n) {
  return new sp.SkeletonAnimation(t, e, n);
};
(function() {
  sp.Skeleton.CanvasRenderCmd = function(n) {
    cc.Node.CanvasRenderCmd.call(this, n), this._needDraw = !0;
  };
  var t = sp.Skeleton.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
  t.constructor = sp.Skeleton.CanvasRenderCmd, t.rendering = function(n, r, s) {
    var o = (this || window)._node, a, c, l, h;
    n = n || cc._renderContext;
    var u = o._skeleton, _ = u.drawOrder;
    for (a = 0, c = _.length; a < c; a++)
      l = _[a], h = l._slotNode, h._visible && h._renderCmd && l.currentSprite && (h._renderCmd.transform(this, !0), l.currentSprite._renderCmd.rendering(n, r, s), h._renderCmd._dirtyFlag = l.currentSprite._renderCmd._dirtyFlag = 0);
    if (!(!o._debugSlots && !o._debugBones)) {
      n.setTransform(this._worldTransform, r, s), n.setGlobalAlpha(1);
      var d, f = cc._drawingUtil;
      if (o._debugSlots) {
        f.setDrawColor(0, 0, 255, 255), f.setLineWidth(1);
        var C = [];
        for (a = 0, c = u.slots.length; a < c; a++)
          l = u.drawOrder[a], !(!l.attachment || l.attachment.type != sp.ATTACHMENT_TYPE.REGION) && (d = l.attachment, this._updateRegionAttachmentSlot(d, l, C), f.drawPoly(C, 4, !0));
      }
      if (o._debugBones) {
        var m;
        for (f.setLineWidth(2), f.setDrawColor(255, 0, 0, 255), a = 0, c = u.bones.length; a < c; a++) {
          m = u.bones[a];
          var g = m.data.length * m.m00 + m.worldX, y = m.data.length * m.m10 + m.worldY;
          f.drawLine(
            { x: m.worldX, y: m.worldY },
            { x: g, y }
          );
        }
        for (f.setPointSize(4), f.setDrawColor(0, 0, 255, 255), a = 0, c = u.bones.length; a < c; a++)
          m = u.bones[a], f.drawPoint({ x: m.worldX, y: m.worldY }), a === 0 && f.setDrawColor(0, 255, 0, 255);
      }
    }
  }, t._updateRegionAttachmentSlot = function(n, r, s) {
    if (s) {
      var o = {}, a = sp.VERTEX_INDEX, c = r.bone;
      n.computeVertices(c.skeleton.x, c.skeleton.y, c, o), s.length = 0, s.push(cc.p(o[a.X1], o[a.Y1])), s.push(cc.p(o[a.X4], o[a.Y4])), s.push(cc.p(o[a.X3], o[a.Y3])), s.push(cc.p(o[a.X2], o[a.Y2]));
    }
  }, t._createChildFormSkeletonData = function() {
    for (var n = (this || window)._node, r = n._skeleton, s, o, a = 0, c = r.slots.length; a < c; a++) {
      var l = r.slots[a], h = l.attachment, u = new cc.Node();
      l._slotNode = u, h instanceof spine.RegionAttachment && (s = h.rendererObject.name, o = (this || window)._createSprite(l, h), l.currentSprite = o, l.currentSpriteName = s, u.addChild(o));
    }
  };
  var e = /* @__PURE__ */ H(function(n, r, s, o) {
    var a = new cc.Rect(s.x, s.y, s.width, s.height);
    n.initWithTexture(r, a, s.rotate, !1), n._rect.width = o.width, n._rect.height = o.height, n.setContentSize(o.width, o.height), n.setRotation(-o.rotation), n.setScale(
      s.width / s.originalWidth * o.scaleX,
      s.height / s.originalHeight * o.scaleY
    );
  }, "loaded");
  t._createSprite = function(n, r) {
    var s = r.rendererObject, o = s.page._texture, a = new cc.Sprite();
    return o.isLoaded() ? e(a, o, s, r) : o.addEventListener("load", function() {
      e(a, o, s, r);
    }, this), n.sprites = n.sprites || {}, n.sprites[s.name] = a, a;
  }, t._updateChild = function() {
    var n = (this || window)._node._skeleton, r = n.slots, s, o, a, c, l, h;
    for (s = 0, o = r.length; s < o; s++) {
      if (c = r[s], l = c.attachment, h = c._slotNode, !l) {
        h.setVisible(!1);
        continue;
      }
      var u = l.type;
      if (u === spine.AttachmentType.region) {
        if (l.rendererObject && (!c.currentSpriteName || c.currentSpriteName !== l.name)) {
          var _ = l.rendererObject.name;
          if (c.currentSprite !== void 0 && c.currentSprite.setVisible(!1), c.sprites = c.sprites || {}, c.sprites[_] !== void 0)
            c.sprites[_].setVisible(!0);
          else {
            var d = (this || window)._createSprite(c, l);
            h.addChild(d);
          }
          c.currentSprite = c.sprites[_], c.currentSpriteName = _;
        }
        var f = c.bone;
        h.setPosition(
          f.worldX + l.x * f.m00 + l.y * f.m01,
          f.worldY + l.x * f.m10 + l.y * f.m11
        ), h.setScale(f.worldScaleX, f.worldScaleY), a = c.currentSprite, a._flippedX = f.worldFlipX, a._flippedY = f.worldFlipY, a._flippedY || a._flippedX ? (h.setRotation(f.worldRotation), a.setRotation(l.rotation)) : (h.setRotation(-f.worldRotation), a.setRotation(-l.rotation)), a._renderCmd._displayedOpacity = 0 | this._node.getOpacity() * n.a * c.a;
        var C = 0 | n.r * c.r * 255, m = 0 | n.g * c.g * 255, g = 0 | n.b * c.b * 255;
        a.setColor(cc.color(C, m, g)), a._renderCmd._updateColor();
      } else if (u !== spine.AttachmentType.skinnedmesh) {
        h.setVisible(!1);
        continue;
      }
      h.setVisible(!0);
    }
  };
})();
(function() {
  sp.Skeleton.WebGLRenderCmd = function(e) {
    cc.Node.WebGLRenderCmd.call(this, e), this._needDraw = !0, this._matrix = new cc.math.Matrix4(), this._matrix.identity(), this._tmpQuad = new cc.V3F_C4B_T2F_Quad(), this.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR));
  };
  var t = sp.Skeleton.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
  t.constructor = sp.Skeleton.WebGLRenderCmd, t.rendering = function(e) {
    var n = (this || window)._node, r = (this || window)._tmpQuad, s = n.getColor(), o = n._skeleton, a, c, l, h, u, _, d = n._blendFunc, f = n._premultipliedAlpha, C = (this || window)._worldTransform;
    for (this._matrix.mat[0] = C.a, this._matrix.mat[4] = C.c, this._matrix.mat[12] = C.tx, this._matrix.mat[1] = C.b, this._matrix.mat[5] = C.d, this._matrix.mat[13] = C.ty, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix), o.r = s.r / 255, o.g = s.g / 255, o.b = s.b / 255, o.a = n.getOpacity() / 255, f && (o.r *= o.a, o.g *= o.a, o.b *= o.a), u = 0, _ = o.drawOrder.length; u < _; u++)
      if (h = o.drawOrder[u], !!h.attachment) {
        switch (l = h.attachment, h.attachment.type) {
          case sp.ATTACHMENT_TYPE.REGION:
            this._updateRegionAttachmentQuad(l, h, r, f);
            break;
          case sp.ATTACHMENT_TYPE.MESH:
            this._updateMeshAttachmentQuad(l, h, r, f);
            break;
          case sp.ATTACHMENT_TYPE.SKINNED_MESH:
            break;
          default:
            continue;
        }
        var m = n.getTextureAtlas(l);
        if (h.data.blendMode != a)
          switch (c && (c.drawQuads(), c.removeAllQuads()), a = h.data.blendMode, a) {
            case spine.BlendMode.additive:
              cc.glBlendFunc(f ? cc.ONE : cc.SRC_ALPHA, cc.ONE);
              break;
            case spine.BlendMode.multiply:
              cc.glBlendFunc(cc.DST_COLOR, cc.ONE_MINUS_SRC_ALPHA);
              break;
            case spine.BlendMode.screen:
              cc.glBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_COLOR);
              break;
            default:
              cc.glBlendFunc(d.src, d.dst);
          }
        else
          m != c && c && (c.drawQuads(), c.removeAllQuads());
        c = m;
        var g = c.getTotalQuads();
        if (c.getCapacity() == g && (c.drawQuads(), c.removeAllQuads(), !c.resizeCapacity(c.getCapacity() * 2)))
          return;
        c.updateQuad(r, g);
      }
    if (c && (c.drawQuads(), c.removeAllQuads()), n._debugBones || n._debugSlots) {
      cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.current_stack.stack.push(cc.current_stack.top), cc.current_stack.top = (this || window)._matrix;
      var y = cc._drawingUtil;
      if (n._debugSlots) {
        for (y.setDrawColor(0, 0, 255, 255), y.setLineWidth(1), u = 0, _ = o.slots.length; u < _; u++)
          if (h = o.drawOrder[u], !(!h.attachment || h.attachment.type != sp.ATTACHMENT_TYPE.REGION)) {
            l = h.attachment, this._updateRegionAttachmentQuad(l, h, r);
            var A = [];
            A.push(cc.p(r.bl.vertices.x, r.bl.vertices.y)), A.push(cc.p(r.br.vertices.x, r.br.vertices.y)), A.push(cc.p(r.tr.vertices.x, r.tr.vertices.y)), A.push(cc.p(r.tl.vertices.x, r.tl.vertices.y)), y.drawPoly(A, 4, !0);
          }
      }
      if (n._debugBones) {
        var D;
        for (y.setLineWidth(2), y.setDrawColor(255, 0, 0, 255), u = 0, _ = o.bones.length; u < _; u++) {
          D = o.bones[u];
          var N = D.data.length * D.m00 + D.worldX, z = D.data.length * D.m10 + D.worldY;
          y.drawLine(cc.p(D.worldX, D.worldY), cc.p(N, z));
        }
        for (y.setPointSize(4), y.setDrawColor(0, 0, 255, 255), u = 0, _ = o.bones.length; u < _; u++)
          D = o.bones[u], y.drawPoint(cc.p(D.worldX, D.worldY)), u == 0 && y.setDrawColor(0, 255, 0, 255);
      }
      cc.kmGLPopMatrix();
    }
  }, t._createChildFormSkeletonData = function() {
  }, t._updateChild = function() {
  }, t._updateRegionAttachmentQuad = function(e, n, r, s) {
    var o = {};
    e.computeVertices(n.bone.skeleton.x, n.bone.skeleton.y, n.bone, o);
    var a = n.bone.skeleton.r * n.r * 255, c = n.bone.skeleton.g * n.g * 255, l = n.bone.skeleton.b * n.b * 255, h = n.bone.skeleton.a * n.a;
    s && (a *= h, c *= h, l *= h);
    var u = h * 255;
    r.bl.colors.r = r.tl.colors.r = r.tr.colors.r = r.br.colors.r = a, r.bl.colors.g = r.tl.colors.g = r.tr.colors.g = r.br.colors.g = c, r.bl.colors.b = r.tl.colors.b = r.tr.colors.b = r.br.colors.b = l, r.bl.colors.a = r.tl.colors.a = r.tr.colors.a = r.br.colors.a = u;
    var _ = sp.VERTEX_INDEX;
    r.bl.vertices.x = o[_.X1], r.bl.vertices.y = o[_.Y1], r.tl.vertices.x = o[_.X2], r.tl.vertices.y = o[_.Y2], r.tr.vertices.x = o[_.X3], r.tr.vertices.y = o[_.Y3], r.br.vertices.x = o[_.X4], r.br.vertices.y = o[_.Y4], r.bl.texCoords.u = e.uvs[_.X1], r.bl.texCoords.v = e.uvs[_.Y1], r.tl.texCoords.u = e.uvs[_.X2], r.tl.texCoords.v = e.uvs[_.Y2], r.tr.texCoords.u = e.uvs[_.X3], r.tr.texCoords.v = e.uvs[_.Y3], r.br.texCoords.u = e.uvs[_.X4], r.br.texCoords.v = e.uvs[_.Y4];
  }, t._updateMeshAttachmentQuad = function(e, n, r, s) {
    var o = {};
    e.computeWorldVertices(n.bone.x, n.bone.y, n, o);
    var a = n.bone.skeleton.r * n.r * 255, c = n.bone.skeleton.g * n.g * 255, l = n.bone.skeleton.b * n.b * 255, h = n.bone.skeleton.a * n.a;
    s && (a *= h, c *= h, l *= h);
    var u = h * 255;
    r.bl.colors.r = r.tl.colors.r = r.tr.colors.r = r.br.colors.r = a, r.bl.colors.g = r.tl.colors.g = r.tr.colors.g = r.br.colors.g = c, r.bl.colors.b = r.tl.colors.b = r.tr.colors.b = r.br.colors.b = l, r.bl.colors.a = r.tl.colors.a = r.tr.colors.a = r.br.colors.a = u;
    var _ = sp.VERTEX_INDEX;
    r.bl.vertices.x = o[_.X1], r.bl.vertices.y = o[_.Y1], r.tl.vertices.x = o[_.X2], r.tl.vertices.y = o[_.Y2], r.tr.vertices.x = o[_.X3], r.tr.vertices.y = o[_.Y3], r.br.vertices.x = o[_.X4], r.br.vertices.y = o[_.Y4], r.bl.texCoords.u = e.uvs[_.X1], r.bl.texCoords.v = e.uvs[_.Y1], r.tl.texCoords.u = e.uvs[_.X2], r.tl.texCoords.v = e.uvs[_.Y2], r.tr.texCoords.u = e.uvs[_.X3], r.tr.texCoords.v = e.uvs[_.Y3], r.br.texCoords.u = e.uvs[_.X4], r.br.texCoords.v = e.uvs[_.Y4];
  };
})();
(function() {
  gaf.Sprite.WebGLRenderCmd = function(e) {
    cc.Sprite.WebGLRenderCmd.call(this, e), this._defualtShader = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR), this._customShader = gaf._Shaders.Alpha, this._tintMult = null, this._tintOffset = null, this._ctxMatrixBody = null, this._ctxMatrixAppendix = null;
  };
  var t = gaf.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
  t.constructor = gaf.Sprite.WebGLRenderCmd, t._identityVec = [1, 1, 1, 1], t._zeroVec = [0, 0, 0, 0], t._identityMat = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ], t._disableCtx = function() {
    this.setShaderProgram(this._defualtShader);
  }, t._enableCtx = function() {
    this.setShaderProgram(this._customShader);
  }, t._applyCtxState = function(e) {
    var n = e._cascadeColorMult;
    this._tintMult = [
      n.r / 255,
      n.g / 255,
      n.b / 255,
      n.a / 255
    ];
    var r = e._cascadeColorOffset;
    this._tintOffset = [
      r.r / 255,
      r.g / 255,
      r.b / 255,
      r.a / 255
    ];
    var s = e._filterStack;
    if (s && s.length > 0 && s[0].type === gaf.EFFECT_COLOR_MATRIX) {
      var o = s[0].colorMatrix;
      this._ctxMatrixBody = [
        o.rr,
        o.rg,
        o.rb,
        o.ra,
        o.gr,
        o.gg,
        o.gb,
        o.ga,
        o.br,
        o.bg,
        o.bb,
        o.ba,
        o.ar,
        o.ag,
        o.ab,
        o.aa
      ], this._ctxMatrixAppendix = [
        o.r / 255,
        o.g / 255,
        o.b / 255,
        o.a / 255
      ];
    } else
      this._ctxMatrixBody = null, this._ctxMatrixAppendix = null;
  }, t._setUniforms = function() {
    this._shaderProgram === (this || window)._customShader && (this._shaderProgram.use(), this._shaderProgram.setUniformLocationWith4fv(
      gaf._Uniforms.ColorTransformMult,
      this._tintMult,
      1
    ), this._shaderProgram.setUniformLocationWith4fv(
      gaf._Uniforms.ColorTransformOffset,
      this._tintOffset,
      1
    ), this._ctxMatrixBody && this._ctxMatrixAppendix ? (this._shaderProgram.setUniformLocationWithMatrix4fv(
      gaf._Uniforms.ColorMatrixBody,
      this._ctxMatrixBody,
      1
    ), this._shaderProgram.setUniformLocationWith4fv(
      gaf._Uniforms.ColorMatrixAppendix,
      this._ctxMatrixAppendix,
      1
    )) : (this._shaderProgram.setUniformLocationWithMatrix4fv(
      gaf._Uniforms.ColorMatrixBody,
      this._identityMat,
      1
    ), this._shaderProgram.setUniformLocationWith4fv(
      gaf._Uniforms.ColorMatrixAppendix,
      this._zeroVec,
      1
    )));
  }, t.rendering = function(e) {
    this._setUniforms(), cc.Sprite.WebGLRenderCmd.prototype.rendering.call(this, e);
  };
})();
const cocos2dx = { cc, ccs, ccui }, __CJS__cocos__export_default__ = (module.exports == null ? {} : module.exports).default || module.exports, __CJS__cocos__export_managers__ = (module.exports == null ? {} : module.exports).managers, __CJS__cocos__export_protocol__ = (module.exports == null ? {} : module.exports).protocol, __CJS__cocos__export_connect__ = (module.exports == null ? {} : module.exports).connect, __CJS__cocos__export_Manager__ = (module.exports == null ? {} : module.exports).Manager, __CJS__cocos__export_Socket__ = (module.exports == null ? {} : module.exports).Socket, __CJS__cocos__export_polling__ = (module.exports == null ? {} : module.exports).polling, __CJS__cocos__export_websocket__ = (module.exports == null ? {} : module.exports).websocket, __CJS__cocos__export_log__ = (module.exports == null ? {} : module.exports).log, __CJS__cocos__export_formatArgs__ = (module.exports == null ? {} : module.exports).formatArgs, __CJS__cocos__export_save__ = (module.exports == null ? {} : module.exports).save, __CJS__cocos__export_load__ = (module.exports == null ? {} : module.exports).load, __CJS__cocos__export_useColors__ = (module.exports == null ? {} : module.exports).useColors, __CJS__cocos__export_colors__ = (module.exports == null ? {} : module.exports).colors, __CJS__cocos__export_coerce__ = (module.exports == null ? {} : module.exports).coerce, __CJS__cocos__export_disable__ = (module.exports == null ? {} : module.exports).disable, __CJS__cocos__export_enable__ = (module.exports == null ? {} : module.exports).enable, __CJS__cocos__export_enabled__ = (module.exports == null ? {} : module.exports).enabled, __CJS__cocos__export_humanize__ = (module.exports == null ? {} : module.exports).humanize, __CJS__cocos__export_names__ = (module.exports == null ? {} : module.exports).names, __CJS__cocos__export_skips__ = (module.exports == null ? {} : module.exports).skips, __CJS__cocos__export_formatters__ = (module.exports == null ? {} : module.exports).formatters, __CJS__cocos__export_packets__ = (module.exports == null ? {} : module.exports).packets, __CJS__cocos__export_encodePacket__ = (module.exports == null ? {} : module.exports).encodePacket, __CJS__cocos__export_encodeBase64Packet__ = (module.exports == null ? {} : module.exports).encodeBase64Packet, __CJS__cocos__export_decodePacket__ = (module.exports == null ? {} : module.exports).decodePacket, __CJS__cocos__export_decodeBase64Packet__ = (module.exports == null ? {} : module.exports).decodeBase64Packet, __CJS__cocos__export_encodePayload__ = (module.exports == null ? {} : module.exports).encodePayload, __CJS__cocos__export_decodePayload__ = (module.exports == null ? {} : module.exports).decodePayload, __CJS__cocos__export_encodePayloadAsArrayBuffer__ = (module.exports == null ? {} : module.exports).encodePayloadAsArrayBuffer, __CJS__cocos__export_encodePayloadAsBlob__ = (module.exports == null ? {} : module.exports).encodePayloadAsBlob, __CJS__cocos__export_decodePayloadAsBinary__ = (module.exports == null ? {} : module.exports).decodePayloadAsBinary, __CJS__cocos__export_encode__ = (module.exports == null ? {} : module.exports).encode, __CJS__cocos__export_decode__ = (module.exports == null ? {} : module.exports).decode, __CJS__cocos__export_keys__ = (module.exports == null ? {} : module.exports).keys, __CJS__cocos__export_values__ = (module.exports == null ? {} : module.exports).values, __CJS__cocos__export_merge__ = (module.exports == null ? {} : module.exports).merge, __CJS__cocos__export_length__ = (module.exports == null ? {} : module.exports).length, __CJS__cocos__export_isEmpty__ = (module.exports == null ? {} : module.exports).isEmpty, __CJS__cocos__export_deconstructPacket__ = (module.exports == null ? {} : module.exports).deconstructPacket, __CJS__cocos__export_reconstructPacket__ = (module.exports == null ? {} : module.exports).reconstructPacket, __CJS__cocos__export_removeBlobs__ = (module.exports == null ? {} : module.exports).removeBlobs, __CJS__cocos__export_types__ = (module.exports == null ? {} : module.exports).types, __CJS__cocos__export_CONNECT__ = (module.exports == null ? {} : module.exports).CONNECT, __CJS__cocos__export_DISCONNECT__ = (module.exports == null ? {} : module.exports).DISCONNECT, __CJS__cocos__export_EVENT__ = (module.exports == null ? {} : module.exports).EVENT, __CJS__cocos__export_ACK__ = (module.exports == null ? {} : module.exports).ACK, __CJS__cocos__export_ERROR__ = (module.exports == null ? {} : module.exports).ERROR, __CJS__cocos__export_BINARY_EVENT__ = (module.exports == null ? {} : module.exports).BINARY_EVENT, __CJS__cocos__export_BINARY_ACK__ = (module.exports == null ? {} : module.exports).BINARY_ACK, __CJS__cocos__export_Encoder__ = (module.exports == null ? {} : module.exports).Encoder, __CJS__cocos__export_Decoder__ = (module.exports == null ? {} : module.exports).Decoder;
export {
  __CJS__cocos__export_ACK__ as ACK,
  __CJS__cocos__export_BINARY_ACK__ as BINARY_ACK,
  __CJS__cocos__export_BINARY_EVENT__ as BINARY_EVENT,
  __CJS__cocos__export_CONNECT__ as CONNECT,
  __CJS__cocos__export_DISCONNECT__ as DISCONNECT,
  __CJS__cocos__export_Decoder__ as Decoder,
  __CJS__cocos__export_ERROR__ as ERROR,
  __CJS__cocos__export_EVENT__ as EVENT,
  __CJS__cocos__export_Encoder__ as Encoder,
  __CJS__cocos__export_Manager__ as Manager,
  __CJS__cocos__export_Socket__ as Socket,
  cocos2dx,
  __CJS__cocos__export_coerce__ as coerce,
  __CJS__cocos__export_colors__ as colors,
  __CJS__cocos__export_connect__ as connect,
  __CJS__cocos__export_decode__ as decode,
  __CJS__cocos__export_decodeBase64Packet__ as decodeBase64Packet,
  __CJS__cocos__export_decodePacket__ as decodePacket,
  __CJS__cocos__export_decodePayload__ as decodePayload,
  __CJS__cocos__export_decodePayloadAsBinary__ as decodePayloadAsBinary,
  __CJS__cocos__export_deconstructPacket__ as deconstructPacket,
  __CJS__cocos__export_disable__ as disable,
  __CJS__cocos__export_enable__ as enable,
  __CJS__cocos__export_enabled__ as enabled,
  __CJS__cocos__export_encode__ as encode,
  __CJS__cocos__export_encodeBase64Packet__ as encodeBase64Packet,
  __CJS__cocos__export_encodePacket__ as encodePacket,
  __CJS__cocos__export_encodePayload__ as encodePayload,
  __CJS__cocos__export_encodePayloadAsArrayBuffer__ as encodePayloadAsArrayBuffer,
  __CJS__cocos__export_encodePayloadAsBlob__ as encodePayloadAsBlob,
  __CJS__cocos__export_formatArgs__ as formatArgs,
  __CJS__cocos__export_formatters__ as formatters,
  __CJS__cocos__export_humanize__ as humanize,
  __CJS__cocos__export_isEmpty__ as isEmpty,
  __CJS__cocos__export_keys__ as keys,
  __CJS__cocos__export_length__ as length,
  __CJS__cocos__export_load__ as load,
  __CJS__cocos__export_log__ as log,
  __CJS__cocos__export_managers__ as managers,
  __CJS__cocos__export_merge__ as merge,
  __CJS__cocos__export_names__ as names,
  __CJS__cocos__export_packets__ as packets,
  __CJS__cocos__export_polling__ as polling,
  __CJS__cocos__export_protocol__ as protocol,
  __CJS__cocos__export_reconstructPacket__ as reconstructPacket,
  __CJS__cocos__export_removeBlobs__ as removeBlobs,
  __CJS__cocos__export_save__ as save,
  __CJS__cocos__export_skips__ as skips,
  __CJS__cocos__export_types__ as types,
  __CJS__cocos__export_useColors__ as useColors,
  __CJS__cocos__export_values__ as values,
  __CJS__cocos__export_websocket__ as websocket
};
